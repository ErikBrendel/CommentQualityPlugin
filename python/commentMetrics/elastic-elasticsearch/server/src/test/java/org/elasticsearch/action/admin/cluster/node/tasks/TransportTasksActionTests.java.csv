commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     requestName = in.readString(). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(requestName). }
false;public;0;4;;@Override public String getDescription() {     return "CancellableNodeRequest[" + requestName + "]". }
false;public;5;4;;@Override public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {     return super.createTask(id, type, action, parentTaskId, headers). }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     requestName = in.readString(). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(requestName). }
false;public;0;4;;@Override public String getDescription() {     return "CancellableNodesRequest[" + requestName + "]". }
false;public;5;4;;@Override public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {     return super.createTask(id, type, action, parentTaskId, headers). }
false;protected;2;4;;@Override protected NodeRequest newNodeRequest(String nodeId, NodesRequest request) {     return new NodeRequest(request, nodeId). }
false;protected;0;4;;@Override protected NodeResponse newNodeResponse() {     return new NodeResponse(). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(status). }
false;public;0;3;;public String getStatus() {     return status. }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVInt(tasks.size()).     for (TestTaskResponse task : tasks) {         task.writeTo(out).     } }
false;protected;4;5;;@Override protected TestTasksResponse newResponse(TestTasksRequest request, List<TestTaskResponse> tasks, List<TaskOperationFailure> taskOperationFailures, List<FailedNodeException> failedNodeExceptions) {     return new TestTasksResponse(tasks, taskOperationFailures, failedNodeExceptions). }
false;private;1;3;;private ActionFuture<NodesResponse> startBlockingTestNodesAction(CountDownLatch checkLatch) throws InterruptedException {     return startBlockingTestNodesAction(checkLatch, new NodesRequest("Test Request")). }
false;private;2;6;;private ActionFuture<NodesResponse> startBlockingTestNodesAction(CountDownLatch checkLatch, NodesRequest request) throws InterruptedException {     PlainActionFuture<NodesResponse> future = newFuture().     startBlockingTestNodesAction(checkLatch, request, future).     return future. }
false;private;2;4;;private Task startBlockingTestNodesAction(CountDownLatch checkLatch, ActionListener<NodesResponse> listener) throws InterruptedException {     return startBlockingTestNodesAction(checkLatch, new NodesRequest("Test Request"), listener). }
false;protected;1;12;;@Override protected NodeResponse nodeOperation(NodeRequest request) {     logger.info("Action on node {}", node).     actionLatch.countDown().     try {         checkLatch.await().     } catch (InterruptedException ex) {         Thread.currentThread().interrupt().     }     logger.info("Action on node {} finished", node).     return new NodeResponse(testNodes[node].discoveryNode()). }
false;private;3;32;;private Task startBlockingTestNodesAction(CountDownLatch checkLatch, NodesRequest request, ActionListener<NodesResponse> listener) throws InterruptedException {     CountDownLatch actionLatch = new CountDownLatch(nodesCount).     TestNodesAction[] actions = new TestNodesAction[nodesCount].     for (int i = 0. i < testNodes.length. i++) {         final int node = i.         actions[i] = new TestNodesAction("internal:testAction", threadPool, testNodes[i].clusterService, testNodes[i].transportService) {              @Override             protected NodeResponse nodeOperation(NodeRequest request) {                 logger.info("Action on node {}", node).                 actionLatch.countDown().                 try {                     checkLatch.await().                 } catch (InterruptedException ex) {                     Thread.currentThread().interrupt().                 }                 logger.info("Action on node {} finished", node).                 return new NodeResponse(testNodes[node].discoveryNode()).             }         }.     }     // Make sure no tasks are running     for (TestNode node : testNodes) {         assertEquals(0, node.transportService.getTaskManager().getTasks().size()).     }     Task task = actions[0].execute(request, listener).     logger.info("Awaiting for all actions to start").     assertTrue(actionLatch.await(10, TimeUnit.SECONDS)).     logger.info("Done waiting for all actions to start").     return task. }
false;public;1;5;;@Override public void onResponse(NodesResponse listTasksResponse) {     responseReference.set(listTasksResponse).     responseLatch.countDown(). }
false;public;1;5;;@Override public void onFailure(Exception e) {     logger.warn("Couldn't get list of tasks", e).     responseLatch.countDown(). }
false;public;0;98;;public void testRunningTasksCount() throws Exception {     setupTestNodes(Settings.EMPTY).     connectNodes(testNodes).     CountDownLatch checkLatch = new CountDownLatch(1).     CountDownLatch responseLatch = new CountDownLatch(1).     final AtomicReference<NodesResponse> responseReference = new AtomicReference<>().     Task mainTask = startBlockingTestNodesAction(checkLatch, new ActionListener<NodesResponse>() {          @Override         public void onResponse(NodesResponse listTasksResponse) {             responseReference.set(listTasksResponse).             responseLatch.countDown().         }          @Override         public void onFailure(Exception e) {             logger.warn("Couldn't get list of tasks", e).             responseLatch.countDown().         }     }).     // Check task counts using taskManager     Map<Long, Task> localTasks = testNodes[0].transportService.getTaskManager().getTasks().     // all node tasks + 1 coordinating task     assertEquals(2, localTasks.size()).     Task coordinatingTask = localTasks.get(Collections.min(localTasks.keySet())).     Task subTask = localTasks.get(Collections.max(localTasks.keySet())).     assertThat(subTask.getAction(), endsWith("[n]")).     assertThat(coordinatingTask.getAction(), not(endsWith("[n]"))).     for (int i = 1. i < testNodes.length. i++) {         Map<Long, Task> remoteTasks = testNodes[i].transportService.getTaskManager().getTasks().         assertEquals(1, remoteTasks.size()).         Task remoteTask = remoteTasks.values().iterator().next().         assertThat(remoteTask.getAction(), endsWith("[n]")).     }     // Check task counts using transport     int testNodeNum = randomIntBetween(0, testNodes.length - 1).     TestNode testNode = testNodes[testNodeNum].     ListTasksRequest listTasksRequest = new ListTasksRequest().     // pick all test actions     listTasksRequest.setActions("internal:testAction*").     logger.info("Listing currently running tasks using node [{}]", testNodeNum).     ListTasksResponse response = ActionTestUtils.executeBlocking(testNode.transportListTasksAction, listTasksRequest).     logger.info("Checking currently running tasks").     assertEquals(testNodes.length, response.getPerNodeTasks().size()).     // Coordinating node     assertEquals(2, response.getPerNodeTasks().get(testNodes[0].getNodeId()).size()).     // Other nodes node     for (int i = 1. i < testNodes.length. i++) {         assertEquals(1, response.getPerNodeTasks().get(testNodes[i].getNodeId()).size()).     }     // There should be a single main task when grouped by tasks     assertEquals(1, response.getTaskGroups().size()).     // And as many child tasks as we have nodes     assertEquals(testNodes.length, response.getTaskGroups().get(0).getChildTasks().size()).     // Check task counts using transport with filtering     testNode = testNodes[randomIntBetween(0, testNodes.length - 1)].     listTasksRequest = new ListTasksRequest().     // only pick node actions     listTasksRequest.setActions("internal:testAction[n]").     response = ActionTestUtils.executeBlocking(testNode.transportListTasksAction, listTasksRequest).     assertEquals(testNodes.length, response.getPerNodeTasks().size()).     for (Map.Entry<String, List<TaskInfo>> entry : response.getPerNodeTasks().entrySet()) {         assertEquals(1, entry.getValue().size()).         assertNull(entry.getValue().get(0).getDescription()).     }     // Since the main task is not in the list - all tasks should be by themselves     assertEquals(testNodes.length, response.getTaskGroups().size()).     for (TaskGroup taskGroup : response.getTaskGroups()) {         assertEquals(0, taskGroup.getChildTasks().size()).     }     // Check task counts using transport with detailed description     // same request only with detailed description     listTasksRequest.setDetailed(true).     response = ActionTestUtils.executeBlocking(testNode.transportListTasksAction, listTasksRequest).     assertEquals(testNodes.length, response.getPerNodeTasks().size()).     for (Map.Entry<String, List<TaskInfo>> entry : response.getPerNodeTasks().entrySet()) {         assertEquals(1, entry.getValue().size()).         assertEquals("CancellableNodeRequest[Test Request]", entry.getValue().get(0).getDescription()).     }     // Make sure that the main task on coordinating node is the task that was returned to us by execute()     // only pick the main task     listTasksRequest.setActions("internal:testAction").     response = ActionTestUtils.executeBlocking(testNode.transportListTasksAction, listTasksRequest).     assertEquals(1, response.getTasks().size()).     assertEquals(mainTask.getId(), response.getTasks().get(0).getId()).     // Release all tasks and wait for response     checkLatch.countDown().     assertTrue(responseLatch.await(10, TimeUnit.SECONDS)).     NodesResponse responses = responseReference.get().     assertEquals(0, responses.failureCount()).     // Make sure that we don't have any lingering tasks     for (TestNode node : testNodes) {         assertEquals(0, node.transportService.getTaskManager().getTasks().size()).     } }
false;public;0;32;;public void testFindChildTasks() throws Exception {     setupTestNodes(Settings.EMPTY).     connectNodes(testNodes).     CountDownLatch checkLatch = new CountDownLatch(1).     ActionFuture<NodesResponse> future = startBlockingTestNodesAction(checkLatch).     TestNode testNode = testNodes[randomIntBetween(0, testNodes.length - 1)].     // Get the parent task     ListTasksRequest listTasksRequest = new ListTasksRequest().     listTasksRequest.setActions("internal:testAction").     ListTasksResponse response = ActionTestUtils.executeBlocking(testNode.transportListTasksAction, listTasksRequest).     assertEquals(1, response.getTasks().size()).     String parentNode = response.getTasks().get(0).getTaskId().getNodeId().     long parentTaskId = response.getTasks().get(0).getId().     // Find tasks with common parent     listTasksRequest = new ListTasksRequest().     listTasksRequest.setParentTaskId(new TaskId(parentNode, parentTaskId)).     response = ActionTestUtils.executeBlocking(testNode.transportListTasksAction, listTasksRequest).     assertEquals(testNodes.length, response.getTasks().size()).     for (TaskInfo task : response.getTasks()) {         assertEquals("internal:testAction[n]", task.getAction()).         assertEquals(parentNode, task.getParentTaskId().getNodeId()).         assertEquals(parentTaskId, task.getParentTaskId().getId()).     }     // Release all tasks and wait for response     checkLatch.countDown().     NodesResponse responses = future.get().     assertEquals(0, responses.failureCount()). }
false;public;0;36;;public void testTasksDescriptions() throws Exception {     long minimalStartTime = System.currentTimeMillis().     setupTestNodes(Settings.EMPTY).     connectNodes(testNodes).     CountDownLatch checkLatch = new CountDownLatch(1).     ActionFuture<NodesResponse> future = startBlockingTestNodesAction(checkLatch).     long maximumStartTimeNanos = System.nanoTime().     // Check task counts using transport with filtering     TestNode testNode = testNodes[randomIntBetween(0, testNodes.length - 1)].     ListTasksRequest listTasksRequest = new ListTasksRequest().     // only pick node actions     listTasksRequest.setActions("internal:testAction[n]").     ListTasksResponse response = ActionTestUtils.executeBlocking(testNode.transportListTasksAction, listTasksRequest).     assertEquals(testNodes.length, response.getPerNodeTasks().size()).     for (Map.Entry<String, List<TaskInfo>> entry : response.getPerNodeTasks().entrySet()) {         assertEquals(1, entry.getValue().size()).         assertNull(entry.getValue().get(0).getDescription()).     }     // Check task counts using transport with detailed description     long minimalDurationNanos = System.nanoTime() - maximumStartTimeNanos.     // same request only with detailed description     listTasksRequest.setDetailed(true).     response = ActionTestUtils.executeBlocking(testNode.transportListTasksAction, listTasksRequest).     assertEquals(testNodes.length, response.getPerNodeTasks().size()).     for (Map.Entry<String, List<TaskInfo>> entry : response.getPerNodeTasks().entrySet()) {         assertEquals(1, entry.getValue().size()).         assertEquals("CancellableNodeRequest[Test Request]", entry.getValue().get(0).getDescription()).         assertThat(entry.getValue().get(0).getStartTime(), greaterThanOrEqualTo(minimalStartTime)).         assertThat(entry.getValue().get(0).getRunningTimeNanos(), greaterThanOrEqualTo(minimalDurationNanos)).     }     // Release all tasks and wait for response     checkLatch.countDown().     NodesResponse responses = future.get().     assertEquals(0, responses.failureCount()). }
false;public;1;4;;@Override public void onResponse(NodesResponse nodeResponses) {     responseLatch.countDown(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     responseLatch.countDown(). }
false;public;0;60;;public void testCancellingTasksThatDontSupportCancellation() throws Exception {     setupTestNodes(Settings.EMPTY).     connectNodes(testNodes).     CountDownLatch checkLatch = new CountDownLatch(1).     CountDownLatch responseLatch = new CountDownLatch(1).     Task task = startBlockingTestNodesAction(checkLatch, new ActionListener<NodesResponse>() {          @Override         public void onResponse(NodesResponse nodeResponses) {             responseLatch.countDown().         }          @Override         public void onFailure(Exception e) {             responseLatch.countDown().         }     }).     // only pick the main action     String actionName = "internal:testAction".     // Try to cancel main task using action name     CancelTasksRequest request = new CancelTasksRequest().     request.setNodes(testNodes[0].getNodeId()).     request.setReason("Testing Cancellation").     request.setActions(actionName).     CancelTasksResponse response = ActionTestUtils.executeBlocking(testNodes[randomIntBetween(0, testNodes.length - 1)].transportCancelTasksAction, request).     // Shouldn't match any tasks since testAction doesn't support cancellation     assertEquals(0, response.getTasks().size()).     assertEquals(0, response.getTaskFailures().size()).     assertEquals(0, response.getNodeFailures().size()).     // Try to cancel main task using id     request = new CancelTasksRequest().     request.setReason("Testing Cancellation").     request.setTaskId(new TaskId(testNodes[0].getNodeId(), task.getId())).     response = ActionTestUtils.executeBlocking(testNodes[randomIntBetween(0, testNodes.length - 1)].transportCancelTasksAction, request).     // Shouldn't match any tasks since testAction doesn't support cancellation     assertEquals(0, response.getTasks().size()).     assertEquals(0, response.getTaskFailures().size()).     assertEquals(1, response.getNodeFailures().size()).     assertThat(response.getNodeFailures().get(0).getDetailedMessage(), containsString("doesn't support cancellation")).     // Make sure that task is still running     ListTasksRequest listTasksRequest = new ListTasksRequest().     listTasksRequest.setActions(actionName).     ListTasksResponse listResponse = ActionTestUtils.executeBlocking(testNodes[randomIntBetween(0, testNodes.length - 1)].transportListTasksAction, listTasksRequest).     assertEquals(1, listResponse.getPerNodeTasks().size()).     // Verify that tasks are marked as non-cancellable     for (TaskInfo taskInfo : listResponse.getTasks()) {         assertFalse(taskInfo.isCancellable()).     }     // Release all tasks and wait for response     checkLatch.countDown().     responseLatch.await(10, TimeUnit.SECONDS). }
false;protected;1;5;;@Override protected NodeResponse nodeOperation(NodeRequest request) {     logger.info("Action on node {}", node).     throw new RuntimeException("Test exception"). }
false;public;0;36;;public void testFailedTasksCount() throws ExecutionException, InterruptedException, IOException {     Settings settings = Settings.builder().put(MockTaskManager.USE_MOCK_TASK_MANAGER_SETTING.getKey(), true).build().     setupTestNodes(settings).     connectNodes(testNodes).     TestNodesAction[] actions = new TestNodesAction[nodesCount].     RecordingTaskManagerListener[] listeners = setupListeners(testNodes, "internal:testAction*").     for (int i = 0. i < testNodes.length. i++) {         final int node = i.         actions[i] = new TestNodesAction("internal:testAction", threadPool, testNodes[i].clusterService, testNodes[i].transportService) {              @Override             protected NodeResponse nodeOperation(NodeRequest request) {                 logger.info("Action on node {}", node).                 throw new RuntimeException("Test exception").             }         }.     }     for (TestNode testNode : testNodes) {         assertEquals(0, testNode.transportService.getTaskManager().getTasks().size()).     }     NodesRequest request = new NodesRequest("Test Request").     NodesResponse responses = ActionTestUtils.executeBlocking(actions[0], request).     assertEquals(nodesCount, responses.failureCount()).     // Make sure that actions are still registered in the task manager on all nodes     // Twice on the coordinating node and once on all other nodes.     assertEquals(4, listeners[0].getEvents().size()).     assertEquals(2, listeners[0].getRegistrationEvents().size()).     assertEquals(2, listeners[0].getUnregistrationEvents().size()).     for (int i = 1. i < listeners.length. i++) {         assertEquals(2, listeners[i].getEvents().size()).         assertEquals(1, listeners[i].getRegistrationEvents().size()).         assertEquals(1, listeners[i].getUnregistrationEvents().size()).     } }
false;protected;3;30;;@Override protected void taskOperation(TestTasksRequest request, Task task, ActionListener<TestTaskResponse> listener) {     logger.info("Task action on node {}", node).     if (failTaskOnNode == node && task.getParentTaskId().isSet()) {         logger.info("Failing on node {}", node).         // Fail in a random way to make sure we can handle all these ways         Runnable failureMode = randomFrom(() -> {             logger.info("Throwing exception from taskOperation").             throw new RuntimeException("Task level failure (direct)").         }, () -> {             logger.info("Calling listener synchronously with exception from taskOperation").             listener.onFailure(new RuntimeException("Task level failure (sync listener)")).         }, () -> {             logger.info("Calling listener asynchronously with exception from taskOperation").             threadPool.generic().execute(() -> listener.onFailure(new RuntimeException("Task level failure (async listener)"))).         }).         failureMode.run().     } else {         if (randomBoolean()) {             listener.onResponse(new TestTaskResponse("Success on node (sync)" + node)).         } else {             threadPool.generic().execute(() -> listener.onResponse(new TestTaskResponse("Success on node (async)" + node))).         }     } }
false;public;0;62;;public void testTaskLevelActionFailures() throws ExecutionException, InterruptedException, IOException {     setupTestNodes(Settings.EMPTY).     connectNodes(testNodes).     CountDownLatch checkLatch = new CountDownLatch(1).     ActionFuture<NodesResponse> future = startBlockingTestNodesAction(checkLatch).     TestTasksAction[] tasksActions = new TestTasksAction[nodesCount].     final int failTaskOnNode = randomIntBetween(1, nodesCount - 1).     for (int i = 0. i < testNodes.length. i++) {         final int node = i.         // Simulate task action that fails on one of the tasks on one of the nodes         tasksActions[i] = new TestTasksAction("internal:testTasksAction", testNodes[i].clusterService, testNodes[i].transportService) {              @Override             protected void taskOperation(TestTasksRequest request, Task task, ActionListener<TestTaskResponse> listener) {                 logger.info("Task action on node {}", node).                 if (failTaskOnNode == node && task.getParentTaskId().isSet()) {                     logger.info("Failing on node {}", node).                     // Fail in a random way to make sure we can handle all these ways                     Runnable failureMode = randomFrom(() -> {                         logger.info("Throwing exception from taskOperation").                         throw new RuntimeException("Task level failure (direct)").                     }, () -> {                         logger.info("Calling listener synchronously with exception from taskOperation").                         listener.onFailure(new RuntimeException("Task level failure (sync listener)")).                     }, () -> {                         logger.info("Calling listener asynchronously with exception from taskOperation").                         threadPool.generic().execute(() -> listener.onFailure(new RuntimeException("Task level failure (async listener)"))).                     }).                     failureMode.run().                 } else {                     if (randomBoolean()) {                         listener.onResponse(new TestTaskResponse("Success on node (sync)" + node)).                     } else {                         threadPool.generic().execute(() -> listener.onResponse(new TestTaskResponse("Success on node (async)" + node))).                     }                 }             }         }.     }     // Run task action on node tasks that are currently running     // should be successful on all nodes except one     TestTasksRequest testTasksRequest = new TestTasksRequest().     // pick all test actions     testTasksRequest.setActions("internal:testAction[n]").     TestTasksResponse response = ActionTestUtils.executeBlocking(tasksActions[0], testTasksRequest).     // one task failed     assertThat(response.getTaskFailures(), hasSize(1)).     assertThat(response.getTaskFailures().get(0).getReason(), containsString("Task level failure")).     // Get successful responses from all nodes except one     assertEquals(testNodes.length - 1, response.tasks.size()).     // no nodes failed     assertEquals(0, response.getNodeFailures().size()).     // Release all node tasks and wait for response     checkLatch.countDown().     NodesResponse responses = future.get().     assertEquals(0, responses.failureCount()). }
false;protected;2;11;;@Override protected String[] filterNodeIds(DiscoveryNodes nodes, String[] nodesIds) {     String[] superNodes = super.filterNodeIds(nodes, nodesIds).     List<String> filteredNodes = new ArrayList<>().     for (String node : superNodes) {         if (filterNodes.contains(node) == false) {             filteredNodes.add(node).         }     }     return filteredNodes.toArray(new String[filteredNodes.size()]). }
false;protected;3;8;;@Override protected void taskOperation(TestTasksRequest request, Task task, ActionListener<TestTaskResponse> listener) {     if (randomBoolean()) {         listener.onResponse(new TestTaskResponse(testNodes[node].getNodeId())).     } else {         threadPool.generic().execute(() -> listener.onResponse(new TestTaskResponse(testNodes[node].getNodeId()))).     } }
true;public;0;69;/**  * This test starts nodes actions that blocks on all nodes. While node actions are blocked in the middle of execution  * it executes a tasks action that targets these blocked node actions. The test verifies that task actions are only  * getting executed on nodes that are not listed in the node filter.  */ ;/**  * This test starts nodes actions that blocks on all nodes. While node actions are blocked in the middle of execution  * it executes a tasks action that targets these blocked node actions. The test verifies that task actions are only  * getting executed on nodes that are not listed in the node filter.  */ public void testTaskNodeFiltering() throws ExecutionException, InterruptedException, IOException {     setupTestNodes(Settings.EMPTY).     connectNodes(testNodes).     CountDownLatch checkLatch = new CountDownLatch(1).     // Start some test nodes action so we could have something to run tasks actions on     ActionFuture<NodesResponse> future = startBlockingTestNodesAction(checkLatch).     String[] allNodes = new String[testNodes.length].     for (int i = 0. i < testNodes.length. i++) {         allNodes[i] = testNodes[i].getNodeId().     }     int filterNodesSize = randomInt(allNodes.length).     Set<String> filterNodes = new HashSet<>(randomSubsetOf(filterNodesSize, allNodes)).     logger.info("Filtering out nodes {} size: {}", filterNodes, filterNodesSize).     TestTasksAction[] tasksActions = new TestTasksAction[nodesCount].     for (int i = 0. i < testNodes.length. i++) {         final int node = i.         // Simulate a task action that works on all nodes except nodes listed in filterNodes.         // We are testing that it works.         tasksActions[i] = new TestTasksAction("internal:testTasksAction", testNodes[i].clusterService, testNodes[i].transportService) {              @Override             protected String[] filterNodeIds(DiscoveryNodes nodes, String[] nodesIds) {                 String[] superNodes = super.filterNodeIds(nodes, nodesIds).                 List<String> filteredNodes = new ArrayList<>().                 for (String node : superNodes) {                     if (filterNodes.contains(node) == false) {                         filteredNodes.add(node).                     }                 }                 return filteredNodes.toArray(new String[filteredNodes.size()]).             }              @Override             protected void taskOperation(TestTasksRequest request, Task task, ActionListener<TestTaskResponse> listener) {                 if (randomBoolean()) {                     listener.onResponse(new TestTaskResponse(testNodes[node].getNodeId())).                 } else {                     threadPool.generic().execute(() -> listener.onResponse(new TestTaskResponse(testNodes[node].getNodeId()))).                 }             }         }.     }     // Run task action on node tasks that are currently running     // should be successful on all nodes except nodes that we filtered out     TestTasksRequest testTasksRequest = new TestTasksRequest().     // pick all test actions     testTasksRequest.setActions("internal:testAction[n]").     TestTasksResponse response = ActionTestUtils.executeBlocking(tasksActions[randomIntBetween(0, nodesCount - 1)], testTasksRequest).     // Get successful responses from all nodes except nodes that we filtered out     assertEquals(testNodes.length - filterNodes.size(), response.tasks.size()).     // no task failed     assertEquals(0, response.getTaskFailures().size()).     // no nodes failed     assertEquals(0, response.getNodeFailures().size()).     // Make sure that filtered nodes didn't send any responses     for (TestTaskResponse taskResponse : response.tasks) {         String nodeId = taskResponse.getStatus().         assertFalse("Found response from filtered node " + nodeId, filterNodes.contains(nodeId)).     }     // Release all node tasks and wait for response     checkLatch.countDown().     NodesResponse responses = future.get().     assertEquals(0, responses.failureCount()). }
false;public;0;37;;@SuppressWarnings("unchecked") public void testTasksToXContentGrouping() throws Exception {     setupTestNodes(Settings.EMPTY).     connectNodes(testNodes).     // Get the parent task     ListTasksRequest listTasksRequest = new ListTasksRequest().     listTasksRequest.setActions(ListTasksAction.NAME + "*").     ListTasksResponse response = ActionTestUtils.executeBlocking(testNodes[0].transportListTasksAction, listTasksRequest).     assertEquals(testNodes.length + 1, response.getTasks().size()).     Map<String, Object> byNodes = serialize(response, true).     byNodes = (Map<String, Object>) byNodes.get("nodes").     // One element on the top level     assertEquals(testNodes.length, byNodes.size()).     Map<String, Object> firstNode = (Map<String, Object>) byNodes.get(testNodes[0].getNodeId()).     firstNode = (Map<String, Object>) firstNode.get("tasks").     // two tasks for the first node     assertEquals(2, firstNode.size()).     for (int i = 1. i < testNodes.length. i++) {         Map<String, Object> otherNode = (Map<String, Object>) byNodes.get(testNodes[i].getNodeId()).         otherNode = (Map<String, Object>) otherNode.get("tasks").         // one tasks for the all other nodes         assertEquals(1, otherNode.size()).     }     // Group by parents     Map<String, Object> byParent = serialize(response, false).     byParent = (Map<String, Object>) byParent.get("tasks").     // One element on the top level     // Only one top level task     assertEquals(1, byParent.size()).     Map<String, Object> topTask = (Map<String, Object>) byParent.values().iterator().next().     List<Object> children = (List<Object>) topTask.get("children").     // two tasks for the first node     assertEquals(testNodes.length, children.size()).     for (int i = 0. i < testNodes.length. i++) {         Map<String, Object> child = (Map<String, Object>) children.get(i).         assertNull(child.get("children")).     } }
false;private;2;14;;private Map<String, Object> serialize(ListTasksResponse response, boolean byParents) throws IOException {     XContentBuilder builder = XContentFactory.contentBuilder(XContentType.JSON).     builder.startObject().     if (byParents) {         DiscoveryNodes nodes = testNodes[0].clusterService.state().nodes().         response.toXContentGroupedByNode(builder, ToXContent.EMPTY_PARAMS, nodes).     } else {         response.toXContentGroupedByParents(builder, ToXContent.EMPTY_PARAMS).     }     builder.endObject().     builder.flush().     logger.info(Strings.toString(builder)).     return XContentHelper.convertToMap(BytesReference.bytes(builder), false, builder.contentType()).v2(). }
