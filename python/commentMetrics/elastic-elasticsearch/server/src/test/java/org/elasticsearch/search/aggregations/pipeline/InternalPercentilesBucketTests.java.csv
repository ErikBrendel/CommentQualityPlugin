commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;5;;@Override protected InternalPercentilesBucket createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) {     return createTestInstance(name, pipelineAggregators, metaData, randomPercents(), true). }
false;private,static;5;8;;private static InternalPercentilesBucket createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData, double[] percents, boolean keyed) {     final double[] percentiles = new double[percents.length].     for (int i = 0. i < percents.length. ++i) {         percentiles[i] = frequently() ? randomDouble() : Double.NaN.     }     return createTestInstance(name, pipelineAggregators, metaData, percents, percentiles, keyed). }
false;private,static;6;5;;private static InternalPercentilesBucket createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData, double[] percents, double[] percentiles, boolean keyed) {     DocValueFormat format = randomNumericDocValueFormat().     return new InternalPercentilesBucket(name, percents, percentiles, keyed, format, pipelineAggregators, metaData). }
false;public;0;5;;@Override public void testReduceRandom() {     expectThrows(UnsupportedOperationException.class, () -> createTestInstance("name", Collections.emptyList(), null).reduce(null, null)). }
false;protected;2;4;;@Override protected void assertReduced(InternalPercentilesBucket reduced, List<InternalPercentilesBucket> inputs) { // no test since reduce operation is unsupported }
false;protected;0;4;;@Override protected Writeable.Reader<InternalPercentilesBucket> instanceReader() {     return InternalPercentilesBucket::new. }
false;protected,final;2;15;;@Override protected final void assertFromXContent(InternalPercentilesBucket aggregation, ParsedAggregation parsedAggregation) {     assertTrue(parsedAggregation instanceof ParsedPercentilesBucket).     ParsedPercentilesBucket parsedPercentiles = (ParsedPercentilesBucket) parsedAggregation.     for (Percentile percentile : aggregation) {         Double percent = percentile.getPercent().         assertEquals(aggregation.percentile(percent), parsedPercentiles.percentile(percent), 0).         // null and we don't have a formatted string representation in the rest output         if (Double.isNaN(aggregation.percentile(percent)) == false) {             assertEquals(aggregation.percentileAsString(percent), parsedPercentiles.percentileAsString(percent)).         }     } }
true;public;0;12;/**  * check that we don't rely on the percent array order and that the iterator returns the values in the original order  */ ;/**  * check that we don't rely on the percent array order and that the iterator returns the values in the original order  */ public void testPercentOrder() {     final double[] percents = new double[] { 0.50, 0.25, 0.01, 0.99, 0.60 }.     InternalPercentilesBucket aggregation = createTestInstance("test", Collections.emptyList(), Collections.emptyMap(), percents, randomBoolean()).     Iterator<Percentile> iterator = aggregation.iterator().     for (double percent : percents) {         assertTrue(iterator.hasNext()).         Percentile percentile = iterator.next().         assertEquals(percent, percentile.getPercent(), 0.0d).         assertEquals(aggregation.percentile(percent), percentile.getValue(), 0.0d).     } }
false;public;0;8;;public void testErrorOnDifferentArgumentSize() {     final double[] percents = new double[] { 0.1, 0.2, 0.3 }.     final double[] percentiles = new double[] { 0.10, 0.2 }.     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new InternalPercentilesBucket("test", percents, percentiles, randomBoolean(), DocValueFormat.RAW, Collections.emptyList(), Collections.emptyMap())).     assertEquals("The number of provided percents and percentiles didn't match. percents: [0.1, 0.2, 0.3], percentiles: [0.1, 0.2]", e.getMessage()). }
false;public;0;9;;public void testParsedAggregationIteratorOrder() throws IOException {     final InternalPercentilesBucket aggregation = createTestInstance().     final Iterable<Percentile> parsedAggregation = parseAndAssert(aggregation, false, false).     Iterator<Percentile> it = aggregation.iterator().     Iterator<Percentile> parsedIt = parsedAggregation.iterator().     while (it.hasNext()) {         assertEquals(it.next(), parsedIt.next()).     } }
false;public;0;45;;public void testEmptyRanksXContent() throws IOException {     double[] percents = new double[] { 1, 2, 3 }.     double[] percentiles = new double[3].     for (int i = 0. i < 3. ++i) {         percentiles[i] = randomBoolean() ? Double.NaN : Double.POSITIVE_INFINITY.     }     boolean keyed = randomBoolean().     InternalPercentilesBucket agg = createTestInstance("test", Collections.emptyList(), Collections.emptyMap(), percents, percentiles, keyed).     XContentBuilder builder = JsonXContent.contentBuilder().prettyPrint().     builder.startObject().     agg.doXContentBody(builder, ToXContent.EMPTY_PARAMS).     builder.endObject().     String expected.     if (keyed) {         expected = "{\n" + "  \"values\" : {\n" + "    \"1.0\" : null,\n" + "    \"2.0\" : null,\n" + "    \"3.0\" : null\n" + "  }\n" + "}".     } else {         expected = "{\n" + "  \"values\" : [\n" + "    {\n" + "      \"key\" : 1.0,\n" + "      \"value\" : null\n" + "    },\n" + "    {\n" + "      \"key\" : 2.0,\n" + "      \"value\" : null\n" + "    },\n" + "    {\n" + "      \"key\" : 3.0,\n" + "      \"value\" : null\n" + "    }\n" + "  ]\n" + "}".     }     assertThat(Strings.toString(builder), equalTo(expected)). }
false;protected;0;4;;@Override protected Predicate<String> excludePathsFromXContentInsertion() {     return path -> path.endsWith(CommonFields.VALUES.getPreferredName()). }
false;protected;1;33;;@Override protected InternalPercentilesBucket mutateInstance(InternalPercentilesBucket instance) {     String name = instance.getName().     double[] percents = extractPercents(instance).     double[] percentiles = extractPercentiles(instance).     DocValueFormat formatter = instance.formatter().     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 3)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             percents = Arrays.copyOf(percents, percents.length).             percents[percents.length - 1] = randomDouble().             break.         case 2:             percentiles = Arrays.copyOf(percentiles, percentiles.length).             percentiles[percentiles.length - 1] = randomDouble().             break.         case 3:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new InternalPercentilesBucket(name, percents, percentiles, randomBoolean(), formatter, pipelineAggregators, metaData). }
false;private;1;9;;private double[] extractPercentiles(InternalPercentilesBucket instance) {     List<Double> values = new ArrayList<>().     instance.iterator().forEachRemaining(percentile -> values.add(percentile.getValue())).     double[] valuesArray = new double[values.size()].     for (int i = 0. i < values.size(). i++) {         valuesArray[i] = values.get(i).     }     return valuesArray. }
false;private;1;9;;private double[] extractPercents(InternalPercentilesBucket instance) {     List<Double> percents = new ArrayList<>().     instance.iterator().forEachRemaining(percentile -> percents.add(percentile.getPercent())).     double[] percentArray = new double[percents.size()].     for (int i = 0. i < percents.size(). i++) {         percentArray[i] = percents.get(i).     }     return percentArray. }
