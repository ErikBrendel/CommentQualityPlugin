commented;modifiers;parameterAmount;loc;comment;code
false;public;0;17;;public void testManualSerialization() throws IOException {     Map<String, Map<String, Map<String, FieldMappingMetaData>>> mappings = new HashMap<>().     FieldMappingMetaData fieldMappingMetaData = new FieldMappingMetaData("my field", new BytesArray("{}")).     mappings.put("index", Collections.singletonMap("type", Collections.singletonMap("field", fieldMappingMetaData))).     GetFieldMappingsResponse response = new GetFieldMappingsResponse(mappings).     try (BytesStreamOutput out = new BytesStreamOutput()) {         response.writeTo(out).         GetFieldMappingsResponse serialized = new GetFieldMappingsResponse().         try (StreamInput in = StreamInput.wrap(out.bytes().toBytesRef().bytes)) {             serialized.readFrom(in).             FieldMappingMetaData metaData = serialized.fieldMappings("index", "type", "field").             assertNotNull(metaData).             assertEquals(new BytesArray("{}"), metaData.getSource()).         }     } }
false;public;0;41;;public void testManualJunkedJson() throws Exception {     // in fact random fields could be evaluated as proper mapping, while proper junk in this case is arrays and values     final String json = "{\"index1\":{\"mappings\":" + "{\"doctype0\":{\"field1\":{\"full_name\":\"my field\",\"mapping\":{\"type\":\"keyword\"}}," + "\"field0\":{\"full_name\":\"my field\",\"mapping\":{\"type\":\"keyword\"}}}," + // junk here     "\"junk1\": [\"field1\", {\"field2\":{}}]," + "\"junk2\": [{\"field3\":{}}]," + "\"junk3\": 42," + "\"junk4\": \"Q\"," + "\"doctype1\":{\"field1\":{\"full_name\":\"my field\",\"mapping\":{\"type\":\"keyword\"}}," + "\"field0\":{\"full_name\":\"my field\",\"mapping\":{\"type\":\"keyword\"}}}}}," + "\"index0\":{\"mappings\":" + "{\"doctype0\":{\"field1\":{\"full_name\":\"my field\",\"mapping\":{\"type\":\"keyword\"}}," + "\"field0\":{\"full_name\":\"my field\",\"mapping\":{\"type\":\"keyword\"}}}," + "\"doctype1\":{\"field1\":{\"full_name\":\"my field\",\"mapping\":{\"type\":\"keyword\"}}," + "\"field0\":{\"full_name\":\"my field\",\"mapping\":{\"type\":\"keyword\"}}}}}}".     final XContentParser parser = XContentType.JSON.xContent().createParser(xContentRegistry(), LoggingDeprecationHandler.INSTANCE, json.getBytes("UTF-8")).     final GetFieldMappingsResponse response = GetFieldMappingsResponse.fromXContent(parser).     FieldMappingMetaData fieldMappingMetaData = new FieldMappingMetaData("my field", new BytesArray("{\"type\":\"keyword\"}")).     Map<String, FieldMappingMetaData> fieldMapping = new HashMap<>().     fieldMapping.put("field0", fieldMappingMetaData).     fieldMapping.put("field1", fieldMappingMetaData).     Map<String, Map<String, FieldMappingMetaData>> typeMapping = new HashMap<>().     typeMapping.put("doctype0", fieldMapping).     typeMapping.put("doctype1", fieldMapping).     Map<String, Map<String, Map<String, FieldMappingMetaData>>> mappings = new HashMap<>().     mappings.put("index0", typeMapping).     mappings.put("index1", typeMapping).     final Map<String, Map<String, Map<String, FieldMappingMetaData>>> responseMappings = response.mappings().     assertThat(responseMappings, equalTo(mappings)). }
false;protected;1;4;;@Override protected GetFieldMappingsResponse doParseInstance(XContentParser parser) throws IOException {     return GetFieldMappingsResponse.fromXContent(parser). }
false;protected;0;4;;@Override protected GetFieldMappingsResponse createBlankInstance() {     return new GetFieldMappingsResponse(). }
false;protected;0;4;;@Override protected GetFieldMappingsResponse createTestInstance() {     return new GetFieldMappingsResponse(randomMapping()). }
false;protected;0;7;;@Override protected Predicate<String> getRandomFieldsExcludeFilter() {     // otherwise random field could be evaluated as index name or type name     return s -> false == (s.matches("(?<index>[^.]+)") || s.matches("(?<index>[^.]+)\\.mappings\\.(?<doctype>[^.]+)\\.(?<field>[^.]+)")). }
true;protected;0;4;/**  * For xContent roundtrip testing we force the xContent output to still contain types because the parser  * still expects them. The new typeless parsing is implemented in the client side GetFieldMappingsResponse.  */ ;/**  * For xContent roundtrip testing we force the xContent output to still contain types because the parser  * still expects them. The new typeless parsing is implemented in the client side GetFieldMappingsResponse.  */ @Override protected ToXContent.Params getToXContentParams() {     return new ToXContent.MapParams(Collections.singletonMap(INCLUDE_TYPE_NAME_PARAMETER, "true")). }
false;private;0;22;;private Map<String, Map<String, Map<String, FieldMappingMetaData>>> randomMapping() {     Map<String, Map<String, Map<String, FieldMappingMetaData>>> mappings = new HashMap<>().     int indices = randomInt(10).     for (int i = 0. i < indices. i++) {         final Map<String, Map<String, FieldMappingMetaData>> doctypesMappings = new HashMap<>().         int doctypes = randomInt(10).         for (int j = 0. j < doctypes. j++) {             Map<String, FieldMappingMetaData> fieldMappings = new HashMap<>().             int fields = randomInt(10).             for (int k = 0. k < fields. k++) {                 final String mapping = randomBoolean() ? "{\"type\":\"string\"}" : "{\"type\":\"keyword\"}".                 FieldMappingMetaData metaData = new FieldMappingMetaData("my field", new BytesArray(mapping)).                 fieldMappings.put("field" + k, metaData).             }             doctypesMappings.put("doctype" + j, fieldMappings).         }         mappings.put("index" + i, doctypesMappings).     }     return mappings. }
