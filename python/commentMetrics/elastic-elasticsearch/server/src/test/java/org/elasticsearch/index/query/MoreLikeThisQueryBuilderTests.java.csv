commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;@Before public void setup() {     // MLT only supports string fields, unsupported fields are tested below     randomFields = randomStringFields().     // we also preset the item requests     randomLikeItems = new Item[randomIntBetween(1, 3)].     for (int i = 0. i < randomLikeItems.length. i++) {         randomLikeItems[i] = generateRandomItem().     }     // and for the unlike items too     randomUnlikeItems = new Item[randomIntBetween(1, 3)].     for (int i = 0. i < randomUnlikeItems.length. i++) {         randomUnlikeItems[i] = generateRandomItem().     } }
false;private,static;0;5;;private static String[] randomStringFields() {     String[] mappedStringFields = new String[] { STRING_FIELD_NAME, STRING_FIELD_NAME_2, STRING_ALIAS_FIELD_NAME }.     String[] unmappedStringFields = generateRandomStringArray(2, 5, false, false).     return Stream.concat(Arrays.stream(mappedStringFields), Arrays.stream(unmappedStringFields)).toArray(String[]::new). }
false;private;0;35;;private Item generateRandomItem() {     String index = randomBoolean() ? getIndex().getName() : null.     // indexed item or artificial document     Item item.     if (randomBoolean()) {         item = randomBoolean() ? new Item(index, randomAlphaOfLength(10)) : new Item(index, randomArtificialDoc()).     } else {         String type = "doc".         item = randomBoolean() ? new Item(index, type, randomAlphaOfLength(10)) : new Item(index, type, randomArtificialDoc()).     }     // if no field is specified MLT uses all mapped fields for this item     if (randomBoolean()) {         item.fields(randomFrom(randomFields)).     }     // per field analyzer     if (randomBoolean()) {         item.perFieldAnalyzer(randomPerFieldAnalyzer()).     }     if (randomBoolean()) {         item.routing(randomAlphaOfLength(10)).     }     if (randomBoolean()) {         item.version(randomInt(5)).     }     if (randomBoolean()) {         item.versionType(randomFrom(VersionType.values())).     }     return item. }
false;private;0;13;;private XContentBuilder randomArtificialDoc() {     XContentBuilder doc.     try {         doc = XContentFactory.jsonBuilder().startObject().         for (String field : randomFields) {             doc.field(field, randomAlphaOfLength(10)).         }         doc.endObject().     } catch (IOException e) {         throw new ElasticsearchException("Unable to generate random artificial doc!").     }     return doc. }
false;private;0;7;;private Map<String, String> randomPerFieldAnalyzer() {     Map<String, String> perFieldAnalyzer = new HashMap<>().     for (String field : randomFields) {         perFieldAnalyzer.put(field, randomAnalyzer()).     }     return perFieldAnalyzer. }
false;protected;0;61;;@Override protected MoreLikeThisQueryBuilder doCreateTestQueryBuilder() {     MoreLikeThisQueryBuilder queryBuilder.     String[] likeTexts = null.     Item[] likeItems = null.     // like field is required     if (randomBoolean()) {         likeTexts = generateRandomStringArray(5, 5, false, false).     } else {         likeItems = randomLikeItems.     }     if (randomBoolean()) {         // for the default field         queryBuilder = new MoreLikeThisQueryBuilder(likeTexts, likeItems).     } else {         queryBuilder = new MoreLikeThisQueryBuilder(randomFields, likeTexts, likeItems).     }     if (randomBoolean()) {         queryBuilder.unlike(generateRandomStringArray(5, 5, false, false)).     }     if (randomBoolean()) {         queryBuilder.unlike(randomUnlikeItems).     }     if (randomBoolean()) {         queryBuilder.maxQueryTerms(randomInt(25)).     }     if (randomBoolean()) {         queryBuilder.minTermFreq(randomInt(5)).     }     if (randomBoolean()) {         queryBuilder.minDocFreq(randomInt(5)).     }     if (randomBoolean()) {         queryBuilder.maxDocFreq(randomInt(100)).     }     if (randomBoolean()) {         queryBuilder.minWordLength(randomInt(5)).     }     if (randomBoolean()) {         queryBuilder.maxWordLength(randomInt(25)).     }     if (randomBoolean()) {         queryBuilder.stopWords(generateRandomStringArray(5, 5, false, false)).     }     if (randomBoolean()) {         // fix the analyzer?         queryBuilder.analyzer(randomAnalyzer()).     }     if (randomBoolean()) {         queryBuilder.minimumShouldMatch(randomMinimumShouldMatch()).     }     if (randomBoolean()) {         queryBuilder.boostTerms(randomFloat() * 10).     }     if (randomBoolean()) {         queryBuilder.include(randomBoolean()).     }     if (randomBoolean()) {         queryBuilder.failOnUnsupportedField(randomBoolean()).     }     return queryBuilder. }
true;protected;0;4;/**  * we don't want to shuffle the "doc" field internally in {@link #testFromXContent()} because even though the  * documents would be functionally the same, their {@link BytesReference} representation isn't and thats what we  * compare when check for equality of the original and the shuffled builder  */ ;/**  * we don't want to shuffle the "doc" field internally in {@link #testFromXContent()} because even though the  * documents would be functionally the same, their {@link BytesReference} representation isn't and thats what we  * compare when check for equality of the original and the shuffled builder  */ @Override protected String[] shuffleProtectedFields() {     return SHUFFLE_PROTECTED_FIELDS. }
false;protected;0;5;;@Override protected Set<String> getObjectsHoldingArbitraryContent() {     // doc contains arbitrary content, anything can be added to it and no exception will be thrown     return Collections.singleton(MoreLikeThisQueryBuilder.DOC.getPreferredName()). }
false;protected;1;24;;@Override protected MultiTermVectorsResponse executeMultiTermVectors(MultiTermVectorsRequest mtvRequest) {     try {         MultiTermVectorsItemResponse[] responses = new MultiTermVectorsItemResponse[mtvRequest.size()].         int i = 0.         for (TermVectorsRequest request : mtvRequest) {             TermVectorsResponse response = new TermVectorsResponse(request.index(), request.type(), request.id()).             response.setExists(true).             Fields generatedFields.             if (request.doc() != null) {                 generatedFields = generateFields(randomFields, request.doc().utf8ToString()).             } else {                 generatedFields = generateFields(request.selectedFields().toArray(new String[request.selectedFields().size()]), request.id()).             }             EnumSet<TermVectorsRequest.Flag> flags = EnumSet.of(TermVectorsRequest.Flag.Positions, TermVectorsRequest.Flag.Offsets).             response.setFields(generatedFields, request.selectedFields(), flags, generatedFields).             responses[i++] = new MultiTermVectorsItemResponse(response, null).         }         return new MultiTermVectorsResponse(responses).     } catch (IOException ex) {         throw new ElasticsearchException("boom", ex).     } }
true;private,static;2;7;/**  * Here we could go overboard and use a pre-generated indexed random document for a given Item,  * but for now we'd prefer to simply return the id as the content of the document and that for  * every field.  */ ;/**  * Here we could go overboard and use a pre-generated indexed random document for a given Item,  * but for now we'd prefer to simply return the id as the content of the document and that for  * every field.  */ private static Fields generateFields(String[] fieldNames, String text) throws IOException {     MemoryIndex index = new MemoryIndex().     for (String fieldName : fieldNames) {         index.addField(fieldName, text, new WhitespaceAnalyzer()).     }     return index.createSearcher().getIndexReader().getTermVectors(0). }
false;protected;3;16;;@Override protected void doAssertLuceneQuery(MoreLikeThisQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     if (queryBuilder.likeItems() != null && queryBuilder.likeItems().length > 0) {         assertThat(query, instanceOf(BooleanQuery.class)).         BooleanQuery booleanQuery = (BooleanQuery) query.         for (BooleanClause booleanClause : booleanQuery) {             if (booleanClause.getQuery() instanceof MoreLikeThisQuery) {                 MoreLikeThisQuery moreLikeThisQuery = (MoreLikeThisQuery) booleanClause.getQuery().                 assertThat(moreLikeThisQuery.getLikeFields().length, greaterThan(0)).             }         }     } else {         // we rely on integration tests for a deeper check here         assertThat(query, instanceOf(MoreLikeThisQuery.class)).     } }
false;public;0;5;;public void testValidateEmptyFields() {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new MoreLikeThisQueryBuilder(new String[0], new String[] { "likeText" }, null)).     assertThat(e.getMessage(), containsString("requires 'fields' to be specified")). }
false;public;0;7;;public void testValidateEmptyLike() {     String[] likeTexts = randomBoolean() ? null : new String[0].     Item[] likeItems = randomBoolean() ? null : new Item[0].     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new MoreLikeThisQueryBuilder(likeTexts, likeItems)).     assertThat(e.getMessage(), containsString("requires either 'like' texts or items to be specified")). }
false;public;0;8;;public void testUnsupportedFields() throws IOException {     String unsupportedField = randomFrom(INT_FIELD_NAME, DOUBLE_FIELD_NAME, DATE_FIELD_NAME).     MoreLikeThisQueryBuilder queryBuilder = new MoreLikeThisQueryBuilder(new String[] { unsupportedField }, new String[] { "some text" }, null).failOnUnsupportedField(true).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> queryBuilder.toQuery(createShardContext())).     assertThat(e.getMessage(), containsString("more_like_this only supports text/keyword fields")). }
false;public;0;11;;public void testMoreLikeThisBuilder() throws Exception {     Query parsedQuery = parseQuery(moreLikeThisQuery(new String[] { "name.first", "name.last" }, new String[] { "something" }, null).minTermFreq(1).maxQueryTerms(12)).toQuery(createShardContext()).     assertThat(parsedQuery, instanceOf(MoreLikeThisQuery.class)).     MoreLikeThisQuery mltQuery = (MoreLikeThisQuery) parsedQuery.     assertThat(mltQuery.getMoreLikeFields()[0], equalTo("name.first")).     assertThat(mltQuery.getLikeText(), equalTo("something")).     assertThat(mltQuery.getMinTermFrequency(), equalTo(1)).     assertThat(mltQuery.getMaxQueryTerms(), equalTo(12)). }
false;public;0;7;;public void testItemSerialization() throws IOException {     Item expectedItem = generateRandomItem().     BytesStreamOutput output = new BytesStreamOutput().     expectedItem.writeTo(output).     Item newItem = new Item(output.bytes().streamInput()).     assertEquals(expectedItem, newItem). }
false;public;0;5;;public void testItemCopy() throws IOException {     Item expectedItem = generateRandomItem().     Item newItem = new Item(expectedItem).     assertEquals(expectedItem, newItem). }
false;public;0;7;;public void testItemFromXContent() throws IOException {     Item expectedItem = generateRandomItem().     String json = Strings.toString(expectedItem.toXContent(XContentFactory.jsonBuilder(), ToXContent.EMPTY_PARAMS)).     XContentParser parser = createParser(JsonXContent.jsonXContent, json).     Item newItem = Item.parse(parser, new Item()).     assertEquals(expectedItem, newItem). }
false;protected;1;4;;@Override protected boolean isCacheable(MoreLikeThisQueryBuilder queryBuilder) {     // items are always fetched     return queryBuilder.likeItems().length == 0. }
false;public;0;34;;public void testFromJson() throws IOException {     String json = "{\n" + "  \"more_like_this\" : {\n" + "    \"fields\" : [ \"title\", \"description\" ],\n" + "    \"like\" : [ \"and potentially some more text here as well\", {\n" + "      \"_index\" : \"imdb\",\n" + "      \"_type\" : \"movies\",\n" + "      \"_id\" : \"1\"\n" + "    }, {\n" + "      \"_index\" : \"imdb\",\n" + "      \"_type\" : \"movies\",\n" + "      \"_id\" : \"2\"\n" + "    } ],\n" + "    \"max_query_terms\" : 12,\n" + "    \"min_term_freq\" : 1,\n" + "    \"min_doc_freq\" : 5,\n" + "    \"max_doc_freq\" : 2147483647,\n" + "    \"min_word_length\" : 0,\n" + "    \"max_word_length\" : 0,\n" + "    \"minimum_should_match\" : \"30%\",\n" + "    \"boost_terms\" : 0.0,\n" + "    \"include\" : false,\n" + "    \"fail_on_unsupported_field\" : true,\n" + "    \"boost\" : 1.0\n" + "  }\n" + "}".     MoreLikeThisQueryBuilder parsed = (MoreLikeThisQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     assertEquals(json, 2, parsed.fields().length).     assertEquals(json, "and potentially some more text here as well", parsed.likeTexts()[0]). }
false;protected;1;11;;@Override protected QueryBuilder parseQuery(XContentParser parser) throws IOException {     QueryBuilder query = super.parseQuery(parser).     assertThat(query, instanceOf(MoreLikeThisQueryBuilder.class)).     MoreLikeThisQueryBuilder mltQuery = (MoreLikeThisQueryBuilder) query.     if (mltQuery.isTypeless() == false) {         assertWarnings(MoreLikeThisQueryBuilder.TYPES_DEPRECATION_MESSAGE).     }     return query. }
