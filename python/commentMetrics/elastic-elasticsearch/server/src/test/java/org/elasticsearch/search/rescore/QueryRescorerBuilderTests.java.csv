commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;6;/**  * setup for the whole base test class  */ ;/**  * setup for the whole base test class  */ @BeforeClass public static void init() {     SearchModule searchModule = new SearchModule(Settings.EMPTY, false, emptyList()).     namedWriteableRegistry = new NamedWriteableRegistry(searchModule.getNamedWriteables()).     xContentRegistry = new NamedXContentRegistry(searchModule.getNamedXContents()). }
false;public,static;0;5;;@AfterClass public static void afterClass() throws Exception {     namedWriteableRegistry = null.     xContentRegistry = null. }
true;public;0;9;/**  * Test serialization and deserialization of the rescore builder  */ ;/**  * Test serialization and deserialization of the rescore builder  */ public void testSerialization() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         RescorerBuilder<?> original = randomRescoreBuilder().         RescorerBuilder<?> deserialized = copy(original).         assertEquals(deserialized, original).         assertEquals(deserialized.hashCode(), original.hashCode()).         assertNotSame(deserialized, original).     } }
true;public;0;5;/**  * Test equality and hashCode properties  */ ;/**  * Test equality and hashCode properties  */ public void testEqualsAndHashcode() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         checkEqualsAndHashCode(randomRescoreBuilder(), this::copy, QueryRescorerBuilderTests::mutate).     } }
false;private;1;4;;private RescorerBuilder<?> copy(RescorerBuilder<?> original) throws IOException {     return copyWriteable(original, namedWriteableRegistry, namedWriteableRegistry.getReader(RescorerBuilder.class, original.getWriteableName())). }
true;public;0;20;/**  *  creates random rescorer, renders it to xContent and back to new instance that should be equal to original  */ ;/**  *  creates random rescorer, renders it to xContent and back to new instance that should be equal to original  */ public void testFromXContent() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         RescorerBuilder<?> rescoreBuilder = randomRescoreBuilder().         XContentBuilder builder = XContentFactory.contentBuilder(randomFrom(XContentType.values())).         if (randomBoolean()) {             builder.prettyPrint().         }         rescoreBuilder.toXContent(builder, ToXContent.EMPTY_PARAMS).         XContentBuilder shuffled = shuffleXContent(builder).         try (XContentParser parser = createParser(shuffled)) {             parser.nextToken().             RescorerBuilder<?> secondRescoreBuilder = RescorerBuilder.parseFromXContent(parser).             assertNotSame(rescoreBuilder, secondRescoreBuilder).             assertEquals(rescoreBuilder, secondRescoreBuilder).             assertEquals(rescoreBuilder.hashCode(), secondRescoreBuilder.hashCode()).         }     } }
false;public;1;5;;@Override public MappedFieldType fieldMapper(String name) {     TextFieldMapper.Builder builder = new TextFieldMapper.Builder(name).     return builder.build(new Mapper.BuilderContext(idxSettings.getSettings(), new ContentPath(1))).fieldType(). }
true;public;0;28;/**  * test that build() outputs a {@link RescoreContext} that has the same properties  * than the test builder  */ ;/**  * test that build() outputs a {@link RescoreContext} that has the same properties  * than the test builder  */ public void testBuildRescoreSearchContext() throws ElasticsearchParseException, IOException {     final long nowInMillis = randomNonNegativeLong().     Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build().     IndexSettings idxSettings = IndexSettingsModule.newIndexSettings(randomAlphaOfLengthBetween(1, 10), indexSettings).     // shard context will only need indicesQueriesRegistry for building Query objects nested in query rescorer     QueryShardContext mockShardContext = new QueryShardContext(0, idxSettings, null, null, null, null, null, xContentRegistry(), namedWriteableRegistry, null, null, () -> nowInMillis, null) {          @Override         public MappedFieldType fieldMapper(String name) {             TextFieldMapper.Builder builder = new TextFieldMapper.Builder(name).             return builder.build(new Mapper.BuilderContext(idxSettings.getSettings(), new ContentPath(1))).fieldType().         }     }.     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         QueryRescorerBuilder rescoreBuilder = randomRescoreBuilder().         QueryRescoreContext rescoreContext = (QueryRescoreContext) rescoreBuilder.buildContext(mockShardContext).         int expectedWindowSize = rescoreBuilder.windowSize() == null ? RescorerBuilder.DEFAULT_WINDOW_SIZE : rescoreBuilder.windowSize().intValue().         assertEquals(expectedWindowSize, rescoreContext.getWindowSize()).         Query expectedQuery = Rewriteable.rewrite(rescoreBuilder.getRescoreQuery(), mockShardContext).toQuery(mockShardContext).         assertEquals(expectedQuery, rescoreContext.query()).         assertEquals(rescoreBuilder.getQueryWeight(), rescoreContext.queryWeight(), Float.MIN_VALUE).         assertEquals(rescoreBuilder.getRescoreQueryWeight(), rescoreContext.rescoreQueryWeight(), Float.MIN_VALUE).         assertEquals(rescoreBuilder.getScoreMode(), rescoreContext.scoreMode()).     } }
false;public;0;4;;public void testRescoreQueryNull() throws IOException {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new QueryRescorerBuilder((QueryBuilder) null)).     assertEquals("rescore_query cannot be null", e.getMessage()). }
false;protected;1;4;;@Override protected QueryBuilder doRewrite(QueryRewriteContext queryShardContext) throws IOException {     return new MatchAllQueryBuilder(). }
false;public;1;5;;@Override public MappedFieldType fieldMapper(String name) {     TextFieldMapper.Builder builder = new TextFieldMapper.Builder(name).     return builder.build(new Mapper.BuilderContext(idxSettings.getSettings(), new ContentPath(1))).fieldType(). }
false;public;0;31;;public void testRewritingKeepsSettings() throws IOException {     final long nowInMillis = randomNonNegativeLong().     Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build().     IndexSettings idxSettings = IndexSettingsModule.newIndexSettings(randomAlphaOfLengthBetween(1, 10), indexSettings).     // shard context will only need indicesQueriesRegistry for building Query objects nested in query rescorer     QueryShardContext mockShardContext = new QueryShardContext(0, idxSettings, null, null, null, null, null, xContentRegistry(), namedWriteableRegistry, null, null, () -> nowInMillis, null) {          @Override         public MappedFieldType fieldMapper(String name) {             TextFieldMapper.Builder builder = new TextFieldMapper.Builder(name).             return builder.build(new Mapper.BuilderContext(idxSettings.getSettings(), new ContentPath(1))).fieldType().         }     }.     QueryBuilder rewriteQb = new AlwaysRewriteQueryBuilder().     org.elasticsearch.search.rescore.QueryRescorerBuilder rescoreBuilder = new org.elasticsearch.search.rescore.QueryRescorerBuilder(rewriteQb).     rescoreBuilder.setQueryWeight(randomFloat()).     rescoreBuilder.setRescoreQueryWeight(randomFloat()).     rescoreBuilder.setScoreMode(QueryRescoreMode.Max).     rescoreBuilder.windowSize(randomIntBetween(0, 100)).     QueryRescorerBuilder rescoreRewritten = rescoreBuilder.rewrite(mockShardContext).     assertEquals(rescoreRewritten.getQueryWeight(), rescoreBuilder.getQueryWeight(), 0.01f).     assertEquals(rescoreRewritten.getRescoreQueryWeight(), rescoreBuilder.getRescoreQueryWeight(), 0.01f).     assertEquals(rescoreRewritten.getScoreMode(), rescoreBuilder.getScoreMode()).     assertEquals(rescoreRewritten.windowSize(), rescoreBuilder.windowSize()). }
true;public;0;59;/**  * test parsing exceptions for incorrect rescorer syntax  */ ;/**  * test parsing exceptions for incorrect rescorer syntax  */ public void testUnknownFieldsExpection() throws IOException {     String rescoreElement = "{\n" + "    \"window_size\" : 20,\n" + "    \"bad_rescorer_name\" : { }\n" + "}\n".     try (XContentParser parser = createParser(rescoreElement)) {         Exception e = expectThrows(NamedObjectNotFoundException.class, () -> RescorerBuilder.parseFromXContent(parser)).         assertEquals("[3:27] unable to parse RescorerBuilder with name [bad_rescorer_name]: parser not found", e.getMessage()).     }     rescoreElement = "{\n" + "    \"bad_fieldName\" : 20\n" + "}\n".     try (XContentParser parser = createParser(rescoreElement)) {         Exception e = expectThrows(ParsingException.class, () -> RescorerBuilder.parseFromXContent(parser)).         assertEquals("rescore doesn't support [bad_fieldName]", e.getMessage()).     }     rescoreElement = "{\n" + "    \"window_size\" : 20,\n" + "    \"query\" : [ ]\n" + "}\n".     try (XContentParser parser = createParser(rescoreElement)) {         Exception e = expectThrows(ParsingException.class, () -> RescorerBuilder.parseFromXContent(parser)).         assertEquals("unexpected token [START_ARRAY] after [query]", e.getMessage()).     }     rescoreElement = "{ }".     try (XContentParser parser = createParser(rescoreElement)) {         Exception e = expectThrows(ParsingException.class, () -> RescorerBuilder.parseFromXContent(parser)).         assertEquals("missing rescore type", e.getMessage()).     }     rescoreElement = "{\n" + "    \"window_size\" : 20,\n" + "    \"query\" : { \"bad_fieldname\" : 1.0  } \n" + "}\n".     try (XContentParser parser = createParser(rescoreElement)) {         XContentParseException e = expectThrows(XContentParseException.class, () -> RescorerBuilder.parseFromXContent(parser)).         assertEquals("[3:17] [query] unknown field [bad_fieldname], parser not found", e.getMessage()).     }     rescoreElement = "{\n" + "    \"window_size\" : 20,\n" + "    \"query\" : { \"rescore_query\" : { \"unknown_queryname\" : { } } } \n" + "}\n".     try (XContentParser parser = createParser(rescoreElement)) {         Exception e = expectThrows(XContentParseException.class, () -> RescorerBuilder.parseFromXContent(parser)).         assertThat(e.getMessage(), containsString("[query] failed to parse field [rescore_query]")).     }     rescoreElement = "{\n" + "    \"window_size\" : 20,\n" + "    \"query\" : { \"rescore_query\" : { \"match_all\" : { } } } \n" + "}\n".     try (XContentParser parser = createParser(rescoreElement)) {         RescorerBuilder.parseFromXContent(parser).     } }
true;private;1;6;/**  * create a new parser from the rescorer string representation and reset context with it  */ ;/**  * create a new parser from the rescorer string representation and reset context with it  */ private XContentParser createParser(String rescoreElement) throws IOException {     XContentParser parser = createParser(JsonXContent.jsonXContent, rescoreElement).     // move to first token, this is where the internal fromXContent     assertTrue(parser.nextToken() == XContentParser.Token.START_OBJECT).     return parser. }
false;protected;0;4;;@Override protected NamedXContentRegistry xContentRegistry() {     return xContentRegistry. }
false;private,static;1;35;;private static RescorerBuilder<?> mutate(RescorerBuilder<?> original) throws IOException {     RescorerBuilder<?> mutation = ESTestCase.copyWriteable(original, namedWriteableRegistry, QueryRescorerBuilder::new).     if (randomBoolean()) {         Integer windowSize = original.windowSize().         if (windowSize != null) {             mutation.windowSize(windowSize + 1).         } else {             mutation.windowSize(randomIntBetween(0, 100)).         }     } else {         QueryRescorerBuilder queryRescorer = (QueryRescorerBuilder) mutation.         switch(randomIntBetween(0, 3)) {             case 0:                 queryRescorer.setQueryWeight(queryRescorer.getQueryWeight() + 0.1f).                 break.             case 1:                 queryRescorer.setRescoreQueryWeight(queryRescorer.getRescoreQueryWeight() + 0.1f).                 break.             case 2:                 QueryRescoreMode other.                 do {                     other = randomFrom(QueryRescoreMode.values()).                 } while (other == queryRescorer.getScoreMode()).                 queryRescorer.setScoreMode(other).                 break.             case 3:                 // only increase the boost to make it a slightly different query                 queryRescorer.getRescoreQuery().boost(queryRescorer.getRescoreQuery().boost() + 0.1f).                 break.             default:                 throw new IllegalStateException("unexpected random mutation in test").         }     }     return mutation. }
true;public,static;0;19;/**  * create random shape that is put under test  */ ;/**  * create random shape that is put under test  */ public static QueryRescorerBuilder randomRescoreBuilder() {     QueryBuilder queryBuilder = new MatchAllQueryBuilder().boost(randomFloat()).queryName(randomAlphaOfLength(20)).     org.elasticsearch.search.rescore.QueryRescorerBuilder rescorer = new org.elasticsearch.search.rescore.QueryRescorerBuilder(queryBuilder).     if (randomBoolean()) {         rescorer.setQueryWeight(randomFloat()).     }     if (randomBoolean()) {         rescorer.setRescoreQueryWeight(randomFloat()).     }     if (randomBoolean()) {         rescorer.setScoreMode(randomFrom(QueryRescoreMode.values())).     }     if (randomBoolean()) {         rescorer.windowSize(randomIntBetween(0, 100)).     }     return rescorer. }
