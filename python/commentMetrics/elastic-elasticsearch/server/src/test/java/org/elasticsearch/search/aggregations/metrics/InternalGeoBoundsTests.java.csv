commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;11;;@Override protected InternalGeoBounds createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) {     // we occasionally want to test top = Double.NEGATIVE_INFINITY since this triggers empty xContent object     double top = frequently() ? randomDouble() : Double.NEGATIVE_INFINITY.     InternalGeoBounds geo = new InternalGeoBounds(name, top, randomDouble(), randomDouble(), randomDouble(), randomDouble(), randomDouble(), randomBoolean(), pipelineAggregators, Collections.emptyMap()).     return geo. }
false;protected;2;35;;@Override protected void assertReduced(InternalGeoBounds reduced, List<InternalGeoBounds> inputs) {     double top = Double.NEGATIVE_INFINITY.     double bottom = Double.POSITIVE_INFINITY.     double posLeft = Double.POSITIVE_INFINITY.     double posRight = Double.NEGATIVE_INFINITY.     double negLeft = Double.POSITIVE_INFINITY.     double negRight = Double.NEGATIVE_INFINITY.     for (InternalGeoBounds bounds : inputs) {         if (bounds.top > top) {             top = bounds.top.         }         if (bounds.bottom < bottom) {             bottom = bounds.bottom.         }         if (bounds.posLeft < posLeft) {             posLeft = bounds.posLeft.         }         if (bounds.posRight > posRight) {             posRight = bounds.posRight.         }         if (bounds.negLeft < negLeft) {             negLeft = bounds.negLeft.         }         if (bounds.negRight > negRight) {             negRight = bounds.negRight.         }     }     assertValueClose(reduced.top, top).     assertValueClose(reduced.bottom, bottom).     assertValueClose(reduced.posLeft, posLeft).     assertValueClose(reduced.posRight, posRight).     assertValueClose(reduced.negLeft, negLeft).     assertValueClose(reduced.negRight, negRight). }
false;private,static;2;7;;private static void assertValueClose(double expected, double actual) {     if (Double.isInfinite(expected) == false) {         assertThat(expected, closeTo(actual, GEOHASH_TOLERANCE)).     } else {         assertTrue(Double.isInfinite(actual)).     } }
false;protected;2;8;;@Override protected void assertFromXContent(InternalGeoBounds aggregation, ParsedAggregation parsedAggregation) {     assertTrue(parsedAggregation instanceof ParsedGeoBounds).     ParsedGeoBounds parsed = (ParsedGeoBounds) parsedAggregation.     assertEquals(aggregation.topLeft(), parsed.topLeft()).     assertEquals(aggregation.bottomRight(), parsed.bottomRight()). }
false;protected;0;4;;@Override protected Writeable.Reader<InternalGeoBounds> instanceReader() {     return InternalGeoBounds::new. }
false;protected;1;54;;@Override protected InternalGeoBounds mutateInstance(InternalGeoBounds instance) {     String name = instance.getName().     double top = instance.top.     double bottom = instance.bottom.     double posLeft = instance.posLeft.     double posRight = instance.posRight.     double negLeft = instance.negLeft.     double negRight = instance.negRight.     boolean wrapLongitude = instance.wrapLongitude.     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 8)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             if (Double.isFinite(top)) {                 top += between(1, 20).             } else {                 top = randomDouble().             }             break.         case 2:             bottom += between(1, 20).             break.         case 3:             posLeft += between(1, 20).             break.         case 4:             posRight += between(1, 20).             break.         case 5:             negLeft += between(1, 20).             break.         case 6:             negRight += between(1, 20).             break.         case 7:             wrapLongitude = wrapLongitude == false.             break.         case 8:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new InternalGeoBounds(name, top, bottom, posLeft, posRight, negLeft, negRight, wrapLongitude, pipelineAggregators, metaData). }
