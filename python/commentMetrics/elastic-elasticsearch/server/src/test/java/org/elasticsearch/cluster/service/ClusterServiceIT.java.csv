commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected Void newResponse(boolean acknowledged) {     return null. }
false;public;1;4;;@Override public boolean mustAck(DiscoveryNode discoveryNode) {     return true. }
false;public;1;5;;@Override public void onAllNodesAcked(@Nullable Exception e) {     allNodesAcked.set(true).     latch.countDown(). }
false;public;0;5;;@Override public void onAckTimeout() {     ackTimeout.set(true).     latch.countDown(). }
false;public;0;4;;@Override public TimeValue ackTimeout() {     return TimeValue.timeValueSeconds(10). }
false;public;0;4;;@Override public TimeValue timeout() {     return TimeValue.timeValueSeconds(10). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     processedLatch.countDown(). }
false;public;1;5;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     executed.set(true).     return ClusterState.builder(currentState).build(). }
false;public;2;6;;@Override public void onFailure(String source, Exception e) {     logger.error(() -> new ParameterizedMessage("failed to execute callback in test {}", source), e).     onFailure.set(true).     latch.countDown(). }
false;public;0;72;;public void testAckedUpdateTask() throws Exception {     internalCluster().startNode().     ClusterService clusterService = internalCluster().getInstance(ClusterService.class).     final AtomicBoolean allNodesAcked = new AtomicBoolean(false).     final AtomicBoolean ackTimeout = new AtomicBoolean(false).     final AtomicBoolean onFailure = new AtomicBoolean(false).     final AtomicBoolean executed = new AtomicBoolean(false).     final CountDownLatch latch = new CountDownLatch(1).     final CountDownLatch processedLatch = new CountDownLatch(1).     clusterService.submitStateUpdateTask("test", new AckedClusterStateUpdateTask<Void>(null, null) {          @Override         protected Void newResponse(boolean acknowledged) {             return null.         }          @Override         public boolean mustAck(DiscoveryNode discoveryNode) {             return true.         }          @Override         public void onAllNodesAcked(@Nullable Exception e) {             allNodesAcked.set(true).             latch.countDown().         }          @Override         public void onAckTimeout() {             ackTimeout.set(true).             latch.countDown().         }          @Override         public TimeValue ackTimeout() {             return TimeValue.timeValueSeconds(10).         }          @Override         public TimeValue timeout() {             return TimeValue.timeValueSeconds(10).         }          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {             processedLatch.countDown().         }          @Override         public ClusterState execute(ClusterState currentState) throws Exception {             executed.set(true).             return ClusterState.builder(currentState).build().         }          @Override         public void onFailure(String source, Exception e) {             logger.error(() -> new ParameterizedMessage("failed to execute callback in test {}", source), e).             onFailure.set(true).             latch.countDown().         }     }).     ensureGreen().     assertThat(latch.await(1, TimeUnit.SECONDS), equalTo(true)).     assertThat(allNodesAcked.get(), equalTo(true)).     assertThat(ackTimeout.get(), equalTo(false)).     assertThat(executed.get(), equalTo(true)).     assertThat(onFailure.get(), equalTo(false)).     assertThat(processedLatch.await(1, TimeUnit.SECONDS), equalTo(true)). }
false;protected;1;4;;@Override protected Void newResponse(boolean acknowledged) {     return null. }
false;public;1;5;;@Override public void onAllNodesAcked(@Nullable Exception e) {     allNodesAcked.set(true).     latch.countDown(). }
false;public;0;5;;@Override public void onAckTimeout() {     ackTimeout.set(true).     latch.countDown(). }
false;public;0;4;;@Override public TimeValue ackTimeout() {     return TimeValue.timeValueSeconds(10). }
false;public;0;4;;@Override public TimeValue timeout() {     return TimeValue.timeValueSeconds(10). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     processedLatch.countDown(). }
false;public;1;5;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     executed.set(true).     return currentState. }
false;public;2;6;;@Override public void onFailure(String source, Exception e) {     logger.error(() -> new ParameterizedMessage("failed to execute callback in test {}", source), e).     onFailure.set(true).     latch.countDown(). }
false;public;0;67;;public void testAckedUpdateTaskSameClusterState() throws Exception {     internalCluster().startNode().     ClusterService clusterService = internalCluster().getInstance(ClusterService.class).     final AtomicBoolean allNodesAcked = new AtomicBoolean(false).     final AtomicBoolean ackTimeout = new AtomicBoolean(false).     final AtomicBoolean onFailure = new AtomicBoolean(false).     final AtomicBoolean executed = new AtomicBoolean(false).     final CountDownLatch latch = new CountDownLatch(1).     final CountDownLatch processedLatch = new CountDownLatch(1).     clusterService.submitStateUpdateTask("test", new AckedClusterStateUpdateTask<Void>(null, null) {          @Override         protected Void newResponse(boolean acknowledged) {             return null.         }          @Override         public void onAllNodesAcked(@Nullable Exception e) {             allNodesAcked.set(true).             latch.countDown().         }          @Override         public void onAckTimeout() {             ackTimeout.set(true).             latch.countDown().         }          @Override         public TimeValue ackTimeout() {             return TimeValue.timeValueSeconds(10).         }          @Override         public TimeValue timeout() {             return TimeValue.timeValueSeconds(10).         }          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {             processedLatch.countDown().         }          @Override         public ClusterState execute(ClusterState currentState) throws Exception {             executed.set(true).             return currentState.         }          @Override         public void onFailure(String source, Exception e) {             logger.error(() -> new ParameterizedMessage("failed to execute callback in test {}", source), e).             onFailure.set(true).             latch.countDown().         }     }).     ensureGreen().     assertThat(latch.await(1, TimeUnit.SECONDS), equalTo(true)).     assertThat(allNodesAcked.get(), equalTo(true)).     assertThat(ackTimeout.get(), equalTo(false)).     assertThat(executed.get(), equalTo(true)).     assertThat(onFailure.get(), equalTo(false)).     assertThat(processedLatch.await(1, TimeUnit.SECONDS), equalTo(true)). }
false;protected;1;4;;@Override protected Void newResponse(boolean acknowledged) {     return null. }
false;public;1;4;;@Override public boolean mustAck(DiscoveryNode discoveryNode) {     return false. }
false;public;1;5;;@Override public void onAllNodesAcked(@Nullable Exception e) {     allNodesAcked.set(true).     latch.countDown(). }
false;public;0;5;;@Override public void onAckTimeout() {     ackTimeout.set(true).     latch.countDown(). }
false;public;0;4;;@Override public TimeValue ackTimeout() {     return TimeValue.timeValueSeconds(10). }
false;public;0;4;;@Override public TimeValue timeout() {     return TimeValue.timeValueSeconds(10). }
false;public;3;3;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) { }
false;public;1;5;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     executed.set(true).     return ClusterState.builder(currentState).build(). }
false;public;2;6;;@Override public void onFailure(String source, Exception e) {     logger.error(() -> new ParameterizedMessage("failed to execute callback in test {}", source), e).     onFailure.set(true).     latch.countDown(). }
false;public;0;68;;public void testAckedUpdateTaskNoAckExpected() throws Exception {     internalCluster().startNode().     ClusterService clusterService = internalCluster().getInstance(ClusterService.class).     final AtomicBoolean allNodesAcked = new AtomicBoolean(false).     final AtomicBoolean ackTimeout = new AtomicBoolean(false).     final AtomicBoolean onFailure = new AtomicBoolean(false).     final AtomicBoolean executed = new AtomicBoolean(false).     final CountDownLatch latch = new CountDownLatch(1).     clusterService.submitStateUpdateTask("test", new AckedClusterStateUpdateTask<Void>(null, null) {          @Override         protected Void newResponse(boolean acknowledged) {             return null.         }          @Override         public boolean mustAck(DiscoveryNode discoveryNode) {             return false.         }          @Override         public void onAllNodesAcked(@Nullable Exception e) {             allNodesAcked.set(true).             latch.countDown().         }          @Override         public void onAckTimeout() {             ackTimeout.set(true).             latch.countDown().         }          @Override         public TimeValue ackTimeout() {             return TimeValue.timeValueSeconds(10).         }          @Override         public TimeValue timeout() {             return TimeValue.timeValueSeconds(10).         }          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {         }          @Override         public ClusterState execute(ClusterState currentState) throws Exception {             executed.set(true).             return ClusterState.builder(currentState).build().         }          @Override         public void onFailure(String source, Exception e) {             logger.error(() -> new ParameterizedMessage("failed to execute callback in test {}", source), e).             onFailure.set(true).             latch.countDown().         }     }).     ensureGreen().     assertThat(latch.await(1, TimeUnit.SECONDS), equalTo(true)).     assertThat(allNodesAcked.get(), equalTo(true)).     assertThat(ackTimeout.get(), equalTo(false)).     assertThat(executed.get(), equalTo(true)).     assertThat(onFailure.get(), equalTo(false)). }
false;protected;1;4;;@Override protected Void newResponse(boolean acknowledged) {     return null. }
false;public;1;4;;@Override public boolean mustAck(DiscoveryNode discoveryNode) {     return false. }
false;public;1;5;;@Override public void onAllNodesAcked(@Nullable Exception e) {     allNodesAcked.set(true).     latch.countDown(). }
false;public;0;5;;@Override public void onAckTimeout() {     ackTimeout.set(true).     latch.countDown(). }
false;public;0;4;;@Override public TimeValue ackTimeout() {     return TimeValue.timeValueSeconds(0). }
false;public;0;4;;@Override public TimeValue timeout() {     return TimeValue.timeValueSeconds(10). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     processedLatch.countDown(). }
false;public;1;5;;@Override public ClusterState execute(ClusterState currentState) throws Exception {     executed.set(true).     return ClusterState.builder(currentState).build(). }
false;public;2;6;;@Override public void onFailure(String source, Exception e) {     logger.error(() -> new ParameterizedMessage("failed to execute callback in test {}", source), e).     onFailure.set(true).     latch.countDown(). }
false;public;0;72;;public void testAckedUpdateTaskTimeoutZero() throws Exception {     internalCluster().startNode().     ClusterService clusterService = internalCluster().getInstance(ClusterService.class).     final AtomicBoolean allNodesAcked = new AtomicBoolean(false).     final AtomicBoolean ackTimeout = new AtomicBoolean(false).     final AtomicBoolean onFailure = new AtomicBoolean(false).     final AtomicBoolean executed = new AtomicBoolean(false).     final CountDownLatch latch = new CountDownLatch(1).     final CountDownLatch processedLatch = new CountDownLatch(1).     clusterService.submitStateUpdateTask("test", new AckedClusterStateUpdateTask<Void>(null, null) {          @Override         protected Void newResponse(boolean acknowledged) {             return null.         }          @Override         public boolean mustAck(DiscoveryNode discoveryNode) {             return false.         }          @Override         public void onAllNodesAcked(@Nullable Exception e) {             allNodesAcked.set(true).             latch.countDown().         }          @Override         public void onAckTimeout() {             ackTimeout.set(true).             latch.countDown().         }          @Override         public TimeValue ackTimeout() {             return TimeValue.timeValueSeconds(0).         }          @Override         public TimeValue timeout() {             return TimeValue.timeValueSeconds(10).         }          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {             processedLatch.countDown().         }          @Override         public ClusterState execute(ClusterState currentState) throws Exception {             executed.set(true).             return ClusterState.builder(currentState).build().         }          @Override         public void onFailure(String source, Exception e) {             logger.error(() -> new ParameterizedMessage("failed to execute callback in test {}", source), e).             onFailure.set(true).             latch.countDown().         }     }).     ensureGreen().     assertThat(latch.await(1, TimeUnit.SECONDS), equalTo(true)).     assertThat(allNodesAcked.get(), equalTo(false)).     assertThat(ackTimeout.get(), equalTo(true)).     assertThat(executed.get(), equalTo(true)).     assertThat(onFailure.get(), equalTo(false)).     assertThat(processedLatch.await(1, TimeUnit.SECONDS), equalTo(true)). }
false;public;1;10;;@Override public ClusterState execute(ClusterState currentState) {     invoked1.countDown().     try {         block1.await().     } catch (InterruptedException e) {         fail().     }     return currentState. }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     invoked1.countDown().     fail(). }
false;public;1;4;;@Override public ClusterState execute(ClusterState currentState) {     return currentState. }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     fail(). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     invoked2.countDown(). }
false;public;1;10;;@Override public ClusterState execute(ClusterState currentState) {     invoked3.countDown().     try {         block2.await().     } catch (InterruptedException e) {         fail().     }     return currentState. }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     invoked3.countDown().     fail(). }
false;public;1;4;;@Override public ClusterState execute(ClusterState currentState) {     return currentState. }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     fail(). }
false;public;0;132;;@TestLogging("_root:debug,org.elasticsearch.action.admin.cluster.tasks:trace") public void testPendingUpdateTask() throws Exception {     String node_0 = internalCluster().startNode().     internalCluster().startCoordinatingOnlyNode(Settings.EMPTY).     final ClusterService clusterService = internalCluster().getInstance(ClusterService.class, node_0).     final CountDownLatch block1 = new CountDownLatch(1).     final CountDownLatch invoked1 = new CountDownLatch(1).     clusterService.submitStateUpdateTask("1", new ClusterStateUpdateTask() {          @Override         public ClusterState execute(ClusterState currentState) {             invoked1.countDown().             try {                 block1.await().             } catch (InterruptedException e) {                 fail().             }             return currentState.         }          @Override         public void onFailure(String source, Exception e) {             invoked1.countDown().             fail().         }     }).     invoked1.await().     final CountDownLatch invoked2 = new CountDownLatch(9).     for (int i = 2. i <= 10. i++) {         clusterService.submitStateUpdateTask(Integer.toString(i), new ClusterStateUpdateTask() {              @Override             public ClusterState execute(ClusterState currentState) {                 return currentState.             }              @Override             public void onFailure(String source, Exception e) {                 fail().             }              @Override             public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {                 invoked2.countDown().             }         }).     }     // there might be other tasks in this node, make sure to only take the ones we add into account in this test     // The tasks can be re-ordered, so we need to check out-of-order     Set<String> controlSources = new HashSet<>(Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10")).     List<PendingClusterTask> pendingClusterTasks = clusterService.getMasterService().pendingTasks().     assertThat(pendingClusterTasks.size(), greaterThanOrEqualTo(10)).     assertThat(pendingClusterTasks.get(0).getSource().string(), equalTo("1")).     assertThat(pendingClusterTasks.get(0).isExecuting(), equalTo(true)).     for (PendingClusterTask task : pendingClusterTasks) {         controlSources.remove(task.getSource().string()).     }     assertTrue(controlSources.isEmpty()).     controlSources = new HashSet<>(Arrays.asList("1", "2", "3", "4", "5", "6", "7", "8", "9", "10")).     PendingClusterTasksResponse response = internalCluster().coordOnlyNodeClient().admin().cluster().preparePendingClusterTasks().get().     assertThat(response.pendingTasks().size(), greaterThanOrEqualTo(10)).     assertThat(response.pendingTasks().get(0).getSource().string(), equalTo("1")).     assertThat(response.pendingTasks().get(0).isExecuting(), equalTo(true)).     for (PendingClusterTask task : response) {         controlSources.remove(task.getSource().string()).     }     assertTrue(controlSources.isEmpty()).     block1.countDown().     invoked2.await().     // whenever we test for no tasks, we need to awaitBusy since this is a live node     assertTrue(awaitBusy(() -> clusterService.getMasterService().pendingTasks().isEmpty())).     waitNoPendingTasksOnAll().     final CountDownLatch block2 = new CountDownLatch(1).     final CountDownLatch invoked3 = new CountDownLatch(1).     clusterService.submitStateUpdateTask("1", new ClusterStateUpdateTask() {          @Override         public ClusterState execute(ClusterState currentState) {             invoked3.countDown().             try {                 block2.await().             } catch (InterruptedException e) {                 fail().             }             return currentState.         }          @Override         public void onFailure(String source, Exception e) {             invoked3.countDown().             fail().         }     }).     invoked3.await().     for (int i = 2. i <= 5. i++) {         clusterService.submitStateUpdateTask(Integer.toString(i), new ClusterStateUpdateTask() {              @Override             public ClusterState execute(ClusterState currentState) {                 return currentState.             }              @Override             public void onFailure(String source, Exception e) {                 fail().             }         }).     }     Thread.sleep(100).     pendingClusterTasks = clusterService.getMasterService().pendingTasks().     assertThat(pendingClusterTasks.size(), greaterThanOrEqualTo(5)).     controlSources = new HashSet<>(Arrays.asList("1", "2", "3", "4", "5")).     for (PendingClusterTask task : pendingClusterTasks) {         controlSources.remove(task.getSource().string()).     }     assertTrue(controlSources.isEmpty()).     response = internalCluster().coordOnlyNodeClient().admin().cluster().preparePendingClusterTasks().get().     assertThat(response.pendingTasks().size(), greaterThanOrEqualTo(5)).     controlSources = new HashSet<>(Arrays.asList("1", "2", "3", "4", "5")).     for (PendingClusterTask task : response) {         if (controlSources.remove(task.getSource().string())) {             assertThat(task.getTimeInQueueInMillis(), greaterThan(0L)).         }     }     assertTrue(controlSources.isEmpty()).     block2.countDown(). }
