commented;modifiers;parameterAmount;loc;comment;code
true;public;0;7;/**  * Test ipv4 host with a default port works  */ ;/**  * Test ipv4 host with a default port works  */ public void testParseV4DefaultPort() throws Exception {     TransportAddress[] addresses = TcpTransport.parse("127.0.0.1", "1234", Integer.MAX_VALUE).     assertEquals(1, addresses.length).     assertEquals("127.0.0.1", addresses[0].getAddress()).     assertEquals(1234, addresses[0].getPort()). }
true;public;0;10;/**  * Test ipv4 host with a default port range works  */ ;/**  * Test ipv4 host with a default port range works  */ public void testParseV4DefaultRange() throws Exception {     TransportAddress[] addresses = TcpTransport.parse("127.0.0.1", "1234-1235", Integer.MAX_VALUE).     assertEquals(2, addresses.length).     assertEquals("127.0.0.1", addresses[0].getAddress()).     assertEquals(1234, addresses[0].getPort()).     assertEquals("127.0.0.1", addresses[1].getAddress()).     assertEquals(1235, addresses[1].getPort()). }
true;public;0;7;/**  * Test ipv4 host with port works  */ ;/**  * Test ipv4 host with port works  */ public void testParseV4WithPort() throws Exception {     TransportAddress[] addresses = TcpTransport.parse("127.0.0.1:2345", "1234", Integer.MAX_VALUE).     assertEquals(1, addresses.length).     assertEquals("127.0.0.1", addresses[0].getAddress()).     assertEquals(2345, addresses[0].getPort()). }
true;public;0;10;/**  * Test ipv4 host with port range works  */ ;/**  * Test ipv4 host with port range works  */ public void testParseV4WithPortRange() throws Exception {     TransportAddress[] addresses = TcpTransport.parse("127.0.0.1:2345-2346", "1234", Integer.MAX_VALUE).     assertEquals(2, addresses.length).     assertEquals("127.0.0.1", addresses[0].getAddress()).     assertEquals(2345, addresses[0].getPort()).     assertEquals("127.0.0.1", addresses[1].getAddress()).     assertEquals(2346, addresses[1].getPort()). }
true;public;0;8;/**  * Test unbracketed ipv6 hosts in configuration fail. Leave no ambiguity  */ ;/**  * Test unbracketed ipv6 hosts in configuration fail. Leave no ambiguity  */ public void testParseV6UnBracketed() throws Exception {     try {         TcpTransport.parse("::1", "1234", Integer.MAX_VALUE).         fail("should have gotten exception").     } catch (IllegalArgumentException expected) {         assertTrue(expected.getMessage().contains("must be bracketed")).     } }
true;public;0;7;/**  * Test ipv6 host with a default port works  */ ;/**  * Test ipv6 host with a default port works  */ public void testParseV6DefaultPort() throws Exception {     TransportAddress[] addresses = TcpTransport.parse("[::1]", "1234", Integer.MAX_VALUE).     assertEquals(1, addresses.length).     assertEquals("::1", addresses[0].getAddress()).     assertEquals(1234, addresses[0].getPort()). }
true;public;0;10;/**  * Test ipv6 host with a default port range works  */ ;/**  * Test ipv6 host with a default port range works  */ public void testParseV6DefaultRange() throws Exception {     TransportAddress[] addresses = TcpTransport.parse("[::1]", "1234-1235", Integer.MAX_VALUE).     assertEquals(2, addresses.length).     assertEquals("::1", addresses[0].getAddress()).     assertEquals(1234, addresses[0].getPort()).     assertEquals("::1", addresses[1].getAddress()).     assertEquals(1235, addresses[1].getPort()). }
true;public;0;7;/**  * Test ipv6 host with port works  */ ;/**  * Test ipv6 host with port works  */ public void testParseV6WithPort() throws Exception {     TransportAddress[] addresses = TcpTransport.parse("[::1]:2345", "1234", Integer.MAX_VALUE).     assertEquals(1, addresses.length).     assertEquals("::1", addresses[0].getAddress()).     assertEquals(2345, addresses[0].getPort()). }
true;public;0;10;/**  * Test ipv6 host with port range works  */ ;/**  * Test ipv6 host with port range works  */ public void testParseV6WithPortRange() throws Exception {     TransportAddress[] addresses = TcpTransport.parse("[::1]:2345-2346", "1234", Integer.MAX_VALUE).     assertEquals(2, addresses.length).     assertEquals("::1", addresses[0].getAddress()).     assertEquals(2345, addresses[0].getPort()).     assertEquals("::1", addresses[1].getAddress()).     assertEquals(2346, addresses[1].getPort()). }
true;public;0;7;/**  * Test per-address limit  */ ;/**  * Test per-address limit  */ public void testAddressLimit() throws Exception {     TransportAddress[] addresses = TcpTransport.parse("[::1]:100-200", "1000", 3).     assertEquals(3, addresses.length).     assertEquals(100, addresses[0].getPort()).     assertEquals(101, addresses[1].getPort()).     assertEquals(102, addresses[2].getPort()). }
false;protected;2;4;;@Override protected FakeServerChannel bind(String name, InetSocketAddress address) throws IOException {     return null. }
false;protected;1;4;;@Override protected FakeTcpChannel initiateChannel(DiscoveryNode node) throws IOException {     return new FakeTcpChannel(false). }
false;protected;0;3;;@Override protected void stopInternal() { }
false;public;3;13;;@Override public Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Connection> listener) {     if (compressed) {         assertTrue(profile.getCompressionEnabled()).     }     int numConnections = profile.getNumConnections().     ArrayList<TcpChannel> fakeChannels = new ArrayList<>(numConnections).     for (int i = 0. i < numConnections. ++i) {         fakeChannels.add(new FakeTcpChannel(false, messageCaptor)).     }     listener.onResponse(new NodeChannels(node, fakeChannels, profile, Version.CURRENT)).     return () -> CloseableChannel.closeChannels(fakeChannels, false). }
false;public;0;86;;@SuppressForbidden(reason = "Allow accessing localhost") public void testCompressRequestAndResponse() throws IOException {     final boolean compressed = randomBoolean().     Req request = new Req(randomRealisticUnicodeOfLengthBetween(10, 100)).     ThreadPool threadPool = new TestThreadPool(TcpTransportTests.class.getName()).     AtomicReference<BytesReference> messageCaptor = new AtomicReference<>().     try {         TcpTransport transport = new TcpTransport("test", Settings.EMPTY, Version.CURRENT, threadPool, PageCacheRecycler.NON_RECYCLING_INSTANCE, new NoneCircuitBreakerService(), null, null) {              @Override             protected FakeServerChannel bind(String name, InetSocketAddress address) throws IOException {                 return null.             }              @Override             protected FakeTcpChannel initiateChannel(DiscoveryNode node) throws IOException {                 return new FakeTcpChannel(false).             }              @Override             protected void stopInternal() {             }              @Override             public Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Connection> listener) {                 if (compressed) {                     assertTrue(profile.getCompressionEnabled()).                 }                 int numConnections = profile.getNumConnections().                 ArrayList<TcpChannel> fakeChannels = new ArrayList<>(numConnections).                 for (int i = 0. i < numConnections. ++i) {                     fakeChannels.add(new FakeTcpChannel(false, messageCaptor)).                 }                 listener.onResponse(new NodeChannels(node, fakeChannels, profile, Version.CURRENT)).                 return () -> CloseableChannel.closeChannels(fakeChannels, false).             }         }.         DiscoveryNode node = new DiscoveryNode("foo", buildNewFakeTransportAddress(), Version.CURRENT).         ConnectionProfile.Builder profileBuilder = new ConnectionProfile.Builder(TestProfiles.LIGHT_PROFILE).         if (compressed) {             profileBuilder.setCompressionEnabled(true).         } else {             profileBuilder.setCompressionEnabled(false).         }         PlainActionFuture<Transport.Connection> future = PlainActionFuture.newFuture().         transport.openConnection(node, profileBuilder.build(), future).         Transport.Connection connection = future.actionGet().         connection.sendRequest(42, "foobar", request, TransportRequestOptions.EMPTY).         transport.registerRequestHandler(new RequestHandlerRegistry<>("foobar", Req::new, mock(TaskManager.class), (request1, channel, task) -> channel.sendResponse(TransportResponse.Empty.INSTANCE), ThreadPool.Names.SAME, true, true)).         BytesReference reference = messageCaptor.get().         assertNotNull(reference).         AtomicReference<BytesReference> responseCaptor = new AtomicReference<>().         InetSocketAddress address = new InetSocketAddress(InetAddress.getLocalHost(), 0).         FakeTcpChannel responseChannel = new FakeTcpChannel(true, address, address, "profile", responseCaptor).         transport.messageReceived(reference.slice(6, reference.length() - 6), responseChannel).         StreamInput streamIn = responseCaptor.get().streamInput().         streamIn.skip(TcpHeader.MARKER_BYTES_SIZE).         @SuppressWarnings("unused")         int len = streamIn.readInt().         long requestId = streamIn.readLong().         assertEquals(42, requestId).         byte status = streamIn.readByte().         Version version = Version.fromId(streamIn.readInt()).         assertEquals(Version.CURRENT, version).         assertEquals(compressed, TransportStatus.isCompress(status)).         assertFalse(TransportStatus.isRequest(status)).         if (compressed) {             final int bytesConsumed = TcpHeader.HEADER_SIZE.             streamIn = CompressorFactory.compressor(reference.slice(bytesConsumed, reference.length() - bytesConsumed)).streamInput(streamIn).         }         threadPool.getThreadContext().readHeaders(streamIn).         TransportResponse.Empty.INSTANCE.readFrom(streamIn).     } finally {         ThreadPool.terminate(threadPool, 10, TimeUnit.SECONDS).     } }
false;public;0;3;;@Override public void close() { }
false;public;0;4;;@Override public String getProfile() {     return null. }
false;public;1;3;;@Override public void addCloseListener(ActionListener<Void> listener) { }
false;public;0;4;;@Override public boolean isOpen() {     return false. }
false;public;0;4;;@Override public InetSocketAddress getLocalAddress() {     return null. }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     value = in.readString(). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(value). }
false;public;0;9;;public void testDecodeWithIncompleteHeader() throws IOException {     BytesStreamOutput streamOutput = new BytesStreamOutput(1 << 14).     streamOutput.write('E').     streamOutput.write('S').     streamOutput.write(1).     streamOutput.write(1).     assertNull(TcpTransport.decodeFrame(streamOutput.bytes())). }
false;public;0;10;;public void testDecodePing() throws IOException {     BytesStreamOutput streamOutput = new BytesStreamOutput(1 << 14).     streamOutput.write('E').     streamOutput.write('S').     streamOutput.writeInt(-1).     BytesReference message = TcpTransport.decodeFrame(streamOutput.bytes()).     assertEquals(0, message.length()). }
false;public;0;12;;public void testDecodePingWithStartOfSecondMessage() throws IOException {     BytesStreamOutput streamOutput = new BytesStreamOutput(1 << 14).     streamOutput.write('E').     streamOutput.write('S').     streamOutput.writeInt(-1).     streamOutput.write('E').     streamOutput.write('S').     BytesReference message = TcpTransport.decodeFrame(streamOutput.bytes()).     assertEquals(0, message.length()). }
false;public;0;12;;public void testDecodeMessage() throws IOException {     BytesStreamOutput streamOutput = new BytesStreamOutput(1 << 14).     streamOutput.write('E').     streamOutput.write('S').     streamOutput.writeInt(2).     streamOutput.write('M').     streamOutput.write('A').     BytesReference message = TcpTransport.decodeFrame(streamOutput.bytes()).     assertEquals(streamOutput.bytes().slice(6, 2), message). }
false;public;0;12;;public void testDecodeIncompleteMessage() throws IOException {     BytesStreamOutput streamOutput = new BytesStreamOutput(1 << 14).     streamOutput.write('E').     streamOutput.write('S').     streamOutput.writeInt(3).     streamOutput.write('M').     streamOutput.write('A').     BytesReference message = TcpTransport.decodeFrame(streamOutput.bytes()).     assertNull(message). }
false;public;0;16;;public void testInvalidLength() throws IOException {     BytesStreamOutput streamOutput = new BytesStreamOutput(1 << 14).     streamOutput.write('E').     streamOutput.write('S').     streamOutput.writeInt(-2).     streamOutput.write('M').     streamOutput.write('A').     try {         TcpTransport.decodeFrame(streamOutput.bytes()).         fail("Expected exception").     } catch (Exception ex) {         assertThat(ex, instanceOf(StreamCorruptedException.class)).         assertEquals("invalid data length: -2", ex.getMessage()).     } }
false;public;0;23;;public void testInvalidHeader() throws IOException {     BytesStreamOutput streamOutput = new BytesStreamOutput(1 << 14).     streamOutput.write('E').     streamOutput.write('C').     byte byte1 = randomByte().     byte byte2 = randomByte().     streamOutput.write(byte1).     streamOutput.write(byte2).     streamOutput.write(randomByte()).     streamOutput.write(randomByte()).     streamOutput.write(randomByte()).     try {         TcpTransport.decodeFrame(streamOutput.bytes()).         fail("Expected exception").     } catch (Exception ex) {         assertThat(ex, instanceOf(StreamCorruptedException.class)).         String expected = "invalid internal transport message format, got (45,43," + Integer.toHexString(byte1 & 0xFF) + "," + Integer.toHexString(byte2 & 0xFF) + ")".         assertEquals(expected, ex.getMessage()).     } }
false;public;0;21;;public void testHTTPHeader() throws IOException {     String[] httpHeaders = { "GET", "POST", "PUT", "HEAD", "DELETE", "OPTIONS", "PATCH", "TRACE" }.     for (String httpHeader : httpHeaders) {         BytesStreamOutput streamOutput = new BytesStreamOutput(1 << 14).         for (char c : httpHeader.toCharArray()) {             streamOutput.write((byte) c).         }         streamOutput.write(new byte[6]).         try {             BytesReference bytes = streamOutput.bytes().             TcpTransport.decodeFrame(bytes).             fail("Expected exception").         } catch (Exception ex) {             assertThat(ex, instanceOf(TcpTransport.HttpOnTransportException.class)).             assertEquals("This is not an HTTP port", ex.getMessage()).         }     } }
