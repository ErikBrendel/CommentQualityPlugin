# id;timestamp;commentText;codeText;commentWords;codeWords
SearchHitTests -> public void testFromXContentWithoutTypeAndId() throws IOException;1524684173;When e.g. with "stored_fields": "_none_", only "_index" and "_score" are returned.;public void testFromXContentWithoutTypeAndId() throws IOException {_        String hit = "{\"_index\": \"my_index\", \"_score\": 1}"__        SearchHit parsed__        try (XContentParser parser = createParser(JsonXContent.jsonXContent, hit)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertEquals("my_index", parsed.getIndex())__        assertEquals(1, parsed.getScore(), Float.MIN_VALUE)__        assertNull(parsed.getType())__        assertNull(parsed.getId())__    };when,e,g,with,only,and,are,returned;public,void,test,from,xcontent,without,type,and,id,throws,ioexception,string,hit,1,search,hit,parsed,try,xcontent,parser,parser,create,parser,json,xcontent,json,xcontent,hit,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,equals,parsed,get,index,assert,equals,1,parsed,get,score,float,assert,null,parsed,get,type,assert,null,parsed,get,id
SearchHitTests -> public void testFromXContentWithoutTypeAndId() throws IOException;1533063033;When e.g. with "stored_fields": "_none_", only "_index" and "_score" are returned.;public void testFromXContentWithoutTypeAndId() throws IOException {_        String hit = "{\"_index\": \"my_index\", \"_score\": 1}"__        SearchHit parsed__        try (XContentParser parser = createParser(JsonXContent.jsonXContent, hit)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertEquals("my_index", parsed.getIndex())__        assertEquals(1, parsed.getScore(), Float.MIN_VALUE)__        assertNull(parsed.getType())__        assertNull(parsed.getId())__    };when,e,g,with,only,and,are,returned;public,void,test,from,xcontent,without,type,and,id,throws,ioexception,string,hit,1,search,hit,parsed,try,xcontent,parser,parser,create,parser,json,xcontent,json,xcontent,hit,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,equals,parsed,get,index,assert,equals,1,parsed,get,score,float,assert,null,parsed,get,type,assert,null,parsed,get,id
SearchHitTests -> public void testFromXContentWithoutTypeAndId() throws IOException;1544035746;When e.g. with "stored_fields": "_none_", only "_index" and "_score" are returned.;public void testFromXContentWithoutTypeAndId() throws IOException {_        String hit = "{\"_index\": \"my_index\", \"_score\": 1}"__        SearchHit parsed__        try (XContentParser parser = createParser(JsonXContent.jsonXContent, hit)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertEquals("my_index", parsed.getIndex())__        assertEquals(1, parsed.getScore(), Float.MIN_VALUE)__        assertNull(parsed.getType())__        assertNull(parsed.getId())__    };when,e,g,with,only,and,are,returned;public,void,test,from,xcontent,without,type,and,id,throws,ioexception,string,hit,1,search,hit,parsed,try,xcontent,parser,parser,create,parser,json,xcontent,json,xcontent,hit,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,equals,parsed,get,index,assert,equals,1,parsed,get,score,float,assert,null,parsed,get,type,assert,null,parsed,get,id
SearchHitTests -> public void testFromXContentWithoutTypeAndId() throws IOException;1544470880;When e.g. with "stored_fields": "_none_", only "_index" and "_score" are returned.;public void testFromXContentWithoutTypeAndId() throws IOException {_        String hit = "{\"_index\": \"my_index\", \"_score\": 1}"__        SearchHit parsed__        try (XContentParser parser = createParser(JsonXContent.jsonXContent, hit)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertEquals("my_index", parsed.getIndex())__        assertEquals(1, parsed.getScore(), Float.MIN_VALUE)__        assertNull(parsed.getType())__        assertNull(parsed.getId())__    };when,e,g,with,only,and,are,returned;public,void,test,from,xcontent,without,type,and,id,throws,ioexception,string,hit,1,search,hit,parsed,try,xcontent,parser,parser,create,parser,json,xcontent,json,xcontent,hit,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,equals,parsed,get,index,assert,equals,1,parsed,get,score,float,assert,null,parsed,get,type,assert,null,parsed,get,id
SearchHitTests -> public void testFromXContentWithoutTypeAndId() throws IOException;1544786574;When e.g. with "stored_fields": "_none_", only "_index" and "_score" are returned.;public void testFromXContentWithoutTypeAndId() throws IOException {_        String hit = "{\"_index\": \"my_index\", \"_score\": 1}"__        SearchHit parsed__        try (XContentParser parser = createParser(JsonXContent.jsonXContent, hit)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertEquals("my_index", parsed.getIndex())__        assertEquals(1, parsed.getScore(), Float.MIN_VALUE)__        assertNull(parsed.getType())__        assertNull(parsed.getId())__    };when,e,g,with,only,and,are,returned;public,void,test,from,xcontent,without,type,and,id,throws,ioexception,string,hit,1,search,hit,parsed,try,xcontent,parser,parser,create,parser,json,xcontent,json,xcontent,hit,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,equals,parsed,get,index,assert,equals,1,parsed,get,score,float,assert,null,parsed,get,type,assert,null,parsed,get,id
SearchHitTests -> public void testFromXContentWithoutTypeAndId() throws IOException;1544810257;When e.g. with "stored_fields": "_none_", only "_index" and "_score" are returned.;public void testFromXContentWithoutTypeAndId() throws IOException {_        String hit = "{\"_index\": \"my_index\", \"_score\": 1}"__        SearchHit parsed__        try (XContentParser parser = createParser(JsonXContent.jsonXContent, hit)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertEquals("my_index", parsed.getIndex())__        assertEquals(1, parsed.getScore(), Float.MIN_VALUE)__        assertNull(parsed.getType())__        assertNull(parsed.getId())__    };when,e,g,with,only,and,are,returned;public,void,test,from,xcontent,without,type,and,id,throws,ioexception,string,hit,1,search,hit,parsed,try,xcontent,parser,parser,create,parser,json,xcontent,json,xcontent,hit,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,equals,parsed,get,index,assert,equals,1,parsed,get,score,float,assert,null,parsed,get,type,assert,null,parsed,get,id
SearchHitTests -> public void testFromXContentWithoutTypeAndId() throws IOException;1545997405;When e.g. with "stored_fields": "_none_", only "_index" and "_score" are returned.;public void testFromXContentWithoutTypeAndId() throws IOException {_        String hit = "{\"_index\": \"my_index\", \"_score\": 1}"__        SearchHit parsed__        try (XContentParser parser = createParser(JsonXContent.jsonXContent, hit)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertEquals("my_index", parsed.getIndex())__        assertEquals(1, parsed.getScore(), Float.MIN_VALUE)__        assertNull(parsed.getType())__        assertNull(parsed.getId())__    };when,e,g,with,only,and,are,returned;public,void,test,from,xcontent,without,type,and,id,throws,ioexception,string,hit,1,search,hit,parsed,try,xcontent,parser,parser,create,parser,json,xcontent,json,xcontent,hit,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,equals,parsed,get,index,assert,equals,1,parsed,get,score,float,assert,null,parsed,get,type,assert,null,parsed,get,id
SearchHitTests -> public void testFromXContentWithoutTypeAndId() throws IOException;1548230518;When e.g. with "stored_fields": "_none_", only "_index" and "_score" are returned.;public void testFromXContentWithoutTypeAndId() throws IOException {_        String hit = "{\"_index\": \"my_index\", \"_score\": 1}"__        SearchHit parsed__        try (XContentParser parser = createParser(JsonXContent.jsonXContent, hit)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertEquals("my_index", parsed.getIndex())__        assertEquals(1, parsed.getScore(), Float.MIN_VALUE)__        assertNull(parsed.getType())__        assertNull(parsed.getId())__    };when,e,g,with,only,and,are,returned;public,void,test,from,xcontent,without,type,and,id,throws,ioexception,string,hit,1,search,hit,parsed,try,xcontent,parser,parser,create,parser,json,xcontent,json,xcontent,hit,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,equals,parsed,get,index,assert,equals,1,parsed,get,score,float,assert,null,parsed,get,type,assert,null,parsed,get,id
SearchHitTests -> public void testFromXContentWithoutTypeAndId() throws IOException;1548846354;When e.g. with "stored_fields": "_none_", only "_index" and "_score" are returned.;public void testFromXContentWithoutTypeAndId() throws IOException {_        String hit = "{\"_index\": \"my_index\", \"_score\": 1}"__        SearchHit parsed__        try (XContentParser parser = createParser(JsonXContent.jsonXContent, hit)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertEquals("my_index", parsed.getIndex())__        assertEquals(1, parsed.getScore(), Float.MIN_VALUE)__        assertNull(parsed.getType())__        assertNull(parsed.getId())__    };when,e,g,with,only,and,are,returned;public,void,test,from,xcontent,without,type,and,id,throws,ioexception,string,hit,1,search,hit,parsed,try,xcontent,parser,parser,create,parser,json,xcontent,json,xcontent,hit,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,equals,parsed,get,index,assert,equals,1,parsed,get,score,float,assert,null,parsed,get,type,assert,null,parsed,get,id
SearchHitTests -> public void testFromXContentLenientParsing() throws IOException;1524684173;This test adds randomized fields on all json objects and checks that we can parse it to_ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field name since these_objects allow arbitrary keys (the field names that are queries). Also we want to exclude_to add anything under "_source" since it is not parsed, and avoid complexity by excluding_everything under "inner_hits". They are also keyed by arbitrary names and contain SearchHits,_which are already tested elsewhere.;public void testFromXContentLenientParsing() throws IOException {_        SearchHit searchHit = createTestItem(true)__        XContentType xContentType = randomFrom(XContentType.values())__        BytesReference originalBytes = toXContent(searchHit, xContentType, true)__        Predicate<String> pathsToExclude = path -> (path.endsWith("highlight") || path.endsWith("fields") || path.contains("_source")_                || path.contains("inner_hits"))__        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, pathsToExclude, random())___        SearchHit parsed__        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xContentType, true), xContentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed,and,avoid,complexity,by,excluding,everything,under,they,are,also,keyed,by,arbitrary,names,and,contain,search,hits,which,are,already,tested,elsewhere;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,search,hit,search,hit,create,test,item,true,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,original,bytes,to,xcontent,search,hit,x,content,type,true,predicate,string,paths,to,exclude,path,path,ends,with,highlight,path,ends,with,fields,path,contains,path,contains,bytes,reference,with,random,fields,insert,random,fields,x,content,type,original,bytes,paths,to,exclude,random,search,hit,parsed,try,xcontent,parser,parser,create,parser,x,content,type,x,content,with,random,fields,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,x,content,type,true,x,content,type
SearchHitTests -> public void testFromXContentLenientParsing() throws IOException;1533063033;This test adds randomized fields on all json objects and checks that we can parse it to_ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field name since these_objects allow arbitrary keys (the field names that are queries). Also we want to exclude_to add anything under "_source" since it is not parsed, and avoid complexity by excluding_everything under "inner_hits". They are also keyed by arbitrary names and contain SearchHits,_which are already tested elsewhere.;public void testFromXContentLenientParsing() throws IOException {_        SearchHit searchHit = createTestItem(true)__        XContentType xContentType = randomFrom(XContentType.values())__        BytesReference originalBytes = toXContent(searchHit, xContentType, true)__        Predicate<String> pathsToExclude = path -> (path.endsWith("highlight") || path.endsWith("fields") || path.contains("_source")_                || path.contains("inner_hits"))__        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, pathsToExclude, random())___        SearchHit parsed__        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xContentType, true), xContentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed,and,avoid,complexity,by,excluding,everything,under,they,are,also,keyed,by,arbitrary,names,and,contain,search,hits,which,are,already,tested,elsewhere;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,search,hit,search,hit,create,test,item,true,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,original,bytes,to,xcontent,search,hit,x,content,type,true,predicate,string,paths,to,exclude,path,path,ends,with,highlight,path,ends,with,fields,path,contains,path,contains,bytes,reference,with,random,fields,insert,random,fields,x,content,type,original,bytes,paths,to,exclude,random,search,hit,parsed,try,xcontent,parser,parser,create,parser,x,content,type,x,content,with,random,fields,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,x,content,type,true,x,content,type
SearchHitTests -> public void testFromXContentLenientParsing() throws IOException;1544035746;This test adds randomized fields on all json objects and checks that we can parse it to_ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field name since these_objects allow arbitrary keys (the field names that are queries). Also we want to exclude_to add anything under "_source" since it is not parsed, and avoid complexity by excluding_everything under "inner_hits". They are also keyed by arbitrary names and contain SearchHits,_which are already tested elsewhere.;public void testFromXContentLenientParsing() throws IOException {_        SearchHit searchHit = createTestItem(true)__        XContentType xContentType = randomFrom(XContentType.values())__        BytesReference originalBytes = toXContent(searchHit, xContentType, true)__        Predicate<String> pathsToExclude = path -> (path.endsWith("highlight") || path.endsWith("fields") || path.contains("_source")_                || path.contains("inner_hits"))__        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, pathsToExclude, random())___        SearchHit parsed__        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xContentType, true), xContentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed,and,avoid,complexity,by,excluding,everything,under,they,are,also,keyed,by,arbitrary,names,and,contain,search,hits,which,are,already,tested,elsewhere;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,search,hit,search,hit,create,test,item,true,xcontent,type,x,content,type,random,from,xcontent,type,values,bytes,reference,original,bytes,to,xcontent,search,hit,x,content,type,true,predicate,string,paths,to,exclude,path,path,ends,with,highlight,path,ends,with,fields,path,contains,path,contains,bytes,reference,with,random,fields,insert,random,fields,x,content,type,original,bytes,paths,to,exclude,random,search,hit,parsed,try,xcontent,parser,parser,create,parser,x,content,type,x,content,with,random,fields,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,x,content,type,true,x,content,type
SearchHitTests -> public void testFromXContentLenientParsing() throws IOException;1544470880;This test adds randomized fields on all json objects and checks that we can parse it to_ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field name since these_objects allow arbitrary keys (the field names that are queries). Also we want to exclude_to add anything under "_source" since it is not parsed, and avoid complexity by excluding_everything under "inner_hits". They are also keyed by arbitrary names and contain SearchHits,_which are already tested elsewhere.;public void testFromXContentLenientParsing() throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        SearchHit searchHit = createTestItem(xContentType, true, true)__        BytesReference originalBytes = toXContent(searchHit, xContentType, true)__        Predicate<String> pathsToExclude = path -> (path.endsWith("highlight") || path.endsWith("fields") || path.contains("_source")_                || path.contains("inner_hits"))__        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, pathsToExclude, random())___        SearchHit parsed__        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xContentType, true), xContentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed,and,avoid,complexity,by,excluding,everything,under,they,are,also,keyed,by,arbitrary,names,and,contain,search,hits,which,are,already,tested,elsewhere;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,search,hit,search,hit,create,test,item,x,content,type,true,true,bytes,reference,original,bytes,to,xcontent,search,hit,x,content,type,true,predicate,string,paths,to,exclude,path,path,ends,with,highlight,path,ends,with,fields,path,contains,path,contains,bytes,reference,with,random,fields,insert,random,fields,x,content,type,original,bytes,paths,to,exclude,random,search,hit,parsed,try,xcontent,parser,parser,create,parser,x,content,type,x,content,with,random,fields,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,x,content,type,true,x,content,type
SearchHitTests -> public void testFromXContentLenientParsing() throws IOException;1544786574;This test adds randomized fields on all json objects and checks that we can parse it to_ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field name since these_objects allow arbitrary keys (the field names that are queries). Also we want to exclude_to add anything under "_source" since it is not parsed, and avoid complexity by excluding_everything under "inner_hits". They are also keyed by arbitrary names and contain SearchHits,_which are already tested elsewhere.;public void testFromXContentLenientParsing() throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        SearchHit searchHit = createTestItem(xContentType, true, true)__        BytesReference originalBytes = toXContent(searchHit, xContentType, true)__        Predicate<String> pathsToExclude = path -> (path.endsWith("highlight") || path.endsWith("fields") || path.contains("_source")_                || path.contains("inner_hits"))__        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, pathsToExclude, random())___        SearchHit parsed__        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xContentType, true), xContentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed,and,avoid,complexity,by,excluding,everything,under,they,are,also,keyed,by,arbitrary,names,and,contain,search,hits,which,are,already,tested,elsewhere;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,search,hit,search,hit,create,test,item,x,content,type,true,true,bytes,reference,original,bytes,to,xcontent,search,hit,x,content,type,true,predicate,string,paths,to,exclude,path,path,ends,with,highlight,path,ends,with,fields,path,contains,path,contains,bytes,reference,with,random,fields,insert,random,fields,x,content,type,original,bytes,paths,to,exclude,random,search,hit,parsed,try,xcontent,parser,parser,create,parser,x,content,type,x,content,with,random,fields,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,x,content,type,true,x,content,type
SearchHitTests -> public void testFromXContentLenientParsing() throws IOException;1544810257;This test adds randomized fields on all json objects and checks that we can parse it to_ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field name since these_objects allow arbitrary keys (the field names that are queries). Also we want to exclude_to add anything under "_source" since it is not parsed, and avoid complexity by excluding_everything under "inner_hits". They are also keyed by arbitrary names and contain SearchHits,_which are already tested elsewhere.;public void testFromXContentLenientParsing() throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        SearchHit searchHit = createTestItem(xContentType, true, true)__        BytesReference originalBytes = toXContent(searchHit, xContentType, true)__        Predicate<String> pathsToExclude = path -> (path.endsWith("highlight") || path.endsWith("fields") || path.contains("_source")_                || path.contains("inner_hits"))__        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, pathsToExclude, random())___        SearchHit parsed__        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xContentType, true), xContentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed,and,avoid,complexity,by,excluding,everything,under,they,are,also,keyed,by,arbitrary,names,and,contain,search,hits,which,are,already,tested,elsewhere;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,search,hit,search,hit,create,test,item,x,content,type,true,true,bytes,reference,original,bytes,to,xcontent,search,hit,x,content,type,true,predicate,string,paths,to,exclude,path,path,ends,with,highlight,path,ends,with,fields,path,contains,path,contains,bytes,reference,with,random,fields,insert,random,fields,x,content,type,original,bytes,paths,to,exclude,random,search,hit,parsed,try,xcontent,parser,parser,create,parser,x,content,type,x,content,with,random,fields,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,x,content,type,true,x,content,type
SearchHitTests -> public void testFromXContentLenientParsing() throws IOException;1545997405;This test adds randomized fields on all json objects and checks that we can parse it to_ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field name since these_objects allow arbitrary keys (the field names that are queries). Also we want to exclude_to add anything under "_source" since it is not parsed, and avoid complexity by excluding_everything under "inner_hits". They are also keyed by arbitrary names and contain SearchHits,_which are already tested elsewhere.;public void testFromXContentLenientParsing() throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        SearchHit searchHit = createTestItem(xContentType, true, true)__        BytesReference originalBytes = toXContent(searchHit, xContentType, true)__        Predicate<String> pathsToExclude = path -> (path.endsWith("highlight") || path.endsWith("fields") || path.contains("_source")_                || path.contains("inner_hits"))__        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, pathsToExclude, random())___        SearchHit parsed__        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xContentType, true), xContentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed,and,avoid,complexity,by,excluding,everything,under,they,are,also,keyed,by,arbitrary,names,and,contain,search,hits,which,are,already,tested,elsewhere;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,search,hit,search,hit,create,test,item,x,content,type,true,true,bytes,reference,original,bytes,to,xcontent,search,hit,x,content,type,true,predicate,string,paths,to,exclude,path,path,ends,with,highlight,path,ends,with,fields,path,contains,path,contains,bytes,reference,with,random,fields,insert,random,fields,x,content,type,original,bytes,paths,to,exclude,random,search,hit,parsed,try,xcontent,parser,parser,create,parser,x,content,type,x,content,with,random,fields,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,x,content,type,true,x,content,type
SearchHitTests -> public void testFromXContentLenientParsing() throws IOException;1548230518;This test adds randomized fields on all json objects and checks that we can parse it to_ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field name since these_objects allow arbitrary keys (the field names that are queries). Also we want to exclude_to add anything under "_source" since it is not parsed, and avoid complexity by excluding_everything under "inner_hits". They are also keyed by arbitrary names and contain SearchHits,_which are already tested elsewhere.;public void testFromXContentLenientParsing() throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        SearchHit searchHit = createTestItem(xContentType, true, true)__        BytesReference originalBytes = toXContent(searchHit, xContentType, true)__        Predicate<String> pathsToExclude = path -> (path.endsWith("highlight") || path.endsWith("fields") || path.contains("_source")_                || path.contains("inner_hits"))__        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, pathsToExclude, random())___        SearchHit parsed__        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xContentType, true), xContentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed,and,avoid,complexity,by,excluding,everything,under,they,are,also,keyed,by,arbitrary,names,and,contain,search,hits,which,are,already,tested,elsewhere;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,search,hit,search,hit,create,test,item,x,content,type,true,true,bytes,reference,original,bytes,to,xcontent,search,hit,x,content,type,true,predicate,string,paths,to,exclude,path,path,ends,with,highlight,path,ends,with,fields,path,contains,path,contains,bytes,reference,with,random,fields,insert,random,fields,x,content,type,original,bytes,paths,to,exclude,random,search,hit,parsed,try,xcontent,parser,parser,create,parser,x,content,type,x,content,with,random,fields,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,x,content,type,true,x,content,type
SearchHitTests -> public void testFromXContentLenientParsing() throws IOException;1548846354;This test adds randomized fields on all json objects and checks that we can parse it to_ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field name since these_objects allow arbitrary keys (the field names that are queries). Also we want to exclude_to add anything under "_source" since it is not parsed, and avoid complexity by excluding_everything under "inner_hits". They are also keyed by arbitrary names and contain SearchHits,_which are already tested elsewhere.;public void testFromXContentLenientParsing() throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        SearchHit searchHit = createTestItem(xContentType, true, true)__        BytesReference originalBytes = toXContent(searchHit, xContentType, true)__        Predicate<String> pathsToExclude = path -> (path.endsWith("highlight") || path.endsWith("fields") || path.contains("_source")_                || path.contains("inner_hits"))__        BytesReference withRandomFields = insertRandomFields(xContentType, originalBytes, pathsToExclude, random())___        SearchHit parsed__        try (XContentParser parser = createParser(xContentType.xContent(), withRandomFields)) {_            parser.nextToken()_ _            parsed = SearchHit.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xContentType, true), xContentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed,and,avoid,complexity,by,excluding,everything,under,they,are,also,keyed,by,arbitrary,names,and,contain,search,hits,which,are,already,tested,elsewhere;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,search,hit,search,hit,create,test,item,x,content,type,true,true,bytes,reference,original,bytes,to,xcontent,search,hit,x,content,type,true,predicate,string,paths,to,exclude,path,path,ends,with,highlight,path,ends,with,fields,path,contains,path,contains,bytes,reference,with,random,fields,insert,random,fields,x,content,type,original,bytes,paths,to,exclude,random,search,hit,parsed,try,xcontent,parser,parser,create,parser,x,content,type,x,content,with,random,fields,parser,next,token,parsed,search,hit,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,x,content,type,true,x,content,type
