commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;public void testSetupActionsContainsKnownBuiltin() {     assertThat(ActionModule.setupActions(emptyList()), hasEntry(MainAction.INSTANCE.name(), new ActionHandler<>(MainAction.INSTANCE, TransportMainAction.class))). }
false;public;0;4;;@Override public List<ActionHandler<? extends ActionRequest, ? extends ActionResponse>> getActions() {     return singletonList(new ActionHandler<>(MainAction.INSTANCE, TransportMainAction.class)). }
false;public;0;10;;public void testPluginCantOverwriteBuiltinAction() {     ActionPlugin dupsMainAction = new ActionPlugin() {          @Override         public List<ActionHandler<? extends ActionRequest, ? extends ActionResponse>> getActions() {             return singletonList(new ActionHandler<>(MainAction.INSTANCE, TransportMainAction.class)).         }     }.     Exception e = expectThrows(IllegalArgumentException.class, () -> ActionModule.setupActions(singletonList(dupsMainAction))).     assertEquals("action for name [" + MainAction.NAME + "] already registered", e.getMessage()). }
false;public;0;4;;@Override public ActionRequestValidationException validate() {     return null. }
false;protected;3;3;;@Override protected void doExecute(Task task, FakeRequest request, ActionListener<ActionResponse> listener) { }
false;public;0;4;;@Override public ActionResponse newResponse() {     return null. }
false;public;0;4;;@Override public List<ActionHandler<? extends ActionRequest, ? extends ActionResponse>> getActions() {     return singletonList(new ActionHandler<>(action, FakeTransportAction.class)). }
false;public;0;36;;public void testPluginCanRegisterAction() {     class FakeRequest extends ActionRequest {          @Override         public ActionRequestValidationException validate() {             return null.         }     }     class FakeTransportAction extends TransportAction<FakeRequest, ActionResponse> {          protected FakeTransportAction(String actionName, ActionFilters actionFilters, TaskManager taskManager) {             super(actionName, actionFilters, taskManager).         }          @Override         protected void doExecute(Task task, FakeRequest request, ActionListener<ActionResponse> listener) {         }     }     class FakeAction extends Action<ActionResponse> {          protected FakeAction() {             super("fake").         }          @Override         public ActionResponse newResponse() {             return null.         }     }     FakeAction action = new FakeAction().     ActionPlugin registersFakeAction = new ActionPlugin() {          @Override         public List<ActionHandler<? extends ActionRequest, ? extends ActionResponse>> getActions() {             return singletonList(new ActionHandler<>(action, FakeTransportAction.class)).         }     }.     assertThat(ActionModule.setupActions(singletonList(registersFakeAction)), hasEntry("fake", new ActionHandler<>(action, FakeTransportAction.class))). }
false;public;0;12;;public void testSetupRestHandlerContainsKnownBuiltin() {     SettingsModule settings = new SettingsModule(Settings.EMPTY).     UsageService usageService = new UsageService().     ActionModule actionModule = new ActionModule(false, settings.getSettings(), new IndexNameExpressionResolver(), settings.getIndexScopedSettings(), settings.getClusterSettings(), settings.getSettingsFilter(), null, emptyList(), null, null, usageService).     actionModule.initRestHandlers(null).     // At this point the easiest way to confirm that a handler is loaded is to try to register another one on top of it and to fail     Exception e = expectThrows(IllegalArgumentException.class, () -> actionModule.getRestController().registerHandler(Method.GET, "/", null)).     assertThat(e.getMessage(), startsWith("Cannot replace existing handler for [/] for method: GET")). }
false;public;7;6;;@Override public List<RestHandler> getRestHandlers(Settings settings, RestController restController, ClusterSettings clusterSettings, IndexScopedSettings indexScopedSettings, SettingsFilter settingsFilter, IndexNameExpressionResolver indexNameExpressionResolver, Supplier<DiscoveryNodes> nodesInCluster) {     return singletonList(new RestMainAction(settings, restController)). }
false;public;0;22;;public void testPluginCantOverwriteBuiltinRestHandler() throws IOException {     ActionPlugin dupsMainAction = new ActionPlugin() {          @Override         public List<RestHandler> getRestHandlers(Settings settings, RestController restController, ClusterSettings clusterSettings, IndexScopedSettings indexScopedSettings, SettingsFilter settingsFilter, IndexNameExpressionResolver indexNameExpressionResolver, Supplier<DiscoveryNodes> nodesInCluster) {             return singletonList(new RestMainAction(settings, restController)).         }     }.     SettingsModule settings = new SettingsModule(Settings.EMPTY).     ThreadPool threadPool = new TestThreadPool(getTestName()).     try {         UsageService usageService = new UsageService().         ActionModule actionModule = new ActionModule(false, settings.getSettings(), new IndexNameExpressionResolver(), settings.getIndexScopedSettings(), settings.getClusterSettings(), settings.getSettingsFilter(), threadPool, singletonList(dupsMainAction), null, null, usageService).         Exception e = expectThrows(IllegalArgumentException.class, () -> actionModule.initRestHandlers(null)).         assertThat(e.getMessage(), startsWith("Cannot replace existing handler for [/] for method: GET")).     } finally {         threadPool.shutdown().     } }
false;public;3;3;;@Override public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception { }
false;public;7;6;;@Override public List<RestHandler> getRestHandlers(Settings settings, RestController restController, ClusterSettings clusterSettings, IndexScopedSettings indexScopedSettings, SettingsFilter settingsFilter, IndexNameExpressionResolver indexNameExpressionResolver, Supplier<DiscoveryNodes> nodesInCluster) {     return singletonList(new FakeHandler(restController)). }
false;public;0;34;;public void testPluginCanRegisterRestHandler() {     class FakeHandler implements RestHandler {          FakeHandler(RestController restController) {             restController.registerHandler(Method.GET, "/_dummy", this).         }          @Override         public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {         }     }     ActionPlugin registersFakeHandler = new ActionPlugin() {          @Override         public List<RestHandler> getRestHandlers(Settings settings, RestController restController, ClusterSettings clusterSettings, IndexScopedSettings indexScopedSettings, SettingsFilter settingsFilter, IndexNameExpressionResolver indexNameExpressionResolver, Supplier<DiscoveryNodes> nodesInCluster) {             return singletonList(new FakeHandler(restController)).         }     }.     SettingsModule settings = new SettingsModule(Settings.EMPTY).     ThreadPool threadPool = new TestThreadPool(getTestName()).     try {         UsageService usageService = new UsageService().         ActionModule actionModule = new ActionModule(false, settings.getSettings(), new IndexNameExpressionResolver(), settings.getIndexScopedSettings(), settings.getClusterSettings(), settings.getSettingsFilter(), threadPool, singletonList(registersFakeHandler), null, null, usageService).         actionModule.initRestHandlers(null).         // At this point the easiest way to confirm that a handler is loaded is to try to register another one on top of it and to fail         Exception e = expectThrows(IllegalArgumentException.class, () -> actionModule.getRestController().registerHandler(Method.GET, "/_dummy", null)).         assertThat(e.getMessage(), startsWith("Cannot replace existing handler for [/_dummy] for method: GET")).     } finally {         threadPool.shutdown().     } }
