commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;8;/**  * setup for the whole base test class  */ ;/**  * setup for the whole base test class  */ @BeforeClass public static void init() {     if (namedWriteableRegistry == null) {         List<NamedWriteableRegistry.Entry> namedWriteables = new ArrayList<>().         SearchModule.registerSmoothingModels(namedWriteables).         namedWriteableRegistry = new NamedWriteableRegistry(namedWriteables).     } }
false;public,static;0;4;;@AfterClass public static void afterClass() throws Exception {     namedWriteableRegistry = null. }
true;protected,abstract;0;1;/**  * create random model that is put under test  */ ;/**  * create random model that is put under test  */ protected abstract SmoothingModel createTestModel().
true;protected,abstract;1;1;/**  * mutate the given model so the returned smoothing model is different  */ ;/**  * mutate the given model so the returned smoothing model is different  */ protected abstract SmoothingModel createMutation(SmoothingModel original) throws IOException.
false;protected,abstract;1;1;;protected abstract SmoothingModel fromXContent(XContentParser parser) throws IOException.
true;public;0;17;/**  * Test that creates new smoothing model from a random test smoothing model and checks both for equality  */ ;/**  * Test that creates new smoothing model from a random test smoothing model and checks both for equality  */ public void testFromXContent() throws IOException {     SmoothingModel testModel = createTestModel().     XContentBuilder contentBuilder = XContentFactory.contentBuilder(randomFrom(XContentType.values())).     if (randomBoolean()) {         contentBuilder.prettyPrint().     }     contentBuilder.startObject().     testModel.innerToXContent(contentBuilder, ToXContent.EMPTY_PARAMS).     contentBuilder.endObject().     try (XContentParser parser = createParser(shuffleXContent(contentBuilder))) {         // go to start token, real parsing would do that in the outer element parser         parser.nextToken().         SmoothingModel parsedModel = fromXContent(parser).         assertNotSame(testModel, parsedModel).         assertEquals(testModel, parsedModel).         assertEquals(testModel.hashCode(), parsedModel.hashCode()).     } }
true;public;0;15;/**  * Test the WordScorer emitted by the smoothing model  */ ;/**  * Test the WordScorer emitted by the smoothing model  */ public void testBuildWordScorer() throws IOException {     SmoothingModel testModel = createTestModel().     Map<String, Analyzer> mapping = new HashMap<>().     mapping.put("field", new WhitespaceAnalyzer()).     PerFieldAnalyzerWrapper wrapper = new PerFieldAnalyzerWrapper(new WhitespaceAnalyzer(), mapping).     IndexWriter writer = new IndexWriter(new RAMDirectory(), new IndexWriterConfig(wrapper)).     Document doc = new Document().     doc.add(new Field("field", "someText", TextField.TYPE_NOT_STORED)).     writer.addDocument(doc).     DirectoryReader ir = DirectoryReader.open(writer).     WordScorer wordScorer = testModel.buildWordScorerFactory().newScorer(ir, MultiTerms.getTerms(ir, "field"), "field", 0.9d, BytesRefs.toBytesRef(" ")).     assertWordScorer(wordScorer, testModel). }
true;abstract;2;1;/**  * implementation dependant assertions on the wordScorer produced by the smoothing model under test  */ ;/**  * implementation dependant assertions on the wordScorer produced by the smoothing model under test  */ abstract void assertWordScorer(WordScorer wordScorer, SmoothingModel testModel).
true;public;0;7;/**  * Test serialization and deserialization of the tested model.  */ ;/**  * Test serialization and deserialization of the tested model.  */ public void testSerialization() throws IOException {     SmoothingModel testModel = createTestModel().     SmoothingModel deserializedModel = copy(testModel).     assertEquals(testModel, deserializedModel).     assertEquals(testModel.hashCode(), deserializedModel.hashCode()).     assertNotSame(testModel, deserializedModel). }
true;public;0;3;/**  * Test equality and hashCode properties  */ ;/**  * Test equality and hashCode properties  */ public void testEqualsAndHashcode() throws IOException {     checkEqualsAndHashCode(createTestModel(), this::copy, this::createMutation). }
false;private;1;4;;private SmoothingModel copy(SmoothingModel original) throws IOException {     return ESTestCase.copyWriteable(original, namedWriteableRegistry, namedWriteableRegistry.getReader(SmoothingModel.class, original.getWriteableName())). }
