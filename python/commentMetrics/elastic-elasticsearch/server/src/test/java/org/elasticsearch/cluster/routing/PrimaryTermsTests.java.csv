commented;modifiers;parameterAmount;loc;comment;code
false;public;0;26;;@Override public void setUp() throws Exception {     super.setUp().     this.allocationService = createAllocationService(Settings.builder().put("cluster.routing.allocation.node_concurrent_recoveries", // don't limit recoveries     Integer.MAX_VALUE).put("cluster.routing.allocation.node_initial_primaries_recoveries", Integer.MAX_VALUE).build()).     this.numberOfShards = randomIntBetween(1, 5).     this.numberOfReplicas = randomIntBetween(0, 5).     logger.info("Setup test with {} shards and {} replicas.", this.numberOfShards, this.numberOfReplicas).     this.primaryTermsPerIndex.clear().     MetaData metaData = MetaData.builder().put(createIndexMetaData(TEST_INDEX_1)).put(createIndexMetaData(TEST_INDEX_2)).build().     RoutingTable routingTable = new RoutingTable.Builder().add(new IndexRoutingTable.Builder(metaData.index(TEST_INDEX_1).getIndex()).initializeAsNew(metaData.index(TEST_INDEX_1)).build()).add(new IndexRoutingTable.Builder(metaData.index(TEST_INDEX_2).getIndex()).initializeAsNew(metaData.index(TEST_INDEX_2)).build()).build().     this.clusterState = ClusterState.builder(org.elasticsearch.cluster.ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).routingTable(routingTable).build(). }
true;private;0;12;/**  * puts primary shard indexRoutings into initializing state  */ ;/**  * puts primary shard indexRoutings into initializing state  */ private void initPrimaries() {     logger.info("adding {} nodes and performing rerouting", this.numberOfReplicas + 1).     Builder discoBuilder = DiscoveryNodes.builder().     for (int i = 0. i < this.numberOfReplicas + 1. i++) {         discoBuilder = discoBuilder.add(newNode("node" + i)).     }     this.clusterState = ClusterState.builder(clusterState).nodes(discoBuilder).build().     ClusterState rerouteResult = allocationService.reroute(clusterState, "reroute").     assertThat(rerouteResult, not(equalTo(this.clusterState))).     applyRerouteResult(rerouteResult).     primaryTermsPerIndex.keySet().forEach(this::incrementPrimaryTerm). }
false;private;1;6;;private void incrementPrimaryTerm(String index) {     final long[] primaryTerms = primaryTermsPerIndex.get(index).     for (int i = 0. i < primaryTerms.length. i++) {         primaryTerms[i]++.     } }
false;private;2;3;;private void incrementPrimaryTerm(String index, int shard) {     primaryTermsPerIndex.get(index)[shard]++. }
false;private;1;8;;private boolean startInitializingShards(String index) {     final List<ShardRouting> startedShards = this.clusterState.getRoutingNodes().shardsWithState(index, INITIALIZING).     logger.info("start primary shards for index [{}]: {} ", index, startedShards).     ClusterState rerouteResult = allocationService.applyStartedShards(this.clusterState, startedShards).     boolean changed = rerouteResult.equals(this.clusterState) == false.     applyRerouteResult(rerouteResult).     return changed. }
false;private;1;16;;private void applyRerouteResult(ClusterState newClusterState) {     ClusterState previousClusterState = this.clusterState.     ClusterState.Builder builder = ClusterState.builder(newClusterState).incrementVersion().     if (previousClusterState.routingTable() != newClusterState.routingTable()) {         builder.routingTable(RoutingTable.builder(newClusterState.routingTable()).version(newClusterState.routingTable().version() + 1).build()).     }     if (previousClusterState.metaData() != newClusterState.metaData()) {         builder.metaData(MetaData.builder(newClusterState.metaData()).version(newClusterState.metaData().version() + 1)).     }     this.clusterState = builder.build().     final ClusterStateHealth clusterHealth = new ClusterStateHealth(clusterState).     logger.info("applied reroute. active shards: p [{}], t [{}], init shards: [{}], relocating: [{}]", clusterHealth.getActivePrimaryShards(), clusterHealth.getActiveShards(), clusterHealth.getInitializingShards(), clusterHealth.getRelocatingShards()). }
false;private;1;14;;private void failSomePrimaries(String index) {     final IndexRoutingTable indexShardRoutingTable = clusterState.routingTable().index(index).     Set<Integer> shardIdsToFail = new HashSet<>().     for (int i = 1 + randomInt(numberOfShards - 1). i > 0. i--) {         shardIdsToFail.add(randomInt(numberOfShards - 1)).     }     logger.info("failing primary shards {} for index [{}]", shardIdsToFail, index).     List<FailedShard> failedShards = new ArrayList<>().     for (int shard : shardIdsToFail) {         failedShards.add(new FailedShard(indexShardRoutingTable.shard(shard).primaryShard(), "test", null, randomBoolean())).         // the primary failure should increment the primary term.         incrementPrimaryTerm(index, shard).     }     applyRerouteResult(allocationService.applyFailedShards(this.clusterState, failedShards, Collections.emptyList())). }
false;private;0;11;;private void addNodes() {     DiscoveryNodes.Builder nodesBuilder = DiscoveryNodes.builder(clusterState.nodes()).     final int newNodes = randomInt(10).     logger.info("adding [{}] nodes", newNodes).     for (int i = 0. i < newNodes. i++) {         nodesBuilder.add(newNode("extra_" + i)).     }     this.clusterState = ClusterState.builder(clusterState).nodes(nodesBuilder).build().     applyRerouteResult(allocationService.reroute(this.clusterState, "nodes added")). }
false;private;1;12;;private IndexMetaData.Builder createIndexMetaData(String indexName) {     primaryTermsPerIndex.put(indexName, new long[numberOfShards]).     final IndexMetaData.Builder builder = new IndexMetaData.Builder(indexName).settings(DEFAULT_SETTINGS).numberOfReplicas(this.numberOfReplicas).numberOfShards(this.numberOfShards).     for (int i = 0. i < numberOfShards. i++) {         builder.primaryTerm(i, randomInt(200)).         primaryTermsPerIndex.get(indexName)[i] = builder.primaryTerm(i).     }     return builder. }
false;private;0;3;;private void assertAllPrimaryTerm() {     primaryTermsPerIndex.keySet().forEach(this::assertPrimaryTerm). }
false;private;1;9;;private void assertPrimaryTerm(String index) {     final long[] terms = primaryTermsPerIndex.get(index).     final IndexMetaData indexMetaData = clusterState.metaData().index(index).     for (IndexShardRoutingTable shardRoutingTable : this.clusterState.routingTable().index(index)) {         final int shard = shardRoutingTable.shardId().id().         assertThat("primary term mismatch between indexMetaData of [" + index + "] and shard [" + shard + "]'s routing", indexMetaData.primaryTerm(shard), equalTo(terms[shard])).     } }
false;public;0;41;;public void testPrimaryTermMetaDataSync() {     assertAllPrimaryTerm().     initPrimaries().     assertAllPrimaryTerm().     startInitializingShards(TEST_INDEX_1).     assertAllPrimaryTerm().     startInitializingShards(TEST_INDEX_2).     assertAllPrimaryTerm().     // now start all replicas too     startInitializingShards(TEST_INDEX_1).     startInitializingShards(TEST_INDEX_2).     assertAllPrimaryTerm().     // relocations shouldn't change much     addNodes().     assertAllPrimaryTerm().     boolean changed = true.     while (changed) {         changed = startInitializingShards(TEST_INDEX_1).         assertAllPrimaryTerm().         changed |= startInitializingShards(TEST_INDEX_2).         assertAllPrimaryTerm().     }     // primary promotion     failSomePrimaries(TEST_INDEX_1).     assertAllPrimaryTerm().     // stablize cluster     changed = true.     while (changed) {         changed = startInitializingShards(TEST_INDEX_1).         assertAllPrimaryTerm().         changed |= startInitializingShards(TEST_INDEX_2).         assertAllPrimaryTerm().     } }
