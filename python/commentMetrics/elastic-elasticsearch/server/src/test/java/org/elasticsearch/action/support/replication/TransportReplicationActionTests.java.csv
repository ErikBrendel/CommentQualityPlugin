# id;timestamp;commentText;codeText;commentWords;codeWords
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1524684173;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1528762805;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1531179852;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1533295538;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1534203100;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1538067637;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1539615817;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1541092382;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1541552300;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1541698679;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1542185035;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1542379131;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1542885199;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected aID [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected aID [" + primary.allocationId().getId() + "] with term [" +_                    requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,a,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,a,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1542961598;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected allocation id [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected allocation id [" + primary.allocationId().getId()_                    + "] with term [" + requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,allocation,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,allocation,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1544081506;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected allocation id [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected allocation id [" + primary.allocationId().getId()_                    + "] with term [" + requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,allocation,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,allocation,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1544810347;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected allocation id [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected allocation id [" + primary.allocationId().getId()_                    + "] with term [" + requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,allocation,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,allocation,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception;1550588016;test that a primary request is rejected if it arrives at a shard with a wrong allocation id or term;public void testPrimaryActionRejectsWrongAidOrWrongTerm() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        setState(clusterService, state(index, true, ShardRoutingState.STARTED))__        final ShardRouting primary = clusterService.state().routingTable().shardRoutingTable(shardId).primaryShard()__        final long primaryTerm = clusterService.state().metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final boolean wrongAllocationId = randomBoolean()__        final long requestTerm = wrongAllocationId && randomBoolean() ? primaryTerm : primaryTerm + randomIntBetween(1, 10)__        Request request = new Request(shardId).timeout("1ms")__            action.new PrimaryOperationTransportHandler().messageReceived(_                new TransportReplicationAction.ConcreteShardRequest<>(request,_                    wrongAllocationId ? "_not_a_valid_aid_" : primary.allocationId().getId(),_                    requestTerm),_                createTransportChannel(listener), maybeTask()_            )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            logger.debug("got exception:" , throwable)__            assertTrue(throwable.getClass() + " is not a retry exception", action.retryPrimaryException(throwable))__            if (wrongAllocationId) {_                assertThat(throwable.getMessage(), containsString("expected allocation id [_not_a_valid_aid_] but found [" +_                    primary.allocationId().getId() + "]"))__            } else {_                assertThat(throwable.getMessage(), containsString("expected allocation id [" + primary.allocationId().getId()_                    + "] with term [" + requestTerm + "] but found [" + primaryTerm + "]"))__            }_        }_    };test,that,a,primary,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id,or,term;public,void,test,primary,action,rejects,wrong,aid,or,wrong,term,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,set,state,cluster,service,state,index,true,shard,routing,state,started,final,shard,routing,primary,cluster,service,state,routing,table,shard,routing,table,shard,id,primary,shard,final,long,primary,term,cluster,service,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,plain,action,future,test,response,listener,new,plain,action,future,final,boolean,wrong,allocation,id,random,boolean,final,long,request,term,wrong,allocation,id,random,boolean,primary,term,primary,term,random,int,between,1,10,request,request,new,request,shard,id,timeout,1ms,action,new,primary,operation,transport,handler,message,received,new,transport,replication,action,concrete,shard,request,request,wrong,allocation,id,primary,allocation,id,get,id,request,term,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,logger,debug,got,exception,throwable,assert,true,throwable,get,class,is,not,a,retry,exception,action,retry,primary,exception,throwable,if,wrong,allocation,id,assert,that,throwable,get,message,contains,string,expected,allocation,id,but,found,primary,allocation,id,get,id,else,assert,that,throwable,get,message,contains,string,expected,allocation,id,primary,allocation,id,get,id,with,term,request,term,but,found,primary,term
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1524684173;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1528762805;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1531179852;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1533295538;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1534203100;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1538067637;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1539615817;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1541092382;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1541552300;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1541698679;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1542185035;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1542379131;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1542885199;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1542961598;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1544081506;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1544810347;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception;1550588016;This test ensures that replication operations adhere to the {@link IndexMetaData#SETTING_WAIT_FOR_ACTIVE_SHARDS} setting_when the request is using the default value for waitForActiveShards.;public void testDefaultWaitForActiveShardsUsesIndexSetting() throws Exception {_        final String indexName = "test"__        final ShardId shardId = new ShardId(indexName, "_na_", 0)___        _        int numReplicas = randomIntBetween(0, 5)__        int idxSettingWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        ClusterState state = stateWithActivePrimary(indexName, randomBoolean(), numReplicas)__        IndexMetaData indexMetaData = state.metaData().index(indexName)__        Settings indexSettings = Settings.builder().put(indexMetaData.getSettings())_                                     .put(SETTING_WAIT_FOR_ACTIVE_SHARDS.getKey(), Integer.toString(idxSettingWaitForActiveShards))_                                     .build()__        MetaData.Builder metaDataBuilder = MetaData.builder(state.metaData())_                                               .put(IndexMetaData.builder(indexMetaData).settings(indexSettings).build(), true)__        state = ClusterState.builder(state).metaData(metaDataBuilder).build()__        setState(clusterService, state)__        Request request = new Request(shardId).waitForActiveShards(ActiveShardCount.DEFAULT)_ _        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(idxSettingWaitForActiveShards), request.waitForActiveShards())___        _        int requestWaitForActiveShards = randomIntBetween(0, numReplicas + 1)__        request = new Request(shardId).waitForActiveShards(ActiveShardCount.from(requestWaitForActiveShards))__        action.resolveRequest(state.metaData().index(indexName), request)__        assertEquals(ActiveShardCount.from(requestWaitForActiveShards), request.waitForActiveShards())__    };this,test,ensures,that,replication,operations,adhere,to,the,link,index,meta,data,setting,when,the,request,is,using,the,default,value,for,wait,for,active,shards;public,void,test,default,wait,for,active,shards,uses,index,setting,throws,exception,final,string,index,name,test,final,shard,id,shard,id,new,shard,id,index,name,0,int,num,replicas,random,int,between,0,5,int,idx,setting,wait,for,active,shards,random,int,between,0,num,replicas,1,cluster,state,state,state,with,active,primary,index,name,random,boolean,num,replicas,index,meta,data,index,meta,data,state,meta,data,index,index,name,settings,index,settings,settings,builder,put,index,meta,data,get,settings,put,get,key,integer,to,string,idx,setting,wait,for,active,shards,build,meta,data,builder,meta,data,builder,meta,data,builder,state,meta,data,put,index,meta,data,builder,index,meta,data,settings,index,settings,build,true,state,cluster,state,builder,state,meta,data,meta,data,builder,build,set,state,cluster,service,state,request,request,new,request,shard,id,wait,for,active,shards,active,shard,count,default,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,idx,setting,wait,for,active,shards,request,wait,for,active,shards,int,request,wait,for,active,shards,random,int,between,0,num,replicas,1,request,new,request,shard,id,wait,for,active,shards,active,shard,count,from,request,wait,for,active,shards,action,resolve,request,state,meta,data,index,index,name,request,assert,equals,active,shard,count,from,request,wait,for,active,shards,request,wait,for,active,shards
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1524684173;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1528762805;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1531179852;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1533295538;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1534203100;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1538067637;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1539615817;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1541092382;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1541552300;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1541698679;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1542185035;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1542379131;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1542885199;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1542961598;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1544081506;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1544810347;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testReplicaActionRejectsWrongAid() throws Exception;1550588016;test that a replica request is rejected if it arrives at a shard with a wrong allocation id;public void testReplicaActionRejectsWrongAid() throws Exception {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, false, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.routingTable().shardRoutingTable(shardId).replicaShards().get(0)__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)___        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        Request request = new Request(shardId).timeout("1ms")__        action.new ReplicaOperationTransportHandler().messageReceived(_            new TransportReplicationAction.ConcreteReplicaRequest<>(request, "_not_a_valid_aid_", randomNonNegativeLong(),_                randomNonNegativeLong(), randomNonNegativeLong()),_            createTransportChannel(listener), maybeTask()_        )__        try {_            listener.get()__            fail("using a wrong aid didn't fail the operation")__        } catch (ExecutionException execException) {_            Throwable throwable = execException.getCause()__            if (action.retryPrimaryException(throwable) == false) {_                throw new AssertionError("thrown exception is not retriable", throwable)__            }_            assertThat(throwable.getMessage(), containsString("_not_a_valid_aid_"))__        }_    };test,that,a,replica,request,is,rejected,if,it,arrives,at,a,shard,with,a,wrong,allocation,id;public,void,test,replica,action,rejects,wrong,aid,throws,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,false,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,routing,table,shard,routing,table,shard,id,replica,shards,get,0,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,plain,action,future,test,response,listener,new,plain,action,future,request,request,new,request,shard,id,timeout,1ms,action,new,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,random,non,negative,long,random,non,negative,long,random,non,negative,long,create,transport,channel,listener,maybe,task,try,listener,get,fail,using,a,wrong,aid,didn,t,fail,the,operation,catch,execution,exception,exec,exception,throwable,throwable,exec,exception,get,cause,if,action,retry,primary,exception,throwable,false,throw,new,assertion,error,thrown,exception,is,not,retriable,throwable,assert,that,throwable,get,message,contains,string
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1524684173;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "testActionWithExceptions", transportService, clusterService, shardStateAction,_            threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(), primaryTerm, checkpoint),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1528762805;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "testActionWithExceptions", transportService, clusterService, shardStateAction,_            threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(), primaryTerm, checkpoint),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1531179852;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(), primaryTerm, checkpoint),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1533295538;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(), primaryTerm, checkpoint),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1534203100;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(), primaryTerm, checkpoint),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1538067637;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1539615817;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1541092382;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1541552300;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1541698679;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1542185035;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1542379131;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1542885199;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1542961598;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1544081506;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1544810347;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public void testRetryOnReplica() throws Exception;1550588016;test throwing a {@link org.elasticsearch.action.support.replication.TransportReplicationAction.RetryOnReplicaException}_causes a retry;public void testRetryOnReplica() throws Exception {_        final ShardId shardId = new ShardId("test", "_na_", 0)__        ClusterState state = state(shardId.getIndexName(), true, ShardRoutingState.STARTED, ShardRoutingState.STARTED)__        final ShardRouting replica = state.getRoutingTable().shardRoutingTable(shardId).replicaShards().get(0)__        final long primaryTerm = state.metaData().index(shardId.getIndexName()).primaryTerm(shardId.id())__        _        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(replica.currentNodeId())).build()__        setState(clusterService, state)__        AtomicBoolean throwException = new AtomicBoolean(true)__        final ReplicationTask task = maybeTask()__        TestAction action = new TestAction(Settings.EMPTY, "internal:testActionWithExceptions", transportService, clusterService,_            shardStateAction, threadPool) {_            @Override_            protected ReplicaResult shardOperationOnReplica(Request request, IndexShard replica) {_                assertPhase(task, "replica")__                if (throwException.get()) {_                    throw new RetryOnReplicaException(shardId, "simulation")__                }_                return new ReplicaResult()__            }_        }__        final TestAction.ReplicaOperationTransportHandler replicaOperationTransportHandler = action.new ReplicaOperationTransportHandler()__        final PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        final Request request = new Request().setShardId(shardId)__        final long checkpoint = randomNonNegativeLong()__        final long maxSeqNoOfUpdatesOrDeletes = randomNonNegativeLong()__        replicaOperationTransportHandler.messageReceived(_                new TransportReplicationAction.ConcreteReplicaRequest<>(request, replica.allocationId().getId(),_                    primaryTerm, checkpoint, maxSeqNoOfUpdatesOrDeletes),_                createTransportChannel(listener), task)__        if (listener.isDone()) {_            listener.get()_ _            fail("listener shouldn't be done")__        }__        _        List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, nullValue())___        _        throwException.set(false)__        setState(clusterService, state)___        capturedRequests = transport.getCapturedRequestsByTargetNodeAndClear().get(replica.currentNodeId())__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        final CapturingTransport.CapturedRequest capturedRequest = capturedRequests.get(0)__        assertThat(capturedRequest.action, equalTo("internal:testActionWithExceptions[r]"))__        assertThat(capturedRequest.request, instanceOf(TransportReplicationAction.ConcreteReplicaRequest.class))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getGlobalCheckpoint(),_                equalTo(checkpoint))__        assertThat(((TransportReplicationAction.ConcreteReplicaRequest) capturedRequest.request).getMaxSeqNoOfUpdatesOrDeletes(),_            equalTo(maxSeqNoOfUpdatesOrDeletes))__        assertConcreteShardRequest(capturedRequest.request, request, replica.allocationId())__    };test,throwing,a,link,org,elasticsearch,action,support,replication,transport,replication,action,retry,on,replica,exception,causes,a,retry;public,void,test,retry,on,replica,throws,exception,final,shard,id,shard,id,new,shard,id,test,0,cluster,state,state,state,shard,id,get,index,name,true,shard,routing,state,started,shard,routing,state,started,final,shard,routing,replica,state,get,routing,table,shard,routing,table,shard,id,replica,shards,get,0,final,long,primary,term,state,meta,data,index,shard,id,get,index,name,primary,term,shard,id,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,replica,current,node,id,build,set,state,cluster,service,state,atomic,boolean,throw,exception,new,atomic,boolean,true,final,replication,task,task,maybe,task,test,action,action,new,test,action,settings,empty,internal,test,action,with,exceptions,transport,service,cluster,service,shard,state,action,thread,pool,override,protected,replica,result,shard,operation,on,replica,request,request,index,shard,replica,assert,phase,task,replica,if,throw,exception,get,throw,new,retry,on,replica,exception,shard,id,simulation,return,new,replica,result,final,test,action,replica,operation,transport,handler,replica,operation,transport,handler,action,new,replica,operation,transport,handler,final,plain,action,future,test,response,listener,new,plain,action,future,final,request,request,new,request,set,shard,id,shard,id,final,long,checkpoint,random,non,negative,long,final,long,max,seq,no,of,updates,or,deletes,random,non,negative,long,replica,operation,transport,handler,message,received,new,transport,replication,action,concrete,replica,request,request,replica,allocation,id,get,id,primary,term,checkpoint,max,seq,no,of,updates,or,deletes,create,transport,channel,listener,task,if,listener,is,done,listener,get,fail,listener,shouldn,t,be,done,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,null,value,throw,exception,set,false,set,state,cluster,service,state,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,replica,current,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,final,capturing,transport,captured,request,captured,request,captured,requests,get,0,assert,that,captured,request,action,equal,to,internal,test,action,with,exceptions,r,assert,that,captured,request,request,instance,of,transport,replication,action,concrete,replica,request,class,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,global,checkpoint,equal,to,checkpoint,assert,that,transport,replication,action,concrete,replica,request,captured,request,request,get,max,seq,no,of,updates,or,deletes,equal,to,max,seq,no,of,updates,or,deletes,assert,concrete,shard,request,captured,request,request,request,replica,allocation,id
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1524684173;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1528762805;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1531179852;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1533295538;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1534203100;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1538067637;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1539615817;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1541092382;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1541552300;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1541698679;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1542185035;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1542379131;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1542885199;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1542961598;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1544081506;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1544810347;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest);1550588016;takes a request that was sent by a {@link TransportReplicationAction} and captured_and returns the underlying request if it's wrapped or the original (cast to the expected type).__This will throw a {@link ClassCastException} if the request is of the wrong type.;public static <R extends ReplicationRequest> R resolveRequest(TransportRequest requestOrWrappedRequest) {_        if (requestOrWrappedRequest instanceof TransportReplicationAction.ConcreteShardRequest) {_            requestOrWrappedRequest = ((TransportReplicationAction.ConcreteShardRequest<?>)requestOrWrappedRequest).getRequest()__        }_        return (R) requestOrWrappedRequest__    };takes,a,request,that,was,sent,by,a,link,transport,replication,action,and,captured,and,returns,the,underlying,request,if,it,s,wrapped,or,the,original,cast,to,the,expected,type,this,will,throw,a,link,class,cast,exception,if,the,request,is,of,the,wrong,type;public,static,r,extends,replication,request,r,resolve,request,transport,request,request,or,wrapped,request,if,request,or,wrapped,request,instanceof,transport,replication,action,concrete,shard,request,request,or,wrapped,request,transport,replication,action,concrete,shard,request,request,or,wrapped,request,get,request,return,r,request,or,wrapped,request
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1524684173;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1528762805;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1531179852;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1533295538;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1534203100;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1538067637;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1539615817;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1541092382;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1541552300;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1541698679;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1542185035;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1542379131;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1542885199;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1542961598;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1544081506;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1544810347;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException;1550588016;When relocating a primary shard, there is a cluster state update at the end of relocation where the active primary is switched from_the relocation source to the relocation target. If relocation source receives and processes this cluster state_before the relocation target, there is a time span where relocation source believes active primary to be on_relocation target and relocation target believes active primary to be on relocation source. This results in replication_requests being sent back and forth._<p>_This test checks that replication request is not routed back from relocation target to relocation source in case of_stale index routing table on relocation target.;public void testNoRerouteOnStaleClusterState() throws InterruptedException, ExecutionException {_        final String index = "test"__        final ShardId shardId = new ShardId(index, "_na_", 0)__        ClusterState state = state(index, true, ShardRoutingState.RELOCATING)__        String relocationTargetNode = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().relocatingNodeId()__        state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).localNodeId(relocationTargetNode)).build()__        setState(clusterService, state)__        logger.debug("--> relocation ongoing state:\n{}", clusterService.state())___        Request request = new Request(shardId).timeout("1ms").routedBasedOnClusterVersion(clusterService.state().version() + 1)__        PlainActionFuture<TestResponse> listener = new PlainActionFuture<>()__        TestAction.ReroutePhase reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertListenerThrows("cluster state too old didn't cause a timeout", listener, UnavailableShardsException.class)__        assertTrue(request.isRetrySet.compareAndSet(true, false))___        request = new Request(shardId).routedBasedOnClusterVersion(clusterService.state().version() + 1)__        listener = new PlainActionFuture<>()__        reroutePhase = action.new ReroutePhase(null, request, listener)__        reroutePhase.run()__        assertFalse("cluster state too old didn't cause a retry", listener.isDone())__        assertTrue(request.isRetrySet.get())___        _        ShardRouting relocationTarget = clusterService.state().getRoutingTable().shardRoutingTable(shardId)_            .shardsWithState(ShardRoutingState.INITIALIZING).get(0)__        AllocationService allocationService = ESAllocationTestCase.createAllocationService()__        ClusterState updatedState = allocationService.applyStartedShards(state, Collections.singletonList(relocationTarget))___        setState(clusterService, updatedState)__        logger.debug("--> relocation complete state:\n{}", clusterService.state())___        IndexShardRoutingTable shardRoutingTable = clusterService.state().routingTable().index(index).shard(shardId.id())__        final String primaryNodeId = shardRoutingTable.primaryShard().currentNodeId()__        final List<CapturingTransport.CapturedRequest> capturedRequests =_            transport.getCapturedRequestsByTargetNodeAndClear().get(primaryNodeId)__        assertThat(capturedRequests, notNullValue())__        assertThat(capturedRequests.size(), equalTo(1))__        assertThat(capturedRequests.get(0).action, equalTo("internal:testAction[p]"))__        assertIndexShardCounter(0)__    };when,relocating,a,primary,shard,there,is,a,cluster,state,update,at,the,end,of,relocation,where,the,active,primary,is,switched,from,the,relocation,source,to,the,relocation,target,if,relocation,source,receives,and,processes,this,cluster,state,before,the,relocation,target,there,is,a,time,span,where,relocation,source,believes,active,primary,to,be,on,relocation,target,and,relocation,target,believes,active,primary,to,be,on,relocation,source,this,results,in,replication,requests,being,sent,back,and,forth,p,this,test,checks,that,replication,request,is,not,routed,back,from,relocation,target,to,relocation,source,in,case,of,stale,index,routing,table,on,relocation,target;public,void,test,no,reroute,on,stale,cluster,state,throws,interrupted,exception,execution,exception,final,string,index,test,final,shard,id,shard,id,new,shard,id,index,0,cluster,state,state,state,index,true,shard,routing,state,relocating,string,relocation,target,node,state,get,routing,table,shard,routing,table,shard,id,primary,shard,relocating,node,id,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,local,node,id,relocation,target,node,build,set,state,cluster,service,state,logger,debug,relocation,ongoing,state,n,cluster,service,state,request,request,new,request,shard,id,timeout,1ms,routed,based,on,cluster,version,cluster,service,state,version,1,plain,action,future,test,response,listener,new,plain,action,future,test,action,reroute,phase,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,listener,throws,cluster,state,too,old,didn,t,cause,a,timeout,listener,unavailable,shards,exception,class,assert,true,request,is,retry,set,compare,and,set,true,false,request,new,request,shard,id,routed,based,on,cluster,version,cluster,service,state,version,1,listener,new,plain,action,future,reroute,phase,action,new,reroute,phase,null,request,listener,reroute,phase,run,assert,false,cluster,state,too,old,didn,t,cause,a,retry,listener,is,done,assert,true,request,is,retry,set,get,shard,routing,relocation,target,cluster,service,state,get,routing,table,shard,routing,table,shard,id,shards,with,state,shard,routing,state,initializing,get,0,allocation,service,allocation,service,esallocation,test,case,create,allocation,service,cluster,state,updated,state,allocation,service,apply,started,shards,state,collections,singleton,list,relocation,target,set,state,cluster,service,updated,state,logger,debug,relocation,complete,state,n,cluster,service,state,index,shard,routing,table,shard,routing,table,cluster,service,state,routing,table,index,index,shard,shard,id,id,final,string,primary,node,id,shard,routing,table,primary,shard,current,node,id,final,list,capturing,transport,captured,request,captured,requests,transport,get,captured,requests,by,target,node,and,clear,get,primary,node,id,assert,that,captured,requests,not,null,value,assert,that,captured,requests,size,equal,to,1,assert,that,captured,requests,get,0,action,equal,to,internal,test,action,p,assert,index,shard,counter,0
TransportReplicationActionTests -> private ReplicationTask maybeTask();1524684173;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1528762805;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1531179852;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1533295538;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1534203100;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1538067637;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1539615817;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1541092382;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1541552300;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1541698679;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1542185035;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1542379131;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1542885199;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1542961598;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1544081506;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1544810347;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private ReplicationTask maybeTask();1550588016;Sometimes build a ReplicationTask for tracking the phase of the_TransportReplicationAction. Since TransportReplicationAction has to work_if the task as null just as well as if it is supplied this returns null_half the time.;private ReplicationTask maybeTask() {_        return random().nextBoolean() ? new ReplicationTask(0, null, null, null, null, null) : null__    };sometimes,build,a,replication,task,for,tracking,the,phase,of,the,transport,replication,action,since,transport,replication,action,has,to,work,if,the,task,as,null,just,as,well,as,if,it,is,supplied,this,returns,null,half,the,time;private,replication,task,maybe,task,return,random,next,boolean,new,replication,task,0,null,null,null,null,null,null
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1524684173;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1528762805;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1531179852;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1533295538;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1534203100;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1538067637;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1539615817;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1541092382;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1541552300;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1541698679;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1542185035;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1542379131;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1542885199;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1542961598;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1544081506;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1544810347;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> private void assertPhase(@Nullable ReplicationTask task, String phase);1550588016;If the task is non-null this asserts that the phrase matches.;private void assertPhase(@Nullable ReplicationTask task, String phase) {_        assertPhase(task, equalTo(phase))__    };if,the,task,is,non,null,this,asserts,that,the,phrase,matches;private,void,assert,phase,nullable,replication,task,task,string,phase,assert,phase,task,equal,to,phase
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1524684173;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(TransportResponse response, TransportResponseOptions options) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,transport,response,response,transport,response,options,options,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1528762805;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(TransportResponse response, TransportResponseOptions options) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,transport,response,response,transport,response,options,options,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1531179852;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(TransportResponse response, TransportResponseOptions options) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,transport,response,response,transport,response,options,options,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1533295538;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(TransportResponse response, TransportResponseOptions options) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,transport,response,response,transport,response,options,options,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1534203100;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(TransportResponse response, TransportResponseOptions options) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,transport,response,response,transport,response,options,options,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1538067637;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(TransportResponse response, TransportResponseOptions options) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,transport,response,response,transport,response,options,options,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1539615817;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(TransportResponse response, TransportResponseOptions options) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,transport,response,response,transport,response,options,options,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1541092382;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(TransportResponse response, TransportResponseOptions options) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,transport,response,response,transport,response,options,options,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1541552300;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(TransportResponse response, TransportResponseOptions options) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,transport,response,response,transport,response,options,options,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1541698679;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1542185035;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1542379131;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1542885199;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1542961598;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1544081506;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1544810347;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
TransportReplicationActionTests -> public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener);1550588016;Transport channel that is needed for replica operation testing.;public TransportChannel createTransportChannel(final PlainActionFuture<TestResponse> listener) {_        return new TransportChannel() {__            @Override_            public String getProfileName() {_                return ""__            }__            @Override_            public void sendResponse(TransportResponse response) throws IOException {_                listener.onResponse(((TestResponse) response))__            }__            @Override_            public void sendResponse(Exception exception) throws IOException {_                listener.onFailure(exception)__            }__            @Override_            public String getChannelType() {_                return "replica_test"__            }_        }__    };transport,channel,that,is,needed,for,replica,operation,testing;public,transport,channel,create,transport,channel,final,plain,action,future,test,response,listener,return,new,transport,channel,override,public,string,get,profile,name,return,override,public,void,send,response,transport,response,response,throws,ioexception,listener,on,response,test,response,response,override,public,void,send,response,exception,exception,throws,ioexception,listener,on,failure,exception,override,public,string,get,channel,type,return
