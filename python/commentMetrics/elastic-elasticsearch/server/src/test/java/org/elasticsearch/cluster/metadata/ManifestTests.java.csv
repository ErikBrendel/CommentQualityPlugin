commented;modifiers;parameterAmount;loc;comment;code
false;private;2;42;;private Manifest copyState(Manifest state, boolean introduceErrors) {     long currentTerm = state.getCurrentTerm().     long clusterStateVersion = state.getClusterStateVersion().     long generation = state.getGlobalGeneration().     Map<Index, Long> indices = new HashMap<>(state.getIndexGenerations()).     if (introduceErrors) {         switch(randomInt(3)) {             case 0:                 {                     currentTerm = randomValueOtherThan(currentTerm, () -> randomNonNegativeLong()).                     break.                 }             case 1:                 {                     clusterStateVersion = randomValueOtherThan(clusterStateVersion, () -> randomNonNegativeLong()).                     break.                 }             case 2:                 {                     generation = randomValueOtherThan(generation, () -> randomNonNegativeLong()).                     break.                 }             case 3:                 {                     switch(randomInt(2)) {                         case 0:                             {                                 indices.remove(randomFrom(indices.keySet())).                                 break.                             }                         case 1:                             {                                 Tuple<Index, Long> indexEntry = randomIndexEntry().                                 indices.put(indexEntry.v1(), indexEntry.v2()).                                 break.                             }                         case 2:                             {                                 Index index = randomFrom(indices.keySet()).                                 indices.compute(index, (i, g) -> randomValueOtherThan(g, () -> randomNonNegativeLong())).                                 break.                             }                     }                     break.                 }         }     }     return new Manifest(currentTerm, clusterStateVersion, generation, indices). }
false;private;0;7;;private Tuple<Index, Long> randomIndexEntry() {     final String name = randomAlphaOfLengthBetween(4, 15).     final String uuid = UUIDs.randomBase64UUID().     final Index index = new Index(name, uuid).     final long indexGeneration = randomNonNegativeLong().     return Tuple.tuple(index, indexGeneration). }
false;private;0;11;;private Manifest randomManifest() {     long currentTerm = randomNonNegativeLong().     long clusterStateVersion = randomNonNegativeLong().     long generation = randomNonNegativeLong().     Map<Index, Long> indices = new HashMap<>().     for (int i = 0. i < randomIntBetween(1, 5). i++) {         Tuple<Index, Long> indexEntry = randomIndexEntry().         indices.put(indexEntry.v1(), indexEntry.v2()).     }     return new Manifest(currentTerm, clusterStateVersion, generation, indices). }
false;public;0;3;;public void testEqualsAndHashCode() {     checkEqualsAndHashCode(randomManifest(), org -> copyState(org, false), org -> copyState(org, true)). }
false;public;0;12;;public void testXContent() throws IOException {     Manifest state = randomManifest().     final XContentBuilder builder = JsonXContent.contentBuilder().     builder.startObject().     Manifest.FORMAT.toXContent(builder, state).     builder.endObject().     BytesReference bytes = BytesReference.bytes(builder).     try (XContentParser parser = createParser(JsonXContent.jsonXContent, bytes)) {         assertThat(Manifest.fromXContent(parser), equalTo(state)).     } }
false;public;0;4;;public void testEmptyManifest() {     assertTrue(Manifest.empty().isEmpty()).     assertFalse(randomManifest().isEmpty()). }
