commented;modifiers;parameterAmount;loc;comment;code
true;public;2;4;// metaData upgrader should do nothing ;// metaData upgrader should do nothing @Override public IndexMetaData upgradeIndexMetaData(IndexMetaData indexMetaData, Version minimumIndexCompatibilityVersion) {     return indexMetaData. }
false;public;2;3;;public ClusterState createIndex(ClusterState state, CreateIndexRequest request) {     return execute(transportCreateIndexAction, request, state). }
false;public;2;11;;public ClusterState closeIndices(ClusterState state, CloseIndexRequest request) {     final Index[] concreteIndices = Arrays.stream(request.indices()).map(index -> state.metaData().index(index).getIndex()).toArray(Index[]::new).     final Map<Index, ClusterBlock> blockedIndices = new HashMap<>().     ClusterState newState = MetaDataIndexStateServiceUtils.addIndexClosedBlocks(concreteIndices, blockedIndices, state).     newState = MetaDataIndexStateServiceUtils.closeRoutingTable(newState, blockedIndices, blockedIndices.keySet().stream().collect(Collectors.toMap(Function.identity(), index -> new AcknowledgedResponse(true)))).     return allocationService.reroute(newState, "indices closed"). }
false;public;2;3;;public ClusterState openIndices(ClusterState state, OpenIndexRequest request) {     return execute(transportOpenIndexAction, request, state). }
false;public;2;3;;public ClusterState deleteIndices(ClusterState state, DeleteIndexRequest request) {     return execute(transportDeleteIndexAction, request, state). }
false;public;2;3;;public ClusterState updateSettings(ClusterState state, UpdateSettingsRequest request) {     return execute(transportUpdateSettingsAction, request, state). }
false;public;2;3;;public ClusterState reroute(ClusterState state, ClusterRerouteRequest request) {     return execute(transportClusterRerouteAction, request, state). }
false;public;2;4;;public ClusterState addNodes(ClusterState clusterState, List<DiscoveryNode> nodes) {     return runTasks(joinTaskExecutor, clusterState, nodes.stream().map(node -> new JoinTaskExecutor.Task(node, "dummy reason")).collect(Collectors.toList())). }
false;public;2;9;;public ClusterState joinNodesAndBecomeMaster(ClusterState clusterState, List<DiscoveryNode> nodes) {     List<JoinTaskExecutor.Task> joinNodes = new ArrayList<>().     joinNodes.add(JoinTaskExecutor.newBecomeMasterTask()).     joinNodes.add(JoinTaskExecutor.newFinishElectionTask()).     joinNodes.addAll(nodes.stream().map(node -> new JoinTaskExecutor.Task(node, "dummy reason")).collect(Collectors.toList())).     return runTasks(joinTaskExecutor, clusterState, joinNodes). }
false;public;2;4;;public ClusterState removeNodes(ClusterState clusterState, List<DiscoveryNode> nodes) {     return runTasks(nodeRemovalExecutor, clusterState, nodes.stream().map(n -> new NodeRemovalClusterStateTaskExecutor.Task(n, "dummy reason")).collect(Collectors.toList())). }
false;public;2;7;;public ClusterState applyFailedShards(ClusterState clusterState, List<FailedShard> failedShards) {     List<FailedShardEntry> entries = failedShards.stream().map(failedShard -> new FailedShardEntry(failedShard.getRoutingEntry().shardId(), failedShard.getRoutingEntry().allocationId().getId(), 0L, failedShard.getMessage(), failedShard.getFailure(), failedShard.markAsStale())).collect(Collectors.toList()).     return runTasks(shardFailedClusterStateTaskExecutor, clusterState, entries). }
false;public;2;8;;public ClusterState applyStartedShards(ClusterState clusterState, List<ShardRouting> startedShards) {     final Map<ShardRouting, Long> entries = startedShards.stream().collect(Collectors.toMap(Function.identity(), startedShard -> {         final IndexMetaData indexMetaData = clusterState.metaData().index(startedShard.shardId().getIndex()).         return indexMetaData != null ? indexMetaData.primaryTerm(startedShard.shardId().id()) : 0L.     })).     return applyStartedShards(clusterState, entries). }
false;public;2;5;;public ClusterState applyStartedShards(ClusterState clusterState, Map<ShardRouting, Long> startedShards) {     return runTasks(shardStartedClusterStateTaskExecutor, clusterState, startedShards.entrySet().stream().map(e -> new StartedShardEntry(e.getKey().shardId(), e.getKey().allocationId().getId(), e.getValue(), "shard started")).collect(Collectors.toList())). }
false;private;3;13;;private <T> ClusterState runTasks(ClusterStateTaskExecutor<T> executor, ClusterState clusterState, List<T> entries) {     try {         ClusterTasksResult<T> result = executor.execute(clusterState, entries).         for (ClusterStateTaskExecutor.TaskResult taskResult : result.executionResults.values()) {             if (taskResult.isSuccess() == false) {                 throw taskResult.getFailure().             }         }         return result.resultingState.     } catch (Exception e) {         throw ExceptionsHelper.convertToRuntime(e).     } }
false;private;3;10;;private <Request extends MasterNodeRequest<Request>, Response extends ActionResponse> ClusterState execute(TransportMasterNodeAction<Request, Response> masterNodeAction, Request request, ClusterState clusterState) {     return executeClusterStateUpdateTask(clusterState, () -> {         try {             TransportMasterNodeActionUtils.runMasterOperation(masterNodeAction, request, clusterState, new PlainActionFuture<>()).         } catch (Exception e) {             throw new RuntimeException(e).         }     }). }
false;private;2;11;;private ClusterState executeClusterStateUpdateTask(ClusterState state, Runnable runnable) {     ClusterState[] result = new ClusterState[1].     doAnswer(invocationOnMock -> {         ClusterStateUpdateTask task = (ClusterStateUpdateTask) invocationOnMock.getArguments()[1].         result[0] = task.execute(state).         return null.     }).when(clusterService).submitStateUpdateTask(anyString(), any(ClusterStateUpdateTask.class)).     runnable.run().     assertThat(result[0], notNullValue()).     return result[0]. }
