commented;modifiers;parameterAmount;loc;comment;code
false;public;0;19;;public void testGeoPointReset() throws IOException {     double lat = 1 + randomDouble() * 89.     double lon = 1 + randomDouble() * 179.     GeoPoint point = new GeoPoint(0, 0).     GeoPoint point2 = new GeoPoint(0, 0).     assertPointsEqual(point, point2).     assertPointsEqual(point.reset(lat, lon), point2.reset(lat, lon)).     assertPointsEqual(point.reset(0, 0), point2.reset(0, 0)).     assertPointsEqual(point.resetLat(lat), point2.reset(lat, 0)).     assertPointsEqual(point.resetLat(0), point2.reset(0, 0)).     assertPointsEqual(point.resetLon(lon), point2.reset(0, lon)).     assertPointsEqual(point.resetLon(0), point2.reset(0, 0)).     assertCloseTo(point.resetFromGeoHash(stringEncode(lon, lat)), lat, lon).     assertPointsEqual(point.reset(0, 0), point2.reset(0, 0)).     assertPointsEqual(point.resetFromString(Double.toString(lat) + ", " + Double.toHexString(lon)), point2.reset(lat, lon)).     assertPointsEqual(point.reset(0, 0), point2.reset(0, 0)). }
false;public;0;10;;public void testEqualsHashCodeContract() {     // GeoPoint doesn't care about coordinate system bounds, this simply validates equality and hashCode.     final DoubleSupplier randomDelta = () -> randomValueOtherThan(0.0, () -> randomDoubleBetween(-1000000, 1000000, true)).     checkEqualsAndHashCode(RandomGeoGenerator.randomPoint(random()), GeoPoint::new, pt -> new GeoPoint(pt.lat() + randomDelta.getAsDouble(), pt.lon())).     checkEqualsAndHashCode(RandomGeoGenerator.randomPoint(random()), GeoPoint::new, pt -> new GeoPoint(pt.lat(), pt.lon() + randomDelta.getAsDouble())).     checkEqualsAndHashCode(RandomGeoGenerator.randomPoint(random()), GeoPoint::new, pt -> new GeoPoint(pt.lat() + randomDelta.getAsDouble(), pt.lon() + randomDelta.getAsDouble())). }
false;public;0;27;;public void testGeoPointParsing() throws IOException {     GeoPoint randomPt = RandomGeoGenerator.randomPoint(random()).     GeoPoint point = GeoUtils.parseGeoPoint(objectLatLon(randomPt.lat(), randomPt.lon())).     assertPointsEqual(point, randomPt).     GeoUtils.parseGeoPoint(toObject(objectLatLon(randomPt.lat(), randomPt.lon())), randomBoolean()).     assertPointsEqual(point, randomPt).     GeoUtils.parseGeoPoint(arrayLatLon(randomPt.lat(), randomPt.lon()), point).     assertPointsEqual(point, randomPt).     GeoUtils.parseGeoPoint(toObject(arrayLatLon(randomPt.lat(), randomPt.lon())), randomBoolean()).     assertPointsEqual(point, randomPt).     GeoUtils.parseGeoPoint(geohash(randomPt.lat(), randomPt.lon()), point).     assertCloseTo(point, randomPt.lat(), randomPt.lon()).     GeoUtils.parseGeoPoint(toObject(geohash(randomPt.lat(), randomPt.lon())), randomBoolean()).     assertCloseTo(point, randomPt.lat(), randomPt.lon()).     GeoUtils.parseGeoPoint(stringLatLon(randomPt.lat(), randomPt.lon()), point).     assertCloseTo(point, randomPt.lat(), randomPt.lon()).     GeoUtils.parseGeoPoint(toObject(stringLatLon(randomPt.lat(), randomPt.lon())), randomBoolean()).     assertCloseTo(point, randomPt.lat(), randomPt.lon()). }
true;public;0;20;// Based on #5390 ;// Based on #5390 public void testInvalidPointEmbeddedObject() throws IOException {     XContentBuilder content = JsonXContent.contentBuilder().     content.startObject().     content.startObject("location").     content.field("lat", 0).field("lon", 0).     content.endObject().     content.endObject().     try (XContentParser parser = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content))) {         parser.nextToken().         Exception e = expectThrows(ElasticsearchParseException.class, () -> GeoUtils.parseGeoPoint(parser)).         assertThat(e.getMessage(), is("field must be either [lat], [lon] or [geohash]")).     }     try (XContentParser parser2 = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content))) {         parser2.nextToken().         Exception e = expectThrows(ElasticsearchParseException.class, () -> GeoUtils.parseGeoPoint(toObject(parser2), randomBoolean())).         assertThat(e.getMessage(), is("field must be either [lat], [lon] or [geohash]")).     } }
false;public;0;18;;public void testInvalidPointLatHashMix() throws IOException {     XContentBuilder content = JsonXContent.contentBuilder().     content.startObject().     content.field("lat", 0).field("geohash", stringEncode(0d, 0d)).     content.endObject().     try (XContentParser parser = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content))) {         parser.nextToken().         Exception e = expectThrows(ElasticsearchParseException.class, () -> GeoUtils.parseGeoPoint(parser)).         assertThat(e.getMessage(), is("field must be either lat/lon or geohash")).     }     try (XContentParser parser2 = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content))) {         parser2.nextToken().         Exception e = expectThrows(ElasticsearchParseException.class, () -> GeoUtils.parseGeoPoint(toObject(parser2), randomBoolean())).         assertThat(e.getMessage(), is("field must be either lat/lon or geohash")).     } }
false;public;0;19;;public void testInvalidPointLonHashMix() throws IOException {     XContentBuilder content = JsonXContent.contentBuilder().     content.startObject().     content.field("lon", 0).field("geohash", stringEncode(0d, 0d)).     content.endObject().     try (XContentParser parser = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content))) {         parser.nextToken().         Exception e = expectThrows(ElasticsearchParseException.class, () -> GeoUtils.parseGeoPoint(parser)).         assertThat(e.getMessage(), is("field must be either lat/lon or geohash")).     }     try (XContentParser parser2 = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content))) {         parser2.nextToken().         Exception e = expectThrows(ElasticsearchParseException.class, () -> GeoUtils.parseGeoPoint(toObject(parser2), randomBoolean())).         assertThat(e.getMessage(), is("field must be either lat/lon or geohash")).     } }
false;public;0;19;;public void testInvalidField() throws IOException {     XContentBuilder content = JsonXContent.contentBuilder().     content.startObject().     content.field("lon", 0).field("lat", 0).field("test", 0).     content.endObject().     try (XContentParser parser = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content))) {         parser.nextToken().         Exception e = expectThrows(ElasticsearchParseException.class, () -> GeoUtils.parseGeoPoint(parser)).         assertThat(e.getMessage(), is("field must be either [lat], [lon] or [geohash]")).     }     try (XContentParser parser2 = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content))) {         parser2.nextToken().         Exception e = expectThrows(ElasticsearchParseException.class, () -> GeoUtils.parseGeoPoint(toObject(parser2), randomBoolean())).         assertThat(e.getMessage(), is("field must be either [lat], [lon] or [geohash]")).     } }
false;public;0;13;;public void testInvalidGeoHash() throws IOException {     XContentBuilder content = JsonXContent.contentBuilder().     content.startObject().     content.field("geohash", "!!!!").     content.endObject().     try (XContentParser parser = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content))) {         parser.nextToken().         Exception e = expectThrows(ElasticsearchParseException.class, () -> GeoUtils.parseGeoPoint(parser)).         assertThat(e.getMessage(), is("unsupported symbol [!] in geohash [!!!!]")).     } }
false;private;2;9;;private XContentParser objectLatLon(double lat, double lon) throws IOException {     XContentBuilder content = JsonXContent.contentBuilder().     content.startObject().     content.field("lat", lat).field("lon", lon).     content.endObject().     XContentParser parser = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content)).     parser.nextToken().     return parser. }
false;private;2;7;;private XContentParser arrayLatLon(double lat, double lon) throws IOException {     XContentBuilder content = JsonXContent.contentBuilder().     content.startArray().value(lon).value(lat).endArray().     XContentParser parser = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content)).     parser.nextToken().     return parser. }
false;private;2;7;;private XContentParser stringLatLon(double lat, double lon) throws IOException {     XContentBuilder content = JsonXContent.contentBuilder().     content.value(Double.toString(lat) + ", " + Double.toString(lon)).     XContentParser parser = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content)).     parser.nextToken().     return parser. }
false;private;2;7;;private XContentParser geohash(double lat, double lon) throws IOException {     XContentBuilder content = JsonXContent.contentBuilder().     content.value(stringEncode(lon, lat)).     XContentParser parser = createParser(JsonXContent.jsonXContent, BytesReference.bytes(content)).     parser.nextToken().     return parser. }
false;public,static;2;4;;public static void assertPointsEqual(final GeoPoint point1, final GeoPoint point2) {     assertEquals(point1, point2).     assertEquals(point1.hashCode(), point2.hashCode()). }
false;public,static;3;4;;public static void assertCloseTo(final GeoPoint point, final double lat, final double lon) {     assertEquals(point.lat(), lat, TOLERANCE).     assertEquals(point.lon(), lon, TOLERANCE). }
false;public,static;1;17;;public static Object toObject(XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     if (token == XContentParser.Token.VALUE_NULL) {         return null.     } else if (token == XContentParser.Token.VALUE_STRING) {         return parser.text().     } else if (token == XContentParser.Token.VALUE_NUMBER) {         return parser.numberValue().     } else if (token == XContentParser.Token.START_OBJECT) {         return parser.map().     } else if (token == XContentParser.Token.START_ARRAY) {         return parser.list().     } else {         fail("Unexpected token " + token).     }     return null. }
