commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;11;;@Override protected Settings getIndexSettings(Index index) {     if ("oldest".equals(index.getName())) {         return Settings.builder().put(IndexMetaData.SETTING_CREATION_DATE, 10).put(IndexMetaData.SETTING_PRIORITY, 1).build().     } else if ("newest".equals(index.getName())) {         return Settings.builder().put(IndexMetaData.SETTING_CREATION_DATE, 100).put(IndexMetaData.SETTING_PRIORITY, 1).build().     }     return Settings.EMPTY. }
false;public;0;31;;public void testPreferNewIndices() {     RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class)).     List<ShardRouting> shardRoutings = Arrays.asList(TestShardRouting.newShardRouting("oldest", 0, null, null, randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), "foobar")), TestShardRouting.newShardRouting("newest", 0, null, null, randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), "foobar"))).     Collections.shuffle(shardRoutings, random()).     for (ShardRouting routing : shardRoutings) {         shards.add(routing).     }     shards.sort(new PriorityComparator() {          @Override         protected Settings getIndexSettings(Index index) {             if ("oldest".equals(index.getName())) {                 return Settings.builder().put(IndexMetaData.SETTING_CREATION_DATE, 10).put(IndexMetaData.SETTING_PRIORITY, 1).build().             } else if ("newest".equals(index.getName())) {                 return Settings.builder().put(IndexMetaData.SETTING_CREATION_DATE, 100).put(IndexMetaData.SETTING_PRIORITY, 1).build().             }             return Settings.EMPTY.         }     }).     RoutingNodes.UnassignedShards.UnassignedIterator iterator = shards.iterator().     ShardRouting next = iterator.next().     assertEquals("newest", next.getIndexName()).     next = iterator.next().     assertEquals("oldest", next.getIndexName()).     assertFalse(iterator.hasNext()). }
false;protected;1;11;;@Override protected Settings getIndexSettings(Index index) {     if ("oldest".equals(index.getName())) {         return Settings.builder().put(IndexMetaData.SETTING_CREATION_DATE, 10).put(IndexMetaData.SETTING_PRIORITY, 100).build().     } else if ("newest".equals(index.getName())) {         return Settings.builder().put(IndexMetaData.SETTING_CREATION_DATE, 100).put(IndexMetaData.SETTING_PRIORITY, 1).build().     }     return Settings.EMPTY. }
false;public;0;31;;public void testPreferPriorityIndices() {     RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class)).     List<ShardRouting> shardRoutings = Arrays.asList(TestShardRouting.newShardRouting("oldest", 0, null, null, randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), "foobar")), TestShardRouting.newShardRouting("newest", 0, null, null, randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), "foobar"))).     Collections.shuffle(shardRoutings, random()).     for (ShardRouting routing : shardRoutings) {         shards.add(routing).     }     shards.sort(new PriorityComparator() {          @Override         protected Settings getIndexSettings(Index index) {             if ("oldest".equals(index.getName())) {                 return Settings.builder().put(IndexMetaData.SETTING_CREATION_DATE, 10).put(IndexMetaData.SETTING_PRIORITY, 100).build().             } else if ("newest".equals(index.getName())) {                 return Settings.builder().put(IndexMetaData.SETTING_CREATION_DATE, 100).put(IndexMetaData.SETTING_PRIORITY, 1).build().             }             return Settings.EMPTY.         }     }).     RoutingNodes.UnassignedShards.UnassignedIterator iterator = shards.iterator().     ShardRouting next = iterator.next().     assertEquals("oldest", next.getIndexName()).     next = iterator.next().     assertEquals("newest", next.getIndexName()).     assertFalse(iterator.hasNext()). }
false;protected;1;5;;@Override protected Settings getIndexSettings(Index index) {     IndexMeta indexMeta = map.get(index.getName()).     return indexMeta.settings. }
false;public;0;52;;public void testPriorityComparatorSort() {     RoutingNodes.UnassignedShards shards = new RoutingNodes.UnassignedShards(mock(RoutingNodes.class)).     int numIndices = randomIntBetween(3, 99).     IndexMeta[] indices = new IndexMeta[numIndices].     final Map<String, IndexMeta> map = new HashMap<>().     for (int i = 0. i < indices.length. i++) {         if (frequently()) {             indices[i] = new IndexMeta("idx_2015_04_" + String.format(Locale.ROOT, "%02d", i), randomIntBetween(1, 1000), randomIntBetween(1, 10000)).         } else {             // sometimes just use defaults             indices[i] = new IndexMeta("idx_2015_04_" + String.format(Locale.ROOT, "%02d", i)).         }         map.put(indices[i].name, indices[i]).     }     int numShards = randomIntBetween(10, 100).     for (int i = 0. i < numShards. i++) {         IndexMeta indexMeta = randomFrom(indices).         shards.add(TestShardRouting.newShardRouting(indexMeta.name, randomIntBetween(1, 5), null, null, randomBoolean(), ShardRoutingState.UNASSIGNED, new UnassignedInfo(randomFrom(UnassignedInfo.Reason.values()), "foobar"))).     }     shards.sort(new PriorityComparator() {          @Override         protected Settings getIndexSettings(Index index) {             IndexMeta indexMeta = map.get(index.getName()).             return indexMeta.settings.         }     }).     ShardRouting previous = null.     for (ShardRouting routing : shards) {         if (previous != null) {             IndexMeta prevMeta = map.get(previous.getIndexName()).             IndexMeta currentMeta = map.get(routing.getIndexName()).             if (prevMeta.priority == currentMeta.priority) {                 if (prevMeta.creationDate == currentMeta.creationDate) {                     if (prevMeta.name.equals(currentMeta.name) == false) {                         assertTrue("indexName mismatch, expected:" + currentMeta.name + " after " + prevMeta.name + " " + prevMeta.name.compareTo(currentMeta.name), prevMeta.name.compareTo(currentMeta.name) > 0).                     }                 } else {                     assertTrue("creationDate mismatch, expected:" + currentMeta.creationDate + " after " + prevMeta.creationDate, prevMeta.creationDate > currentMeta.creationDate).                 }             } else {                 assertTrue("priority mismatch, expected:" + currentMeta.priority + " after " + prevMeta.priority, prevMeta.priority > currentMeta.priority).             }         }         previous = routing.     } }
