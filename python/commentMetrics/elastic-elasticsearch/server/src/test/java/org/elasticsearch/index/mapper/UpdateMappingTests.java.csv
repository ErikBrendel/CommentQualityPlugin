commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return pluginList(InternalSettingsPlugin.class). }
false;public;1;27;;public void testConflictFieldsMapping(String fieldName) throws Exception {     // test store, ... all the parameters that are not to be changed just like in other fields     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject(fieldName).field("enabled", true).field("store", false).endObject().endObject().endObject().     XContentBuilder mappingUpdate = XContentFactory.jsonBuilder().startObject().startObject("type").startObject(fieldName).field("enabled", true).field("store", true).endObject().startObject("properties").startObject("text").field("type", "text").endObject().endObject().endObject().endObject().     testConflictWhileMergingAndMappingUnchanged(mapping, mappingUpdate). }
false;protected;2;15;;protected void testConflictWhileMergingAndMappingUnchanged(XContentBuilder mapping, XContentBuilder mappingUpdate) throws IOException {     IndexService indexService = createIndex("test", Settings.builder().build(), "type", mapping).     CompressedXContent mappingBeforeUpdate = indexService.mapperService().documentMapper("type").mappingSource().     // simulate like in MetaDataMappingService#putMapping     try {         indexService.mapperService().merge("type", new CompressedXContent(BytesReference.bytes(mappingUpdate)), MapperService.MergeReason.MAPPING_UPDATE).         fail().     } catch (IllegalArgumentException e) {     // expected     }     // make sure simulate flag actually worked - no mappings applied     CompressedXContent mappingAfterUpdate = indexService.mapperService().documentMapper("type").mappingSource().     assertThat(mappingAfterUpdate, equalTo(mappingBeforeUpdate)). }
false;public;0;27;;public void testConflictSameType() throws Exception {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("foo").field("type", "long").endObject().endObject().endObject().endObject().     MapperService mapperService = createIndex("test", Settings.builder().build(), "type", mapping).mapperService().     XContentBuilder update = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("foo").field("type", "double").endObject().endObject().endObject().endObject().     try {         mapperService.merge("type", new CompressedXContent(Strings.toString(update)), MapperService.MergeReason.MAPPING_UPDATE).         fail().     } catch (IllegalArgumentException e) {         assertThat(e.getMessage(), containsString("mapper [foo] cannot be changed from type [long] to [double]")).     }     try {         mapperService.merge("type", new CompressedXContent(Strings.toString(update)), MapperService.MergeReason.MAPPING_UPDATE).         fail().     } catch (IllegalArgumentException e) {         assertThat(e.getMessage(), containsString("mapper [foo] cannot be changed from type [long] to [double]")).     }     assertThat(((FieldMapper) mapperService.documentMapper("type").mapping().root().getMapper("foo")).fieldType().typeName(), equalTo("long")). }
false;public;0;21;;public void testConflictNewType() throws Exception {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("foo").field("type", "long").endObject().endObject().endObject().endObject().     MapperService mapperService = createIndex("test", Settings.builder().build(), "type", mapping).mapperService().     XContentBuilder update = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("foo").field("type", "double").endObject().endObject().endObject().endObject().     try {         mapperService.merge("type", new CompressedXContent(Strings.toString(update)), MapperService.MergeReason.MAPPING_UPDATE).         fail().     } catch (IllegalArgumentException e) {         // expected         assertTrue(e.getMessage(), e.getMessage().contains("mapper [foo] cannot be changed from type [long] to [double]")).     }     assertThat(((FieldMapper) mapperService.documentMapper("type").mapping().root().getMapper("foo")).fieldType().typeName(), equalTo("long")). }
false;public;0;20;;public void testReuseMetaField() throws IOException {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("_id").field("type", "text").endObject().endObject().endObject().endObject().     MapperService mapperService = createIndex("test", Settings.builder().build()).mapperService().     try {         mapperService.merge("type", new CompressedXContent(Strings.toString(mapping)), MapperService.MergeReason.MAPPING_UPDATE).         fail().     } catch (IllegalArgumentException e) {         assertTrue(e.getMessage().contains("Field [_id] is defined twice in [type]")).     }     try {         mapperService.merge("type", new CompressedXContent(Strings.toString(mapping)), MapperService.MergeReason.MAPPING_UPDATE).         fail().     } catch (IllegalArgumentException e) {         assertTrue(e.getMessage().contains("Field [_id] is defined twice in [type]")).     } }
false;public;0;30;;public void testRejectFieldDefinedTwice() throws IOException {     String mapping1 = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("foo").field("type", "object").endObject().endObject().endObject().endObject()).     String mapping2 = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("foo").field("type", "long").endObject().endObject().endObject().endObject()).     MapperService mapperService1 = createIndex("test1").mapperService().     mapperService1.merge("type", new CompressedXContent(mapping1), MergeReason.MAPPING_UPDATE).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> mapperService1.merge("type", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE)).     assertThat(e.getMessage(), equalTo("Can't merge a non object mapping [foo] with an object mapping [foo]")).     MapperService mapperService2 = createIndex("test2").mapperService().     mapperService2.merge("type", new CompressedXContent(mapping2), MergeReason.MAPPING_UPDATE).     e = expectThrows(IllegalArgumentException.class, () -> mapperService2.merge("type", new CompressedXContent(mapping1), MergeReason.MAPPING_UPDATE)).     assertThat(e.getMessage(), equalTo("mapper [foo] of different type, current_type [long], merged_type [ObjectMapper]")). }
false;public;0;24;;public void testMappingVersion() {     createIndex("test", client().admin().indices().prepareCreate("test").addMapping("type")).     final ClusterService clusterService = getInstanceFromNode(ClusterService.class).     {         final long previousVersion = clusterService.state().metaData().index("test").getMappingVersion().         final PutMappingRequest request = new PutMappingRequest().         request.indices("test").         request.type("type").         request.source("field", "type=text").         client().admin().indices().putMapping(request).actionGet().         assertThat(clusterService.state().metaData().index("test").getMappingVersion(), Matchers.equalTo(1 + previousVersion)).     }     {         final long previousVersion = clusterService.state().metaData().index("test").getMappingVersion().         final PutMappingRequest request = new PutMappingRequest().         request.indices("test").         request.type("type").         request.source("field", "type=text").         client().admin().indices().putMapping(request).actionGet().         // the version should be unchanged after putting the same mapping again         assertThat(clusterService.state().metaData().index("test").getMappingVersion(), Matchers.equalTo(previousVersion)).     } }
