# id;timestamp;commentText;codeText;commentWords;codeWords
AggregationsTests -> private void parseAndAssert(boolean addRandomFields) throws IOException;1524684173;Test that parsing works for a randomly created Aggregations object with a_randomized aggregation tree. The test randomly chooses an_{@link XContentType}, randomizes the order of the {@link XContent} fields_and randomly sets the `humanReadable` flag when rendering the_{@link XContent}.__@param addRandomFields_if set, this will also add random {@link XContent} fields to_tests that the parsers are lenient to future additions to rest_responses;private void parseAndAssert(boolean addRandomFields) throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        final ToXContent.Params params = new ToXContent.MapParams(singletonMap(RestSearchAction.TYPED_KEYS_PARAM, "true"))__        Aggregations aggregations = createTestInstance()__        BytesReference originalBytes = toShuffledXContent(aggregations, xContentType, params, randomBoolean())__        BytesReference mutated__        if (addRandomFields) {_            _            Predicate<String> excludes = path -> (path.isEmpty() || path.endsWith("aggregations")_                    || path.endsWith(Aggregation.CommonFields.META.getPreferredName())_                    || path.endsWith(Aggregation.CommonFields.BUCKETS.getPreferredName())_                    || path.endsWith(CommonFields.VALUES.getPreferredName()) || path.endsWith("covariance") || path.endsWith("correlation")_                    || path.contains(CommonFields.VALUE.getPreferredName())_                    || path.endsWith(CommonFields.KEY.getPreferredName()))__            mutated = insertRandomFields(xContentType, originalBytes, excludes, random())__        } else {_            mutated = originalBytes__        }_        try (XContentParser parser = createParser(xContentType.xContent(), mutated)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(Aggregations.AGGREGATIONS_FIELD, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            Aggregations parsedAggregations = Aggregations.fromXContent(parser)__            BytesReference parsedBytes = XContentHelper.toXContent(parsedAggregations, xContentType, randomBoolean())__            ElasticsearchAssertions.assertToXContentEquivalent(originalBytes, parsedBytes, xContentType)__        }_    };test,that,parsing,works,for,a,randomly,created,aggregations,object,with,a,randomized,aggregation,tree,the,test,randomly,chooses,an,link,xcontent,type,randomizes,the,order,of,the,link,xcontent,fields,and,randomly,sets,the,human,readable,flag,when,rendering,the,link,xcontent,param,add,random,fields,if,set,this,will,also,add,random,link,xcontent,fields,to,tests,that,the,parsers,are,lenient,to,future,additions,to,rest,responses;private,void,parse,and,assert,boolean,add,random,fields,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,final,to,xcontent,params,params,new,to,xcontent,map,params,singleton,map,rest,search,action,true,aggregations,aggregations,create,test,instance,bytes,reference,original,bytes,to,shuffled,xcontent,aggregations,x,content,type,params,random,boolean,bytes,reference,mutated,if,add,random,fields,predicate,string,excludes,path,path,is,empty,path,ends,with,aggregations,path,ends,with,aggregation,common,fields,meta,get,preferred,name,path,ends,with,aggregation,common,fields,buckets,get,preferred,name,path,ends,with,common,fields,values,get,preferred,name,path,ends,with,covariance,path,ends,with,correlation,path,contains,common,fields,value,get,preferred,name,path,ends,with,common,fields,key,get,preferred,name,mutated,insert,random,fields,x,content,type,original,bytes,excludes,random,else,mutated,original,bytes,try,xcontent,parser,parser,create,parser,x,content,type,x,content,mutated,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,aggregations,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,aggregations,parsed,aggregations,aggregations,from,xcontent,parser,bytes,reference,parsed,bytes,xcontent,helper,to,xcontent,parsed,aggregations,x,content,type,random,boolean,elasticsearch,assertions,assert,to,xcontent,equivalent,original,bytes,parsed,bytes,x,content,type
AggregationsTests -> private void parseAndAssert(boolean addRandomFields) throws IOException;1531179852;Test that parsing works for a randomly created Aggregations object with a_randomized aggregation tree. The test randomly chooses an_{@link XContentType}, randomizes the order of the {@link XContent} fields_and randomly sets the `humanReadable` flag when rendering the_{@link XContent}.__@param addRandomFields_if set, this will also add random {@link XContent} fields to_tests that the parsers are lenient to future additions to rest_responses;private void parseAndAssert(boolean addRandomFields) throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        final ToXContent.Params params = new ToXContent.MapParams(singletonMap(RestSearchAction.TYPED_KEYS_PARAM, "true"))__        Aggregations aggregations = createTestInstance()__        BytesReference originalBytes = toShuffledXContent(aggregations, xContentType, params, randomBoolean())__        BytesReference mutated__        if (addRandomFields) {_            _            Predicate<String> excludes = path -> (path.isEmpty() || path.endsWith("aggregations")_                    || path.endsWith(Aggregation.CommonFields.META.getPreferredName())_                    || path.endsWith(Aggregation.CommonFields.BUCKETS.getPreferredName())_                    || path.endsWith(CommonFields.VALUES.getPreferredName()) || path.endsWith("covariance") || path.endsWith("correlation")_                    || path.contains(CommonFields.VALUE.getPreferredName())_                    || path.endsWith(CommonFields.KEY.getPreferredName()))__            mutated = insertRandomFields(xContentType, originalBytes, excludes, random())__        } else {_            mutated = originalBytes__        }_        try (XContentParser parser = createParser(xContentType.xContent(), mutated)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(Aggregations.AGGREGATIONS_FIELD, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            Aggregations parsedAggregations = Aggregations.fromXContent(parser)__            BytesReference parsedBytes = XContentHelper.toXContent(parsedAggregations, xContentType, randomBoolean())__            ElasticsearchAssertions.assertToXContentEquivalent(originalBytes, parsedBytes, xContentType)__        }_    };test,that,parsing,works,for,a,randomly,created,aggregations,object,with,a,randomized,aggregation,tree,the,test,randomly,chooses,an,link,xcontent,type,randomizes,the,order,of,the,link,xcontent,fields,and,randomly,sets,the,human,readable,flag,when,rendering,the,link,xcontent,param,add,random,fields,if,set,this,will,also,add,random,link,xcontent,fields,to,tests,that,the,parsers,are,lenient,to,future,additions,to,rest,responses;private,void,parse,and,assert,boolean,add,random,fields,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,final,to,xcontent,params,params,new,to,xcontent,map,params,singleton,map,rest,search,action,true,aggregations,aggregations,create,test,instance,bytes,reference,original,bytes,to,shuffled,xcontent,aggregations,x,content,type,params,random,boolean,bytes,reference,mutated,if,add,random,fields,predicate,string,excludes,path,path,is,empty,path,ends,with,aggregations,path,ends,with,aggregation,common,fields,meta,get,preferred,name,path,ends,with,aggregation,common,fields,buckets,get,preferred,name,path,ends,with,common,fields,values,get,preferred,name,path,ends,with,covariance,path,ends,with,correlation,path,contains,common,fields,value,get,preferred,name,path,ends,with,common,fields,key,get,preferred,name,mutated,insert,random,fields,x,content,type,original,bytes,excludes,random,else,mutated,original,bytes,try,xcontent,parser,parser,create,parser,x,content,type,x,content,mutated,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,aggregations,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,aggregations,parsed,aggregations,aggregations,from,xcontent,parser,bytes,reference,parsed,bytes,xcontent,helper,to,xcontent,parsed,aggregations,x,content,type,random,boolean,elasticsearch,assertions,assert,to,xcontent,equivalent,original,bytes,parsed,bytes,x,content,type
AggregationsTests -> private void parseAndAssert(boolean addRandomFields) throws IOException;1531729807;Test that parsing works for a randomly created Aggregations object with a_randomized aggregation tree. The test randomly chooses an_{@link XContentType}, randomizes the order of the {@link XContent} fields_and randomly sets the `humanReadable` flag when rendering the_{@link XContent}.__@param addRandomFields_if set, this will also add random {@link XContent} fields to_tests that the parsers are lenient to future additions to rest_responses;private void parseAndAssert(boolean addRandomFields) throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        final ToXContent.Params params = new ToXContent.MapParams(singletonMap(RestSearchAction.TYPED_KEYS_PARAM, "true"))__        Aggregations aggregations = createTestInstance()__        BytesReference originalBytes = toShuffledXContent(aggregations, xContentType, params, randomBoolean())__        BytesReference mutated__        if (addRandomFields) {_            _            Predicate<String> excludes = path -> (path.isEmpty() || path.endsWith("aggregations")_                    || path.endsWith(Aggregation.CommonFields.META.getPreferredName())_                    || path.endsWith(Aggregation.CommonFields.BUCKETS.getPreferredName())_                    || path.endsWith(CommonFields.VALUES.getPreferredName()) || path.endsWith("covariance") || path.endsWith("correlation")_                    || path.contains(CommonFields.VALUE.getPreferredName())_                    || path.endsWith(CommonFields.KEY.getPreferredName()))__            mutated = insertRandomFields(xContentType, originalBytes, excludes, random())__        } else {_            mutated = originalBytes__        }_        try (XContentParser parser = createParser(xContentType.xContent(), mutated)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(Aggregations.AGGREGATIONS_FIELD, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            Aggregations parsedAggregations = Aggregations.fromXContent(parser)__            BytesReference parsedBytes = XContentHelper.toXContent(parsedAggregations, xContentType, randomBoolean())__            ElasticsearchAssertions.assertToXContentEquivalent(originalBytes, parsedBytes, xContentType)__        }_    };test,that,parsing,works,for,a,randomly,created,aggregations,object,with,a,randomized,aggregation,tree,the,test,randomly,chooses,an,link,xcontent,type,randomizes,the,order,of,the,link,xcontent,fields,and,randomly,sets,the,human,readable,flag,when,rendering,the,link,xcontent,param,add,random,fields,if,set,this,will,also,add,random,link,xcontent,fields,to,tests,that,the,parsers,are,lenient,to,future,additions,to,rest,responses;private,void,parse,and,assert,boolean,add,random,fields,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,final,to,xcontent,params,params,new,to,xcontent,map,params,singleton,map,rest,search,action,true,aggregations,aggregations,create,test,instance,bytes,reference,original,bytes,to,shuffled,xcontent,aggregations,x,content,type,params,random,boolean,bytes,reference,mutated,if,add,random,fields,predicate,string,excludes,path,path,is,empty,path,ends,with,aggregations,path,ends,with,aggregation,common,fields,meta,get,preferred,name,path,ends,with,aggregation,common,fields,buckets,get,preferred,name,path,ends,with,common,fields,values,get,preferred,name,path,ends,with,covariance,path,ends,with,correlation,path,contains,common,fields,value,get,preferred,name,path,ends,with,common,fields,key,get,preferred,name,mutated,insert,random,fields,x,content,type,original,bytes,excludes,random,else,mutated,original,bytes,try,xcontent,parser,parser,create,parser,x,content,type,x,content,mutated,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,aggregations,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,aggregations,parsed,aggregations,aggregations,from,xcontent,parser,bytes,reference,parsed,bytes,xcontent,helper,to,xcontent,parsed,aggregations,x,content,type,random,boolean,elasticsearch,assertions,assert,to,xcontent,equivalent,original,bytes,parsed,bytes,x,content,type
AggregationsTests -> private void parseAndAssert(boolean addRandomFields) throws IOException;1536314350;Test that parsing works for a randomly created Aggregations object with a_randomized aggregation tree. The test randomly chooses an_{@link XContentType}, randomizes the order of the {@link XContent} fields_and randomly sets the `humanReadable` flag when rendering the_{@link XContent}.__@param addRandomFields_if set, this will also add random {@link XContent} fields to_tests that the parsers are lenient to future additions to rest_responses;private void parseAndAssert(boolean addRandomFields) throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        final ToXContent.Params params = new ToXContent.MapParams(singletonMap(RestSearchAction.TYPED_KEYS_PARAM, "true"))__        Aggregations aggregations = createTestInstance()__        BytesReference originalBytes = toShuffledXContent(aggregations, xContentType, params, randomBoolean())__        BytesReference mutated__        if (addRandomFields) {_            _            Predicate<String> excludes = path -> (path.isEmpty() || path.endsWith("aggregations")_                    || path.endsWith(Aggregation.CommonFields.META.getPreferredName())_                    || path.endsWith(Aggregation.CommonFields.BUCKETS.getPreferredName())_                    || path.endsWith(CommonFields.VALUES.getPreferredName()) || path.endsWith("covariance") || path.endsWith("correlation")_                    || path.contains(CommonFields.VALUE.getPreferredName())_                    || path.endsWith(CommonFields.KEY.getPreferredName()))__            mutated = insertRandomFields(xContentType, originalBytes, excludes, random())__        } else {_            mutated = originalBytes__        }_        try (XContentParser parser = createParser(xContentType.xContent(), mutated)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(Aggregations.AGGREGATIONS_FIELD, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            Aggregations parsedAggregations = Aggregations.fromXContent(parser)__            BytesReference parsedBytes = XContentHelper.toXContent(parsedAggregations, xContentType, randomBoolean())__            ElasticsearchAssertions.assertToXContentEquivalent(originalBytes, parsedBytes, xContentType)__        }_    };test,that,parsing,works,for,a,randomly,created,aggregations,object,with,a,randomized,aggregation,tree,the,test,randomly,chooses,an,link,xcontent,type,randomizes,the,order,of,the,link,xcontent,fields,and,randomly,sets,the,human,readable,flag,when,rendering,the,link,xcontent,param,add,random,fields,if,set,this,will,also,add,random,link,xcontent,fields,to,tests,that,the,parsers,are,lenient,to,future,additions,to,rest,responses;private,void,parse,and,assert,boolean,add,random,fields,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,final,to,xcontent,params,params,new,to,xcontent,map,params,singleton,map,rest,search,action,true,aggregations,aggregations,create,test,instance,bytes,reference,original,bytes,to,shuffled,xcontent,aggregations,x,content,type,params,random,boolean,bytes,reference,mutated,if,add,random,fields,predicate,string,excludes,path,path,is,empty,path,ends,with,aggregations,path,ends,with,aggregation,common,fields,meta,get,preferred,name,path,ends,with,aggregation,common,fields,buckets,get,preferred,name,path,ends,with,common,fields,values,get,preferred,name,path,ends,with,covariance,path,ends,with,correlation,path,contains,common,fields,value,get,preferred,name,path,ends,with,common,fields,key,get,preferred,name,mutated,insert,random,fields,x,content,type,original,bytes,excludes,random,else,mutated,original,bytes,try,xcontent,parser,parser,create,parser,x,content,type,x,content,mutated,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,aggregations,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,aggregations,parsed,aggregations,aggregations,from,xcontent,parser,bytes,reference,parsed,bytes,xcontent,helper,to,xcontent,parsed,aggregations,x,content,type,random,boolean,elasticsearch,assertions,assert,to,xcontent,equivalent,original,bytes,parsed,bytes,x,content,type
AggregationsTests -> private void parseAndAssert(boolean addRandomFields) throws IOException;1540486836;Test that parsing works for a randomly created Aggregations object with a_randomized aggregation tree. The test randomly chooses an_{@link XContentType}, randomizes the order of the {@link XContent} fields_and randomly sets the `humanReadable` flag when rendering the_{@link XContent}.__@param addRandomFields_if set, this will also add random {@link XContent} fields to_tests that the parsers are lenient to future additions to rest_responses;private void parseAndAssert(boolean addRandomFields) throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        final ToXContent.Params params = new ToXContent.MapParams(singletonMap(RestSearchAction.TYPED_KEYS_PARAM, "true"))__        Aggregations aggregations = createTestInstance()__        BytesReference originalBytes = toShuffledXContent(aggregations, xContentType, params, randomBoolean())__        BytesReference mutated__        if (addRandomFields) {_            _            Predicate<String> excludes = path -> (path.isEmpty() || path.endsWith("aggregations")_                    || path.endsWith(Aggregation.CommonFields.META.getPreferredName())_                    || path.endsWith(Aggregation.CommonFields.BUCKETS.getPreferredName())_                    || path.endsWith(CommonFields.VALUES.getPreferredName()) || path.endsWith("covariance") || path.endsWith("correlation")_                    || path.contains(CommonFields.VALUE.getPreferredName())_                    || path.endsWith(CommonFields.KEY.getPreferredName()))__            mutated = insertRandomFields(xContentType, originalBytes, excludes, random())__        } else {_            mutated = originalBytes__        }_        try (XContentParser parser = createParser(xContentType.xContent(), mutated)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(Aggregations.AGGREGATIONS_FIELD, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            Aggregations parsedAggregations = Aggregations.fromXContent(parser)__            BytesReference parsedBytes = XContentHelper.toXContent(parsedAggregations, xContentType, randomBoolean())__            ElasticsearchAssertions.assertToXContentEquivalent(originalBytes, parsedBytes, xContentType)__        }_    };test,that,parsing,works,for,a,randomly,created,aggregations,object,with,a,randomized,aggregation,tree,the,test,randomly,chooses,an,link,xcontent,type,randomizes,the,order,of,the,link,xcontent,fields,and,randomly,sets,the,human,readable,flag,when,rendering,the,link,xcontent,param,add,random,fields,if,set,this,will,also,add,random,link,xcontent,fields,to,tests,that,the,parsers,are,lenient,to,future,additions,to,rest,responses;private,void,parse,and,assert,boolean,add,random,fields,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,final,to,xcontent,params,params,new,to,xcontent,map,params,singleton,map,rest,search,action,true,aggregations,aggregations,create,test,instance,bytes,reference,original,bytes,to,shuffled,xcontent,aggregations,x,content,type,params,random,boolean,bytes,reference,mutated,if,add,random,fields,predicate,string,excludes,path,path,is,empty,path,ends,with,aggregations,path,ends,with,aggregation,common,fields,meta,get,preferred,name,path,ends,with,aggregation,common,fields,buckets,get,preferred,name,path,ends,with,common,fields,values,get,preferred,name,path,ends,with,covariance,path,ends,with,correlation,path,contains,common,fields,value,get,preferred,name,path,ends,with,common,fields,key,get,preferred,name,mutated,insert,random,fields,x,content,type,original,bytes,excludes,random,else,mutated,original,bytes,try,xcontent,parser,parser,create,parser,x,content,type,x,content,mutated,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,aggregations,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,aggregations,parsed,aggregations,aggregations,from,xcontent,parser,bytes,reference,parsed,bytes,xcontent,helper,to,xcontent,parsed,aggregations,x,content,type,random,boolean,elasticsearch,assertions,assert,to,xcontent,equivalent,original,bytes,parsed,bytes,x,content,type
AggregationsTests -> private void parseAndAssert(boolean addRandomFields) throws IOException;1540912197;Test that parsing works for a randomly created Aggregations object with a_randomized aggregation tree. The test randomly chooses an_{@link XContentType}, randomizes the order of the {@link XContent} fields_and randomly sets the `humanReadable` flag when rendering the_{@link XContent}.__@param addRandomFields_if set, this will also add random {@link XContent} fields to_tests that the parsers are lenient to future additions to rest_responses;private void parseAndAssert(boolean addRandomFields) throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        final ToXContent.Params params = new ToXContent.MapParams(singletonMap(RestSearchAction.TYPED_KEYS_PARAM, "true"))__        Aggregations aggregations = createTestInstance()__        BytesReference originalBytes = toShuffledXContent(aggregations, xContentType, params, randomBoolean())__        BytesReference mutated__        if (addRandomFields) {_            _            Predicate<String> excludes = path -> (path.isEmpty() || path.endsWith("aggregations")_                    || path.endsWith(Aggregation.CommonFields.META.getPreferredName())_                    || path.endsWith(Aggregation.CommonFields.BUCKETS.getPreferredName())_                    || path.endsWith(CommonFields.VALUES.getPreferredName()) || path.endsWith("covariance") || path.endsWith("correlation")_                    || path.contains(CommonFields.VALUE.getPreferredName())_                    || path.endsWith(CommonFields.KEY.getPreferredName()))__            mutated = insertRandomFields(xContentType, originalBytes, excludes, random())__        } else {_            mutated = originalBytes__        }_        try (XContentParser parser = createParser(xContentType.xContent(), mutated)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(Aggregations.AGGREGATIONS_FIELD, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            Aggregations parsedAggregations = Aggregations.fromXContent(parser)__            BytesReference parsedBytes = XContentHelper.toXContent(parsedAggregations, xContentType, randomBoolean())__            ElasticsearchAssertions.assertToXContentEquivalent(originalBytes, parsedBytes, xContentType)__        }_    };test,that,parsing,works,for,a,randomly,created,aggregations,object,with,a,randomized,aggregation,tree,the,test,randomly,chooses,an,link,xcontent,type,randomizes,the,order,of,the,link,xcontent,fields,and,randomly,sets,the,human,readable,flag,when,rendering,the,link,xcontent,param,add,random,fields,if,set,this,will,also,add,random,link,xcontent,fields,to,tests,that,the,parsers,are,lenient,to,future,additions,to,rest,responses;private,void,parse,and,assert,boolean,add,random,fields,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,final,to,xcontent,params,params,new,to,xcontent,map,params,singleton,map,rest,search,action,true,aggregations,aggregations,create,test,instance,bytes,reference,original,bytes,to,shuffled,xcontent,aggregations,x,content,type,params,random,boolean,bytes,reference,mutated,if,add,random,fields,predicate,string,excludes,path,path,is,empty,path,ends,with,aggregations,path,ends,with,aggregation,common,fields,meta,get,preferred,name,path,ends,with,aggregation,common,fields,buckets,get,preferred,name,path,ends,with,common,fields,values,get,preferred,name,path,ends,with,covariance,path,ends,with,correlation,path,contains,common,fields,value,get,preferred,name,path,ends,with,common,fields,key,get,preferred,name,mutated,insert,random,fields,x,content,type,original,bytes,excludes,random,else,mutated,original,bytes,try,xcontent,parser,parser,create,parser,x,content,type,x,content,mutated,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,aggregations,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,aggregations,parsed,aggregations,aggregations,from,xcontent,parser,bytes,reference,parsed,bytes,xcontent,helper,to,xcontent,parsed,aggregations,x,content,type,random,boolean,elasticsearch,assertions,assert,to,xcontent,equivalent,original,bytes,parsed,bytes,x,content,type
AggregationsTests -> private void parseAndAssert(boolean addRandomFields) throws IOException;1546466001;Test that parsing works for a randomly created Aggregations object with a_randomized aggregation tree. The test randomly chooses an_{@link XContentType}, randomizes the order of the {@link XContent} fields_and randomly sets the `humanReadable` flag when rendering the_{@link XContent}.__@param addRandomFields_if set, this will also add random {@link XContent} fields to_tests that the parsers are lenient to future additions to rest_responses;private void parseAndAssert(boolean addRandomFields) throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        final ToXContent.Params params = new ToXContent.MapParams(singletonMap(RestSearchAction.TYPED_KEYS_PARAM, "true"))__        Aggregations aggregations = createTestInstance()__        BytesReference originalBytes = toShuffledXContent(aggregations, xContentType, params, randomBoolean())__        BytesReference mutated__        if (addRandomFields) {_            _            Predicate<String> excludes = path -> (path.isEmpty() || path.endsWith("aggregations")_                    || path.endsWith(Aggregation.CommonFields.META.getPreferredName())_                    || path.endsWith(Aggregation.CommonFields.BUCKETS.getPreferredName())_                    || path.endsWith(CommonFields.VALUES.getPreferredName()) || path.endsWith("covariance") || path.endsWith("correlation")_                    || path.contains(CommonFields.VALUE.getPreferredName())_                    || path.endsWith(CommonFields.KEY.getPreferredName()))__            mutated = insertRandomFields(xContentType, originalBytes, excludes, random())__        } else {_            mutated = originalBytes__        }_        try (XContentParser parser = createParser(xContentType.xContent(), mutated)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(Aggregations.AGGREGATIONS_FIELD, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            Aggregations parsedAggregations = Aggregations.fromXContent(parser)__            BytesReference parsedBytes = XContentHelper.toXContent(parsedAggregations, xContentType, randomBoolean())__            ElasticsearchAssertions.assertToXContentEquivalent(originalBytes, parsedBytes, xContentType)__        }_    };test,that,parsing,works,for,a,randomly,created,aggregations,object,with,a,randomized,aggregation,tree,the,test,randomly,chooses,an,link,xcontent,type,randomizes,the,order,of,the,link,xcontent,fields,and,randomly,sets,the,human,readable,flag,when,rendering,the,link,xcontent,param,add,random,fields,if,set,this,will,also,add,random,link,xcontent,fields,to,tests,that,the,parsers,are,lenient,to,future,additions,to,rest,responses;private,void,parse,and,assert,boolean,add,random,fields,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,final,to,xcontent,params,params,new,to,xcontent,map,params,singleton,map,rest,search,action,true,aggregations,aggregations,create,test,instance,bytes,reference,original,bytes,to,shuffled,xcontent,aggregations,x,content,type,params,random,boolean,bytes,reference,mutated,if,add,random,fields,predicate,string,excludes,path,path,is,empty,path,ends,with,aggregations,path,ends,with,aggregation,common,fields,meta,get,preferred,name,path,ends,with,aggregation,common,fields,buckets,get,preferred,name,path,ends,with,common,fields,values,get,preferred,name,path,ends,with,covariance,path,ends,with,correlation,path,contains,common,fields,value,get,preferred,name,path,ends,with,common,fields,key,get,preferred,name,mutated,insert,random,fields,x,content,type,original,bytes,excludes,random,else,mutated,original,bytes,try,xcontent,parser,parser,create,parser,x,content,type,x,content,mutated,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,aggregations,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,aggregations,parsed,aggregations,aggregations,from,xcontent,parser,bytes,reference,parsed,bytes,xcontent,helper,to,xcontent,parsed,aggregations,x,content,type,random,boolean,elasticsearch,assertions,assert,to,xcontent,equivalent,original,bytes,parsed,bytes,x,content,type
AggregationsTests -> private void parseAndAssert(boolean addRandomFields) throws IOException;1548353534;Test that parsing works for a randomly created Aggregations object with a_randomized aggregation tree. The test randomly chooses an_{@link XContentType}, randomizes the order of the {@link XContent} fields_and randomly sets the `humanReadable` flag when rendering the_{@link XContent}.__@param addRandomFields_if set, this will also add random {@link XContent} fields to_tests that the parsers are lenient to future additions to rest_responses;private void parseAndAssert(boolean addRandomFields) throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        final ToXContent.Params params = new ToXContent.MapParams(singletonMap(RestSearchAction.TYPED_KEYS_PARAM, "true"))__        Aggregations aggregations = createTestInstance()__        BytesReference originalBytes = toShuffledXContent(aggregations, xContentType, params, randomBoolean())__        BytesReference mutated__        if (addRandomFields) {_            _            Predicate<String> excludes = path -> (path.isEmpty() || path.endsWith("aggregations")_                    || path.endsWith(Aggregation.CommonFields.META.getPreferredName())_                    || path.endsWith(Aggregation.CommonFields.BUCKETS.getPreferredName())_                    || path.endsWith(CommonFields.VALUES.getPreferredName()) || path.endsWith("covariance") || path.endsWith("correlation")_                    || path.contains(CommonFields.VALUE.getPreferredName())_                    || path.endsWith(CommonFields.KEY.getPreferredName()))__            mutated = insertRandomFields(xContentType, originalBytes, excludes, random())__        } else {_            mutated = originalBytes__        }_        try (XContentParser parser = createParser(xContentType.xContent(), mutated)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(Aggregations.AGGREGATIONS_FIELD, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            Aggregations parsedAggregations = Aggregations.fromXContent(parser)__            BytesReference parsedBytes = XContentHelper.toXContent(parsedAggregations, xContentType, randomBoolean())__            ElasticsearchAssertions.assertToXContentEquivalent(originalBytes, parsedBytes, xContentType)__        }_    };test,that,parsing,works,for,a,randomly,created,aggregations,object,with,a,randomized,aggregation,tree,the,test,randomly,chooses,an,link,xcontent,type,randomizes,the,order,of,the,link,xcontent,fields,and,randomly,sets,the,human,readable,flag,when,rendering,the,link,xcontent,param,add,random,fields,if,set,this,will,also,add,random,link,xcontent,fields,to,tests,that,the,parsers,are,lenient,to,future,additions,to,rest,responses;private,void,parse,and,assert,boolean,add,random,fields,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,final,to,xcontent,params,params,new,to,xcontent,map,params,singleton,map,rest,search,action,true,aggregations,aggregations,create,test,instance,bytes,reference,original,bytes,to,shuffled,xcontent,aggregations,x,content,type,params,random,boolean,bytes,reference,mutated,if,add,random,fields,predicate,string,excludes,path,path,is,empty,path,ends,with,aggregations,path,ends,with,aggregation,common,fields,meta,get,preferred,name,path,ends,with,aggregation,common,fields,buckets,get,preferred,name,path,ends,with,common,fields,values,get,preferred,name,path,ends,with,covariance,path,ends,with,correlation,path,contains,common,fields,value,get,preferred,name,path,ends,with,common,fields,key,get,preferred,name,mutated,insert,random,fields,x,content,type,original,bytes,excludes,random,else,mutated,original,bytes,try,xcontent,parser,parser,create,parser,x,content,type,x,content,mutated,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,aggregations,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,aggregations,parsed,aggregations,aggregations,from,xcontent,parser,bytes,reference,parsed,bytes,xcontent,helper,to,xcontent,parsed,aggregations,x,content,type,random,boolean,elasticsearch,assertions,assert,to,xcontent,equivalent,original,bytes,parsed,bytes,x,content,type
AggregationsTests -> private void parseAndAssert(boolean addRandomFields) throws IOException;1548979890;Test that parsing works for a randomly created Aggregations object with a_randomized aggregation tree. The test randomly chooses an_{@link XContentType}, randomizes the order of the {@link XContent} fields_and randomly sets the `humanReadable` flag when rendering the_{@link XContent}.__@param addRandomFields_if set, this will also add random {@link XContent} fields to_tests that the parsers are lenient to future additions to rest_responses;private void parseAndAssert(boolean addRandomFields) throws IOException {_        XContentType xContentType = randomFrom(XContentType.values())__        final ToXContent.Params params = new ToXContent.MapParams(singletonMap(RestSearchAction.TYPED_KEYS_PARAM, "true"))__        Aggregations aggregations = createTestInstance()__        BytesReference originalBytes = toShuffledXContent(aggregations, xContentType, params, randomBoolean())__        BytesReference mutated__        if (addRandomFields) {_            _            Predicate<String> excludes = path -> (path.isEmpty() || path.endsWith("aggregations")_                    || path.endsWith(Aggregation.CommonFields.META.getPreferredName())_                    || path.endsWith(Aggregation.CommonFields.BUCKETS.getPreferredName())_                    || path.endsWith(CommonFields.VALUES.getPreferredName()) || path.endsWith("covariance") || path.endsWith("correlation")_                    || path.contains(CommonFields.VALUE.getPreferredName())_                    || path.endsWith(CommonFields.KEY.getPreferredName()))__            mutated = insertRandomFields(xContentType, originalBytes, excludes, random())__        } else {_            mutated = originalBytes__        }_        try (XContentParser parser = createParser(xContentType.xContent(), mutated)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(Aggregations.AGGREGATIONS_FIELD, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            Aggregations parsedAggregations = Aggregations.fromXContent(parser)__            BytesReference parsedBytes = XContentHelper.toXContent(parsedAggregations, xContentType, randomBoolean())__            ElasticsearchAssertions.assertToXContentEquivalent(originalBytes, parsedBytes, xContentType)__        }_    };test,that,parsing,works,for,a,randomly,created,aggregations,object,with,a,randomized,aggregation,tree,the,test,randomly,chooses,an,link,xcontent,type,randomizes,the,order,of,the,link,xcontent,fields,and,randomly,sets,the,human,readable,flag,when,rendering,the,link,xcontent,param,add,random,fields,if,set,this,will,also,add,random,link,xcontent,fields,to,tests,that,the,parsers,are,lenient,to,future,additions,to,rest,responses;private,void,parse,and,assert,boolean,add,random,fields,throws,ioexception,xcontent,type,x,content,type,random,from,xcontent,type,values,final,to,xcontent,params,params,new,to,xcontent,map,params,singleton,map,rest,search,action,true,aggregations,aggregations,create,test,instance,bytes,reference,original,bytes,to,shuffled,xcontent,aggregations,x,content,type,params,random,boolean,bytes,reference,mutated,if,add,random,fields,predicate,string,excludes,path,path,is,empty,path,ends,with,aggregations,path,ends,with,aggregation,common,fields,meta,get,preferred,name,path,ends,with,aggregation,common,fields,buckets,get,preferred,name,path,ends,with,common,fields,values,get,preferred,name,path,ends,with,covariance,path,ends,with,correlation,path,contains,common,fields,value,get,preferred,name,path,ends,with,common,fields,key,get,preferred,name,mutated,insert,random,fields,x,content,type,original,bytes,excludes,random,else,mutated,original,bytes,try,xcontent,parser,parser,create,parser,x,content,type,x,content,mutated,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,aggregations,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,aggregations,parsed,aggregations,aggregations,from,xcontent,parser,bytes,reference,parsed,bytes,xcontent,helper,to,xcontent,parsed,aggregations,x,content,type,random,boolean,elasticsearch,assertions,assert,to,xcontent,equivalent,original,bytes,parsed,bytes,x,content,type
