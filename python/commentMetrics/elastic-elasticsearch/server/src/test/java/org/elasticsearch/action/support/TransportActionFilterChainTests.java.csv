commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void init() throws Exception {     counter = new AtomicInteger().     threadPool = new ThreadPool(Settings.builder().put(Node.NODE_NAME_SETTING.getKey(), "TransportActionFilterChainTests").build()). }
false;public;0;4;;@After public void shutdown() throws Exception {     terminate(threadPool). }
false;protected;3;4;;@Override protected void doExecute(Task task, TestRequest request, ActionListener<TestResponse> listener) {     listener.onResponse(new TestResponse()). }
false;public;0;73;;public void testActionFiltersRequest() throws ExecutionException, InterruptedException {     int numFilters = randomInt(10).     Set<Integer> orders = new HashSet<>(numFilters).     while (orders.size() < numFilters) {         orders.add(randomInt(10)).     }     Set<ActionFilter> filters = new HashSet<>().     for (Integer order : orders) {         filters.add(new RequestTestFilter(order, randomFrom(RequestOperation.values()))).     }     String actionName = randomAlphaOfLength(randomInt(30)).     ActionFilters actionFilters = new ActionFilters(filters).     TransportAction<TestRequest, TestResponse> transportAction = new TransportAction<TestRequest, TestResponse>(actionName, actionFilters, new TaskManager(Settings.EMPTY, threadPool, Collections.emptySet())) {          @Override         protected void doExecute(Task task, TestRequest request, ActionListener<TestResponse> listener) {             listener.onResponse(new TestResponse()).         }     }.     ArrayList<ActionFilter> actionFiltersByOrder = new ArrayList<>(filters).     actionFiltersByOrder.sort(Comparator.comparingInt(ActionFilter::order)).     List<ActionFilter> expectedActionFilters = new ArrayList<>().     boolean errorExpected = false.     for (ActionFilter filter : actionFiltersByOrder) {         RequestTestFilter testFilter = (RequestTestFilter) filter.         expectedActionFilters.add(testFilter).         if (testFilter.callback == RequestOperation.LISTENER_FAILURE) {             errorExpected = true.         }         if (!(testFilter.callback == RequestOperation.CONTINUE_PROCESSING)) {             break.         }     }     PlainActionFuture<TestResponse> future = PlainActionFuture.newFuture().     transportAction.execute(new TestRequest(), future).     try {         assertThat(future.get(), notNullValue()).         assertThat("shouldn't get here if an error is expected", errorExpected, equalTo(false)).     } catch (ExecutionException e) {         assertThat("shouldn't get here if an error is not expected " + e.getMessage(), errorExpected, equalTo(true)).     }     List<RequestTestFilter> testFiltersByLastExecution = new ArrayList<>().     for (ActionFilter actionFilter : actionFilters.filters()) {         testFiltersByLastExecution.add((RequestTestFilter) actionFilter).     }     testFiltersByLastExecution.sort(Comparator.comparingInt(o -> o.executionToken)).     ArrayList<RequestTestFilter> finalTestFilters = new ArrayList<>().     for (ActionFilter filter : testFiltersByLastExecution) {         RequestTestFilter testFilter = (RequestTestFilter) filter.         finalTestFilters.add(testFilter).         if (!(testFilter.callback == RequestOperation.CONTINUE_PROCESSING)) {             break.         }     }     assertThat(finalTestFilters.size(), equalTo(expectedActionFilters.size())).     for (int i = 0. i < finalTestFilters.size(). i++) {         RequestTestFilter testFilter = finalTestFilters.get(i).         assertThat(testFilter, equalTo(expectedActionFilters.get(i))).         assertThat(testFilter.runs.get(), equalTo(1)).         assertThat(testFilter.lastActionName, equalTo(actionName)).     } }
false;public;5;7;;@Override public <Request extends ActionRequest, Response extends ActionResponse> void execute(Task task, String action, Request request, ActionListener<Response> listener, ActionFilterChain<Request, Response> actionFilterChain) {     for (int i = 0. i <= additionalContinueCount. i++) {         actionFilterChain.proceed(task, action, request, listener).     } }
false;protected;3;4;;@Override protected void doExecute(Task task, TestRequest request, ActionListener<TestResponse> listener) {     listener.onResponse(new TestResponse()). }
false;public;1;5;;@Override public void onResponse(TestResponse testResponse) {     responses.incrementAndGet().     latch.countDown(). }
false;public;1;5;;@Override public void onFailure(Exception e) {     failures.add(e).     latch.countDown(). }
false;public;0;57;;public void testTooManyContinueProcessingRequest() throws ExecutionException, InterruptedException {     final int additionalContinueCount = randomInt(10).     RequestTestFilter testFilter = new RequestTestFilter(randomInt(), new RequestCallback() {          @Override         public <Request extends ActionRequest, Response extends ActionResponse> void execute(Task task, String action, Request request, ActionListener<Response> listener, ActionFilterChain<Request, Response> actionFilterChain) {             for (int i = 0. i <= additionalContinueCount. i++) {                 actionFilterChain.proceed(task, action, request, listener).             }         }     }).     Set<ActionFilter> filters = new HashSet<>().     filters.add(testFilter).     String actionName = randomAlphaOfLength(randomInt(30)).     ActionFilters actionFilters = new ActionFilters(filters).     TransportAction<TestRequest, TestResponse> transportAction = new TransportAction<TestRequest, TestResponse>(actionName, actionFilters, new TaskManager(Settings.EMPTY, threadPool, Collections.emptySet())) {          @Override         protected void doExecute(Task task, TestRequest request, ActionListener<TestResponse> listener) {             listener.onResponse(new TestResponse()).         }     }.     final CountDownLatch latch = new CountDownLatch(additionalContinueCount + 1).     final AtomicInteger responses = new AtomicInteger().     final List<Throwable> failures = new CopyOnWriteArrayList<>().     transportAction.execute(new TestRequest(), new ActionListener<TestResponse>() {          @Override         public void onResponse(TestResponse testResponse) {             responses.incrementAndGet().             latch.countDown().         }          @Override         public void onFailure(Exception e) {             failures.add(e).             latch.countDown().         }     }).     if (!latch.await(10, TimeUnit.SECONDS)) {         fail("timeout waiting for the filter to notify the listener as many times as expected").     }     assertThat(testFilter.runs.get(), equalTo(1)).     assertThat(testFilter.lastActionName, equalTo(actionName)).     assertThat(responses.get(), equalTo(1)).     assertThat(failures.size(), equalTo(additionalContinueCount)).     for (Throwable failure : failures) {         assertThat(failure, instanceOf(IllegalStateException.class)).     } }
false;public;0;4;;@Override public int order() {     return order. }
false;public;5;8;;@Override public <Request extends ActionRequest, Response extends ActionResponse> void apply(Task task, String action, Request request, ActionListener<Response> listener, ActionFilterChain<Request, Response> chain) {     this.runs.incrementAndGet().     this.lastActionName = action.     this.executionToken = counter.incrementAndGet().     this.callback.execute(task, action, request, listener, chain). }
false;public;5;5;;@Override public <Request extends ActionRequest, Response extends ActionResponse> void execute(Task task, String action, Request request, ActionListener<Response> listener, ActionFilterChain<Request, Response> actionFilterChain) {     actionFilterChain.proceed(task, action, request, listener). }
false;public;5;6;;@Override // Safe because its all we test with @SuppressWarnings("unchecked") public <Request extends ActionRequest, Response extends ActionResponse> void execute(Task task, String action, Request request, ActionListener<Response> listener, ActionFilterChain<Request, Response> actionFilterChain) {     ((ActionListener<TestResponse>) listener).onResponse(new TestResponse()). }
false;public;5;5;;@Override public <Request extends ActionRequest, Response extends ActionResponse> void execute(Task task, String action, Request request, ActionListener<Response> listener, ActionFilterChain<Request, Response> actionFilterChain) {     listener.onFailure(new ElasticsearchTimeoutException("")). }
false;;5;2;;<Request extends ActionRequest, Response extends ActionResponse> void execute(Task task, String action, Request request, ActionListener<Response> listener, ActionFilterChain<Request, Response> actionFilterChain).
false;public;0;4;;@Override public ActionRequestValidationException validate() {     return null. }
