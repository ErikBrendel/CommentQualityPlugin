commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("It should not fail"). }
false;protected;0;4;;@Override protected void doRunInLifecycle() throws Exception {     runCallable.call(). }
false;public;0;27;;public void testDoRunOnlyRunsWhenNotStoppedOrClosed() throws Exception {     Callable<?> runCallable = mock(Callable.class).     // it's "not stopped or closed"     when(lifecycle.stoppedOrClosed()).thenReturn(false).     AbstractLifecycleRunnable runnable = new AbstractLifecycleRunnable(lifecycle, logger) {          @Override         public void onFailure(Exception e) {             fail("It should not fail").         }          @Override         protected void doRunInLifecycle() throws Exception {             runCallable.call().         }     }.     runnable.run().     InOrder inOrder = inOrder(lifecycle, logger, runCallable).     inOrder.verify(lifecycle).stoppedOrClosed().     inOrder.verify(runCallable).call().     // onAfter uses it too, but we're not testing it here     inOrder.verify(lifecycle).stoppedOrClosed().     inOrder.verifyNoMoreInteractions(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("It should not fail"). }
false;protected;0;4;;@Override protected void doRunInLifecycle() throws Exception {     fail("Should not run with lifecycle stopped or closed."). }
false;public;0;28;;@SuppressLoggerChecks(reason = "mock usage") public void testDoRunDoesNotRunWhenStoppedOrClosed() throws Exception {     Callable<?> runCallable = mock(Callable.class).     // it's stopped or closed     when(lifecycle.stoppedOrClosed()).thenReturn(true).     AbstractLifecycleRunnable runnable = new AbstractLifecycleRunnable(lifecycle, logger) {          @Override         public void onFailure(Exception e) {             fail("It should not fail").         }          @Override         protected void doRunInLifecycle() throws Exception {             fail("Should not run with lifecycle stopped or closed.").         }     }.     runnable.run().     InOrder inOrder = inOrder(lifecycle, logger, runCallable).     inOrder.verify(lifecycle).stoppedOrClosed().     inOrder.verify(logger).trace(anyString()).     // onAfter uses it too, but we're not testing it here     inOrder.verify(lifecycle).stoppedOrClosed().     inOrder.verifyNoMoreInteractions(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("It should not fail"). }
false;protected;0;4;;@Override protected void doRunInLifecycle() throws Exception {     runCallable.call(). }
false;protected;0;9;;@Override protected void onAfterInLifecycle() {     try {         afterCallable.call().     } catch (Exception e) {         fail("Unexpected for mock.").     } }
false;public;0;39;;public void testOnAfterOnlyWhenNotStoppedOrClosed() throws Exception {     Callable<?> runCallable = mock(Callable.class).     Callable<?> afterCallable = mock(Callable.class).     // it's "not stopped or closed"     when(lifecycle.stoppedOrClosed()).thenReturn(false).     AbstractLifecycleRunnable runnable = new AbstractLifecycleRunnable(lifecycle, logger) {          @Override         public void onFailure(Exception e) {             fail("It should not fail").         }          @Override         protected void doRunInLifecycle() throws Exception {             runCallable.call().         }          @Override         protected void onAfterInLifecycle() {             try {                 afterCallable.call().             } catch (Exception e) {                 fail("Unexpected for mock.").             }         }     }.     runnable.run().     InOrder inOrder = inOrder(lifecycle, logger, runCallable, afterCallable).     inOrder.verify(lifecycle).stoppedOrClosed().     inOrder.verify(runCallable).call().     inOrder.verify(lifecycle).stoppedOrClosed().     inOrder.verify(afterCallable).call().     inOrder.verifyNoMoreInteractions(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     fail("It should not fail"). }
false;protected;0;4;;@Override protected void doRunInLifecycle() throws Exception {     fail("Should not run with lifecycle stopped or closed."). }
false;protected;0;4;;@Override protected void onAfterInLifecycle() {     fail("Should not run with lifecycle stopped or closed."). }
false;public;0;30;;public void testOnAfterDoesNotHappenWhenStoppedOrClosed() throws Exception {     Callable<?> runCallable = mock(Callable.class).     // it's stopped or closed     when(lifecycle.stoppedOrClosed()).thenReturn(true).     AbstractLifecycleRunnable runnable = new AbstractLifecycleRunnable(lifecycle, logger) {          @Override         public void onFailure(Exception e) {             fail("It should not fail").         }          @Override         protected void doRunInLifecycle() throws Exception {             fail("Should not run with lifecycle stopped or closed.").         }          @Override         protected void onAfterInLifecycle() {             fail("Should not run with lifecycle stopped or closed.").         }     }.     runnable.run().     InOrder inOrder = inOrder(lifecycle, runCallable).     inOrder.verify(lifecycle, times(2)).stoppedOrClosed().     inOrder.verifyNoMoreInteractions(). }
