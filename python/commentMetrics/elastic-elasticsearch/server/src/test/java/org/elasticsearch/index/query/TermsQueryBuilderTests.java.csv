commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;@Before public void randomTerms() {     List<Object> randomTerms = new ArrayList<>().     String[] strings = generateRandomStringArray(10, 10, false, true).     for (String string : strings) {         randomTerms.add(string).         if (rarely()) {             randomTerms.add(null).         }     }     this.randomTerms = randomTerms.     termsPath = randomAlphaOfLength(10).replace('.', '_'). }
false;protected;0;24;;@Override protected TermsQueryBuilder doCreateTestQueryBuilder() {     TermsQueryBuilder query.     // terms query or lookup query     if (randomBoolean()) {         // make between 0 and 5 different values of the same type         String fieldName = randomValueOtherThanMany(choice -> choice.equals(GEO_POINT_FIELD_NAME) || choice.equals(GEO_POINT_ALIAS_FIELD_NAME) || choice.equals(GEO_SHAPE_FIELD_NAME) || choice.equals(INT_RANGE_FIELD_NAME) || choice.equals(DATE_RANGE_FIELD_NAME), () -> getRandomFieldName()).         Object[] values = new Object[randomInt(5)].         for (int i = 0. i < values.length. i++) {             values[i] = getRandomValueForFieldName(fieldName).         }         query = new TermsQueryBuilder(fieldName, values).     } else {         // right now the mock service returns us a list of strings         query = new TermsQueryBuilder(randomBoolean() ? randomAlphaOfLengthBetween(1, 10) : STRING_FIELD_NAME, randomTermsLookup()).     }     return query. }
false;private;0;9;;private TermsLookup randomTermsLookup() {     // Randomly choose between a typeless terms lookup and one with an explicit type to make sure we are     // testing both cases.     TermsLookup lookup = randomBoolean() ? new TermsLookup(randomAlphaOfLength(10), randomAlphaOfLength(10), termsPath) : new TermsLookup(randomAlphaOfLength(10), randomAlphaOfLength(10), randomAlphaOfLength(10), termsPath).     lookup.routing(randomBoolean() ? randomAlphaOfLength(10) : null).     return lookup. }
false;protected;3;38;;@Override protected void doAssertLuceneQuery(TermsQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     if (queryBuilder.termsLookup() == null && (queryBuilder.values() == null || queryBuilder.values().isEmpty())) {         assertThat(query, instanceOf(MatchNoDocsQuery.class)).         MatchNoDocsQuery matchNoDocsQuery = (MatchNoDocsQuery) query.         assertThat(matchNoDocsQuery.toString(), containsString("No terms supplied for \"terms\" query.")).     } else if (queryBuilder.termsLookup() != null && randomTerms.size() == 0) {         assertThat(query, instanceOf(MatchNoDocsQuery.class)).         MatchNoDocsQuery matchNoDocsQuery = (MatchNoDocsQuery) query.         assertThat(matchNoDocsQuery.toString(), containsString("No terms supplied for \"terms\" query.")).     } else {         assertThat(query, either(instanceOf(TermInSetQuery.class)).or(instanceOf(PointInSetQuery.class)).or(instanceOf(ConstantScoreQuery.class))).         if (query instanceof ConstantScoreQuery) {             assertThat(((ConstantScoreQuery) query).getQuery(), instanceOf(BooleanQuery.class)).         }         // we only do the check below for string fields (otherwise we'd have to decode the values)         if (queryBuilder.fieldName().equals(INT_FIELD_NAME) || queryBuilder.fieldName().equals(DOUBLE_FIELD_NAME) || queryBuilder.fieldName().equals(BOOLEAN_FIELD_NAME) || queryBuilder.fieldName().equals(DATE_FIELD_NAME)) {             return.         }         // expected returned terms depending on whether we have a terms query or a terms lookup query         List<Object> terms.         if (queryBuilder.termsLookup() != null) {             terms = randomTerms.         } else {             terms = queryBuilder.values().         }         String fieldName = expectedFieldName(queryBuilder.fieldName()).         TermInSetQuery expected = new TermInSetQuery(fieldName, terms.stream().filter(Objects::nonNull).map(Object::toString).map(BytesRef::new).collect(Collectors.toList())).         assertEquals(expected, query).     } }
false;public;0;6;;public void testEmtpyFieldName() {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new TermsQueryBuilder(null, "term")).     assertEquals("field name cannot be null.", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new TermsQueryBuilder("", "term")).     assertEquals("field name cannot be null.", e.getMessage()). }
false;public;0;4;;public void testEmtpyTermsLookup() {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new TermsQueryBuilder("field", (TermsLookup) null)).     assertEquals("No value or termsLookup specified for terms query", e.getMessage()). }
false;public;0;16;;public void testNullValues() {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new TermsQueryBuilder("field", (String[]) null)).     assertThat(e.getMessage(), containsString("No value specified for terms query")).     e = expectThrows(IllegalArgumentException.class, () -> new TermsQueryBuilder("field", (int[]) null)).     assertThat(e.getMessage(), containsString("No value specified for terms query")).     e = expectThrows(IllegalArgumentException.class, () -> new TermsQueryBuilder("field", (long[]) null)).     assertThat(e.getMessage(), containsString("No value specified for terms query")).     e = expectThrows(IllegalArgumentException.class, () -> new TermsQueryBuilder("field", (float[]) null)).     assertThat(e.getMessage(), containsString("No value specified for terms query")).     e = expectThrows(IllegalArgumentException.class, () -> new TermsQueryBuilder("field", (double[]) null)).     assertThat(e.getMessage(), containsString("No value specified for terms query")).     e = expectThrows(IllegalArgumentException.class, () -> new TermsQueryBuilder("field", (Object[]) null)).     assertThat(e.getMessage(), containsString("No value specified for terms query")).     e = expectThrows(IllegalArgumentException.class, () -> new TermsQueryBuilder("field", (Iterable<?>) null)).     assertThat(e.getMessage(), containsString("No value specified for terms query")). }
false;public;0;19;;public void testBothValuesAndLookupSet() throws IOException {     String query = "{\n" + "  \"terms\": {\n" + "    \"field\": [\n" + "      \"blue\",\n" + "      \"pill\"\n" + "    ],\n" + "    \"field_lookup\": {\n" + "      \"index\": \"pills\",\n" + "      \"type\": \"red\",\n" + "      \"id\": \"3\",\n" + "      \"path\": \"white rabbit\"\n" + "    }\n" + "  }\n" + "}".     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(query)).     assertThat(e.getMessage(), containsString("[" + TermsQueryBuilder.NAME + "] query does not support more than one field.")). }
false;public;1;15;;@Override public GetResponse executeGet(GetRequest getRequest) {     String json.     try {         XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint().         builder.startObject().         builder.array(termsPath, randomTerms.toArray(new Object[randomTerms.size()])).         builder.endObject().         json = Strings.toString(builder).     } catch (IOException ex) {         throw new ElasticsearchException("boom", ex).     }     return new GetResponse(new GetResult(getRequest.index(), getRequest.type(), getRequest.id(), 0, 1, 0, true, new BytesArray(json), null)). }
false;public;0;26;;public void testNumeric() throws IOException {     {         TermsQueryBuilder builder = new TermsQueryBuilder("foo", new int[] { 1, 3, 4 }).         TermsQueryBuilder copy = (TermsQueryBuilder) assertSerialization(builder).         List<Object> values = copy.values().         assertEquals(Arrays.asList(1L, 3L, 4L), values).     }     {         TermsQueryBuilder builder = new TermsQueryBuilder("foo", new double[] { 1, 3, 4 }).         TermsQueryBuilder copy = (TermsQueryBuilder) assertSerialization(builder).         List<Object> values = copy.values().         assertEquals(Arrays.asList(1d, 3d, 4d), values).     }     {         TermsQueryBuilder builder = new TermsQueryBuilder("foo", new float[] { 1, 3, 4 }).         TermsQueryBuilder copy = (TermsQueryBuilder) assertSerialization(builder).         List<Object> values = copy.values().         assertEquals(Arrays.asList(1f, 3f, 4f), values).     }     {         TermsQueryBuilder builder = new TermsQueryBuilder("foo", new long[] { 1, 3, 4 }).         TermsQueryBuilder copy = (TermsQueryBuilder) assertSerialization(builder).         List<Object> values = copy.values().         assertEquals(Arrays.asList(1L, 3L, 4L), values).     } }
false;public;0;7;;public void testTermsQueryWithMultipleFields() throws IOException {     String query = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("terms").array("foo", 123).array("bar", 456).endObject().endObject()).     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(query)).     assertEquals("[" + TermsQueryBuilder.NAME + "] query does not support multiple fields", e.getMessage()). }
false;public;0;13;;public void testFromJson() throws IOException {     String json = "{\n" + "  \"terms\" : {\n" + "    \"user\" : [ \"kimchy\", \"elasticsearch\" ],\n" + "    \"boost\" : 1.0\n" + "  }\n" + "}".     TermsQueryBuilder parsed = (TermsQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     assertEquals(json, 2, parsed.values().size()). }
false;public;0;9;;@Override public void testMustRewrite() throws IOException {     TermsQueryBuilder termsQueryBuilder = new TermsQueryBuilder(STRING_FIELD_NAME, randomTermsLookup()).     UnsupportedOperationException e = expectThrows(UnsupportedOperationException.class, () -> termsQueryBuilder.toQuery(createShardContext())).     assertEquals("query must be rewritten first", e.getMessage()).     assertEquals(rewriteAndFetch(termsQueryBuilder, createShardContext()), new TermsQueryBuilder(STRING_FIELD_NAME, // terms lookup removes null values     randomTerms.stream().filter(x -> x != null).collect(Collectors.toList()))). }
false;public;0;8;;public void testGeo() throws Exception {     TermsQueryBuilder query = new TermsQueryBuilder(GEO_POINT_FIELD_NAME, "2,3").     QueryShardContext context = createShardContext().     QueryShardException e = expectThrows(QueryShardException.class, () -> query.toQuery(context)).     assertEquals("Geo fields do not support exact searching, use dedicated geo queries instead: [mapped_geo_point]", e.getMessage()). }
false;protected;1;6;;@Override protected boolean isCacheable(TermsQueryBuilder queryBuilder) {     // that's why we return true here all the time     return super.isCacheable(queryBuilder). }
false;public;0;8;;public void testSerializationFailsUnlessFetched() throws IOException {     QueryBuilder builder = new TermsQueryBuilder(STRING_FIELD_NAME, randomTermsLookup()).     QueryBuilder termsQueryBuilder = Rewriteable.rewrite(builder, createShardContext()).     IllegalStateException ise = expectThrows(IllegalStateException.class, () -> termsQueryBuilder.writeTo(new BytesStreamOutput(10))).     assertEquals(ise.getMessage(), "supplier must be null, can't serialize suppliers, missing a rewriteAndFetch?").     builder = rewriteAndFetch(builder, createShardContext()).     builder.writeTo(new BytesStreamOutput(10)). }
false;public;0;21;;public void testConversion() {     List<Object> list = Arrays.asList().     assertSame(Collections.emptyList(), TermsQueryBuilder.convert(list)).     assertEquals(list, TermsQueryBuilder.convertBack(TermsQueryBuilder.convert(list))).     list = Arrays.asList("abc").     assertEquals(Arrays.asList(new BytesRef("abc")), TermsQueryBuilder.convert(list)).     assertEquals(list, TermsQueryBuilder.convertBack(TermsQueryBuilder.convert(list))).     list = Arrays.asList("abc", new BytesRef("def")).     assertEquals(Arrays.asList(new BytesRef("abc"), new BytesRef("def")), TermsQueryBuilder.convert(list)).     assertEquals(Arrays.asList("abc", "def"), TermsQueryBuilder.convertBack(TermsQueryBuilder.convert(list))).     list = Arrays.asList(5, 42L).     assertEquals(Arrays.asList(5L, 42L), TermsQueryBuilder.convert(list)).     assertEquals(Arrays.asList(5L, 42L), TermsQueryBuilder.convertBack(TermsQueryBuilder.convert(list))).     list = Arrays.asList(5, 42d).     assertEquals(Arrays.asList(5, 42d), TermsQueryBuilder.convert(list)).     assertEquals(Arrays.asList(5, 42d), TermsQueryBuilder.convertBack(TermsQueryBuilder.convert(list))). }
false;public;0;5;;public void testTypeField() throws IOException {     TermsQueryBuilder builder = QueryBuilders.termsQuery("_type", "value1", "value2").     builder.doToQuery(createShardContext()).     assertWarnings(QueryShardContext.TYPES_DEPRECATION_MESSAGE). }
false;protected;1;11;;@Override protected QueryBuilder parseQuery(XContentParser parser) throws IOException {     QueryBuilder query = super.parseQuery(parser).     assertThat(query, CoreMatchers.instanceOf(TermsQueryBuilder.class)).     TermsQueryBuilder termsQuery = (TermsQueryBuilder) query.     if (termsQuery.isTypeless() == false) {         assertWarnings(TermsQueryBuilder.TYPES_DEPRECATION_MESSAGE).     }     return query. }
