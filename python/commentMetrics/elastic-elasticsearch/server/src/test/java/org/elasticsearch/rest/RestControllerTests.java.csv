commented;modifiers;parameterAmount;loc;comment;code
false;public;0;25;;@Before public void setup() {     Settings settings = Settings.EMPTY.     circuitBreakerService = new HierarchyCircuitBreakerService(Settings.builder().put(HierarchyCircuitBreakerService.IN_FLIGHT_REQUESTS_CIRCUIT_BREAKER_LIMIT_SETTING.getKey(), BREAKER_LIMIT).put(HierarchyCircuitBreakerService.USE_REAL_MEMORY_USAGE_SETTING.getKey(), false).build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)).     usageService = new UsageService().     // we can do this here only because we know that we don't adjust breaker settings dynamically in the test     inFlightRequestsBreaker = circuitBreakerService.getBreaker(CircuitBreaker.IN_FLIGHT_REQUESTS).     HttpServerTransport httpServerTransport = new TestHttpServerTransport().     restController = new RestController(Collections.emptySet(), null, null, circuitBreakerService, usageService).     restController.registerHandler(RestRequest.Method.GET, "/", (request, channel, client) -> channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY))).     restController.registerHandler(RestRequest.Method.GET, "/error", (request, channel, client) -> {         throw new IllegalArgumentException("test error").     }).     httpServerTransport.start(). }
false;public;0;4;;@Override public boolean hasNext() {     return false. }
false;public;0;8;;@Override public MethodHandlers next() {     return new MethodHandlers("/", (RestRequest request, RestChannel channel, NodeClient client) -> {         assertEquals("true", threadContext.getHeader("header.1")).         assertEquals("true", threadContext.getHeader("header.2")).         assertNull(threadContext.getHeader("header.3")).     }, RestRequest.Method.GET). }
false;public;0;34;;public void testApplyRelevantHeaders() throws Exception {     final ThreadContext threadContext = new ThreadContext(Settings.EMPTY).     Set<String> headers = new HashSet<>(Arrays.asList("header.1", "header.2")).     final RestController restController = new RestController(headers, null, null, circuitBreakerService, usageService).     Map<String, List<String>> restHeaders = new HashMap<>().     restHeaders.put("header.1", Collections.singletonList("true")).     restHeaders.put("header.2", Collections.singletonList("true")).     restHeaders.put("header.3", Collections.singletonList("false")).     RestRequest fakeRequest = new FakeRestRequest.Builder(xContentRegistry()).withHeaders(restHeaders).build().     final RestController spyRestController = spy(restController).     when(spyRestController.getAllHandlers(fakeRequest)).thenReturn(new Iterator<MethodHandlers>() {          @Override         public boolean hasNext() {             return false.         }          @Override         public MethodHandlers next() {             return new MethodHandlers("/", (RestRequest request, RestChannel channel, NodeClient client) -> {                 assertEquals("true", threadContext.getHeader("header.1")).                 assertEquals("true", threadContext.getHeader("header.2")).                 assertNull(threadContext.getHeader("header.3")).             }, RestRequest.Method.GET).         }     }).     AssertingChannel channel = new AssertingChannel(fakeRequest, false, RestStatus.BAD_REQUEST).     restController.dispatchRequest(fakeRequest, channel, threadContext).     // the rest controller relies on the caller to stash the context, so we should expect these values here as we didn't stash the     // context in this test     assertEquals("true", threadContext.getHeader("header.1")).     assertEquals("true", threadContext.getHeader("header.2")).     assertNull(threadContext.getHeader("header.3")). }
false;public;0;23;;public void testCanTripCircuitBreaker() throws Exception {     RestController controller = new RestController(Collections.emptySet(), null, null, circuitBreakerService, usageService).     // trip circuit breaker by default     controller.registerHandler(RestRequest.Method.GET, "/trip", new FakeRestHandler(true)).     controller.registerHandler(RestRequest.Method.GET, "/do-not-trip", new FakeRestHandler(false)).     RestRequest fakeRequest = new FakeRestRequest.Builder(xContentRegistry()).withPath("/trip").build().     for (Iterator<MethodHandlers> it = controller.getAllHandlers(fakeRequest). it.hasNext(). ) {         Optional<MethodHandlers> mHandler = Optional.ofNullable(it.next()).         assertTrue(mHandler.map(mh -> controller.canTripCircuitBreaker(mh.getHandler(RestRequest.Method.GET))).orElse(true)).     }     // assume trip even on unknown paths     fakeRequest = new FakeRestRequest.Builder(xContentRegistry()).withPath("/unknown-path").build().     for (Iterator<MethodHandlers> it = controller.getAllHandlers(fakeRequest). it.hasNext(). ) {         Optional<MethodHandlers> mHandler = Optional.ofNullable(it.next()).         assertTrue(mHandler.map(mh -> controller.canTripCircuitBreaker(mh.getHandler(RestRequest.Method.GET))).orElse(true)).     }     fakeRequest = new FakeRestRequest.Builder(xContentRegistry()).withPath("/do-not-trip").build().     for (Iterator<MethodHandlers> it = controller.getAllHandlers(fakeRequest). it.hasNext(). ) {         Optional<MethodHandlers> mHandler = Optional.ofNullable(it.next()).         assertFalse(mHandler.map(mh -> controller.canTripCircuitBreaker(mh.getHandler(RestRequest.Method.GET))).orElse(false)).     } }
false;public;0;16;;public void testRegisterAsDeprecatedHandler() {     RestController controller = mock(RestController.class).     RestRequest.Method method = randomFrom(RestRequest.Method.values()).     String path = "/_" + randomAlphaOfLengthBetween(1, 6).     RestHandler handler = mock(RestHandler.class).     String deprecationMessage = randomAlphaOfLengthBetween(1, 10).     DeprecationLogger logger = mock(DeprecationLogger.class).     // don't want to test everything -- just that it actually wraps the handler     doCallRealMethod().when(controller).registerAsDeprecatedHandler(method, path, handler, deprecationMessage, logger).     controller.registerAsDeprecatedHandler(method, path, handler, deprecationMessage, logger).     verify(controller).registerHandler(eq(method), eq(path), any(DeprecationRestHandler.class)). }
false;public;0;21;;public void testRegisterWithDeprecatedHandler() {     final RestController controller = mock(RestController.class).     final RestRequest.Method method = randomFrom(RestRequest.Method.values()).     final String path = "/_" + randomAlphaOfLengthBetween(1, 6).     final RestHandler handler = mock(RestHandler.class).     final RestRequest.Method deprecatedMethod = randomFrom(RestRequest.Method.values()).     final String deprecatedPath = "/_" + randomAlphaOfLengthBetween(1, 6).     final DeprecationLogger logger = mock(DeprecationLogger.class).     final String deprecationMessage = "[" + deprecatedMethod.name() + " " + deprecatedPath + "] is deprecated! Use [" + method.name() + " " + path + "] instead.".     // don't want to test everything -- just that it actually wraps the handlers     doCallRealMethod().when(controller).registerWithDeprecatedHandler(method, path, handler, deprecatedMethod, deprecatedPath, logger).     controller.registerWithDeprecatedHandler(method, path, handler, deprecatedMethod, deprecatedPath, logger).     verify(controller).registerHandler(method, path, handler).     verify(controller).registerAsDeprecatedHandler(deprecatedMethod, deprecatedPath, handler, deprecationMessage, logger). }
false;public;0;16;;public void testRestHandlerWrapper() throws Exception {     AtomicBoolean handlerCalled = new AtomicBoolean(false).     AtomicBoolean wrapperCalled = new AtomicBoolean(false).     RestHandler handler = (RestRequest request, RestChannel channel, NodeClient client) -> {         handlerCalled.set(true).     }.     UnaryOperator<RestHandler> wrapper = h -> {         assertSame(handler, h).         return (RestRequest request, RestChannel channel, NodeClient client) -> wrapperCalled.set(true).     }.     final RestController restController = new RestController(Collections.emptySet(), wrapper, null, circuitBreakerService, usageService).     restController.dispatchRequest(new FakeRestRequest.Builder(xContentRegistry()).build(), null, null, Optional.of(handler)).     assertTrue(wrapperCalled.get()).     assertFalse(handlerCalled.get()). }
false;public;3;4;;@Override public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception { // no op }
false;public;0;4;;@Override public boolean canTripCircuitBreaker() {     return canTripCircuitBreaker. }
false;public;0;11;;public void testDispatchRequestAddsAndFreesBytesOnSuccess() {     int contentLength = BREAKER_LIMIT.bytesAsInt().     String content = randomAlphaOfLength((int) Math.round(contentLength / inFlightRequestsBreaker.getOverhead())).     RestRequest request = testRestRequest("/", content, XContentType.JSON).     AssertingChannel channel = new AssertingChannel(request, true, RestStatus.OK).     restController.dispatchRequest(request, channel, new ThreadContext(Settings.EMPTY)).     assertEquals(0, inFlightRequestsBreaker.getTrippedCount()).     assertEquals(0, inFlightRequestsBreaker.getUsed()). }
false;public;0;11;;public void testDispatchRequestAddsAndFreesBytesOnError() {     int contentLength = BREAKER_LIMIT.bytesAsInt().     String content = randomAlphaOfLength((int) Math.round(contentLength / inFlightRequestsBreaker.getOverhead())).     RestRequest request = testRestRequest("/error", content, XContentType.JSON).     AssertingChannel channel = new AssertingChannel(request, true, RestStatus.BAD_REQUEST).     restController.dispatchRequest(request, channel, new ThreadContext(Settings.EMPTY)).     assertEquals(0, inFlightRequestsBreaker.getTrippedCount()).     assertEquals(0, inFlightRequestsBreaker.getUsed()). }
false;public;0;12;;public void testDispatchRequestAddsAndFreesBytesOnlyOnceOnError() {     int contentLength = BREAKER_LIMIT.bytesAsInt().     String content = randomAlphaOfLength((int) Math.round(contentLength / inFlightRequestsBreaker.getOverhead())).     // we will produce an error in the rest handler and one more when sending the error response     RestRequest request = testRestRequest("/error", content, XContentType.JSON).     ExceptionThrowingChannel channel = new ExceptionThrowingChannel(request, true).     restController.dispatchRequest(request, channel, new ThreadContext(Settings.EMPTY)).     assertEquals(0, inFlightRequestsBreaker.getTrippedCount()).     assertEquals(0, inFlightRequestsBreaker.getUsed()). }
false;public;0;11;;public void testDispatchRequestLimitsBytes() {     int contentLength = BREAKER_LIMIT.bytesAsInt() + 1.     String content = randomAlphaOfLength((int) Math.round(contentLength / inFlightRequestsBreaker.getOverhead())).     RestRequest request = testRestRequest("/", content, XContentType.JSON).     AssertingChannel channel = new AssertingChannel(request, true, RestStatus.TOO_MANY_REQUESTS).     restController.dispatchRequest(request, channel, new ThreadContext(Settings.EMPTY)).     assertEquals(1, inFlightRequestsBreaker.getTrippedCount()).     assertEquals(0, inFlightRequestsBreaker.getUsed()). }
false;public;0;13;;public void testDispatchRequiresContentTypeForRequestsWithContent() {     String content = randomAlphaOfLength((int) Math.round(BREAKER_LIMIT.getBytes() / inFlightRequestsBreaker.getOverhead())).     RestRequest request = testRestRequest("/", content, null).     AssertingChannel channel = new AssertingChannel(request, true, RestStatus.NOT_ACCEPTABLE).     restController = new RestController(Collections.emptySet(), null, null, circuitBreakerService, usageService).     restController.registerHandler(RestRequest.Method.GET, "/", (r, c, client) -> c.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY))).     assertFalse(channel.getSendResponseCalled()).     restController.dispatchRequest(request, channel, new ThreadContext(Settings.EMPTY)).     assertTrue(channel.getSendResponseCalled()). }
false;public;0;8;;public void testDispatchDoesNotRequireContentTypeForRequestsWithoutContent() {     FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).build().     AssertingChannel channel = new AssertingChannel(fakeRestRequest, true, RestStatus.OK).     assertFalse(channel.getSendResponseCalled()).     restController.dispatchRequest(fakeRestRequest, channel, new ThreadContext(Settings.EMPTY)).     assertTrue(channel.getSendResponseCalled()). }
false;public;3;4;;@Override public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {     channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)). }
false;public;0;17;;public void testDispatchFailsWithPlainText() {     String content = randomAlphaOfLength((int) Math.round(BREAKER_LIMIT.getBytes() / inFlightRequestsBreaker.getOverhead())).     FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).withContent(new BytesArray(content), null).withPath("/foo").withHeaders(Collections.singletonMap("Content-Type", Collections.singletonList("text/plain"))).build().     AssertingChannel channel = new AssertingChannel(fakeRestRequest, true, RestStatus.NOT_ACCEPTABLE).     restController.registerHandler(RestRequest.Method.GET, "/foo", new RestHandler() {          @Override         public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {             channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)).         }     }).     assertFalse(channel.getSendResponseCalled()).     restController.dispatchRequest(fakeRestRequest, channel, new ThreadContext(Settings.EMPTY)).     assertTrue(channel.getSendResponseCalled()). }
false;public;0;10;;public void testDispatchUnsupportedContentType() {     FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).withContent(new BytesArray("{}"), null).withPath("/").withHeaders(Collections.singletonMap("Content-Type", Collections.singletonList("application/x-www-form-urlencoded"))).build().     AssertingChannel channel = new AssertingChannel(fakeRestRequest, true, RestStatus.NOT_ACCEPTABLE).     assertFalse(channel.getSendResponseCalled()).     restController.dispatchRequest(fakeRestRequest, channel, new ThreadContext(Settings.EMPTY)).     assertTrue(channel.getSendResponseCalled()). }
false;public;3;4;;@Override public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {     channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)). }
false;public;0;4;;@Override public boolean supportsContentStream() {     return true. }
false;public;0;23;;public void testDispatchWorksWithNewlineDelimitedJson() {     final String mimeType = "application/x-ndjson".     String content = randomAlphaOfLength((int) Math.round(BREAKER_LIMIT.getBytes() / inFlightRequestsBreaker.getOverhead())).     FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).withContent(new BytesArray(content), null).withPath("/foo").withHeaders(Collections.singletonMap("Content-Type", Collections.singletonList(mimeType))).build().     AssertingChannel channel = new AssertingChannel(fakeRestRequest, true, RestStatus.OK).     restController.registerHandler(RestRequest.Method.GET, "/foo", new RestHandler() {          @Override         public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {             channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)).         }          @Override         public boolean supportsContentStream() {             return true.         }     }).     assertFalse(channel.getSendResponseCalled()).     restController.dispatchRequest(fakeRestRequest, channel, new ThreadContext(Settings.EMPTY)).     assertTrue(channel.getSendResponseCalled()). }
false;public;3;4;;@Override public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {     channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)). }
false;public;0;4;;@Override public boolean supportsContentStream() {     return true. }
false;public;0;24;;public void testDispatchWithContentStream() {     final String mimeType = randomFrom("application/json", "application/smile").     String content = randomAlphaOfLength((int) Math.round(BREAKER_LIMIT.getBytes() / inFlightRequestsBreaker.getOverhead())).     final List<String> contentTypeHeader = Collections.singletonList(mimeType).     FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).withContent(new BytesArray(content), RestRequest.parseContentType(contentTypeHeader)).withPath("/foo").withHeaders(Collections.singletonMap("Content-Type", contentTypeHeader)).build().     AssertingChannel channel = new AssertingChannel(fakeRestRequest, true, RestStatus.OK).     restController.registerHandler(RestRequest.Method.GET, "/foo", new RestHandler() {          @Override         public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {             channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)).         }          @Override         public boolean supportsContentStream() {             return true.         }     }).     assertFalse(channel.getSendResponseCalled()).     restController.dispatchRequest(fakeRestRequest, channel, new ThreadContext(Settings.EMPTY)).     assertTrue(channel.getSendResponseCalled()). }
false;public;3;4;;@Override public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {     channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)). }
false;public;0;4;;@Override public boolean supportsContentStream() {     return true. }
false;public;0;20;;public void testDispatchWithContentStreamNoContentType() {     FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).withContent(new BytesArray("{}"), null).withPath("/foo").build().     AssertingChannel channel = new AssertingChannel(fakeRestRequest, true, RestStatus.NOT_ACCEPTABLE).     restController.registerHandler(RestRequest.Method.GET, "/foo", new RestHandler() {          @Override         public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {             channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)).         }          @Override         public boolean supportsContentStream() {             return true.         }     }).     assertFalse(channel.getSendResponseCalled()).     restController.dispatchRequest(fakeRestRequest, channel, new ThreadContext(Settings.EMPTY)).     assertTrue(channel.getSendResponseCalled()). }
false;public;3;4;;@Override public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {     channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)). }
false;public;0;4;;@Override public boolean supportsContentStream() {     return true. }
false;public;0;20;;public void testNonStreamingXContentCausesErrorResponse() throws IOException {     FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).withContent(BytesReference.bytes(YamlXContent.contentBuilder().startObject().endObject()), XContentType.YAML).withPath("/foo").build().     AssertingChannel channel = new AssertingChannel(fakeRestRequest, true, RestStatus.NOT_ACCEPTABLE).     restController.registerHandler(RestRequest.Method.GET, "/foo", new RestHandler() {          @Override         public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {             channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)).         }          @Override         public boolean supportsContentStream() {             return true.         }     }).     assertFalse(channel.getSendResponseCalled()).     restController.dispatchRequest(fakeRestRequest, channel, new ThreadContext(Settings.EMPTY)).     assertTrue(channel.getSendResponseCalled()). }
false;public;3;4;;@Override public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {     channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)). }
false;public;0;4;;@Override public boolean supportsContentStream() {     return true. }
false;public;0;21;;public void testUnknownContentWithContentStream() {     FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).withContent(new BytesArray("aaaabbbbb"), null).withPath("/foo").withHeaders(Collections.singletonMap("Content-Type", Collections.singletonList("foo/bar"))).build().     AssertingChannel channel = new AssertingChannel(fakeRestRequest, true, RestStatus.NOT_ACCEPTABLE).     restController.registerHandler(RestRequest.Method.GET, "/foo", new RestHandler() {          @Override         public void handleRequest(RestRequest request, RestChannel channel, NodeClient client) throws Exception {             channel.sendResponse(new BytesRestResponse(RestStatus.OK, BytesRestResponse.TEXT_CONTENT_TYPE, BytesArray.EMPTY)).         }          @Override         public boolean supportsContentStream() {             return true.         }     }).     assertFalse(channel.getSendResponseCalled()).     restController.dispatchRequest(fakeRestRequest, channel, new ThreadContext(Settings.EMPTY)).     assertTrue(channel.getSendResponseCalled()). }
false;public;0;11;;public void testDispatchBadRequest() {     final FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).build().     final AssertingChannel channel = new AssertingChannel(fakeRestRequest, true, RestStatus.BAD_REQUEST).     restController.dispatchBadRequest(fakeRestRequest, channel, new ThreadContext(Settings.EMPTY), randomBoolean() ? new IllegalStateException("bad request") : new Throwable("bad request")).     assertTrue(channel.getSendResponseCalled()).     assertThat(channel.getRestResponse().content().utf8ToString(), containsString("bad request")). }
false;public;0;7;;public void testDispatchBadRequestUnknownCause() {     final FakeRestRequest fakeRestRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).build().     final AssertingChannel channel = new AssertingChannel(fakeRestRequest, true, RestStatus.BAD_REQUEST).     restController.dispatchBadRequest(fakeRestRequest, channel, new ThreadContext(Settings.EMPTY), null).     assertTrue(channel.getSendResponseCalled()).     assertThat(channel.getRestResponse().content().utf8ToString(), containsString("unknown cause")). }
false;protected;0;3;;@Override protected void doStart() { }
false;protected;0;3;;@Override protected void doStop() { }
false;protected;0;3;;@Override protected void doClose() { }
false;public;0;5;;@Override public BoundTransportAddress boundAddress() {     TransportAddress transportAddress = buildNewFakeTransportAddress().     return new BoundTransportAddress(new TransportAddress[] { transportAddress }, transportAddress). }
false;public;0;4;;@Override public HttpInfo info() {     return null. }
false;public;0;4;;@Override public HttpStats stats() {     return null. }
false;public;1;5;;@Override public void sendResponse(RestResponse response) {     assertEquals(expectedStatus, response.status()).     responseReference.set(response). }
false;;0;3;;RestResponse getRestResponse() {     return responseReference.get(). }
false;;0;3;;boolean getSendResponseCalled() {     return getRestResponse() != null. }
false;public;1;4;;@Override public void sendResponse(RestResponse response) {     throw new IllegalStateException("always throwing an exception for testing"). }
false;private,static;3;6;;private static RestRequest testRestRequest(String path, String content, XContentType xContentType) {     FakeRestRequest.Builder builder = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY).     builder.withPath(path).     builder.withContent(new BytesArray(content), xContentType).     return builder.build(). }
