commented;modifiers;parameterAmount;loc;comment;code
true;protected,abstract;5;2;/**  * Instantiate a {@link InternalGeoGrid}-derived class using the same parameters as constructor.  */ ;/**  * Instantiate a {@link InternalGeoGrid}-derived class using the same parameters as constructor.  */ protected abstract T createInternalGeoGrid(String name, int size, List<InternalGeoGridBucket> buckets, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData).
true;protected,abstract;3;1;/**  * Instantiate a {@link InternalGeoGridBucket}-derived class using the same parameters as constructor.  */ ;/**  * Instantiate a {@link InternalGeoGridBucket}-derived class using the same parameters as constructor.  */ protected abstract B createInternalGeoGridBucket(Long key, long docCount, InternalAggregations aggregations).
true;protected,abstract;3;1;/**  * Encode longitude and latitude with a given precision as a long hash.  */ ;/**  * Encode longitude and latitude with a given precision as a long hash.  */ protected abstract long longEncode(double lng, double lat, int precision).
true;protected,abstract;0;1;/**  * Generate a random precision according to the rules of the given aggregation.  */ ;/**  * Generate a random precision according to the rules of the given aggregation.  */ protected abstract int randomPrecision().
false;protected;0;4;;@Override protected int minNumberOfBuckets() {     return 1. }
false;protected;0;4;;@Override protected int maxNumberOfBuckets() {     return 3. }
false;protected;4;17;;@Override protected T createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData, InternalAggregations aggregations) {     final int precision = randomPrecision().     int size = randomNumberOfBuckets().     List<InternalGeoGridBucket> buckets = new ArrayList<>(size).     for (int i = 0. i < size. i++) {         double latitude = randomDoubleBetween(-90.0, 90.0, false).         double longitude = randomDoubleBetween(-180.0, 180.0, false).         long hashAsLong = longEncode(longitude, latitude, precision).         buckets.add(createInternalGeoGridBucket(hashAsLong, randomInt(IndexWriter.MAX_DOCS), aggregations)).     }     return createInternalGeoGrid(name, size, buckets, pipelineAggregators, metaData). }
false;protected;2;38;;@Override protected void assertReduced(T reduced, List<T> inputs) {     Map<Long, List<B>> map = new HashMap<>().     for (T input : inputs) {         for (GeoGrid.Bucket bucketBase : input.getBuckets()) {             B bucket = (B) bucketBase.             List<B> buckets = map.get(bucket.hashAsLong).             if (buckets == null) {                 map.put(bucket.hashAsLong, buckets = new ArrayList<>()).             }             buckets.add(bucket).         }     }     List<B> expectedBuckets = new ArrayList<>().     for (Map.Entry<Long, List<B>> entry : map.entrySet()) {         long docCount = 0.         for (B bucket : entry.getValue()) {             docCount += bucket.docCount.         }         expectedBuckets.add(createInternalGeoGridBucket(entry.getKey(), docCount, InternalAggregations.EMPTY)).     }     expectedBuckets.sort((first, second) -> {         int cmp = Long.compare(second.docCount, first.docCount).         if (cmp == 0) {             return second.compareTo(first).         }         return cmp.     }).     int requestedSize = inputs.get(0).getRequiredSize().     expectedBuckets = expectedBuckets.subList(0, Math.min(requestedSize, expectedBuckets.size())).     assertEquals(expectedBuckets.size(), reduced.getBuckets().size()).     for (int i = 0. i < reduced.getBuckets().size(). i++) {         GeoGrid.Bucket expected = expectedBuckets.get(i).         GeoGrid.Bucket actual = reduced.getBuckets().get(i).         assertEquals(expected.getDocCount(), actual.getDocCount()).         assertEquals(expected.getKey(), actual.getKey()).     } }
false;protected;0;4;;@Override protected Class<? extends ParsedMultiBucketAggregation> implementationClass() {     return ParsedGeoGrid.class. }
false;protected;1;32;;@Override protected T mutateInstance(T instance) {     String name = instance.getName().     int size = instance.getRequiredSize().     List<InternalGeoGridBucket> buckets = instance.getBuckets().     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 3)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             buckets = new ArrayList<>(buckets).             buckets.add(createInternalGeoGridBucket(randomNonNegativeLong(), randomInt(IndexWriter.MAX_DOCS), InternalAggregations.EMPTY)).             break.         case 2:             size = size + between(1, 10).             break.         case 3:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return createInternalGeoGrid(name, size, buckets, pipelineAggregators, metaData). }
false;public;0;4;;public void testCreateFromBuckets() {     InternalGeoGrid original = createTestInstance().     assertThat(original, equalTo(original.create(original.buckets))). }
