commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;public void testNoRetention() throws IOException {     long now = System.currentTimeMillis().     Tuple<List<TranslogReader>, TranslogWriter> readersAndWriter = createReadersAndWriter(now).     List<BaseTranslogReader> allGens = new ArrayList<>(readersAndWriter.v1()).     allGens.add(readersAndWriter.v2()).     try {         TranslogDeletionPolicy deletionPolicy = new MockDeletionPolicy(now, 0, 0).         assertMinGenRequired(deletionPolicy, readersAndWriter, 1L).         final int committedReader = randomIntBetween(0, allGens.size() - 1).         final long committedGen = allGens.get(committedReader).generation.         deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(committedGen, Long.MAX_VALUE)).         deletionPolicy.setMinTranslogGenerationForRecovery(committedGen).         assertMinGenRequired(deletionPolicy, readersAndWriter, committedGen).     } finally {         IOUtils.close(readersAndWriter.v1()).         IOUtils.close(readersAndWriter.v2()).     } }
false;public;0;18;;public void testBytesRetention() throws IOException {     long now = System.currentTimeMillis().     Tuple<List<TranslogReader>, TranslogWriter> readersAndWriter = createReadersAndWriter(now).     List<BaseTranslogReader> allGens = new ArrayList<>(readersAndWriter.v1()).     allGens.add(readersAndWriter.v2()).     try {         final int selectedReader = randomIntBetween(0, allGens.size() - 1).         final long selectedGeneration = allGens.get(selectedReader).generation.         long size = allGens.stream().skip(selectedReader).map(BaseTranslogReader::sizeInBytes).reduce(Long::sum).get().         assertThat(TranslogDeletionPolicy.getMinTranslogGenBySize(readersAndWriter.v1(), readersAndWriter.v2(), size), equalTo(selectedGeneration)).         assertThat(TranslogDeletionPolicy.getMinTranslogGenBySize(readersAndWriter.v1(), readersAndWriter.v2(), -1), equalTo(Long.MIN_VALUE)).     } finally {         IOUtils.close(readersAndWriter.v1()).         IOUtils.close(readersAndWriter.v2()).     } }
false;public;0;18;;public void testAgeRetention() throws IOException {     long now = System.currentTimeMillis().     Tuple<List<TranslogReader>, TranslogWriter> readersAndWriter = createReadersAndWriter(now).     List<BaseTranslogReader> allGens = new ArrayList<>(readersAndWriter.v1()).     allGens.add(readersAndWriter.v2()).     try {         final int selectedReader = randomIntBetween(0, allGens.size() - 1).         final long selectedGeneration = allGens.get(selectedReader).generation.         long maxAge = now - allGens.get(selectedReader).getLastModifiedTime().         assertThat(TranslogDeletionPolicy.getMinTranslogGenByAge(readersAndWriter.v1(), readersAndWriter.v2(), maxAge, now), equalTo(selectedGeneration)).         assertThat(TranslogDeletionPolicy.getMinTranslogGenByAge(readersAndWriter.v1(), readersAndWriter.v2(), -1, now), equalTo(Long.MIN_VALUE)).     } finally {         IOUtils.close(readersAndWriter.v1()).         IOUtils.close(readersAndWriter.v2()).     } }
true;public;0;49;/**  * Tests that age trumps size but recovery trumps both.  */ ;/**  * Tests that age trumps size but recovery trumps both.  */ public void testRetentionHierarchy() throws IOException {     long now = System.currentTimeMillis().     Tuple<List<TranslogReader>, TranslogWriter> readersAndWriter = createReadersAndWriter(now).     List<BaseTranslogReader> allGens = new ArrayList<>(readersAndWriter.v1()).     allGens.add(readersAndWriter.v2()).     try {         TranslogDeletionPolicy deletionPolicy = new MockDeletionPolicy(now, Long.MAX_VALUE, Long.MAX_VALUE).         deletionPolicy.setTranslogGenerationOfLastCommit(Long.MAX_VALUE).         deletionPolicy.setMinTranslogGenerationForRecovery(Long.MAX_VALUE).         int selectedReader = randomIntBetween(0, allGens.size() - 1).         final long selectedGenerationByAge = allGens.get(selectedReader).generation.         long maxAge = now - allGens.get(selectedReader).getLastModifiedTime().         selectedReader = randomIntBetween(0, allGens.size() - 1).         final long selectedGenerationBySize = allGens.get(selectedReader).generation.         long size = allGens.stream().skip(selectedReader).map(BaseTranslogReader::sizeInBytes).reduce(Long::sum).get().         deletionPolicy.setRetentionAgeInMillis(maxAge).         deletionPolicy.setRetentionSizeInBytes(size).         assertMinGenRequired(deletionPolicy, readersAndWriter, Math.max(selectedGenerationByAge, selectedGenerationBySize)).         // make a new policy as committed gen can't go backwards (for now)         deletionPolicy = new MockDeletionPolicy(now, size, maxAge).         long committedGen = randomFrom(allGens).generation.         deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(committedGen, Long.MAX_VALUE)).         deletionPolicy.setMinTranslogGenerationForRecovery(committedGen).         assertMinGenRequired(deletionPolicy, readersAndWriter, Math.min(committedGen, Math.max(selectedGenerationByAge, selectedGenerationBySize))).         long viewGen = randomFrom(allGens).generation.         try (Releasable ignored = deletionPolicy.acquireTranslogGen(viewGen)) {             assertMinGenRequired(deletionPolicy, readersAndWriter, Math.min(Math.min(committedGen, viewGen), Math.max(selectedGenerationByAge, selectedGenerationBySize))).             // disable age             deletionPolicy.setRetentionAgeInMillis(-1).             assertMinGenRequired(deletionPolicy, readersAndWriter, Math.min(Math.min(committedGen, viewGen), selectedGenerationBySize)).             // disable size             deletionPolicy.setRetentionAgeInMillis(maxAge).             deletionPolicy.setRetentionSizeInBytes(-1).             assertMinGenRequired(deletionPolicy, readersAndWriter, Math.min(Math.min(committedGen, viewGen), selectedGenerationByAge)).             // disable both             deletionPolicy.setRetentionAgeInMillis(-1).             deletionPolicy.setRetentionSizeInBytes(-1).             assertMinGenRequired(deletionPolicy, readersAndWriter, Math.min(committedGen, viewGen)).         }     } finally {         IOUtils.close(readersAndWriter.v1()).         IOUtils.close(readersAndWriter.v2()).     } }
false;private;3;4;;private void assertMinGenRequired(TranslogDeletionPolicy deletionPolicy, Tuple<List<TranslogReader>, TranslogWriter> readersAndWriter, long expectedGen) throws IOException {     assertThat(deletionPolicy.minTranslogGenRequired(readersAndWriter.v1(), readersAndWriter.v2()), equalTo(expectedGen)). }
false;private;1;30;;private Tuple<List<TranslogReader>, TranslogWriter> createReadersAndWriter(final long now) throws IOException {     final Path tempDir = createTempDir().     Files.createFile(tempDir.resolve(Translog.CHECKPOINT_FILE_NAME)).     TranslogWriter writer = null.     List<TranslogReader> readers = new ArrayList<>().     final int numberOfReaders = randomIntBetween(0, 10).     final String translogUUID = UUIDs.randomBase64UUID(random()).     for (long gen = 1. gen <= numberOfReaders + 1. gen++) {         if (writer != null) {             final TranslogReader reader = Mockito.spy(writer.closeIntoReader()).             Mockito.doReturn(writer.getLastModifiedTime()).when(reader).getLastModifiedTime().             readers.add(reader).         }         writer = TranslogWriter.create(new ShardId("index", "uuid", 0), translogUUID, gen, tempDir.resolve(Translog.getFilename(gen)), FileChannel::open, TranslogConfig.DEFAULT_BUFFER_SIZE, 1L, 1L, () -> 1L, () -> 1L, randomNonNegativeLong(), new TragicExceptionHolder()).         writer = Mockito.spy(writer).         Mockito.doReturn(now - (numberOfReaders - gen + 1) * 1000).when(writer).getLastModifiedTime().         byte[] bytes = new byte[4].         ByteArrayDataOutput out = new ByteArrayDataOutput(bytes).         for (int ops = randomIntBetween(0, 20). ops > 0. ops--) {             out.reset(bytes).             out.writeInt(ops).             writer.add(new BytesArray(bytes), ops).         }     }     return new Tuple<>(readers, writer). }
false;protected;0;4;;@Override protected long currentTime() {     return now. }
