commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected BytesReference newBytesReference(int length) throws IOException {     return newBytesReferenceWithOffsetOfZero(length). }
false;protected;1;8;;@Override protected BytesReference newBytesReferenceWithOffsetOfZero(int length) throws IOException {     // we know bytes stream output always creates a paged bytes reference, we use it to create randomized content     List<BytesReference> referenceList = newRefList(length).     BytesReference ref = new CompositeBytesReference(referenceList.toArray(new BytesReference[0])).     assertEquals(length, ref.length()).     return ref. }
false;private;1;15;;private List<BytesReference> newRefList(int length) throws IOException {     List<BytesReference> referenceList = new ArrayList<>().     for (int i = 0. i < length. ) {         int remaining = length - i.         int sliceLength = randomIntBetween(1, remaining).         ReleasableBytesStreamOutput out = new ReleasableBytesStreamOutput(sliceLength, bigarrays).         for (int j = 0. j < sliceLength. j++) {             out.writeByte((byte) random().nextInt(1 << 8)).         }         assertEquals(sliceLength, out.size()).         referenceList.add(out.bytes()).         i += sliceLength.     }     return referenceList. }
false;public;0;38;;public void testCompositeBuffer() throws IOException {     List<BytesReference> referenceList = newRefList(randomIntBetween(1, PAGE_SIZE * 2)).     BytesReference ref = new CompositeBytesReference(referenceList.toArray(new BytesReference[0])).     BytesRefIterator iterator = ref.iterator().     BytesRefBuilder builder = new BytesRefBuilder().     for (BytesReference reference : referenceList) {         // sometimes we have a paged ref - pull an iter and walk all pages!         BytesRefIterator innerIter = reference.iterator().         BytesRef scratch.         while ((scratch = innerIter.next()) != null) {             BytesRef next = iterator.next().             assertNotNull(next).             assertEquals(next, scratch).             builder.append(next).         }     }     assertNull(iterator.next()).     int offset = 0.     for (BytesReference reference : referenceList) {         assertEquals(reference, ref.slice(offset, reference.length())).         int probes = randomIntBetween(Math.min(10, reference.length()), reference.length()).         for (int i = 0. i < probes. i++) {             int index = randomIntBetween(0, reference.length() - 1).             assertEquals(ref.get(offset + index), reference.get(index)).         }         offset += reference.length().     }     BytesArray array = new BytesArray(builder.toBytesRef()).     assertEquals(array, ref).     assertEquals(array.hashCode(), ref.hashCode()).     BytesStreamOutput output = new BytesStreamOutput().     ref.writeTo(output).     assertEquals(array, output.bytes()). }
false;public;0;4;;@Override public void testToBytesRefSharedPage() throws IOException { // CompositeBytesReference doesn't share pages }
false;public;0;4;;@Override public void testSliceArrayOffset() throws IOException { // the assertions in this test only work on no-composite buffers }
false;public;0;4;;@Override public void testSliceToBytesRef() throws IOException { // CompositeBytesReference shifts offsets }
false;public;0;13;;public void testSliceIsNotCompositeIfMatchesSingleSubSlice() {     CompositeBytesReference bytesRef = new CompositeBytesReference(new BytesArray(new byte[12]), new BytesArray(new byte[15]), new BytesArray(new byte[13])).     // Slices that cross boundaries are composite too     assertThat(bytesRef.slice(5, 8), Matchers.instanceOf(CompositeBytesReference.class)).     // But not slices that cover a single sub reference     // strictly within sub     assertThat(bytesRef.slice(13, 10), Matchers.not(Matchers.instanceOf(CompositeBytesReference.class))).     // equal to sub     assertThat(bytesRef.slice(12, 15), Matchers.not(Matchers.instanceOf(CompositeBytesReference.class))). }
