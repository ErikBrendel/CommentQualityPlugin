commented;modifiers;parameterAmount;loc;comment;code
false;public;0;41;;public void testNoShardRelocationsOccurWhenElectedMasterNodeFails() throws Exception {     Settings defaultSettings = Settings.builder().put(FaultDetection.PING_TIMEOUT_SETTING.getKey(), "1s").put(FaultDetection.PING_RETRIES_SETTING.getKey(), "1").build().     Settings masterNodeSettings = Settings.builder().put(Node.NODE_DATA_SETTING.getKey(), false).put(defaultSettings).build().     internalCluster().startNodes(2, masterNodeSettings).     Settings dateNodeSettings = Settings.builder().put(Node.NODE_MASTER_SETTING.getKey(), false).put(defaultSettings).build().     internalCluster().startNodes(2, dateNodeSettings).     ClusterHealthResponse clusterHealthResponse = client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).setWaitForNodes("4").setWaitForNoRelocatingShards(true).get().     assertThat(clusterHealthResponse.isTimedOut(), is(false)).     createIndex("test").     ensureSearchable("test").     RecoveryResponse r = client().admin().indices().prepareRecoveries("test").get().     int numRecoveriesBeforeNewMaster = r.shardRecoveryStates().get("test").size().     final String oldMaster = internalCluster().getMasterName().     internalCluster().stopCurrentMasterNode().     assertBusy(() -> {         String current = internalCluster().getMasterName().         assertThat(current, notNullValue()).         assertThat(current, not(equalTo(oldMaster))).     }).     ensureSearchable("test").     r = client().admin().indices().prepareRecoveries("test").get().     int numRecoveriesAfterNewMaster = r.shardRecoveryStates().get("test").size().     assertThat(numRecoveriesAfterNewMaster, equalTo(numRecoveriesBeforeNewMaster)). }
false;public;0;38;;public void testNodeFailuresAreProcessedOnce() throws IOException {     Settings defaultSettings = Settings.builder().put(FaultDetection.PING_TIMEOUT_SETTING.getKey(), "1s").put(FaultDetection.PING_RETRIES_SETTING.getKey(), "1").build().     Settings masterNodeSettings = Settings.builder().put(Node.NODE_DATA_SETTING.getKey(), false).put(defaultSettings).build().     String master = internalCluster().startNode(masterNodeSettings).     Settings dateNodeSettings = Settings.builder().put(Node.NODE_MASTER_SETTING.getKey(), false).put(defaultSettings).build().     internalCluster().startNodes(2, dateNodeSettings).     client().admin().cluster().prepareHealth().setWaitForNodes("3").get().     ClusterService clusterService = internalCluster().getInstance(ClusterService.class, master).     final AtomicInteger numUpdates = new AtomicInteger().     final CountDownLatch nodesStopped = new CountDownLatch(1).     clusterService.addStateApplier(event -> {         numUpdates.incrementAndGet().         try {             // block until both nodes have stopped to accumulate node failures             nodesStopped.await().         } catch (InterruptedException e) {         // meh         }     }).     internalCluster().stopRandomNonMasterNode().     internalCluster().stopRandomNonMasterNode().     nodesStopped.countDown().     // wait for all to be processed     client().admin().cluster().prepareHealth().setWaitForEvents(Priority.LANGUID).get().     // due to batching, both nodes can be handled in same CS update     assertThat(numUpdates.get(), either(equalTo(1)).or(equalTo(2))). }
false;public;0;4;;@Override public void onSuccess() {     future.completeExceptionally(new AssertionError("onSuccess should not be called")). }
false;public;1;4;;@Override public void onFailure(Exception e) {     future.complete(e). }
false;public;0;34;;public void testHandleNodeJoin_incompatibleClusterState() throws InterruptedException, ExecutionException, TimeoutException {     String masterNode = internalCluster().startMasterOnlyNode().     String node1 = internalCluster().startNode().     ClusterService clusterService = internalCluster().getInstance(ClusterService.class, node1).     Coordinator coordinator = (Coordinator) internalCluster().getInstance(Discovery.class, masterNode).     final ClusterState state = clusterService.state().     MetaData.Builder mdBuilder = MetaData.builder(state.metaData()).     mdBuilder.putCustom(CustomMetaData.TYPE, new CustomMetaData("data")).     ClusterState stateWithCustomMetaData = ClusterState.builder(state).metaData(mdBuilder).build().     final CompletableFuture<Throwable> future = new CompletableFuture<>().     DiscoveryNode node = state.nodes().getLocalNode().     coordinator.sendValidateJoinRequest(stateWithCustomMetaData, new JoinRequest(node, Optional.empty()), new JoinHelper.JoinCallback() {          @Override         public void onSuccess() {             future.completeExceptionally(new AssertionError("onSuccess should not be called")).         }          @Override         public void onFailure(Exception e) {             future.complete(e).         }     }).     Throwable t = future.get(10, TimeUnit.SECONDS).     assertTrue(t instanceof IllegalStateException).     assertTrue(t.getCause() instanceof RemoteTransportException).     assertTrue(t.getCause().getCause() instanceof IllegalArgumentException).     assertThat(t.getCause().getCause().getMessage(), containsString("Unknown NamedWriteable")). }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return Version.CURRENT. }
false;public;0;4;;@Override public EnumSet<MetaData.XContentContext> context() {     return EnumSet.of(MetaData.XContentContext.GATEWAY, MetaData.XContentContext.SNAPSHOT). }
false;public;0;44;;public void testDiscoveryStats() throws Exception {     String expectedStatsJsonResponse = "{\n" + "  \"discovery\" : {\n" + "    \"cluster_state_queue\" : {\n" + "      \"total\" : 0,\n" + "      \"pending\" : 0,\n" + "      \"committed\" : 0\n" + "    },\n" + "    \"published_cluster_states\" : {\n" + "      \"full_states\" : 0,\n" + "      \"incompatible_diffs\" : 0,\n" + "      \"compatible_diffs\" : 0\n" + "    }\n" + "  }\n" + "}".     internalCluster().startNode().     // ensures that all events are processed (in particular state recovery fully completed)     ensureGreen().     assertBusy(() -> assertThat(internalCluster().clusterService(internalCluster().getMasterName()).getMasterService().numberOfPendingTasks(), // see https://github.com/elastic/elasticsearch/issues/24388     equalTo(0))).     logger.info("--> request node discovery stats").     NodesStatsResponse statsResponse = client().admin().cluster().prepareNodesStats().clear().setDiscovery(true).get().     assertThat(statsResponse.getNodes().size(), equalTo(1)).     DiscoveryStats stats = statsResponse.getNodes().get(0).getDiscoveryStats().     assertThat(stats.getQueueStats(), notNullValue()).     assertThat(stats.getQueueStats().getTotal(), equalTo(0)).     assertThat(stats.getQueueStats().getCommitted(), equalTo(0)).     assertThat(stats.getQueueStats().getPending(), equalTo(0)).     assertThat(stats.getPublishStats(), notNullValue()).     assertThat(stats.getPublishStats().getFullClusterStateReceivedCount(), equalTo(0L)).     assertThat(stats.getPublishStats().getIncompatibleClusterStateDiffReceivedCount(), equalTo(0L)).     assertThat(stats.getPublishStats().getCompatibleClusterStateDiffReceivedCount(), equalTo(0L)).     XContentBuilder builder = XContentFactory.jsonBuilder().prettyPrint().     builder.startObject().     stats.toXContent(builder, ToXContent.EMPTY_PARAMS).     builder.endObject().     assertThat(Strings.toString(builder), equalTo(expectedStatsJsonResponse)). }
