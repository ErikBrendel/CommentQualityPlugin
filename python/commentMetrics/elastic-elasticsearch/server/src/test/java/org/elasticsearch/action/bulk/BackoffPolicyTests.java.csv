commented;modifiers;parameterAmount;loc;comment;code
false;public;0;33;;public void testWrapBackoffPolicy() {     TimeValue timeValue = timeValueMillis(between(0, Integer.MAX_VALUE)).     int maxNumberOfRetries = between(1, 1000).     BackoffPolicy policy = BackoffPolicy.constantBackoff(timeValue, maxNumberOfRetries).     AtomicInteger retries = new AtomicInteger().     policy = BackoffPolicy.wrap(policy, retries::getAndIncrement).     int expectedRetries = 0.     {         // Fetching the iterator doesn't call the callback         Iterator<TimeValue> itr = policy.iterator().         assertEquals(expectedRetries, retries.get()).         while (itr.hasNext()) {             // hasNext doesn't trigger the callback             assertEquals(expectedRetries, retries.get()).             // next does             itr.next().             expectedRetries += 1.             assertEquals(expectedRetries, retries.get()).         }         // next doesn't call the callback when there isn't a backoff available         expectThrows(NoSuchElementException.class, () -> itr.next()).         assertEquals(expectedRetries, retries.get()).     }     {         // The second iterator also calls the callback         Iterator<TimeValue> itr = policy.iterator().         itr.next().         expectedRetries += 1.         assertEquals(expectedRetries, retries.get()).     } }
