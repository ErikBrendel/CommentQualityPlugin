commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;@Override public void setUp() throws Exception {     super.setUp().     // we have to prefer CURRENT since with the range of versions we support     // it's rather unlikely to get the current actually.     Settings settings = Settings.builder().put("node.name", AbstractQueryTestCase.class.toString()).put(Environment.PATH_HOME_SETTING.getKey(), createTempDir()).build().     // create some random type with some default field, those types will     // stick around for all of the subclasses     currentTypes = new String[randomIntBetween(0, 5)].     for (int i = 0. i < currentTypes.length. i++) {         String type = randomAlphaOfLengthBetween(1, 10).         currentTypes[i] = type.     }     xContentRegistry = new NamedXContentRegistry(new SearchModule(settings, false, emptyList()).getNamedXContents()). }
false;public;0;6;;public void testGetAggregatorFactories_returnsUnmodifiableList() {     AggregatorFactories.Builder builder = new AggregatorFactories.Builder().addAggregator(AggregationBuilders.avg("foo")).     Collection<AggregationBuilder> aggregatorFactories = builder.getAggregatorFactories().     assertThat(aggregatorFactories.size(), equalTo(1)).     expectThrows(UnsupportedOperationException.class, () -> aggregatorFactories.add(AggregationBuilders.avg("bar"))). }
false;public;0;8;;public void testGetPipelineAggregatorFactories_returnsUnmodifiableList() {     AggregatorFactories.Builder builder = new AggregatorFactories.Builder().addPipelineAggregator(PipelineAggregatorBuilders.avgBucket("foo", "path1")).     Collection<PipelineAggregationBuilder> pipelineAggregatorFactories = builder.getPipelineAggregatorFactories().     assertThat(pipelineAggregatorFactories.size(), equalTo(1)).     expectThrows(UnsupportedOperationException.class, () -> pipelineAggregatorFactories.add(PipelineAggregatorBuilders.avgBucket("bar", "path2"))). }
false;public;0;21;;public void testTwoTypes() throws Exception {     XContentBuilder source = JsonXContent.contentBuilder().startObject().startObject("in_stock").startObject("filter").startObject("range").startObject("stock").field("gt", 0).endObject().endObject().endObject().startObject("terms").field("field", "stock").endObject().endObject().endObject().     XContentParser parser = createParser(source).     assertSame(XContentParser.Token.START_OBJECT, parser.nextToken()).     Exception e = expectThrows(ParsingException.class, () -> AggregatorFactories.parseAggregators(parser)).     assertThat(e.toString(), containsString("Found two aggregation type definitions in [in_stock]: [filter] and [terms]")). }
false;public;0;33;;public void testInvalidAggregationName() throws Exception {     Matcher matcher = Pattern.compile("[^\\[\\]>]+").matcher("").     String name.     Random rand = random().     int len = randomIntBetween(1, 5).     char[] word = new char[len].     while (true) {         for (int i = 0. i < word.length. i++) {             word[i] = (char) rand.nextInt(127).         }         name = String.valueOf(word).         if (!matcher.reset(name).matches()) {             break.         }     }     XContentBuilder source = JsonXContent.contentBuilder().startObject().startObject(name).startObject("filter").startObject("range").startObject("stock").field("gt", 0).endObject().endObject().endObject().endObject().endObject().     XContentParser parser = createParser(source).     assertSame(XContentParser.Token.START_OBJECT, parser.nextToken()).     Exception e = expectThrows(ParsingException.class, () -> AggregatorFactories.parseAggregators(parser)).     assertThat(e.toString(), containsString("Invalid aggregation name [" + name + "]")). }
false;public;0;23;;public void testMissingName() throws Exception {     XContentBuilder source = JsonXContent.contentBuilder().startObject().startObject("by_date").startObject("date_histogram").field("field", "timestamp").field("interval", "month").endObject().startObject("aggs").startObject("cardinality").field("field", "tag").endObject().endObject().endObject().endObject().     XContentParser parser = createParser(source).     assertSame(XContentParser.Token.START_OBJECT, parser.nextToken()).     Exception e = expectThrows(ParsingException.class, () -> AggregatorFactories.parseAggregators(parser)).     assertThat(e.toString(), containsString("Expected [START_OBJECT] under [field], but got a [VALUE_STRING] in [cardinality]")). }
false;public;0;23;;public void testMissingType() throws Exception {     XContentBuilder source = JsonXContent.contentBuilder().startObject().startObject("by_date").startObject("date_histogram").field("field", "timestamp").field("interval", "month").endObject().startObject("aggs").startObject("tag_count").field("field", "tag").endObject().endObject().endObject().endObject().     XContentParser parser = createParser(source).     assertSame(XContentParser.Token.START_OBJECT, parser.nextToken()).     Exception e = expectThrows(ParsingException.class, () -> AggregatorFactories.parseAggregators(parser)).     assertThat(e.toString(), containsString("Expected [START_OBJECT] under [field], but got a [VALUE_STRING] in [tag_count]")). }
false;public;0;37;;public void testRewrite() throws Exception {     XContentType xContentType = randomFrom(XContentType.values()).     BytesReference bytesReference.     try (XContentBuilder builder = XContentFactory.contentBuilder(xContentType)) {         builder.startObject().         {             builder.startObject("terms").             {                 builder.array("title", "foo").             }             builder.endObject().         }         builder.endObject().         bytesReference = BytesReference.bytes(builder).     }     FilterAggregationBuilder filterAggBuilder = new FilterAggregationBuilder("titles", new WrapperQueryBuilder(bytesReference)).     BucketScriptPipelineAggregationBuilder pipelineAgg = new BucketScriptPipelineAggregationBuilder("const", new Script("1")).     AggregatorFactories.Builder builder = new AggregatorFactories.Builder().addAggregator(filterAggBuilder).addPipelineAggregator(pipelineAgg).     AggregatorFactories.Builder rewritten = builder.rewrite(new QueryRewriteContext(xContentRegistry, null, null, () -> 0L)).     assertNotSame(builder, rewritten).     Collection<AggregationBuilder> aggregatorFactories = rewritten.getAggregatorFactories().     assertEquals(1, aggregatorFactories.size()).     assertThat(aggregatorFactories.iterator().next(), instanceOf(FilterAggregationBuilder.class)).     FilterAggregationBuilder rewrittenFilterAggBuilder = (FilterAggregationBuilder) aggregatorFactories.iterator().next().     assertNotSame(filterAggBuilder, rewrittenFilterAggBuilder).     assertNotEquals(filterAggBuilder, rewrittenFilterAggBuilder).     // Check the filter was rewritten from a wrapper query to a terms query     QueryBuilder rewrittenFilter = rewrittenFilterAggBuilder.getFilter().     assertThat(rewrittenFilter, instanceOf(TermsQueryBuilder.class)).     // Check that a further rewrite returns the same aggregation factories builder     AggregatorFactories.Builder secondRewritten = rewritten.rewrite(new QueryRewriteContext(xContentRegistry, null, null, () -> 0L)).     assertSame(rewritten, secondRewritten). }
false;protected;0;4;;@Override protected NamedXContentRegistry xContentRegistry() {     return xContentRegistry. }
