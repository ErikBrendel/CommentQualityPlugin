commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected int minNumberOfBuckets() {     return 1. }
false;public;0;26;;@Override public void setUp() throws Exception {     super.setUp().     List<Tuple<BytesRef, BytesRef>> listOfRanges = new ArrayList<>().     if (randomBoolean()) {         listOfRanges.add(Tuple.tuple(null, new BytesRef(randomAlphaOfLength(15)))).     }     if (randomBoolean()) {         listOfRanges.add(Tuple.tuple(new BytesRef(randomAlphaOfLength(15)), null)).     }     if (randomBoolean()) {         listOfRanges.add(Tuple.tuple(null, null)).     }     final int numRanges = Math.max(0, randomNumberOfBuckets() - listOfRanges.size()).     for (int i = 0. i < numRanges. i++) {         BytesRef[] values = new BytesRef[2].         values[0] = new BytesRef(randomAlphaOfLength(15)).         values[1] = new BytesRef(randomAlphaOfLength(15)).         Arrays.sort(values).         listOfRanges.add(Tuple.tuple(values[0], values[1])).     }     Collections.shuffle(listOfRanges, random()).     ranges = Collections.unmodifiableList(listOfRanges). }
false;protected;5;17;;@Override protected InternalBinaryRange createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData, InternalAggregations aggregations, boolean keyed) {     DocValueFormat format = DocValueFormat.RAW.     List<InternalBinaryRange.Bucket> buckets = new ArrayList<>().     int nullKey = randomBoolean() ? randomIntBetween(0, ranges.size() - 1) : -1.     for (int i = 0. i < ranges.size(). ++i) {         final int docCount = randomIntBetween(1, 100).         final String key = (i == nullKey) ? null : randomAlphaOfLength(10).         buckets.add(new InternalBinaryRange.Bucket(format, keyed, key, ranges.get(i).v1(), ranges.get(i).v2(), docCount, aggregations)).     }     return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators, metaData). }
false;protected;0;4;;@Override protected Writeable.Reader<InternalBinaryRange> instanceReader() {     return InternalBinaryRange::new. }
false;protected;0;4;;@Override protected Class<? extends ParsedMultiBucketAggregation> implementationClass() {     return ParsedBinaryRange.class. }
false;protected;2;15;;@Override protected void assertReduced(InternalBinaryRange reduced, List<InternalBinaryRange> inputs) {     int pos = 0.     for (InternalBinaryRange input : inputs) {         assertEquals(reduced.getBuckets().size(), input.getBuckets().size()).     }     for (Range.Bucket bucket : reduced.getBuckets()) {         int expectedCount = 0.         for (InternalBinaryRange input : inputs) {             expectedCount += input.getBuckets().get(pos).getDocCount().         }         assertEquals(expectedCount, bucket.getDocCount()).         pos++.     } }
false;protected;0;4;;@Override protected Class<? extends InternalMultiBucketAggregation.InternalBucket> internalRangeBucketClass() {     return InternalBinaryRange.Bucket.class. }
false;protected;0;4;;@Override protected Class<? extends ParsedMultiBucketAggregation.ParsedBucket> parsedRangeBucketClass() {     return ParsedBinaryRange.ParsedBucket.class. }
false;protected;1;33;;@Override protected InternalBinaryRange mutateInstance(InternalBinaryRange instance) {     String name = instance.getName().     DocValueFormat format = instance.format.     boolean keyed = instance.keyed.     List<InternalBinaryRange.Bucket> buckets = instance.getBuckets().     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 3)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             keyed = keyed == false.             break.         case 2:             buckets = new ArrayList<>(buckets).             buckets.add(new InternalBinaryRange.Bucket(format, keyed, "range_a", new BytesRef(randomAlphaOfLengthBetween(1, 20)), new BytesRef(randomAlphaOfLengthBetween(1, 20)), randomNonNegativeLong(), InternalAggregations.EMPTY)).             break.         case 3:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new InternalBinaryRange(name, format, keyed, buckets, pipelineAggregators, metaData). }
true;public;0;6;/**  * Checks the invariant that bucket keys are always non-null, even if null keys  * were originally provided.  */ ;/**  * Checks the invariant that bucket keys are always non-null, even if null keys  * were originally provided.  */ public void testKeyGeneration() {     InternalBinaryRange range = createTestInstance().     for (InternalBinaryRange.Bucket bucket : range.getBuckets()) {         assertNotNull(bucket.getKey()).     } }
