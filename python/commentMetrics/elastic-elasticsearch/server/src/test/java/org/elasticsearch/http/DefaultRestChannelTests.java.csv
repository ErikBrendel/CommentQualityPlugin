commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void setup() {     httpChannel = mock(HttpChannel.class).     threadPool = new TestThreadPool("test").     bigArrays = new MockBigArrays(new MockPageCacheRecycler(Settings.EMPTY), new NoneCircuitBreakerService()). }
false;public;0;6;;@After public void shutdown() {     if (threadPool != null) {         threadPool.shutdownNow().     } }
false;public;0;4;;public void testResponse() {     final TestResponse response = executeRequest(Settings.EMPTY, "request-host").     assertThat(response.content(), equalTo(new TestRestResponse().content())). }
false;public;0;27;;// TODO: Enable these Cors tests when the Cors logic lives in :server // public void testCorsEnabledWithoutAllowOrigins() { // // Set up an HTTP transport with only the CORS enabled setting // Settings settings = Settings.builder() // .put(HttpTransportSettings.SETTING_CORS_ENABLED.getKey(), true) // .build(). // HttpResponse response = executeRequest(settings, "remote-host", "request-host"). // // inspect response and validate // assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), nullValue()). // } //  // public void testCorsEnabledWithAllowOrigins() { // final String originValue = "remote-host". // // create an HTTP transport with CORS enabled and allow origin configured // Settings settings = Settings.builder() // .put(SETTING_CORS_ENABLED.getKey(), true) // .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue) // .build(). // HttpResponse response = executeRequest(settings, originValue, "request-host"). // // inspect response and validate // assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue()). // String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN). // assertThat(allowedOrigins, is(originValue)). // } //  // public void testCorsAllowOriginWithSameHost() { // String originValue = "remote-host". // String host = "remote-host". // // create an HTTP transport with CORS enabled // Settings settings = Settings.builder() // .put(SETTING_CORS_ENABLED.getKey(), true) // .build(). // HttpResponse response = executeRequest(settings, originValue, host). // // inspect response and validate // assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue()). // String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN). // assertThat(allowedOrigins, is(originValue)). //  // originValue = "http://" + originValue. // response = executeRequest(settings, originValue, host). // assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue()). // allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN). // assertThat(allowedOrigins, is(originValue)). //  // originValue = originValue + ":5555". // host = host + ":5555". // response = executeRequest(settings, originValue, host). // assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue()). // allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN). // assertThat(allowedOrigins, is(originValue)). //  // originValue = originValue.replace("http", "https"). // response = executeRequest(settings, originValue, host). // assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue()). // allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN). // assertThat(allowedOrigins, is(originValue)). // } //  // public void testThatStringLiteralWorksOnMatch() { // final String originValue = "remote-host". // Settings settings = Settings.builder() // .put(SETTING_CORS_ENABLED.getKey(), true) // .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue) // .put(SETTING_CORS_ALLOW_METHODS.getKey(), "get, options, post") // .put(SETTING_CORS_ALLOW_CREDENTIALS.getKey(), true) // .build(). // HttpResponse response = executeRequest(settings, originValue, "request-host"). // // inspect response and validate // assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue()). // String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN). // assertThat(allowedOrigins, is(originValue)). // assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS), equalTo("true")). // } //  // public void testThatAnyOriginWorks() { // final String originValue = NioCorsHandler.ANY_ORIGIN. // Settings settings = Settings.builder() // .put(SETTING_CORS_ENABLED.getKey(), true) // .put(SETTING_CORS_ALLOW_ORIGIN.getKey(), originValue) // .build(). // HttpResponse response = executeRequest(settings, originValue, "request-host"). // // inspect response and validate // assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN), notNullValue()). // String allowedOrigins = response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_ORIGIN). // assertThat(allowedOrigins, is(originValue)). // assertThat(response.headers().get(HttpHeaderNames.ACCESS_CONTROL_ALLOW_CREDENTIALS), nullValue()). // } public void testHeadersSet() {     Settings settings = Settings.builder().build().     final TestRequest httpRequest = new TestRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/").     httpRequest.getHeaders().put(Task.X_OPAQUE_ID, Collections.singletonList("abc")).     final RestRequest request = RestRequest.request(xContentRegistry(), httpRequest, httpChannel).     HttpHandlingSettings handlingSettings = HttpHandlingSettings.fromSettings(settings).     // send a response     DefaultRestChannel channel = new DefaultRestChannel(httpChannel, httpRequest, request, bigArrays, handlingSettings, threadPool.getThreadContext()).     TestRestResponse resp = new TestRestResponse().     final String customHeader = "custom-header".     final String customHeaderValue = "xyz".     resp.addHeader(customHeader, customHeaderValue).     channel.sendResponse(resp).     // inspect what was written     ArgumentCaptor<TestResponse> responseCaptor = ArgumentCaptor.forClass(TestResponse.class).     verify(httpChannel).sendResponse(responseCaptor.capture(), any()).     TestResponse httpResponse = responseCaptor.getValue().     Map<String, List<String>> headers = httpResponse.headers.     assertNull(headers.get("non-existent-header")).     assertEquals(customHeaderValue, headers.get(customHeader).get(0)).     assertEquals("abc", headers.get(Task.X_OPAQUE_ID).get(0)).     assertEquals(Integer.toString(resp.content().length()), headers.get(DefaultRestChannel.CONTENT_LENGTH).get(0)).     assertEquals(resp.contentType(), headers.get(DefaultRestChannel.CONTENT_TYPE).get(0)). }
false;public;0;20;;public void testCookiesSet() {     Settings settings = Settings.builder().put(HttpTransportSettings.SETTING_HTTP_RESET_COOKIES.getKey(), true).build().     final TestRequest httpRequest = new TestRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/").     httpRequest.getHeaders().put(Task.X_OPAQUE_ID, Collections.singletonList("abc")).     final RestRequest request = RestRequest.request(xContentRegistry(), httpRequest, httpChannel).     HttpHandlingSettings handlingSettings = HttpHandlingSettings.fromSettings(settings).     // send a response     DefaultRestChannel channel = new DefaultRestChannel(httpChannel, httpRequest, request, bigArrays, handlingSettings, threadPool.getThreadContext()).     channel.sendResponse(new TestRestResponse()).     // inspect what was written     ArgumentCaptor<TestResponse> responseCaptor = ArgumentCaptor.forClass(TestResponse.class).     verify(httpChannel).sendResponse(responseCaptor.capture(), any()).     TestResponse nioResponse = responseCaptor.getValue().     Map<String, List<String>> headers = nioResponse.headers.     assertThat(headers.get(DefaultRestChannel.SET_COOKIE), hasItem("cookie")).     assertThat(headers.get(DefaultRestChannel.SET_COOKIE), hasItem("cookie2")). }
false;public;0;36;;@SuppressWarnings("unchecked") public void testReleaseInListener() throws IOException {     final Settings settings = Settings.builder().build().     final TestRequest httpRequest = new TestRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/").     final RestRequest request = RestRequest.request(xContentRegistry(), httpRequest, httpChannel).     HttpHandlingSettings handlingSettings = HttpHandlingSettings.fromSettings(settings).     DefaultRestChannel channel = new DefaultRestChannel(httpChannel, httpRequest, request, bigArrays, handlingSettings, threadPool.getThreadContext()).     final BytesRestResponse response = new BytesRestResponse(RestStatus.INTERNAL_SERVER_ERROR, JsonXContent.contentBuilder().startObject().endObject()).     assertThat(response.content(), not(instanceOf(Releasable.class))).     // ensure we have reserved bytes     if (randomBoolean()) {         BytesStreamOutput out = channel.bytesOutput().         assertThat(out, instanceOf(ReleasableBytesStreamOutput.class)).     } else {         try (XContentBuilder builder = channel.newBuilder()) {             // do something builder             builder.startObject().endObject().         }     }     channel.sendResponse(response).     Class<ActionListener<Void>> listenerClass = (Class<ActionListener<Void>>) (Class) ActionListener.class.     ArgumentCaptor<ActionListener<Void>> listenerCaptor = ArgumentCaptor.forClass(listenerClass).     verify(httpChannel).sendResponse(any(), listenerCaptor.capture()).     ActionListener<Void> listener = listenerCaptor.getValue().     if (randomBoolean()) {         listener.onResponse(null).     } else {         listener.onFailure(new ClosedChannelException()).     } // ESTestCase#after will invoke ensureAllArraysAreReleased which will fail if the response content was not released }
false;public;0;38;;@SuppressWarnings("unchecked") public void testConnectionClose() throws Exception {     final Settings settings = Settings.builder().build().     final HttpRequest httpRequest.     final boolean close = randomBoolean().     if (randomBoolean()) {         httpRequest = new TestRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/").         if (close) {             httpRequest.getHeaders().put(DefaultRestChannel.CONNECTION, Collections.singletonList(DefaultRestChannel.CLOSE)).         }     } else {         httpRequest = new TestRequest(HttpRequest.HttpVersion.HTTP_1_0, RestRequest.Method.GET, "/").         if (!close) {             httpRequest.getHeaders().put(DefaultRestChannel.CONNECTION, Collections.singletonList(DefaultRestChannel.KEEP_ALIVE)).         }     }     final RestRequest request = RestRequest.request(xContentRegistry(), httpRequest, httpChannel).     HttpHandlingSettings handlingSettings = HttpHandlingSettings.fromSettings(settings).     DefaultRestChannel channel = new DefaultRestChannel(httpChannel, httpRequest, request, bigArrays, handlingSettings, threadPool.getThreadContext()).     channel.sendResponse(new TestRestResponse()).     Class<ActionListener<Void>> listenerClass = (Class<ActionListener<Void>>) (Class) ActionListener.class.     ArgumentCaptor<ActionListener<Void>> listenerCaptor = ArgumentCaptor.forClass(listenerClass).     verify(httpChannel).sendResponse(any(), listenerCaptor.capture()).     ActionListener<Void> listener = listenerCaptor.getValue().     if (randomBoolean()) {         listener.onResponse(null).     } else {         listener.onFailure(new ClosedChannelException()).     }     if (close) {         verify(httpChannel, times(1)).close().     } else {         verify(httpChannel, times(0)).close().     } }
false;private;2;3;;private TestResponse executeRequest(final Settings settings, final String host) {     return executeRequest(settings, null, host). }
false;private;3;19;;private TestResponse executeRequest(final Settings settings, final String originValue, final String host) {     HttpRequest httpRequest = new TestRequest(HttpRequest.HttpVersion.HTTP_1_1, RestRequest.Method.GET, "/").     // TODO: These exist for the Cors tests     // if (originValue != null) {     // httpRequest.headers().add(HttpHeaderNames.ORIGIN, originValue).     // }     // httpRequest.headers().add(HttpHeaderNames.HOST, host).     final RestRequest request = RestRequest.request(xContentRegistry(), httpRequest, httpChannel).     HttpHandlingSettings httpHandlingSettings = HttpHandlingSettings.fromSettings(settings).     RestChannel channel = new DefaultRestChannel(httpChannel, httpRequest, request, bigArrays, httpHandlingSettings, threadPool.getThreadContext()).     channel.sendResponse(new TestRestResponse()).     // get the response     ArgumentCaptor<TestResponse> responseCaptor = ArgumentCaptor.forClass(TestResponse.class).     verify(httpChannel, atLeastOnce()).sendResponse(responseCaptor.capture(), any()).     return responseCaptor.getValue(). }
false;public;0;4;;@Override public RestRequest.Method method() {     return method. }
false;public;0;4;;@Override public String uri() {     return uri. }
false;public;0;4;;@Override public BytesReference content() {     return BytesArray.EMPTY. }
false;public;0;4;;@Override public Map<String, List<String>> getHeaders() {     return headers. }
false;public;0;4;;@Override public List<String> strictCookies() {     return Arrays.asList("cookie", "cookie2"). }
false;public;0;4;;@Override public HttpVersion protocolVersion() {     return version. }
false;public;1;4;;@Override public HttpRequest removeHeader(String header) {     throw new UnsupportedOperationException("Do not support removing header on test request."). }
false;public;2;4;;@Override public HttpResponse createResponse(RestStatus status, BytesReference content) {     return new TestResponse(status, content). }
false;public;0;3;;public String contentType() {     return "text". }
false;public;0;3;;public BytesReference content() {     return content. }
false;public;0;3;;public RestStatus status() {     return status. }
false;public;2;10;;@Override public void addHeader(String name, String value) {     if (headers.containsKey(name) == false) {         ArrayList<String> values = new ArrayList<>().         values.add(value).         headers.put(name, values).     } else {         headers.get(name).add(value).     } }
false;public;1;4;;@Override public boolean containsHeader(String name) {     return headers.containsKey(name). }
false;public;0;3;;public String contentType() {     return "text". }
false;public;0;3;;public BytesReference content() {     return content. }
false;public;0;3;;public RestStatus status() {     return RestStatus.OK. }
