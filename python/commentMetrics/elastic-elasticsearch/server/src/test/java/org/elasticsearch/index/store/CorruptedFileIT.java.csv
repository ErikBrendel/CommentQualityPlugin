# id;timestamp;commentText;codeText;commentWords;codeWords
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1524684173;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1526574077;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1526900724;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1527096592;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1528762805;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1534203100;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1536137328;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1542697754;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1544598203;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1544628062;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1545201550;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> public void testReplicaCorruption() throws Exception;1547022296;This test verifies that if we corrupt a replica, we can still get to green, even though_listing its store fails. Note, we need to make sure that replicas are allocated on all data_nodes, so that replica won't be sneaky and allocated on a node that doesn't have a corrupted_replica.;public void testReplicaCorruption() throws Exception {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, cluster().numDataNodes() - 1)_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(),_                new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        _        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), "primaries")_        ))___        internalCluster().fullRestart()___        ensureYellow()___        final Index index = resolveIndex("test")___        final IndicesShardStoresResponse stores = client().admin().indices().prepareShardStores(index.getName()).get()____        for (IntObjectCursor<List<IndicesShardStoresResponse.StoreStatus>> shards :_            stores.getStoreStatuses().get(index.getName())) {_            for (IndicesShardStoresResponse.StoreStatus store : shards.value) {_                final ShardId shardId = new ShardId(index, shards.key)__                if (store.getAllocationStatus().equals(IndicesShardStoresResponse.StoreStatus.AllocationStatus.UNUSED)) {_                    for (Path path : findFilesToCorruptOnNode(store.getNode().getName(), shardId)) {_                        try (OutputStream os = Files.newOutputStream(path)) {_                            os.write(0)__                        }_                        logger.info("corrupting file {} on node {}", path, store.getNode().getName())__                    }_                }_            }_        }__        _        assertAcked(client().admin().cluster().prepareUpdateSettings().setPersistentSettings(_            Settings.builder().putNull(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey())_        ))___        ensureGreen()__    };this,test,verifies,that,if,we,corrupt,a,replica,we,can,still,get,to,green,even,though,listing,its,store,fails,note,we,need,to,make,sure,that,replicas,are,allocated,on,all,data,nodes,so,that,replica,won,t,be,sneaky,and,allocated,on,a,node,that,doesn,t,have,a,corrupted,replica;public,void,test,replica,corruption,throws,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,cluster,num,data,nodes,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,enable,allocation,decider,get,key,primaries,internal,cluster,full,restart,ensure,yellow,final,index,index,resolve,index,test,final,indices,shard,stores,response,stores,client,admin,indices,prepare,shard,stores,index,get,name,get,for,int,object,cursor,list,indices,shard,stores,response,store,status,shards,stores,get,store,statuses,get,index,get,name,for,indices,shard,stores,response,store,status,store,shards,value,final,shard,id,shard,id,new,shard,id,index,shards,key,if,store,get,allocation,status,equals,indices,shard,stores,response,store,status,allocation,status,unused,for,path,path,find,files,to,corrupt,on,node,store,get,node,get,name,shard,id,try,output,stream,os,files,new,output,stream,path,os,write,0,logger,info,corrupting,file,on,node,path,store,get,node,get,name,assert,acked,client,admin,cluster,prepare,update,settings,set,persistent,settings,settings,builder,put,null,enable,allocation,decider,get,key,ensure,green
CorruptedFileIT -> private void pruneOldDeleteGenerations(Set<Path> files);1524684173;prunes the list of index files such that only the latest del generation files are contained.;private void pruneOldDeleteGenerations(Set<Path> files) {_        final TreeSet<Path> delFiles = new TreeSet<>()__        for (Path file : files) {_            if (file.getFileName().toString().endsWith(".liv")) {_                delFiles.add(file)__            }_        }_        Path last = null__        for (Path current : delFiles) {_            if (last != null) {_                final String newSegmentName = IndexFileNames.parseSegmentName(current.getFileName().toString())__                final String oldSegmentName = IndexFileNames.parseSegmentName(last.getFileName().toString())__                if (newSegmentName.equals(oldSegmentName)) {_                    int oldGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(last.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    int newGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(current.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    if (newGen > oldGen) {_                        files.remove(last)__                    } else {_                        files.remove(current)__                        continue__                    }_                }_            }_            last = current__        }_    };prunes,the,list,of,index,files,such,that,only,the,latest,del,generation,files,are,contained;private,void,prune,old,delete,generations,set,path,files,final,tree,set,path,del,files,new,tree,set,for,path,file,files,if,file,get,file,name,to,string,ends,with,liv,del,files,add,file,path,last,null,for,path,current,del,files,if,last,null,final,string,new,segment,name,index,file,names,parse,segment,name,current,get,file,name,to,string,final,string,old,segment,name,index,file,names,parse,segment,name,last,get,file,name,to,string,if,new,segment,name,equals,old,segment,name,int,old,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,last,get,file,name,to,string,replace,character,int,new,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,current,get,file,name,to,string,replace,character,if,new,gen,old,gen,files,remove,last,else,files,remove,current,continue,last,current
CorruptedFileIT -> private void pruneOldDeleteGenerations(Set<Path> files);1526574077;prunes the list of index files such that only the latest del generation files are contained.;private void pruneOldDeleteGenerations(Set<Path> files) {_        final TreeSet<Path> delFiles = new TreeSet<>()__        for (Path file : files) {_            if (file.getFileName().toString().endsWith(".liv")) {_                delFiles.add(file)__            }_        }_        Path last = null__        for (Path current : delFiles) {_            if (last != null) {_                final String newSegmentName = IndexFileNames.parseSegmentName(current.getFileName().toString())__                final String oldSegmentName = IndexFileNames.parseSegmentName(last.getFileName().toString())__                if (newSegmentName.equals(oldSegmentName)) {_                    int oldGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(last.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    int newGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(current.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    if (newGen > oldGen) {_                        files.remove(last)__                    } else {_                        files.remove(current)__                        continue__                    }_                }_            }_            last = current__        }_    };prunes,the,list,of,index,files,such,that,only,the,latest,del,generation,files,are,contained;private,void,prune,old,delete,generations,set,path,files,final,tree,set,path,del,files,new,tree,set,for,path,file,files,if,file,get,file,name,to,string,ends,with,liv,del,files,add,file,path,last,null,for,path,current,del,files,if,last,null,final,string,new,segment,name,index,file,names,parse,segment,name,current,get,file,name,to,string,final,string,old,segment,name,index,file,names,parse,segment,name,last,get,file,name,to,string,if,new,segment,name,equals,old,segment,name,int,old,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,last,get,file,name,to,string,replace,character,int,new,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,current,get,file,name,to,string,replace,character,if,new,gen,old,gen,files,remove,last,else,files,remove,current,continue,last,current
CorruptedFileIT -> private void pruneOldDeleteGenerations(Set<Path> files);1526900724;prunes the list of index files such that only the latest del generation files are contained.;private void pruneOldDeleteGenerations(Set<Path> files) {_        final TreeSet<Path> delFiles = new TreeSet<>()__        for (Path file : files) {_            if (file.getFileName().toString().endsWith(".liv")) {_                delFiles.add(file)__            }_        }_        Path last = null__        for (Path current : delFiles) {_            if (last != null) {_                final String newSegmentName = IndexFileNames.parseSegmentName(current.getFileName().toString())__                final String oldSegmentName = IndexFileNames.parseSegmentName(last.getFileName().toString())__                if (newSegmentName.equals(oldSegmentName)) {_                    int oldGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(last.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    int newGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(current.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    if (newGen > oldGen) {_                        files.remove(last)__                    } else {_                        files.remove(current)__                        continue__                    }_                }_            }_            last = current__        }_    };prunes,the,list,of,index,files,such,that,only,the,latest,del,generation,files,are,contained;private,void,prune,old,delete,generations,set,path,files,final,tree,set,path,del,files,new,tree,set,for,path,file,files,if,file,get,file,name,to,string,ends,with,liv,del,files,add,file,path,last,null,for,path,current,del,files,if,last,null,final,string,new,segment,name,index,file,names,parse,segment,name,current,get,file,name,to,string,final,string,old,segment,name,index,file,names,parse,segment,name,last,get,file,name,to,string,if,new,segment,name,equals,old,segment,name,int,old,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,last,get,file,name,to,string,replace,character,int,new,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,current,get,file,name,to,string,replace,character,if,new,gen,old,gen,files,remove,last,else,files,remove,current,continue,last,current
CorruptedFileIT -> private void pruneOldDeleteGenerations(Set<Path> files);1527096592;prunes the list of index files such that only the latest del generation files are contained.;private void pruneOldDeleteGenerations(Set<Path> files) {_        final TreeSet<Path> delFiles = new TreeSet<>()__        for (Path file : files) {_            if (file.getFileName().toString().endsWith(".liv")) {_                delFiles.add(file)__            }_        }_        Path last = null__        for (Path current : delFiles) {_            if (last != null) {_                final String newSegmentName = IndexFileNames.parseSegmentName(current.getFileName().toString())__                final String oldSegmentName = IndexFileNames.parseSegmentName(last.getFileName().toString())__                if (newSegmentName.equals(oldSegmentName)) {_                    int oldGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(last.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    int newGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(current.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    if (newGen > oldGen) {_                        files.remove(last)__                    } else {_                        files.remove(current)__                        continue__                    }_                }_            }_            last = current__        }_    };prunes,the,list,of,index,files,such,that,only,the,latest,del,generation,files,are,contained;private,void,prune,old,delete,generations,set,path,files,final,tree,set,path,del,files,new,tree,set,for,path,file,files,if,file,get,file,name,to,string,ends,with,liv,del,files,add,file,path,last,null,for,path,current,del,files,if,last,null,final,string,new,segment,name,index,file,names,parse,segment,name,current,get,file,name,to,string,final,string,old,segment,name,index,file,names,parse,segment,name,last,get,file,name,to,string,if,new,segment,name,equals,old,segment,name,int,old,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,last,get,file,name,to,string,replace,character,int,new,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,current,get,file,name,to,string,replace,character,if,new,gen,old,gen,files,remove,last,else,files,remove,current,continue,last,current
CorruptedFileIT -> private void pruneOldDeleteGenerations(Set<Path> files);1528762805;prunes the list of index files such that only the latest del generation files are contained.;private void pruneOldDeleteGenerations(Set<Path> files) {_        final TreeSet<Path> delFiles = new TreeSet<>()__        for (Path file : files) {_            if (file.getFileName().toString().endsWith(".liv")) {_                delFiles.add(file)__            }_        }_        Path last = null__        for (Path current : delFiles) {_            if (last != null) {_                final String newSegmentName = IndexFileNames.parseSegmentName(current.getFileName().toString())__                final String oldSegmentName = IndexFileNames.parseSegmentName(last.getFileName().toString())__                if (newSegmentName.equals(oldSegmentName)) {_                    int oldGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(last.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    int newGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(current.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    if (newGen > oldGen) {_                        files.remove(last)__                    } else {_                        files.remove(current)__                        continue__                    }_                }_            }_            last = current__        }_    };prunes,the,list,of,index,files,such,that,only,the,latest,del,generation,files,are,contained;private,void,prune,old,delete,generations,set,path,files,final,tree,set,path,del,files,new,tree,set,for,path,file,files,if,file,get,file,name,to,string,ends,with,liv,del,files,add,file,path,last,null,for,path,current,del,files,if,last,null,final,string,new,segment,name,index,file,names,parse,segment,name,current,get,file,name,to,string,final,string,old,segment,name,index,file,names,parse,segment,name,last,get,file,name,to,string,if,new,segment,name,equals,old,segment,name,int,old,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,last,get,file,name,to,string,replace,character,int,new,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,current,get,file,name,to,string,replace,character,if,new,gen,old,gen,files,remove,last,else,files,remove,current,continue,last,current
CorruptedFileIT -> private void pruneOldDeleteGenerations(Set<Path> files);1534203100;prunes the list of index files such that only the latest del generation files are contained.;private void pruneOldDeleteGenerations(Set<Path> files) {_        final TreeSet<Path> delFiles = new TreeSet<>()__        for (Path file : files) {_            if (file.getFileName().toString().endsWith(".liv")) {_                delFiles.add(file)__            }_        }_        Path last = null__        for (Path current : delFiles) {_            if (last != null) {_                final String newSegmentName = IndexFileNames.parseSegmentName(current.getFileName().toString())__                final String oldSegmentName = IndexFileNames.parseSegmentName(last.getFileName().toString())__                if (newSegmentName.equals(oldSegmentName)) {_                    int oldGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(last.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    int newGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(current.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    if (newGen > oldGen) {_                        files.remove(last)__                    } else {_                        files.remove(current)__                        continue__                    }_                }_            }_            last = current__        }_    };prunes,the,list,of,index,files,such,that,only,the,latest,del,generation,files,are,contained;private,void,prune,old,delete,generations,set,path,files,final,tree,set,path,del,files,new,tree,set,for,path,file,files,if,file,get,file,name,to,string,ends,with,liv,del,files,add,file,path,last,null,for,path,current,del,files,if,last,null,final,string,new,segment,name,index,file,names,parse,segment,name,current,get,file,name,to,string,final,string,old,segment,name,index,file,names,parse,segment,name,last,get,file,name,to,string,if,new,segment,name,equals,old,segment,name,int,old,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,last,get,file,name,to,string,replace,character,int,new,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,current,get,file,name,to,string,replace,character,if,new,gen,old,gen,files,remove,last,else,files,remove,current,continue,last,current
CorruptedFileIT -> private void pruneOldDeleteGenerations(Set<Path> files);1536137328;prunes the list of index files such that only the latest del generation files are contained.;private void pruneOldDeleteGenerations(Set<Path> files) {_        final TreeSet<Path> delFiles = new TreeSet<>()__        for (Path file : files) {_            if (file.getFileName().toString().endsWith(".liv")) {_                delFiles.add(file)__            }_        }_        Path last = null__        for (Path current : delFiles) {_            if (last != null) {_                final String newSegmentName = IndexFileNames.parseSegmentName(current.getFileName().toString())__                final String oldSegmentName = IndexFileNames.parseSegmentName(last.getFileName().toString())__                if (newSegmentName.equals(oldSegmentName)) {_                    int oldGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(last.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    int newGen = Integer.parseInt(IndexFileNames.stripExtension(IndexFileNames.stripSegmentName(current.getFileName().toString())).replace("_", ""), Character.MAX_RADIX)__                    if (newGen > oldGen) {_                        files.remove(last)__                    } else {_                        files.remove(current)__                        continue__                    }_                }_            }_            last = current__        }_    };prunes,the,list,of,index,files,such,that,only,the,latest,del,generation,files,are,contained;private,void,prune,old,delete,generations,set,path,files,final,tree,set,path,del,files,new,tree,set,for,path,file,files,if,file,get,file,name,to,string,ends,with,liv,del,files,add,file,path,last,null,for,path,current,del,files,if,last,null,final,string,new,segment,name,index,file,names,parse,segment,name,current,get,file,name,to,string,final,string,old,segment,name,index,file,names,parse,segment,name,last,get,file,name,to,string,if,new,segment,name,equals,old,segment,name,int,old,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,last,get,file,name,to,string,replace,character,int,new,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,current,get,file,name,to,string,replace,character,if,new,gen,old,gen,files,remove,last,else,files,remove,current,continue,last,current
CorruptedFileIT -> private void pruneOldDeleteGenerations(Set<Path> files);1542697754;prunes the list of index files such that only the latest del generation files are contained.;private void pruneOldDeleteGenerations(Set<Path> files) {_        final TreeSet<Path> delFiles = new TreeSet<>()__        for (Path file : files) {_            if (file.getFileName().toString().endsWith(".liv")) {_                delFiles.add(file)__            }_        }_        Path last = null__        for (Path current : delFiles) {_            if (last != null) {_                final String newSegmentName = IndexFileNames.parseSegmentName(current.getFileName().toString())__                final String oldSegmentName = IndexFileNames.parseSegmentName(last.getFileName().toString())__                if (newSegmentName.equals(oldSegmentName)) {_                    int oldGen =_                        Integer.parseInt(_                            IndexFileNames.stripExtension(_                                IndexFileNames.stripSegmentName(last.getFileName().toString())).replace("_", ""),_                            Character.MAX_RADIX_                        )__                    int newGen = Integer.parseInt(_                        IndexFileNames.stripExtension(_                            IndexFileNames.stripSegmentName(current.getFileName().toString())).replace("_", ""),_                        Character.MAX_RADIX)__                    if (newGen > oldGen) {_                        files.remove(last)__                    } else {_                        files.remove(current)__                        continue__                    }_                }_            }_            last = current__        }_    };prunes,the,list,of,index,files,such,that,only,the,latest,del,generation,files,are,contained;private,void,prune,old,delete,generations,set,path,files,final,tree,set,path,del,files,new,tree,set,for,path,file,files,if,file,get,file,name,to,string,ends,with,liv,del,files,add,file,path,last,null,for,path,current,del,files,if,last,null,final,string,new,segment,name,index,file,names,parse,segment,name,current,get,file,name,to,string,final,string,old,segment,name,index,file,names,parse,segment,name,last,get,file,name,to,string,if,new,segment,name,equals,old,segment,name,int,old,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,last,get,file,name,to,string,replace,character,int,new,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,current,get,file,name,to,string,replace,character,if,new,gen,old,gen,files,remove,last,else,files,remove,current,continue,last,current
CorruptedFileIT -> private void pruneOldDeleteGenerations(Set<Path> files);1544598203;prunes the list of index files such that only the latest del generation files are contained.;private void pruneOldDeleteGenerations(Set<Path> files) {_        final TreeSet<Path> delFiles = new TreeSet<>()__        for (Path file : files) {_            if (file.getFileName().toString().endsWith(".liv")) {_                delFiles.add(file)__            }_        }_        Path last = null__        for (Path current : delFiles) {_            if (last != null) {_                final String newSegmentName = IndexFileNames.parseSegmentName(current.getFileName().toString())__                final String oldSegmentName = IndexFileNames.parseSegmentName(last.getFileName().toString())__                if (newSegmentName.equals(oldSegmentName)) {_                    int oldGen =_                        Integer.parseInt(_                            IndexFileNames.stripExtension(_                                IndexFileNames.stripSegmentName(last.getFileName().toString())).replace("_", ""),_                            Character.MAX_RADIX_                        )__                    int newGen = Integer.parseInt(_                        IndexFileNames.stripExtension(_                            IndexFileNames.stripSegmentName(current.getFileName().toString())).replace("_", ""),_                        Character.MAX_RADIX)__                    if (newGen > oldGen) {_                        files.remove(last)__                    } else {_                        files.remove(current)__                        continue__                    }_                }_            }_            last = current__        }_    };prunes,the,list,of,index,files,such,that,only,the,latest,del,generation,files,are,contained;private,void,prune,old,delete,generations,set,path,files,final,tree,set,path,del,files,new,tree,set,for,path,file,files,if,file,get,file,name,to,string,ends,with,liv,del,files,add,file,path,last,null,for,path,current,del,files,if,last,null,final,string,new,segment,name,index,file,names,parse,segment,name,current,get,file,name,to,string,final,string,old,segment,name,index,file,names,parse,segment,name,last,get,file,name,to,string,if,new,segment,name,equals,old,segment,name,int,old,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,last,get,file,name,to,string,replace,character,int,new,gen,integer,parse,int,index,file,names,strip,extension,index,file,names,strip,segment,name,current,get,file,name,to,string,replace,character,if,new,gen,old,gen,files,remove,last,else,files,remove,current,continue,last,current
CorruptedFileIT -> private void pruneOldDeleteGenerations(Set<Path> files);1544628062;prunes the list of index files such that only the latest del generation files are contained.;private void pruneOldDeleteGenerations(Set<Path> files) {_        final TreeSet<Path> delFiles = new TreeSet<>()__        for (Path file : files) {_            if (file.getFileName().toString().endsWith(".liv")_            || file.getFileName().toString().endsWith(".dvm")_            || file.getFileName().toString().endsWith(".dvd")_            ) {_                delFiles.add(file)__            }_        }_        Path last = null__        for (Path current : delFiles) {_            if (last != null) {_                final String newSegmentName = IndexFileNames.parseSegmentName(current.getFileName().toString())__                final String oldSegmentName = IndexFileNames.parseSegmentName(last.getFileName().toString())__                if (newSegmentName.equals(oldSegmentName) ) {_                    long oldGen = IndexFileNames.parseGeneration(last.getFileName().toString())__                    long newGen = IndexFileNames.parseGeneration(current.getFileName().toString())__                    if (newGen > oldGen) {_                        files.remove(last)__                    } else {_                        files.remove(current)__                        continue__                    }_                }_            }_            last = current__        }_    };prunes,the,list,of,index,files,such,that,only,the,latest,del,generation,files,are,contained;private,void,prune,old,delete,generations,set,path,files,final,tree,set,path,del,files,new,tree,set,for,path,file,files,if,file,get,file,name,to,string,ends,with,liv,file,get,file,name,to,string,ends,with,dvm,file,get,file,name,to,string,ends,with,dvd,del,files,add,file,path,last,null,for,path,current,del,files,if,last,null,final,string,new,segment,name,index,file,names,parse,segment,name,current,get,file,name,to,string,final,string,old,segment,name,index,file,names,parse,segment,name,last,get,file,name,to,string,if,new,segment,name,equals,old,segment,name,long,old,gen,index,file,names,parse,generation,last,get,file,name,to,string,long,new,gen,index,file,names,parse,generation,current,get,file,name,to,string,if,new,gen,old,gen,files,remove,last,else,files,remove,current,continue,last,current
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1524684173;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder().put(Node.NODE_DATA_SETTING.getKey(), true).put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), new MockTransportService.DelegateTransport(mockTransportService.original()) {__                @Override_                protected void sendRequest(Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {_                    if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                        RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                        if (truncate && req.length() > 1) {_                            BytesRef bytesRef = req.content().toBytesRef()__                            BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                            request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(), array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                        } else {_                            assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                            final byte[] array = req.content().toBytesRef().bytes__                            int i = randomIntBetween(0, req.content().length() - 1)__                            array[i] = (byte) ~array[i]_ _                        }_                    }_                    super.sendRequest(connection, requestId, action, request, options)__                }_            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,delegate,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,new,mock,transport,service,delegate,transport,mock,transport,service,original,override,protected,void,send,request,connection,connection,long,request,id,string,action,transport,request,request,transport,request,options,options,throws,ioexception,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,super,send,request,connection,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1526574077;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder().put(Node.NODE_DATA_SETTING.getKey(), true).put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), new MockTransportService.DelegateTransport(mockTransportService.original()) {__                @Override_                protected void sendRequest(Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {_                    if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                        RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                        if (truncate && req.length() > 1) {_                            BytesRef bytesRef = req.content().toBytesRef()__                            BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                            request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(), array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                        } else {_                            assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                            final byte[] array = req.content().toBytesRef().bytes__                            int i = randomIntBetween(0, req.content().length() - 1)__                            array[i] = (byte) ~array[i]_ _                        }_                    }_                    super.sendRequest(connection, requestId, action, request, options)__                }_            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,delegate,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,new,mock,transport,service,delegate,transport,mock,transport,service,original,override,protected,void,send,request,connection,connection,long,request,id,string,action,transport,request,request,transport,request,options,options,throws,ioexception,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,super,send,request,connection,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1526900724;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder().put(Node.NODE_DATA_SETTING.getKey(), true).put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), new MockTransportService.DelegateTransport(mockTransportService.original()) {__                @Override_                protected void sendRequest(Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {_                    if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                        RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                        if (truncate && req.length() > 1) {_                            BytesRef bytesRef = req.content().toBytesRef()__                            BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                            request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(), array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                        } else {_                            assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                            final byte[] array = req.content().toBytesRef().bytes__                            int i = randomIntBetween(0, req.content().length() - 1)__                            array[i] = (byte) ~array[i]_ _                        }_                    }_                    super.sendRequest(connection, requestId, action, request, options)__                }_            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,delegate,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,new,mock,transport,service,delegate,transport,mock,transport,service,original,override,protected,void,send,request,connection,connection,long,request,id,string,action,transport,request,request,transport,request,options,options,throws,ioexception,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,super,send,request,connection,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1527096592;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder().put(Node.NODE_DATA_SETTING.getKey(), true).put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), new MockTransportService.DelegateTransport(mockTransportService.original()) {__                @Override_                protected void sendRequest(Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {_                    if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                        RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                        if (truncate && req.length() > 1) {_                            BytesRef bytesRef = req.content().toBytesRef()__                            BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                            request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(), array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                        } else {_                            assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                            final byte[] array = req.content().toBytesRef().bytes__                            int i = randomIntBetween(0, req.content().length() - 1)__                            array[i] = (byte) ~array[i]_ _                        }_                    }_                    super.sendRequest(connection, requestId, action, request, options)__                }_            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,delegate,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,new,mock,transport,service,delegate,transport,mock,transport,service,original,override,protected,void,send,request,connection,connection,long,request,id,string,action,transport,request,request,transport,request,options,options,throws,ioexception,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,super,send,request,connection,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1528762805;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder().put(Node.NODE_DATA_SETTING.getKey(), true).put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), new MockTransportService.DelegateTransport(mockTransportService.original()) {__                @Override_                protected void sendRequest(Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {_                    if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                        RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                        if (truncate && req.length() > 1) {_                            BytesRef bytesRef = req.content().toBytesRef()__                            BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                            request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(), array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                        } else {_                            assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                            final byte[] array = req.content().toBytesRef().bytes__                            int i = randomIntBetween(0, req.content().length() - 1)__                            array[i] = (byte) ~array[i]_ _                        }_                    }_                    super.sendRequest(connection, requestId, action, request, options)__                }_            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,delegate,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,new,mock,transport,service,delegate,transport,mock,transport,service,original,override,protected,void,send,request,connection,connection,long,request,id,string,action,transport,request,request,transport,request,options,options,throws,ioexception,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,super,send,request,connection,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1534203100;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder().put(Node.NODE_DATA_SETTING.getKey(), true).put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), (connection, requestId, action, request, options) -> {_                if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    if (truncate && req.length() > 1) {_                        BytesRef bytesRef = req.content().toBytesRef()__                        BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                        request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(), array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                    } else {_                        assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                        final byte[] array = req.content().toBytesRef().bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                    }_                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1536137328;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder().put(Node.NODE_DATA_SETTING.getKey(), true).put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), (connection, requestId, action, request, options) -> {_                if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    if (truncate && req.length() > 1) {_                        BytesRef bytesRef = req.content().toBytesRef()__                        BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                        request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(), array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                    } else {_                        assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                        final byte[] array = req.content().toBytesRef().bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                    }_                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1542697754;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder()_                .put(Node.NODE_DATA_SETTING.getKey(), true)_                .put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService =_                ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()),_                    (connection, requestId, action, request, options) -> {_                if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    if (truncate && req.length() > 1) {_                        BytesRef bytesRef = req.content().toBytesRef()__                        BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                        request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(),_                            array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                    } else {_                        assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                        final byte[] array = req.content().toBytesRef().bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                    }_                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1544598203;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder()_                .put(Node.NODE_DATA_SETTING.getKey(), true)_                .put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService =_                ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()),_                    (connection, requestId, action, request, options) -> {_                if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    if (truncate && req.length() > 1) {_                        BytesRef bytesRef = req.content().toBytesRef()__                        BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                        request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(),_                            array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                    } else {_                        assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                        final byte[] array = req.content().toBytesRef().bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                    }_                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1544628062;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder()_                .put(Node.NODE_DATA_SETTING.getKey(), true)_                .put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService =_                ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()),_                    (connection, requestId, action, request, options) -> {_                if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    if (truncate && req.length() > 1) {_                        BytesRef bytesRef = req.content().toBytesRef()__                        BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                        request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(),_                            array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                    } else {_                        assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                        final byte[] array = req.content().toBytesRef().bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                    }_                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1545201550;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder()_                .put(Node.NODE_DATA_SETTING.getKey(), true)_                .put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService =_                ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()),_                    (connection, requestId, action, request, options) -> {_                if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    if (truncate && req.length() > 1) {_                        BytesRef bytesRef = req.content().toBytesRef()__                        BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                        request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(),_                            array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                    } else {_                        assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                        final byte[] array = req.content().toBytesRef().bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                    }_                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException;1547022296;Tests corruption that happens on the network layer and that the primary does not get affected by corruption that happens on the way_to the replica. The file on disk stays uncorrupted;public void testCorruptionOnNetworkLayer() throws ExecutionException, InterruptedException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)__        if (cluster().numDataNodes() < 3) {_            internalCluster().startNode(Settings.builder()_                .put(Node.NODE_DATA_SETTING.getKey(), true)_                .put(Node.NODE_MASTER_SETTING.getKey(), false))__        }_        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)____        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, between(1, 4)) _            _            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)__        final boolean truncate = randomBoolean()__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService =_                ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()),_                    (connection, requestId, action, request, options) -> {_                if (action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    if (truncate && req.length() > 1) {_                        BytesRef bytesRef = req.content().toBytesRef()__                        BytesArray array = new BytesArray(bytesRef.bytes, bytesRef.offset, (int) req.length() - 1)__                        request = new RecoveryFileChunkRequest(req.recoveryId(), req.shardId(), req.metadata(), req.position(),_                            array, req.lastChunk(), req.totalTranslogOps(), req.sourceThrottleTimeInNanos())__                    } else {_                        assert req.content().toBytesRef().bytes == req.content().toBytesRef().bytes : "no internal reference!!"__                        final byte[] array = req.content().toBytesRef().bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                    }_                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", "*").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        ClusterHealthResponse actionGet = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()).actionGet()__        if (actionGet.isTimedOut()) {_            logger.info("ensureGreen timed out, cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", actionGet.isTimedOut(), equalTo(false))__        }_        _        _        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().get()__        for (IndexShardRoutingTable table : clusterStateResponse.getState().getRoutingTable().index("test")) {_            for (ShardRouting routing : table) {_                if (unluckyNode.getNode().getId().equals(routing.currentNodeId())) {_                    assertThat(routing.state(), not(equalTo(ShardRoutingState.STARTED)))__                    assertThat(routing.state(), not(equalTo(ShardRoutingState.RELOCATING)))__                }_            }_        }_        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }__    };tests,corruption,that,happens,on,the,network,layer,and,that,the,primary,does,not,get,affected,by,corruption,that,happens,on,the,way,to,the,replica,the,file,on,disk,stays,uncorrupted;public,void,test,corruption,on,network,layer,throws,execution,exception,interrupted,exception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,if,cluster,num,data,nodes,3,internal,cluster,start,node,settings,builder,put,node,get,key,true,put,node,get,key,false,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,between,1,4,put,mock,fsindex,store,get,key,false,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,boolean,truncate,random,boolean,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,if,truncate,req,length,1,bytes,ref,bytes,ref,req,content,to,bytes,ref,bytes,array,array,new,bytes,array,bytes,ref,bytes,bytes,ref,offset,int,req,length,1,request,new,recovery,file,chunk,request,req,recovery,id,req,shard,id,req,metadata,req,position,array,req,last,chunk,req,total,translog,ops,req,source,throttle,time,in,nanos,else,assert,req,content,to,bytes,ref,bytes,req,content,to,bytes,ref,bytes,no,internal,reference,final,byte,array,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,cluster,health,response,action,get,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,action,get,if,action,get,is,timed,out,logger,info,ensure,green,timed,out,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,action,get,is,timed,out,equal,to,false,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,get,for,index,shard,routing,table,table,cluster,state,response,get,state,get,routing,table,index,test,for,shard,routing,routing,table,if,unlucky,node,get,node,get,id,equals,routing,current,node,id,assert,that,routing,state,not,equal,to,shard,routing,state,started,assert,that,routing,state,not,equal,to,shard,routing,state,relocating,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs
CorruptedFileIT -> public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException;1527096592;Tests that restoring of a corrupted shard fails and we get a partial snapshot._TODO once checksum verification on snapshotting is implemented this test needs to be fixed or split into several_parts... We should also corrupt files on the actual snapshot and check that we don't restore the corrupted shard.;public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0") _                        .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_                        .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _                        .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile(false)__        logger.info("--> shard {} has a corrupted file", shardRouting)__        _        _        _        logger.info("-->  creating repository")__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                .setType("fs").setSettings(Settings.builder()_                        .put("location", randomRepoPath().toAbsolutePath())_                        .put("compress", randomBoolean())_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))__        logger.info("--> snapshot")__        final CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                                        .setWaitForCompletion(true)_                                                                                        .setIndices("test")_                                                                                        .get()__        final SnapshotState snapshotState = createSnapshotResponse.getSnapshotInfo().state()__        logger.info("--> snapshot terminated with state " + snapshotState)__        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(createSnapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.PARTIAL))__        assertThat(corruptedFile, notNullValue())__    };tests,that,restoring,of,a,corrupted,shard,fails,and,we,get,a,partial,snapshot,todo,once,checksum,verification,on,snapshotting,is,implemented,this,test,needs,to,be,fixed,or,split,into,several,parts,we,should,also,corrupt,files,on,the,actual,snapshot,and,check,that,we,don,t,restore,the,corrupted,shard;public,void,test,corrupt,file,then,snapshot,and,restore,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,false,logger,info,shard,has,a,corrupted,file,shard,routing,logger,info,creating,repository,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,random,repo,path,to,absolute,path,put,compress,random,boolean,put,random,int,between,100,1000,byte,size,unit,bytes,logger,info,snapshot,final,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,test,get,final,snapshot,state,snapshot,state,create,snapshot,response,get,snapshot,info,state,logger,info,snapshot,terminated,with,state,snapshot,state,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,create,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,partial,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException;1528762805;Tests that restoring of a corrupted shard fails and we get a partial snapshot._TODO once checksum verification on snapshotting is implemented this test needs to be fixed or split into several_parts... We should also corrupt files on the actual snapshot and check that we don't restore the corrupted shard.;public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0") _                        .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_                        .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _                        .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile(false)__        logger.info("--> shard {} has a corrupted file", shardRouting)__        _        _        _        logger.info("-->  creating repository")__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                .setType("fs").setSettings(Settings.builder()_                        .put("location", randomRepoPath().toAbsolutePath())_                        .put("compress", randomBoolean())_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))__        logger.info("--> snapshot")__        final CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                                        .setWaitForCompletion(true)_                                                                                        .setIndices("test")_                                                                                        .get()__        final SnapshotState snapshotState = createSnapshotResponse.getSnapshotInfo().state()__        logger.info("--> snapshot terminated with state " + snapshotState)__        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(createSnapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.PARTIAL))__        assertThat(corruptedFile, notNullValue())__    };tests,that,restoring,of,a,corrupted,shard,fails,and,we,get,a,partial,snapshot,todo,once,checksum,verification,on,snapshotting,is,implemented,this,test,needs,to,be,fixed,or,split,into,several,parts,we,should,also,corrupt,files,on,the,actual,snapshot,and,check,that,we,don,t,restore,the,corrupted,shard;public,void,test,corrupt,file,then,snapshot,and,restore,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,false,logger,info,shard,has,a,corrupted,file,shard,routing,logger,info,creating,repository,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,random,repo,path,to,absolute,path,put,compress,random,boolean,put,random,int,between,100,1000,byte,size,unit,bytes,logger,info,snapshot,final,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,test,get,final,snapshot,state,snapshot,state,create,snapshot,response,get,snapshot,info,state,logger,info,snapshot,terminated,with,state,snapshot,state,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,create,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,partial,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException;1534203100;Tests that restoring of a corrupted shard fails and we get a partial snapshot._TODO once checksum verification on snapshotting is implemented this test needs to be fixed or split into several_parts... We should also corrupt files on the actual snapshot and check that we don't restore the corrupted shard.;public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0") _                        .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_                        .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _                        .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile(false)__        logger.info("--> shard {} has a corrupted file", shardRouting)__        _        _        _        logger.info("-->  creating repository")__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                .setType("fs").setSettings(Settings.builder()_                        .put("location", randomRepoPath().toAbsolutePath())_                        .put("compress", randomBoolean())_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))__        logger.info("--> snapshot")__        final CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                                        .setWaitForCompletion(true)_                                                                                        .setIndices("test")_                                                                                        .get()__        final SnapshotState snapshotState = createSnapshotResponse.getSnapshotInfo().state()__        logger.info("--> snapshot terminated with state " + snapshotState)__        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(createSnapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.PARTIAL))__        assertThat(corruptedFile, notNullValue())__    };tests,that,restoring,of,a,corrupted,shard,fails,and,we,get,a,partial,snapshot,todo,once,checksum,verification,on,snapshotting,is,implemented,this,test,needs,to,be,fixed,or,split,into,several,parts,we,should,also,corrupt,files,on,the,actual,snapshot,and,check,that,we,don,t,restore,the,corrupted,shard;public,void,test,corrupt,file,then,snapshot,and,restore,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,false,logger,info,shard,has,a,corrupted,file,shard,routing,logger,info,creating,repository,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,random,repo,path,to,absolute,path,put,compress,random,boolean,put,random,int,between,100,1000,byte,size,unit,bytes,logger,info,snapshot,final,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,test,get,final,snapshot,state,snapshot,state,create,snapshot,response,get,snapshot,info,state,logger,info,snapshot,terminated,with,state,snapshot,state,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,create,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,partial,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException;1536137328;Tests that restoring of a corrupted shard fails and we get a partial snapshot._TODO once checksum verification on snapshotting is implemented this test needs to be fixed or split into several_parts... We should also corrupt files on the actual snapshot and check that we don't restore the corrupted shard.;public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0") _                        .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_                        .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _                        .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile(false)__        logger.info("--> shard {} has a corrupted file", shardRouting)__        _        _        _        logger.info("-->  creating repository")__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                .setType("fs").setSettings(Settings.builder()_                        .put("location", randomRepoPath().toAbsolutePath())_                        .put("compress", randomBoolean())_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))__        logger.info("--> snapshot")__        final CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                                        .setWaitForCompletion(true)_                                                                                        .setIndices("test")_                                                                                        .get()__        final SnapshotState snapshotState = createSnapshotResponse.getSnapshotInfo().state()__        logger.info("--> snapshot terminated with state " + snapshotState)__        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(createSnapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.PARTIAL))__        assertThat(corruptedFile, notNullValue())__    };tests,that,restoring,of,a,corrupted,shard,fails,and,we,get,a,partial,snapshot,todo,once,checksum,verification,on,snapshotting,is,implemented,this,test,needs,to,be,fixed,or,split,into,several,parts,we,should,also,corrupt,files,on,the,actual,snapshot,and,check,that,we,don,t,restore,the,corrupted,shard;public,void,test,corrupt,file,then,snapshot,and,restore,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,false,logger,info,shard,has,a,corrupted,file,shard,routing,logger,info,creating,repository,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,random,repo,path,to,absolute,path,put,compress,random,boolean,put,random,int,between,100,1000,byte,size,unit,bytes,logger,info,snapshot,final,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,test,get,final,snapshot,state,snapshot,state,create,snapshot,response,get,snapshot,info,state,logger,info,snapshot,terminated,with,state,snapshot,state,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,create,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,partial,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException;1542697754;Tests that restoring of a corrupted shard fails and we get a partial snapshot._TODO once checksum verification on snapshotting is implemented this test needs to be fixed or split into several_parts... We should also corrupt files on the actual snapshot and check that we don't restore the corrupted shard.;public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(_            prepareCreate("test").setSettings(Settings.builder()_                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0") _                .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_                _                .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_                _                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_            )_        )__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile(false)__        logger.info("--> shard {} has a corrupted file", shardRouting)__        _        _        _        logger.info("-->  creating repository")__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                .setType("fs").setSettings(Settings.builder()_                        .put("location", randomRepoPath().toAbsolutePath())_                        .put("compress", randomBoolean())_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))__        logger.info("--> snapshot")__        final CreateSnapshotResponse createSnapshotResponse =_            client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                .setWaitForCompletion(true)_                .setIndices("test")_                .get()__        final SnapshotState snapshotState = createSnapshotResponse.getSnapshotInfo().state()__        logger.info("--> snapshot terminated with state " + snapshotState)__        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(createSnapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.PARTIAL))__        assertThat(corruptedFile, notNullValue())__    };tests,that,restoring,of,a,corrupted,shard,fails,and,we,get,a,partial,snapshot,todo,once,checksum,verification,on,snapshotting,is,implemented,this,test,needs,to,be,fixed,or,split,into,several,parts,we,should,also,corrupt,files,on,the,actual,snapshot,and,check,that,we,don,t,restore,the,corrupted,shard;public,void,test,corrupt,file,then,snapshot,and,restore,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,false,logger,info,shard,has,a,corrupted,file,shard,routing,logger,info,creating,repository,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,random,repo,path,to,absolute,path,put,compress,random,boolean,put,random,int,between,100,1000,byte,size,unit,bytes,logger,info,snapshot,final,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,test,get,final,snapshot,state,snapshot,state,create,snapshot,response,get,snapshot,info,state,logger,info,snapshot,terminated,with,state,snapshot,state,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,create,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,partial,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException;1544628062;Tests that restoring of a corrupted shard fails and we get a partial snapshot._TODO once checksum verification on snapshotting is implemented this test needs to be fixed or split into several_parts... We should also corrupt files on the actual snapshot and check that we don't restore the corrupted shard.;public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(_            prepareCreate("test").setSettings(Settings.builder()_                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0") _                .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_                _                .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_                _                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_            )_        )__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile(false)__        logger.info("--> shard {} has a corrupted file", shardRouting)__        _        _        _        logger.info("-->  creating repository")__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                .setType("fs").setSettings(Settings.builder()_                        .put("location", randomRepoPath().toAbsolutePath())_                        .put("compress", randomBoolean())_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))__        logger.info("--> snapshot")__        final CreateSnapshotResponse createSnapshotResponse =_            client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                .setWaitForCompletion(true)_                .setIndices("test")_                .get()__        final SnapshotState snapshotState = createSnapshotResponse.getSnapshotInfo().state()__        logger.info("--> snapshot terminated with state " + snapshotState)__        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(createSnapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.PARTIAL))__        assertThat(corruptedFile, notNullValue())__    };tests,that,restoring,of,a,corrupted,shard,fails,and,we,get,a,partial,snapshot,todo,once,checksum,verification,on,snapshotting,is,implemented,this,test,needs,to,be,fixed,or,split,into,several,parts,we,should,also,corrupt,files,on,the,actual,snapshot,and,check,that,we,don,t,restore,the,corrupted,shard;public,void,test,corrupt,file,then,snapshot,and,restore,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,false,logger,info,shard,has,a,corrupted,file,shard,routing,logger,info,creating,repository,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,random,repo,path,to,absolute,path,put,compress,random,boolean,put,random,int,between,100,1000,byte,size,unit,bytes,logger,info,snapshot,final,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,test,get,final,snapshot,state,snapshot,state,create,snapshot,response,get,snapshot,info,state,logger,info,snapshot,terminated,with,state,snapshot,state,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,create,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,partial,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException;1545201550;Tests that restoring of a corrupted shard fails and we get a partial snapshot._TODO once checksum verification on snapshotting is implemented this test needs to be fixed or split into several_parts... We should also corrupt files on the actual snapshot and check that we don't restore the corrupted shard.;public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(_            prepareCreate("test").setSettings(Settings.builder()_                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0") _                .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_                _                .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_                _                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_            )_        )__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile(false)__        logger.info("--> shard {} has a corrupted file", shardRouting)__        _        _        _        logger.info("-->  creating repository")__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                .setType("fs").setSettings(Settings.builder()_                        .put("location", randomRepoPath().toAbsolutePath())_                        .put("compress", randomBoolean())_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))__        logger.info("--> snapshot")__        final CreateSnapshotResponse createSnapshotResponse =_            client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                .setWaitForCompletion(true)_                .setIndices("test")_                .get()__        final SnapshotState snapshotState = createSnapshotResponse.getSnapshotInfo().state()__        logger.info("--> snapshot terminated with state " + snapshotState)__        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(createSnapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.PARTIAL))__        assertThat(corruptedFile, notNullValue())__    };tests,that,restoring,of,a,corrupted,shard,fails,and,we,get,a,partial,snapshot,todo,once,checksum,verification,on,snapshotting,is,implemented,this,test,needs,to,be,fixed,or,split,into,several,parts,we,should,also,corrupt,files,on,the,actual,snapshot,and,check,that,we,don,t,restore,the,corrupted,shard;public,void,test,corrupt,file,then,snapshot,and,restore,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,false,logger,info,shard,has,a,corrupted,file,shard,routing,logger,info,creating,repository,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,random,repo,path,to,absolute,path,put,compress,random,boolean,put,random,int,between,100,1000,byte,size,unit,bytes,logger,info,snapshot,final,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,test,get,final,snapshot,state,snapshot,state,create,snapshot,response,get,snapshot,info,state,logger,info,snapshot,terminated,with,state,snapshot,state,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,create,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,partial,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException;1547022296;Tests that restoring of a corrupted shard fails and we get a partial snapshot._TODO once checksum verification on snapshotting is implemented this test needs to be fixed or split into several_parts... We should also corrupt files on the actual snapshot and check that we don't restore the corrupted shard.;public void testCorruptFileThenSnapshotAndRestore() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(_            prepareCreate("test").setSettings(Settings.builder()_                .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0") _                .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_                _                .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false)_                _                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_            )_        )__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile(false)__        logger.info("--> shard {} has a corrupted file", shardRouting)__        _        _        _        logger.info("-->  creating repository")__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                .setType("fs").setSettings(Settings.builder()_                        .put("location", randomRepoPath().toAbsolutePath())_                        .put("compress", randomBoolean())_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))__        logger.info("--> snapshot")__        final CreateSnapshotResponse createSnapshotResponse =_            client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                .setWaitForCompletion(true)_                .setIndices("test")_                .get()__        final SnapshotState snapshotState = createSnapshotResponse.getSnapshotInfo().state()__        logger.info("--> snapshot terminated with state " + snapshotState)__        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(createSnapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.PARTIAL))__        assertThat(corruptedFile, notNullValue())__    };tests,that,restoring,of,a,corrupted,shard,fails,and,we,get,a,partial,snapshot,todo,once,checksum,verification,on,snapshotting,is,implemented,this,test,needs,to,be,fixed,or,split,into,several,parts,we,should,also,corrupt,files,on,the,actual,snapshot,and,check,that,we,don,t,restore,the,corrupted,shard;public,void,test,corrupt,file,then,snapshot,and,restore,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,false,logger,info,shard,has,a,corrupted,file,shard,routing,logger,info,creating,repository,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,random,repo,path,to,absolute,path,put,compress,random,boolean,put,random,int,between,100,1000,byte,size,unit,bytes,logger,info,snapshot,final,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,test,get,final,snapshot,state,snapshot,state,create,snapshot,response,get,snapshot,info,state,logger,info,snapshot,terminated,with,state,snapshot,state,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,create,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,partial,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1524684173;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators = state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1526574077;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators = state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1526900724;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators = state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1527096592;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators = state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1528762805;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators = state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1534203100;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators = state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1536137328;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators = state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1542697754;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators =_            state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1544598203;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators =_            state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1544628062;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators =_            state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1545201550;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators =_            state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException;1547022296;Tests corruption that happens on a single shard when no replicas are present. We make sure that the primary stays unassigned_and all other replicas for the healthy shards happens;public void testCorruptPrimaryNoReplica() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        internalCluster().ensureAtLeastNumDataNodes(2)___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_        ))__        ensureGreen()__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        ShardRouting shardRouting = corruptRandomPrimaryFile()__        _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()___        boolean didClusterTurnRed = awaitBusy(() -> {_            ClusterHealthStatus test = client().admin().cluster()_                .health(Requests.clusterHealthRequest("test")).actionGet().getStatus()__            return test == ClusterHealthStatus.RED__        }, 5, TimeUnit.MINUTES)__        final ClusterHealthResponse response = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test")).get()__        if (response.getStatus() != ClusterHealthStatus.RED) {_            logger.info("Cluster turned red in busy loop: {}", didClusterTurnRed)__            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__        }_        assertThat(response.getStatus(), is(ClusterHealthStatus.RED))__        ClusterState state = client().admin().cluster().prepareState().get().getState()__        GroupShardsIterator<ShardIterator> shardIterators =_            state.getRoutingTable().activePrimaryShardsGrouped(new String[]{"test"}, false)__        for (ShardIterator iterator : shardIterators) {_            ShardRouting routing__            while ((routing = iterator.nextOrNull()) != null) {_                if (routing.getId() == shardRouting.getId()) {_                    assertThat(routing.state(), equalTo(ShardRoutingState.UNASSIGNED))__                } else {_                    assertThat(routing.state(), anyOf(equalTo(ShardRoutingState.RELOCATING), equalTo(ShardRoutingState.STARTED)))__                }_            }_        }_        final List<Path> files = listShardFiles(shardRouting)__        Path corruptedFile = null__        for (Path file : files) {_            if (file.getFileName().toString().startsWith("corrupted_")) {_                corruptedFile = file__                break__            }_        }_        assertThat(corruptedFile, notNullValue())__    };tests,corruption,that,happens,on,a,single,shard,when,no,replicas,are,present,we,make,sure,that,the,primary,stays,unassigned,and,all,other,replicas,for,the,healthy,shards,happens;public,void,test,corrupt,primary,no,replica,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,2,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,shard,routing,shard,routing,corrupt,random,primary,file,settings,build,settings,builder,put,index,meta,data,1,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,boolean,did,cluster,turn,red,await,busy,cluster,health,status,test,client,admin,cluster,health,requests,cluster,health,request,test,action,get,get,status,return,test,cluster,health,status,red,5,time,unit,minutes,final,cluster,health,response,response,client,admin,cluster,health,requests,cluster,health,request,test,get,if,response,get,status,cluster,health,status,red,logger,info,cluster,turned,red,in,busy,loop,did,cluster,turn,red,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,response,get,status,is,cluster,health,status,red,cluster,state,state,client,admin,cluster,prepare,state,get,get,state,group,shards,iterator,shard,iterator,shard,iterators,state,get,routing,table,active,primary,shards,grouped,new,string,test,false,for,shard,iterator,iterator,shard,iterators,shard,routing,routing,while,routing,iterator,next,or,null,null,if,routing,get,id,shard,routing,get,id,assert,that,routing,state,equal,to,shard,routing,state,unassigned,else,assert,that,routing,state,any,of,equal,to,shard,routing,state,relocating,equal,to,shard,routing,state,started,final,list,path,files,list,shard,files,shard,routing,path,corrupted,file,null,for,path,file,files,if,file,get,file,name,to,string,starts,with,corrupted,file,file,break,assert,that,corrupted,file,not,null,value
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1524684173;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), new MockTransportService.DelegateTransport(mockTransportService.original()) {__                @Override_                protected void sendRequest(Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {_                    if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                        RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                        byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                        hasCorrupted.countDown()__                    }_                    super.sendRequest(connection, requestId, action, request, options)__                }_            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,delegate,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,new,mock,transport,service,delegate,transport,mock,transport,service,original,override,protected,void,send,request,connection,connection,long,request,id,string,action,transport,request,request,transport,request,options,options,throws,ioexception,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,super,send,request,connection,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1526574077;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), new MockTransportService.DelegateTransport(mockTransportService.original()) {__                @Override_                protected void sendRequest(Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {_                    if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                        RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                        byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                        hasCorrupted.countDown()__                    }_                    super.sendRequest(connection, requestId, action, request, options)__                }_            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,delegate,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,new,mock,transport,service,delegate,transport,mock,transport,service,original,override,protected,void,send,request,connection,connection,long,request,id,string,action,transport,request,request,transport,request,options,options,throws,ioexception,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,super,send,request,connection,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1526900724;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), new MockTransportService.DelegateTransport(mockTransportService.original()) {__                @Override_                protected void sendRequest(Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {_                    if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                        RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                        byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                        hasCorrupted.countDown()__                    }_                    super.sendRequest(connection, requestId, action, request, options)__                }_            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,delegate,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,new,mock,transport,service,delegate,transport,mock,transport,service,original,override,protected,void,send,request,connection,connection,long,request,id,string,action,transport,request,request,transport,request,options,options,throws,ioexception,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,super,send,request,connection,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1527096592;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), new MockTransportService.DelegateTransport(mockTransportService.original()) {__                @Override_                protected void sendRequest(Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {_                    if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                        RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                        byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                        hasCorrupted.countDown()__                    }_                    super.sendRequest(connection, requestId, action, request, options)__                }_            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,delegate,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,new,mock,transport,service,delegate,transport,mock,transport,service,original,override,protected,void,send,request,connection,connection,long,request,id,string,action,transport,request,request,transport,request,options,options,throws,ioexception,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,super,send,request,connection,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1528762805;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addDelegate(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), new MockTransportService.DelegateTransport(mockTransportService.original()) {__                @Override_                protected void sendRequest(Connection connection, long requestId, String action, TransportRequest request, TransportRequestOptions options) throws IOException {_                    if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                        RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                        byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                        int i = randomIntBetween(0, req.content().length() - 1)__                        array[i] = (byte) ~array[i]_ _                        hasCorrupted.countDown()__                    }_                    super.sendRequest(connection, requestId, action, request, options)__                }_            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,delegate,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,new,mock,transport,service,delegate,transport,mock,transport,service,original,override,protected,void,send,request,connection,connection,long,request,id,string,action,transport,request,request,transport,request,options,options,throws,ioexception,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,super,send,request,connection,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1534203100;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), (connection, requestId, action, request, options) -> {_                if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                    int i = randomIntBetween(0, req.content().length() - 1)__                    array[i] = (byte) ~array[i]_ _                    hasCorrupted.countDown()__                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1536137328;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService = ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()), (connection, requestId, action, request, options) -> {_                if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                    int i = randomIntBetween(0, req.content().length() - 1)__                    array[i] = (byte) ~array[i]_ _                    hasCorrupted.countDown()__                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1542697754;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService =_                ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()),_                (connection, requestId, action, request, options) -> {_                if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                    int i = randomIntBetween(0, req.content().length() - 1)__                    array[i] = (byte) ~array[i]_ _                    hasCorrupted.countDown()__                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name",_                primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1544598203;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService =_                ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()),_                (connection, requestId, action, request, options) -> {_                if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                    int i = randomIntBetween(0, req.content().length() - 1)__                    array[i] = (byte) ~array[i]_ _                    hasCorrupted.countDown()__                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name",_                primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1544628062;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService =_                ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()),_                (connection, requestId, action, request, options) -> {_                if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                    int i = randomIntBetween(0, req.content().length() - 1)__                    array[i] = (byte) ~array[i]_ _                    hasCorrupted.countDown()__                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name",_                primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1545201550;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService =_                ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()),_                (connection, requestId, action, request, options) -> {_                if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                    int i = randomIntBetween(0, req.content().length() - 1)__                    array[i] = (byte) ~array[i]_ _                    hasCorrupted.countDown()__                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name",_                primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException;1547022296;This test triggers a corrupt index exception during finalization size if an empty commit point is transferred_during recovery we don't know the version of the segments_N file because it has no segments we can take it from._This simulates recoveries from old indices or even without checksums and makes sure if we fail during finalization_we also check if the primary is ok. Without the relevant checks this test fails with a RED cluster;public void testCorruptionOnNetworkLayerFinalizingRecovery() throws ExecutionException, InterruptedException, IOException {_        internalCluster().ensureAtLeastNumDataNodes(2)__        NodesStatsResponse nodeStats = client().admin().cluster().prepareNodesStats().get()__        List<NodeStats> dataNodeStats = new ArrayList<>()__        for (NodeStats stat : nodeStats.getNodes()) {_            if (stat.getNode().isDataNode()) {_                dataNodeStats.add(stat)__            }_        }__        assertThat(dataNodeStats.size(), greaterThanOrEqualTo(2))__        Collections.shuffle(dataNodeStats, random())__        NodeStats primariesNode = dataNodeStats.get(0)__        NodeStats unluckyNode = dataNodeStats.get(1)__        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "0")_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)_            .put("index.routing.allocation.include._name", primariesNode.getNode().getName())_            .put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE)_            .put("index.allocation.max_retries", Integer.MAX_VALUE) __        ))__        ensureGreen()_ _        final AtomicBoolean corrupt = new AtomicBoolean(true)__        final CountDownLatch hasCorrupted = new CountDownLatch(1)__        for (NodeStats dataNode : dataNodeStats) {_            MockTransportService mockTransportService =_                ((MockTransportService) internalCluster().getInstance(TransportService.class, dataNode.getNode().getName()))__            mockTransportService.addSendBehavior(internalCluster().getInstance(TransportService.class, unluckyNode.getNode().getName()),_                (connection, requestId, action, request, options) -> {_                if (corrupt.get() && action.equals(PeerRecoveryTargetService.Actions.FILE_CHUNK)) {_                    RecoveryFileChunkRequest req = (RecoveryFileChunkRequest) request__                    byte[] array = BytesRef.deepCopyOf(req.content().toBytesRef()).bytes__                    int i = randomIntBetween(0, req.content().length() - 1)__                    array[i] = (byte) ~array[i]_ _                    hasCorrupted.countDown()__                }_                connection.sendRequest(requestId, action, request, options)__            })__        }__        Settings build = Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put("index.routing.allocation.include._name",_                primariesNode.getNode().getName() + "," + unluckyNode.getNode().getName()).build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        client().admin().cluster().prepareReroute().get()__        hasCorrupted.await()__        corrupt.set(false)__        ensureGreen()__    };this,test,triggers,a,corrupt,index,exception,during,finalization,size,if,an,empty,commit,point,is,transferred,during,recovery,we,don,t,know,the,version,of,the,file,because,it,has,no,segments,we,can,take,it,from,this,simulates,recoveries,from,old,indices,or,even,without,checksums,and,makes,sure,if,we,fail,during,finalization,we,also,check,if,the,primary,is,ok,without,the,relevant,checks,this,test,fails,with,a,red,cluster;public,void,test,corruption,on,network,layer,finalizing,recovery,throws,execution,exception,interrupted,exception,ioexception,internal,cluster,ensure,at,least,num,data,nodes,2,nodes,stats,response,node,stats,client,admin,cluster,prepare,nodes,stats,get,list,node,stats,data,node,stats,new,array,list,for,node,stats,stat,node,stats,get,nodes,if,stat,get,node,is,data,node,data,node,stats,add,stat,assert,that,data,node,stats,size,greater,than,or,equal,to,2,collections,shuffle,data,node,stats,random,node,stats,primaries,node,data,node,stats,get,0,node,stats,unlucky,node,data,node,stats,get,1,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,0,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,put,enable,allocation,decider,get,key,enable,allocation,decider,rebalance,none,put,index,allocation,integer,ensure,green,final,atomic,boolean,corrupt,new,atomic,boolean,true,final,count,down,latch,has,corrupted,new,count,down,latch,1,for,node,stats,data,node,data,node,stats,mock,transport,service,mock,transport,service,mock,transport,service,internal,cluster,get,instance,transport,service,class,data,node,get,node,get,name,mock,transport,service,add,send,behavior,internal,cluster,get,instance,transport,service,class,unlucky,node,get,node,get,name,connection,request,id,action,request,options,if,corrupt,get,action,equals,peer,recovery,target,service,actions,recovery,file,chunk,request,req,recovery,file,chunk,request,request,byte,array,bytes,ref,deep,copy,of,req,content,to,bytes,ref,bytes,int,i,random,int,between,0,req,content,length,1,array,i,byte,array,i,has,corrupted,count,down,connection,send,request,request,id,action,request,options,settings,build,settings,builder,put,index,meta,data,1,put,index,routing,allocation,include,primaries,node,get,node,get,name,unlucky,node,get,node,get,name,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,client,admin,cluster,prepare,reroute,get,has,corrupted,await,corrupt,set,false,ensure,green
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1524684173;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1526574077;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1526900724;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1527096592;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1528762805;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1534203100;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1536137328;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)) _        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener : internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1542697754;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener :_                internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener :_                    internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1544598203;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener :_                internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener :_                    internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1544628062;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener :_                internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener :_                    internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1545201550;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener :_                internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener :_                    internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
CorruptedFileIT -> public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException;1547022296;Tests that we can actually recover from a corruption on the primary given that we have replica shards around.;public void testCorruptFileAndRecover() throws ExecutionException, InterruptedException, IOException {_        int numDocs = scaledRandomIntBetween(100, 1000)__        _        internalCluster().ensureAtLeastNumDataNodes(3)__        if (cluster().numDataNodes() == 3) {_            logger.info("--> cluster has [3] data nodes, corrupted primary will be overwritten")__        }__        assertThat(cluster().numDataNodes(), greaterThanOrEqualTo(3))___        assertAcked(prepareCreate("test").setSettings(Settings.builder()_            .put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, "1")_            .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "1")_            .put(MergePolicyConfig.INDEX_MERGE_ENABLED, false)_            .put(MockFSIndexStore.INDEX_CHECK_INDEX_ON_CLOSE_SETTING.getKey(), false) _            _            .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB))_        ))__        ensureGreen()__        disableAllocation("test")__        IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs]__        for (int i = 0_ i < builders.length_ i++) {_            builders[i] = client().prepareIndex("test", "type").setSource("field", "value")__        }_        indexRandom(true, builders)__        ensureGreen()__        assertAllSuccessful(client().admin().indices().prepareFlush().setForce(true).execute().actionGet())__        _        SearchResponse countResponse = client().prepareSearch().setSize(0).get()__        assertHitCount(countResponse, numDocs)___        final int numShards = numShards("test")__        ShardRouting corruptedShardRouting = corruptRandomPrimaryFile()__        logger.info("--> {} corrupted", corruptedShardRouting)__        enableAllocation("test")__         _        Settings build = Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, "2").build()__        client().admin().indices().prepareUpdateSettings("test").setSettings(build).get()__        ClusterHealthResponse health = client().admin().cluster()_            .health(Requests.clusterHealthRequest("test").waitForGreenStatus()_                .timeout("5m") _                .waitForNoRelocatingShards(true)).actionGet()__        if (health.isTimedOut()) {_            logger.info("cluster state:\n{}\n{}",_                client().admin().cluster().prepareState().get().getState(), client().admin().cluster().preparePendingClusterTasks().get())__            assertThat("timed out waiting for green state", health.isTimedOut(), equalTo(false))__        }_        assertThat(health.getStatus(), equalTo(ClusterHealthStatus.GREEN))__        final int numIterations = scaledRandomIntBetween(5, 20)__        for (int i = 0_ i < numIterations_ i++) {_            SearchResponse response = client().prepareSearch().setSize(numDocs).get()__            assertHitCount(response, numDocs)__        }____        _        final CountDownLatch latch = new CountDownLatch(numShards * 3)_ _        final CopyOnWriteArrayList<Exception> exception = new CopyOnWriteArrayList<>()__        final IndexEventListener listener = new IndexEventListener() {_            @Override_            public void afterIndexShardClosed(ShardId sid, @Nullable IndexShard indexShard, Settings indexSettings) {_                if (indexShard != null) {_                    Store store = indexShard.store()__                    store.incRef()__                    try {_                        if (!Lucene.indexExists(store.directory()) && indexShard.state() == IndexShardState.STARTED) {_                            return__                        }_                        BytesStreamOutput os = new BytesStreamOutput()__                        PrintStream out = new PrintStream(os, false, StandardCharsets.UTF_8.name())__                        CheckIndex.Status status = store.checkIndex(out)__                        out.flush()__                        if (!status.clean) {_                            logger.warn("check index [failure]\n{}", os.bytes().utf8ToString())__                            throw new IOException("index check failure")__                        }_                    } catch (Exception e) {_                        exception.add(e)__                    } finally {_                        store.decRef()__                        latch.countDown()__                    }_                }_            }_        }___        for (MockIndexEventListener.TestEventListener eventListener :_                internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_            eventListener.setNewDelegate(listener)__        }_        try {_            client().admin().indices().prepareDelete("test").get()__            latch.await()__            assertThat(exception, empty())__        } finally {_            for (MockIndexEventListener.TestEventListener eventListener :_                    internalCluster().getDataNodeInstances(MockIndexEventListener.TestEventListener.class)) {_                eventListener.setNewDelegate(null)__            }_        }_    };tests,that,we,can,actually,recover,from,a,corruption,on,the,primary,given,that,we,have,replica,shards,around;public,void,test,corrupt,file,and,recover,throws,execution,exception,interrupted,exception,ioexception,int,num,docs,scaled,random,int,between,100,1000,internal,cluster,ensure,at,least,num,data,nodes,3,if,cluster,num,data,nodes,3,logger,info,cluster,has,3,data,nodes,corrupted,primary,will,be,overwritten,assert,that,cluster,num,data,nodes,greater,than,or,equal,to,3,assert,acked,prepare,create,test,set,settings,settings,builder,put,index,meta,data,1,put,index,meta,data,1,put,merge,policy,config,false,put,mock,fsindex,store,get,key,false,put,index,settings,get,key,new,byte,size,value,1,byte,size,unit,pb,ensure,green,disable,allocation,test,index,request,builder,builders,new,index,request,builder,num,docs,for,int,i,0,i,builders,length,i,builders,i,client,prepare,index,test,type,set,source,field,value,index,random,true,builders,ensure,green,assert,all,successful,client,admin,indices,prepare,flush,set,force,true,execute,action,get,search,response,count,response,client,prepare,search,set,size,0,get,assert,hit,count,count,response,num,docs,final,int,num,shards,num,shards,test,shard,routing,corrupted,shard,routing,corrupt,random,primary,file,logger,info,corrupted,corrupted,shard,routing,enable,allocation,test,settings,build,settings,builder,put,index,meta,data,2,build,client,admin,indices,prepare,update,settings,test,set,settings,build,get,cluster,health,response,health,client,admin,cluster,health,requests,cluster,health,request,test,wait,for,green,status,timeout,5m,wait,for,no,relocating,shards,true,action,get,if,health,is,timed,out,logger,info,cluster,state,n,n,client,admin,cluster,prepare,state,get,get,state,client,admin,cluster,prepare,pending,cluster,tasks,get,assert,that,timed,out,waiting,for,green,state,health,is,timed,out,equal,to,false,assert,that,health,get,status,equal,to,cluster,health,status,green,final,int,num,iterations,scaled,random,int,between,5,20,for,int,i,0,i,num,iterations,i,search,response,response,client,prepare,search,set,size,num,docs,get,assert,hit,count,response,num,docs,final,count,down,latch,latch,new,count,down,latch,num,shards,3,final,copy,on,write,array,list,exception,exception,new,copy,on,write,array,list,final,index,event,listener,listener,new,index,event,listener,override,public,void,after,index,shard,closed,shard,id,sid,nullable,index,shard,index,shard,settings,index,settings,if,index,shard,null,store,store,index,shard,store,store,inc,ref,try,if,lucene,index,exists,store,directory,index,shard,state,index,shard,state,started,return,bytes,stream,output,os,new,bytes,stream,output,print,stream,out,new,print,stream,os,false,standard,charsets,name,check,index,status,status,store,check,index,out,out,flush,if,status,clean,logger,warn,check,index,failure,n,os,bytes,utf8to,string,throw,new,ioexception,index,check,failure,catch,exception,e,exception,add,e,finally,store,dec,ref,latch,count,down,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,listener,try,client,admin,indices,prepare,delete,test,get,latch,await,assert,that,exception,empty,finally,for,mock,index,event,listener,test,event,listener,event,listener,internal,cluster,get,data,node,instances,mock,index,event,listener,test,event,listener,class,event,listener,set,new,delegate,null
