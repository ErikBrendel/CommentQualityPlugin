commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;public void testRandomReads() throws IOException {     for (int i = 0. i < 100. i++) {         byte[] input = randomUnicodeOfLength(randomIntBetween(1, 1000)).getBytes(StandardCharsets.UTF_8).         ByteArrayIndexInput indexInput = new ByteArrayIndexInput("test", input).         assertEquals(input.length, indexInput.length()).         assertEquals(0, indexInput.getFilePointer()).         byte[] output = randomReadAndSlice(indexInput, input.length).         assertArrayEquals(input, output).     } }
false;public;0;17;;public void testRandomOverflow() throws IOException {     for (int i = 0. i < 100. i++) {         byte[] input = randomUnicodeOfLength(randomIntBetween(1, 1000)).getBytes(StandardCharsets.UTF_8).         ByteArrayIndexInput indexInput = new ByteArrayIndexInput("test", input).         int firstReadLen = randomIntBetween(0, input.length - 1).         randomReadAndSlice(indexInput, firstReadLen).         int bytesLeft = input.length - firstReadLen.         try {             // read using int size             int secondReadLen = bytesLeft + randomIntBetween(1, 100).             indexInput.readBytes(new byte[secondReadLen], 0, secondReadLen).             fail().         } catch (IOException ex) {             assertThat(ex.getMessage(), containsString("EOF")).         }     } }
false;public;0;29;;public void testSeekOverflow() throws IOException {     for (int i = 0. i < 100. i++) {         byte[] input = randomUnicodeOfLength(randomIntBetween(1, 1000)).getBytes(StandardCharsets.UTF_8).         ByteArrayIndexInput indexInput = new ByteArrayIndexInput("test", input).         int firstReadLen = randomIntBetween(0, input.length - 1).         randomReadAndSlice(indexInput, firstReadLen).         try {             switch(randomIntBetween(0, 2)) {                 case 0:                     indexInput.seek(Integer.MAX_VALUE + 4L).                     break.                 case 1:                     indexInput.seek(-randomIntBetween(1, 10)).                     break.                 case 2:                     int seek = input.length + randomIntBetween(1, 100).                     indexInput.seek(seek).                     break.                 default:                     fail().             }             fail().         } catch (IOException ex) {             assertThat(ex.getMessage(), containsString("EOF")).         } catch (IllegalArgumentException ex) {             assertThat(ex.getMessage(), containsString("negative position")).         }     } }
false;private;2;42;;private byte[] randomReadAndSlice(IndexInput indexInput, int length) throws IOException {     int readPos = (int) indexInput.getFilePointer().     byte[] output = new byte[length].     while (readPos < length) {         switch(randomIntBetween(0, 3)) {             case 0:                 // Read by one byte at a time                 output[readPos++] = indexInput.readByte().                 break.             case 1:                 // Read several bytes into target                 int len = randomIntBetween(1, length - readPos).                 indexInput.readBytes(output, readPos, len).                 readPos += len.                 break.             case 2:                 // Read several bytes into 0-offset target                 len = randomIntBetween(1, length - readPos).                 byte[] temp = new byte[len].                 indexInput.readBytes(temp, 0, len).                 System.arraycopy(temp, 0, output, readPos, len).                 readPos += len.                 break.             case 3:                 // Read using slice                 len = randomIntBetween(1, length - readPos).                 IndexInput slice = indexInput.slice("slice (" + readPos + ", " + len + ") of " + indexInput.toString(), readPos, len).                 temp = randomReadAndSlice(slice, len).                 // assert that position in the original input didn't change                 assertEquals(readPos, indexInput.getFilePointer()).                 System.arraycopy(temp, 0, output, readPos, len).                 readPos += len.                 indexInput.seek(readPos).                 assertEquals(readPos, indexInput.getFilePointer()).                 break.             default:                 fail().         }         assertEquals(readPos, indexInput.getFilePointer()).     }     return output. }
