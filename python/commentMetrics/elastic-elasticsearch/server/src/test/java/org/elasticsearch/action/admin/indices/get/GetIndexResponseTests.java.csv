commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected GetIndexResponse doParseInstance(XContentParser parser) throws IOException {     return GetIndexResponse.fromXContent(parser). }
false;protected;0;4;;@Override protected GetIndexResponse createBlankInstance() {     return new GetIndexResponse(). }
false;protected;0;34;;@Override protected GetIndexResponse createTestInstance() {     String[] indices = generateRandomStringArray(5, 5, false, false).     ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> mappings = ImmutableOpenMap.builder().     ImmutableOpenMap.Builder<String, List<AliasMetaData>> aliases = ImmutableOpenMap.builder().     ImmutableOpenMap.Builder<String, Settings> settings = ImmutableOpenMap.builder().     ImmutableOpenMap.Builder<String, Settings> defaultSettings = ImmutableOpenMap.builder().     IndexScopedSettings indexScopedSettings = IndexScopedSettings.DEFAULT_SCOPED_SETTINGS.     boolean includeDefaults = randomBoolean().     for (String index : indices) {         // rarely have no types         int typeCount = rarely() ? 0 : 1.         mappings.put(index, GetMappingsResponseTests.createMappingsForIndex(typeCount, true)).         List<AliasMetaData> aliasMetaDataList = new ArrayList<>().         int aliasesNum = randomIntBetween(0, 3).         for (int i = 0. i < aliasesNum. i++) {             aliasMetaDataList.add(GetAliasesResponseTests.createAliasMetaData()).         }         CollectionUtil.timSort(aliasMetaDataList, Comparator.comparing(AliasMetaData::alias)).         aliases.put(index, Collections.unmodifiableList(aliasMetaDataList)).         Settings.Builder builder = Settings.builder().         builder.put(RandomCreateIndexGenerator.randomIndexSettings()).         settings.put(index, builder.build()).         if (includeDefaults) {             defaultSettings.put(index, indexScopedSettings.diff(settings.get(index), Settings.EMPTY)).         }     }     return new GetIndexResponse(indices, mappings.build(), aliases.build(), settings.build(), defaultSettings.build()). }
false;protected;0;7;;@Override protected Predicate<String> getRandomFieldsExcludeFilter() {     // we do not want to add new fields at the root (index-level), or inside the blocks     return f -> f.equals("") || f.contains(".settings") || f.contains(".defaults") || f.contains(".mappings") || f.contains(".aliases"). }
false;private,static;1;8;;private static ImmutableOpenMap<String, List<AliasMetaData>> getTestAliases(String indexName) {     ImmutableOpenMap.Builder<String, List<AliasMetaData>> aliases = ImmutableOpenMap.builder().     List<AliasMetaData> indexAliases = new ArrayList<>().     indexAliases.add(new AliasMetaData.Builder("alias1").routing("r1").build()).     indexAliases.add(new AliasMetaData.Builder("alias2").filter("{\"term\": {\"year\": 2016}}").build()).     aliases.put(indexName, Collections.unmodifiableList(indexAliases)).     return aliases.build(). }
false;private,static;1;16;;private static ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> getTestMappings(String indexName) {     ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> mappings = ImmutableOpenMap.builder().     ImmutableOpenMap.Builder<String, MappingMetaData> indexMappings = ImmutableOpenMap.builder().     try {         indexMappings.put("doc", new MappingMetaData("doc", Collections.singletonMap("field_1", Collections.singletonMap("type", "string")))).     } catch (IOException e) {         throw new UncheckedIOException(e).     }     mappings.put(indexName, indexMappings.build()).     return mappings.build(). }
false;private,static;1;8;;private static ImmutableOpenMap<String, Settings> getTestSettings(String indexName) {     ImmutableOpenMap.Builder<String, Settings> settings = ImmutableOpenMap.builder().     Settings.Builder indexSettings = Settings.builder().     indexSettings.put(SETTING_NUMBER_OF_SHARDS, 2).     indexSettings.put(SETTING_NUMBER_OF_REPLICAS, 1).     settings.put(indexName, indexSettings.build()).     return settings.build(). }
false;private,static;0;11;;private static GetIndexResponse getExpectedTest630Response() {     // The only difference between this snippet and the one used for generation TEST_6_3_0_RESPONSE_BYTES is the     // constructor for GetIndexResponse which also takes defaultSettings now.     String indexName = "my_index".     String[] indices = { indexName }.     return new GetIndexResponse(indices, getTestMappings(indexName), getTestAliases(indexName), getTestSettings(indexName), ImmutableOpenMap.of()). }
false;private,static;0;13;;private static GetIndexResponse getResponseWithDefaultSettings() {     String indexName = "my_index".     String[] indices = { indexName }.     ImmutableOpenMap.Builder<String, Settings> defaultSettings = ImmutableOpenMap.builder().     Settings.Builder indexDefaultSettings = Settings.builder().     indexDefaultSettings.put(INDEX_REFRESH_INTERVAL_SETTING.getKey(), "1s").     defaultSettings.put(indexName, indexDefaultSettings.build()).     return new GetIndexResponse(indices, getTestMappings(indexName), getTestAliases(indexName), getTestSettings(indexName), defaultSettings.build()). }
false;public;0;8;;public void testCanDecode622Response() throws IOException {     StreamInput si = StreamInput.wrap(Base64.getDecoder().decode(TEST_6_3_0_RESPONSE_BYTES)).     si.setVersion(Version.V_6_3_0).     GetIndexResponse response = new GetIndexResponse().     response.readFrom(si).     Assert.assertEquals(TEST_6_3_0_RESPONSE_INSTANCE, response). }
false;public;0;9;;public void testCanOutput622Response() throws IOException {     GetIndexResponse responseWithExtraFields = getResponseWithDefaultSettings().     BytesStreamOutput bso = new BytesStreamOutput().     bso.setVersion(Version.V_6_3_0).     responseWithExtraFields.writeTo(bso).     String base64OfResponse = Base64.getEncoder().encodeToString(BytesReference.toBytes(bso.bytes())).     Assert.assertEquals(TEST_6_3_0_RESPONSE_BYTES, base64OfResponse). }
true;protected;0;4;/**  * For xContent roundtrip testing we force the xContent output to still contain types because the parser still expects them.  * The new typeless parsing is implemented in the client side GetIndexResponse.  */ ;/**  * For xContent roundtrip testing we force the xContent output to still contain types because the parser still expects them.  * The new typeless parsing is implemented in the client side GetIndexResponse.  */ @Override protected ToXContent.Params getToXContentParams() {     return new ToXContent.MapParams(Collections.singletonMap(BaseRestHandler.INCLUDE_TYPE_NAME_PARAMETER, "true")). }
