# id;timestamp;commentText;codeText;commentWords;codeWords
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1524684173;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1525076988;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1526029249;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1526289033;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1527583663;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1528706846;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1529082965;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1531729807;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1534362961;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1535723122;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1538067637;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1538170812;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1542742188;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits(), equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1544035746;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertThat("RestoreInProgress must be empty", restoreInProgress.entries(), hasSize(0))___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,that,restore,in,progress,must,be,empty,restore,in,progress,entries,has,size,0,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1544783963;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1545215361;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1546003245;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1546871063;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1546901964;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1547030937;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1547760072;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1548452429;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1548681182;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1549033151;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1549056242;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1549180095;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1549273295;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1549381458;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1550831438;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1551113053;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> private void unrestorableUseCase(final String indexName,                                      final Settings createIndexSettings,                                      final Settings repositorySettings,                                      final Settings restoreIndexSettings,                                      final Consumer<UnassignedInfo> checkUnassignedInfo,                                      final Runnable fixUpAction) throws Exception;1551124618;Execute the unrestorable test use case *;private void unrestorableUseCase(final String indexName,_                                     final Settings createIndexSettings,_                                     final Settings repositorySettings,_                                     final Settings restoreIndexSettings,_                                     final Consumer<UnassignedInfo> checkUnassignedInfo,_                                     final Runnable fixUpAction) throws Exception {_        _        final Path repositoryLocation = randomRepoPath()__        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                                .setType("fs")_                                                .setSettings(Settings.builder().put("location", repositoryLocation)))__        _        assertAcked(prepareCreate(indexName, Settings.builder().put(createIndexSettings)))___        _        final int nbDocs = scaledRandomIntBetween(10, 100)__        for (int i = 0_ i < nbDocs_ i++) {_            index(indexName, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        flushAndRefresh(indexName)__        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))___        _        final NumShards numShards = getNumShards(indexName)__        CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_                                                                            .setWaitForCompletion(true)_                                                                            .setIndices(indexName)_                                                                            .get()___        assertThat(snapshotResponse.getSnapshotInfo().state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotResponse.getSnapshotInfo().successfulShards(), equalTo(numShards.numPrimaries))__        assertThat(snapshotResponse.getSnapshotInfo().failedShards(), equalTo(0))___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("mock")_                                              .setSettings(Settings.builder()_                                                                   .put("location", repositoryLocation)_                                                                   .put(repositorySettings)_                                                                   .build()))___        _        RestoreSnapshotResponse restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_                                                                            .setIndices(indexName)_                                                                            .setIndexSettings(restoreIndexSettings)_                                                                            .setWaitForCompletion(true)_                                                                            .get()___        _        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(0))___        ClusterStateResponse clusterStateResponse = client().admin().cluster().prepareState().setCustoms(true).setRoutingTable(true).get()___        _        RestoreInProgress restoreInProgress = clusterStateResponse.getState().custom(RestoreInProgress.TYPE)__        assertNotNull("RestoreInProgress must be not null", restoreInProgress)__        assertTrue(_            "RestoreInProgress must be empty but found entries in " + restoreInProgress, restoreInProgress.isEmpty())___        _        assertThat(clusterStateResponse.getState().getRoutingTable().allShards(indexName), hasSize(numShards.totalNumShards))___        _        for (ShardRouting shard : clusterStateResponse.getState().getRoutingTable().allShards(indexName)) {_            if (shard.primary()) {_                assertThat(shard.state(), equalTo(ShardRoutingState.UNASSIGNED))__                assertThat(shard.recoverySource().getType(), equalTo(RecoverySource.Type.SNAPSHOT))__                assertThat(shard.unassignedInfo().getLastAllocationStatus(), equalTo(UnassignedInfo.AllocationStatus.DECIDERS_NO))__                checkUnassignedInfo.accept(shard.unassignedInfo())__            }_        }__        _        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                                              .setType("fs")_                                              .setSettings(Settings.builder().put("location", repositoryLocation)))___        _        fixUpAction.run()___        _        assertAcked(client().admin().indices().prepareDelete(indexName))___        restoreResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap").setWaitForCompletion(true).get()__        assertThat(restoreResponse.getRestoreInfo().totalShards(), equalTo(numShards.numPrimaries))__        assertThat(restoreResponse.getRestoreInfo().successfulShards(), equalTo(numShards.numPrimaries))___        _        ensureGreen(indexName)__        refresh(indexName)___        assertThat(client().prepareSearch(indexName).setSize(0).get().getHits().getTotalHits().value, equalTo((long) nbDocs))__    };execute,the,unrestorable,test,use,case;private,void,unrestorable,use,case,final,string,index,name,final,settings,create,index,settings,final,settings,repository,settings,final,settings,restore,index,settings,final,consumer,unassigned,info,check,unassigned,info,final,runnable,fix,up,action,throws,exception,final,path,repository,location,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,assert,acked,prepare,create,index,name,settings,builder,put,create,index,settings,final,int,nb,docs,scaled,random,int,between,10,100,for,int,i,0,i,nb,docs,i,index,index,name,integer,to,string,i,foo,bar,i,flush,and,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs,final,num,shards,num,shards,get,num,shards,index,name,create,snapshot,response,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,set,indices,index,name,get,assert,that,snapshot,response,get,snapshot,info,state,equal,to,snapshot,state,success,assert,that,snapshot,response,get,snapshot,info,successful,shards,equal,to,num,shards,num,primaries,assert,that,snapshot,response,get,snapshot,info,failed,shards,equal,to,0,assert,acked,client,admin,indices,prepare,delete,index,name,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,mock,set,settings,settings,builder,put,location,repository,location,put,repository,settings,build,restore,snapshot,response,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,index,name,set,index,settings,restore,index,settings,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,0,cluster,state,response,cluster,state,response,client,admin,cluster,prepare,state,set,customs,true,set,routing,table,true,get,restore,in,progress,restore,in,progress,cluster,state,response,get,state,custom,restore,in,progress,type,assert,not,null,restore,in,progress,must,be,not,null,restore,in,progress,assert,true,restore,in,progress,must,be,empty,but,found,entries,in,restore,in,progress,restore,in,progress,is,empty,assert,that,cluster,state,response,get,state,get,routing,table,all,shards,index,name,has,size,num,shards,total,num,shards,for,shard,routing,shard,cluster,state,response,get,state,get,routing,table,all,shards,index,name,if,shard,primary,assert,that,shard,state,equal,to,shard,routing,state,unassigned,assert,that,shard,recovery,source,get,type,equal,to,recovery,source,type,snapshot,assert,that,shard,unassigned,info,get,last,allocation,status,equal,to,unassigned,info,allocation,status,check,unassigned,info,accept,shard,unassigned,info,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repository,location,fix,up,action,run,assert,acked,client,admin,indices,prepare,delete,index,name,restore,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,response,get,restore,info,total,shards,equal,to,num,shards,num,primaries,assert,that,restore,response,get,restore,info,successful,shards,equal,to,num,shards,num,primaries,ensure,green,index,name,refresh,index,name,assert,that,client,prepare,search,index,name,set,size,0,get,get,hits,get,total,hits,value,equal,to,long,nb,docs
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1524684173;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        PutRepositoryResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,put,repository,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1525076988;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        PutRepositoryResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,put,repository,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1526029249;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        PutRepositoryResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,put,repository,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1526289033;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        PutRepositoryResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,put,repository,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1527583663;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        PutRepositoryResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,put,repository,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1528706846;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        PutRepositoryResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,put,repository,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1529082965;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        PutRepositoryResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,put,repository,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1531729807;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        PutRepositoryResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,put,repository,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1534362961;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1535723122;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1538067637;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1538170812;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1542742188;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1544035746;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1544783963;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1545215361;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1546871063;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1546901964;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1547030937;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1547760072;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(10))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,10,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1548681182;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(60))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,60,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1549033151;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(60))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,60,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1549056242;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(60))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,60,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1549180095;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(60))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,60,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1549273295;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(60))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,60,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1549381458;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(60))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,60,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1550831438;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(60))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,60,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1551113053;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(60))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,60,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testSnapshotCanceledOnRemovedShard() throws Exception;1551124618;This test ensures that when a shard is removed from a node (perhaps due to the node_leaving the cluster, then returning), all snapshotting of that shard is aborted, so_all Store references held onto by the snapshot are released.__See https://github.com/elastic/elasticsearch/issues/20876;public void testSnapshotCanceledOnRemovedShard() throws Exception {_        final int numPrimaries = 1__        final int numReplicas = 1__        final int numDocs = 100__        final String repo = "test-repo"__        final String index = "test-idx"__        final String snapshot = "test-snap"___        assertAcked(prepareCreate(index, 1,_            Settings.builder().put("number_of_shards", numPrimaries).put("number_of_replicas", numReplicas)))___        logger.info("--> indexing some data")__        for (int i = 0_ i < numDocs_ i++) {_            index(index, "_doc", Integer.toString(i), "foo", "bar" + i)__        }_        refresh()___        logger.info("--> creating repository")__        AcknowledgedResponse putRepositoryResponse =_            client().admin().cluster().preparePutRepository(repo).setType("mock").setSettings(Settings.builder()_                .put("location", randomRepoPath())_                .put("random", randomAlphaOfLength(10))_                .put("wait_after_unblock", 200)_            ).get()__        assertTrue(putRepositoryResponse.isAcknowledged())___        String blockedNode = blockNodeWithIndex(repo, index)___        logger.info("--> snapshot")__        client().admin().cluster().prepareCreateSnapshot(repo, snapshot)_            .setWaitForCompletion(false)_            .execute()___        logger.info("--> waiting for block to kick in on node [{}]", blockedNode)__        waitForBlock(blockedNode, repo, TimeValue.timeValueSeconds(10))___        logger.info("--> removing primary shard that is being snapshotted")__        ClusterState clusterState = internalCluster().clusterService(internalCluster().getMasterName()).state()__        IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(index)__        String nodeWithPrimary = clusterState.nodes().get(indexRoutingTable.shard(0).primaryShard().currentNodeId()).getName()__        assertNotNull("should be at least one node with a primary shard", nodeWithPrimary)__        IndicesService indicesService = internalCluster().getInstance(IndicesService.class, nodeWithPrimary)__        IndexService indexService = indicesService.indexService(resolveIndex(index))__        indexService.removeShard(0, "simulate node removal")___        logger.info("--> unblocking blocked node [{}]", blockedNode)__        unblockNode(repo, blockedNode)___        logger.info("--> ensuring snapshot is aborted and the aborted shard was marked as failed")__        SnapshotInfo snapshotInfo = waitForCompletion(repo, snapshot, TimeValue.timeValueSeconds(60))__        assertEquals(1, snapshotInfo.shardFailures().size())__        assertEquals(0, snapshotInfo.shardFailures().get(0).shardId())__        assertEquals("IndexShardSnapshotFailedException[Aborted]", snapshotInfo.shardFailures().get(0).reason())__    };this,test,ensures,that,when,a,shard,is,removed,from,a,node,perhaps,due,to,the,node,leaving,the,cluster,then,returning,all,snapshotting,of,that,shard,is,aborted,so,all,store,references,held,onto,by,the,snapshot,are,released,see,https,github,com,elastic,elasticsearch,issues,20876;public,void,test,snapshot,canceled,on,removed,shard,throws,exception,final,int,num,primaries,1,final,int,num,replicas,1,final,int,num,docs,100,final,string,repo,test,repo,final,string,index,test,idx,final,string,snapshot,test,snap,assert,acked,prepare,create,index,1,settings,builder,put,num,primaries,put,num,replicas,logger,info,indexing,some,data,for,int,i,0,i,num,docs,i,index,index,integer,to,string,i,foo,bar,i,refresh,logger,info,creating,repository,acknowledged,response,put,repository,response,client,admin,cluster,prepare,put,repository,repo,set,type,mock,set,settings,settings,builder,put,location,random,repo,path,put,random,random,alpha,of,length,10,put,200,get,assert,true,put,repository,response,is,acknowledged,string,blocked,node,block,node,with,index,repo,index,logger,info,snapshot,client,admin,cluster,prepare,create,snapshot,repo,snapshot,set,wait,for,completion,false,execute,logger,info,waiting,for,block,to,kick,in,on,node,blocked,node,wait,for,block,blocked,node,repo,time,value,time,value,seconds,10,logger,info,removing,primary,shard,that,is,being,snapshotted,cluster,state,cluster,state,internal,cluster,cluster,service,internal,cluster,get,master,name,state,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,string,node,with,primary,cluster,state,nodes,get,index,routing,table,shard,0,primary,shard,current,node,id,get,name,assert,not,null,should,be,at,least,one,node,with,a,primary,shard,node,with,primary,indices,service,indices,service,internal,cluster,get,instance,indices,service,class,node,with,primary,index,service,index,service,indices,service,index,service,resolve,index,index,index,service,remove,shard,0,simulate,node,removal,logger,info,unblocking,blocked,node,blocked,node,unblock,node,repo,blocked,node,logger,info,ensuring,snapshot,is,aborted,and,the,aborted,shard,was,marked,as,failed,snapshot,info,snapshot,info,wait,for,completion,repo,snapshot,time,value,time,value,seconds,60,assert,equals,1,snapshot,info,shard,failures,size,assert,equals,0,snapshot,info,shard,failures,get,0,shard,id,assert,equals,index,shard,snapshot,failed,exception,aborted,snapshot,info,shard,failures,get,0,reason
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1524684173;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1525076988;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1526029249;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1526289033;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1527583663;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1528706846;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1529082965;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1531729807;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1534362961;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1535723122;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1538067637;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1538170812;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1542742188;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1544035746;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1544783963;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1545215361;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1546003245;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1546871063;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1546901964;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1547030937;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1547760072;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1548452429;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1548681182;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1549033151;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1549056242;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1549180095;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1549273295;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1549381458;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1550831438;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1551113053;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testUnrestorableFilesDuringRestore() throws Exception;1551124618;Test that restoring a snapshot whose files can't be downloaded at all is not stuck or_does not hang indefinitely.;public void testUnrestorableFilesDuringRestore() throws Exception {_        final String indexName = "unrestorable-files"__        final int maxRetries = randomIntBetween(1, 10)___        Settings createIndexSettings = Settings.builder().put(SETTING_ALLOCATION_MAX_RETRY.getKey(), maxRetries).build()___        Settings repositorySettings = Settings.builder()_                                                .put("random", randomAlphaOfLength(10))_                                                .put("max_failure_number", 10000000L)_                                                _                                                .put("use_lucene_corruption", false)_                                                _                                                .put("random_data_file_io_exception_rate", 1.0)_                                                .build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.ALLOCATION_FAILED))__            assertThat(unassignedInfo.getNumFailedAllocations(), anyOf(equalTo(maxRetries), equalTo(1)))__        }___        unrestorableUseCase(indexName, createIndexSettings, repositorySettings, Settings.EMPTY, checkUnassignedInfo, () -> {})__    };test,that,restoring,a,snapshot,whose,files,can,t,be,downloaded,at,all,is,not,stuck,or,does,not,hang,indefinitely;public,void,test,unrestorable,files,during,restore,throws,exception,final,string,index,name,unrestorable,files,final,int,max,retries,random,int,between,1,10,settings,create,index,settings,settings,builder,put,get,key,max,retries,build,settings,repository,settings,settings,builder,put,random,random,alpha,of,length,10,put,10000000l,put,false,put,1,0,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,assert,that,unassigned,info,get,num,failed,allocations,any,of,equal,to,max,retries,equal,to,1,unrestorable,use,case,index,name,create,index,settings,repository,settings,settings,empty,check,unassigned,info
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1524684173;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1525076988;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1526029249;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1526289033;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1527583663;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1528706846;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1529082965;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1531729807;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1534362961;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1535723122;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1538067637;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1538170812;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1542742188;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1544035746;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1544783963;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1545215361;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1546003245;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1546871063;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1546901964;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1547030937;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1547760072;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1548452429;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1548681182;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1549033151;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1549056242;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1549180095;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1549273295;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1549381458;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1550831438;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1551113053;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception;1551124618;Tests that a snapshot with a corrupted global state file can still be restored;public void testRestoreSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_                    .setType("fs")_                    .setSettings(Settings.builder()_                        .put("location", repo)_                        .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_                client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_                client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        try(SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete("test-idx-1", "test-idx-2"))___        SnapshotException ex = expectThrows(SnapshotException.class, () -> client().admin().cluster()_            .prepareRestoreSnapshot("test-repo", "test-snap")_            .setRestoreGlobalState(true)_            .setWaitForCompletion(true)_            .get())__        assertThat(ex.getRepositoryName(), equalTo("test-repo"))__        assertThat(ex.getSnapshotName(), equalTo("test-snap"))__        assertThat(ex.getMessage(), containsString("failed to read global metadata"))___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()__        assertThat(restoreSnapshotResponse.getRestoreInfo().failedShards(), equalTo(0))__        assertThat(restoreSnapshotResponse.getRestoreInfo().successfulShards(), equalTo(snapshotInfo.successfulShards()))___        ensureGreen("test-idx-1", "test-idx-2")__        assertHitCount(client().prepareSearch("test-idx-*").setSize(0).get(), 3)__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,restored;public,void,test,restore,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,test,idx,1,test,idx,2,snapshot,exception,ex,expect,throws,snapshot,exception,class,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,restore,global,state,true,set,wait,for,completion,true,get,assert,that,ex,get,repository,name,equal,to,test,repo,assert,that,ex,get,snapshot,name,equal,to,test,snap,assert,that,ex,get,message,contains,string,failed,to,read,global,metadata,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,assert,that,restore,snapshot,response,get,restore,info,failed,shards,equal,to,0,assert,that,restore,snapshot,response,get,restore,info,successful,shards,equal,to,snapshot,info,successful,shards,ensure,green,test,idx,1,test,idx,2,assert,hit,count,client,prepare,search,test,idx,set,size,0,get,3
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1524684173;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final Map<String, IndexId> indexIds = repository.getRepositoryData().getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,map,string,index,id,index,ids,repository,get,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1525076988;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final Map<String, IndexId> indexIds = repository.getRepositoryData().getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,map,string,index,id,index,ids,repository,get,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1526029249;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final Map<String, IndexId> indexIds = repository.getRepositoryData().getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,map,string,index,id,index,ids,repository,get,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1526289033;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final Map<String, IndexId> indexIds = repository.getRepositoryData().getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,map,string,index,id,index,ids,repository,get,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1527583663;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final Map<String, IndexId> indexIds = repository.getRepositoryData().getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,map,string,index,id,index,ids,repository,get,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1528706846;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final Map<String, IndexId> indexIds = repository.getRepositoryData().getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,map,string,index,id,index,ids,repository,get,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1529082965;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final Map<String, IndexId> indexIds = repository.getRepositoryData().getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,map,string,index,id,index,ids,repository,get,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1531729807;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1534362961;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1535723122;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        RestoreSnapshotResponse restoreSnapshotResponse = client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,restore,snapshot,response,restore,snapshot,response,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1538067637;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1538170812;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1542742188;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1544035746;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1544783963;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1545215361;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1546003245;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1546871063;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1546901964;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1547030937;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1547760072;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1548452429;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1548681182;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1549033151;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1549056242;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1549180095;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1549273295;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1549381458;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1550831438;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1551113053;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception;1551124618;Tests that a snapshot of multiple indices including one with a corrupted index metadata_file can still be used to restore the non corrupted indices;public void testRestoreSnapshotWithCorruptedIndexMetadata() throws Exception {_        final Client client = client()__        final Path repo = randomRepoPath()__        final int nbIndices = randomIntBetween(2, 3)___        final Map<String, Integer> nbDocsPerIndex = new HashMap<>()__        for (int i = 0_ i < nbIndices_ i++) {_            String indexName = "test-idx-" + i___            assertAcked(prepareCreate(indexName).setSettings(Settings.builder()_                .put(SETTING_NUMBER_OF_SHARDS, Math.min(2, numberOfShards())).put(SETTING_NUMBER_OF_REPLICAS, 0)))___            int nbDocs = randomIntBetween(1, 10)__            nbDocsPerIndex.put(indexName, nbDocs)___            IndexRequestBuilder[] documents = new IndexRequestBuilder[nbDocs]__            for (int j = 0_ j < nbDocs_ j++) {_                documents[j] = client.prepareIndex(indexName, "_doc").setSource("foo", "bar")__            }_            indexRandom(true, documents)__        }_        flushAndRefresh()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)))___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setWaitForCompletion(true)_            .get()___        final SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.failedShards(), equalTo(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__        assertThat(snapshotInfo.indices(), hasSize(nbIndices))___        RepositoriesService service = internalCluster().getInstance(RepositoriesService.class, internalCluster().getMasterName())__        Repository repository = service.repository("test-repo")___        final RepositoryData repositoryData = getRepositoryData(repository)__        final Map<String, IndexId> indexIds = repositoryData.getIndices()__        assertThat(indexIds.size(), equalTo(nbIndices))___        _        final IndexId corruptedIndex = randomFrom(indexIds.values())__        final Path indexMetadataPath = repo.resolve("indices")_            .resolve(corruptedIndex.getId())_            .resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")___        _        try(SeekableByteChannel outChan = Files.newByteChannel(indexMetadataPath, StandardOpenOption.WRITE)) {_            outChan.truncate(randomInt(10))__        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().indices().prepareDelete(nbDocsPerIndex.keySet().toArray(new String[nbDocsPerIndex.size()])))___        Predicate<String> isRestorableIndex = index -> corruptedIndex.getName().equals(index) == false___        client().admin().cluster().prepareRestoreSnapshot("test-repo", "test-snap")_            .setIndices(nbDocsPerIndex.keySet().stream().filter(isRestorableIndex).toArray(String[]::new))_            .setRestoreGlobalState(randomBoolean())_            .setWaitForCompletion(true)_            .get()___        ensureGreen()__        for (Map.Entry<String, Integer> entry : nbDocsPerIndex.entrySet()) {_            if (isRestorableIndex.test(entry.getKey())) {_                assertHitCount(client().prepareSearch(entry.getKey()).setSize(0).get(), entry.getValue().longValue())__            }_        }__        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", snapshotInfo.snapshotId().getName()).get())__    };tests,that,a,snapshot,of,multiple,indices,including,one,with,a,corrupted,index,metadata,file,can,still,be,used,to,restore,the,non,corrupted,indices;public,void,test,restore,snapshot,with,corrupted,index,metadata,throws,exception,final,client,client,client,final,path,repo,random,repo,path,final,int,nb,indices,random,int,between,2,3,final,map,string,integer,nb,docs,per,index,new,hash,map,for,int,i,0,i,nb,indices,i,string,index,name,test,idx,i,assert,acked,prepare,create,index,name,set,settings,settings,builder,put,math,min,2,number,of,shards,put,0,int,nb,docs,random,int,between,1,10,nb,docs,per,index,put,index,name,nb,docs,index,request,builder,documents,new,index,request,builder,nb,docs,for,int,j,0,j,nb,docs,j,documents,j,client,prepare,index,index,name,set,source,foo,bar,index,random,true,documents,flush,and,refresh,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,wait,for,completion,true,get,final,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,failed,shards,equal,to,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,assert,that,snapshot,info,indices,has,size,nb,indices,repositories,service,service,internal,cluster,get,instance,repositories,service,class,internal,cluster,get,master,name,repository,repository,service,repository,test,repo,final,repository,data,repository,data,get,repository,data,repository,final,map,string,index,id,index,ids,repository,data,get,indices,assert,that,index,ids,size,equal,to,nb,indices,final,index,id,corrupted,index,random,from,index,ids,values,final,path,index,metadata,path,repo,resolve,indices,resolve,corrupted,index,get,id,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,try,seekable,byte,channel,out,chan,files,new,byte,channel,index,metadata,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,indices,prepare,delete,nb,docs,per,index,key,set,to,array,new,string,nb,docs,per,index,size,predicate,string,is,restorable,index,index,corrupted,index,get,name,equals,index,false,client,admin,cluster,prepare,restore,snapshot,test,repo,test,snap,set,indices,nb,docs,per,index,key,set,stream,filter,is,restorable,index,to,array,string,new,set,restore,global,state,random,boolean,set,wait,for,completion,true,get,ensure,green,for,map,entry,string,integer,entry,nb,docs,per,index,entry,set,if,is,restorable,index,test,entry,get,key,assert,hit,count,client,prepare,search,entry,get,key,set,size,0,get,entry,get,value,long,value,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,snapshot,info,snapshot,id,get,name,get
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1524684173;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1525076988;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1526029249;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1526289033;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1527583663;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1528706846;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1529082965;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1531729807;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1534362961;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1535723122;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1538067637;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1538170812;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1542742188;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1544035746;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1544783963;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1545215361;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1546003245;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1546871063;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1546901964;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1547030937;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1547760072;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1548452429;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1548681182;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1549033151;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1549056242;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1549180095;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1549273295;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1549381458;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1550831438;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1551113053;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testUnrestorableIndexDuringRestore() throws Exception;1551124618;Test that restoring an index with shard allocation filtering settings that prevents_its allocation does not hang indefinitely.;public void testUnrestorableIndexDuringRestore() throws Exception {_        final String indexName = "unrestorable-index"__        Settings restoreIndexSettings = Settings.builder().put("index.routing.allocation.include._name", randomAlphaOfLength(5)).build()___        Consumer<UnassignedInfo> checkUnassignedInfo = unassignedInfo -> {_            assertThat(unassignedInfo.getReason(), equalTo(UnassignedInfo.Reason.NEW_INDEX_RESTORED))__        }___        Runnable fixupAction =() -> {_            _            assertAcked(client().admin().indices().prepareUpdateSettings(indexName)_                                                    .setSettings(Settings.builder()_                                                                            .putNull("index.routing.allocation.include._name")_                                                                            .build()))__            assertAcked(client().admin().cluster().prepareReroute().setRetryFailed(true))__        }___        unrestorableUseCase(indexName, Settings.EMPTY, Settings.EMPTY, restoreIndexSettings, checkUnassignedInfo, fixupAction)__    };test,that,restoring,an,index,with,shard,allocation,filtering,settings,that,prevents,its,allocation,does,not,hang,indefinitely;public,void,test,unrestorable,index,during,restore,throws,exception,final,string,index,name,unrestorable,index,settings,restore,index,settings,settings,builder,put,index,routing,allocation,include,random,alpha,of,length,5,build,consumer,unassigned,info,check,unassigned,info,unassigned,info,assert,that,unassigned,info,get,reason,equal,to,unassigned,info,reason,runnable,fixup,action,assert,acked,client,admin,indices,prepare,update,settings,index,name,set,settings,settings,builder,put,null,index,routing,allocation,include,build,assert,acked,client,admin,cluster,prepare,reroute,set,retry,failed,true,unrestorable,use,case,index,name,settings,empty,settings,empty,restore,index,settings,check,unassigned,info,fixup,action
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1524684173;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1525076988;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1526029249;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1526289033;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1527583663;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1528706846;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1529082965;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1531729807;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1534362961;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1535723122;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1538067637;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1538170812;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1542742188;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1544035746;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1544783963;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1545215361;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1546003245;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1546871063;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1546901964;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1547030937;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1547760072;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1548452429;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1548681182;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1549033151;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1549056242;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1549180095;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1549273295;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1549381458;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1550831438;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1551113053;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
SharedClusterSnapshotRestoreIT -> public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception;1551124618;Tests that a snapshot with a corrupted global state file can still be deleted;public void testDeleteSnapshotWithCorruptedGlobalState() throws Exception {_        final Path repo = randomRepoPath()___        assertAcked(client().admin().cluster().preparePutRepository("test-repo")_            .setType("fs")_            .setSettings(Settings.builder()_                .put("location", repo)_                .put("chunk_size", randomIntBetween(100, 1000), ByteSizeUnit.BYTES)))___        createIndex("test-idx-1", "test-idx-2")__        indexRandom(true,_            client().prepareIndex("test-idx-1", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"),_            client().prepareIndex("test-idx-2", "_doc").setSource("foo", "bar"))__        flushAndRefresh("test-idx-1", "test-idx-2")___        CreateSnapshotResponse createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        SnapshotInfo snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))___        final Path globalStatePath = repo.resolve("meta-" + snapshotInfo.snapshotId().getUUID() + ".dat")__        if (randomBoolean()) {_            _            IOUtils.deleteFilesIgnoringExceptions(globalStatePath)__        } else {_            _            try (SeekableByteChannel outChan = Files.newByteChannel(globalStatePath, StandardOpenOption.WRITE)) {_                outChan.truncate(randomInt(10))__            }_        }__        List<SnapshotInfo> snapshotInfos = client().admin().cluster().prepareGetSnapshots("test-repo").get().getSnapshots()__        assertThat(snapshotInfos.size(), equalTo(1))__        assertThat(snapshotInfos.get(0).state(), equalTo(SnapshotState.SUCCESS))__        assertThat(snapshotInfos.get(0).snapshotId().getName(), equalTo("test-snap"))___        SnapshotsStatusResponse snapshotStatusResponse =_            client().admin().cluster().prepareSnapshotStatus("test-repo").setSnapshots("test-snap").get()__        assertThat(snapshotStatusResponse.getSnapshots(), hasSize(1))__        assertThat(snapshotStatusResponse.getSnapshots().get(0).getSnapshot().getSnapshotId().getName(), equalTo("test-snap"))___        assertAcked(client().admin().cluster().prepareDeleteSnapshot("test-repo", "test-snap").get())__        assertThrows(client().admin().cluster().prepareGetSnapshots("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)__        assertThrows(client().admin().cluster().prepareSnapshotStatus("test-repo").addSnapshots("test-snap"),_            SnapshotMissingException.class)___        createSnapshotResponse = client().admin().cluster().prepareCreateSnapshot("test-repo", "test-snap")_            .setIncludeGlobalState(true)_            .setWaitForCompletion(true)_            .get()__        snapshotInfo = createSnapshotResponse.getSnapshotInfo()__        assertThat(snapshotInfo.successfulShards(), greaterThan(0))__        assertThat(snapshotInfo.successfulShards(), equalTo(snapshotInfo.totalShards()))__    };tests,that,a,snapshot,with,a,corrupted,global,state,file,can,still,be,deleted;public,void,test,delete,snapshot,with,corrupted,global,state,throws,exception,final,path,repo,random,repo,path,assert,acked,client,admin,cluster,prepare,put,repository,test,repo,set,type,fs,set,settings,settings,builder,put,location,repo,put,random,int,between,100,1000,byte,size,unit,bytes,create,index,test,idx,1,test,idx,2,index,random,true,client,prepare,index,test,idx,1,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,client,prepare,index,test,idx,2,set,source,foo,bar,flush,and,refresh,test,idx,1,test,idx,2,create,snapshot,response,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards,final,path,global,state,path,repo,resolve,meta,snapshot,info,snapshot,id,get,uuid,dat,if,random,boolean,ioutils,delete,files,ignoring,exceptions,global,state,path,else,try,seekable,byte,channel,out,chan,files,new,byte,channel,global,state,path,standard,open,option,write,out,chan,truncate,random,int,10,list,snapshot,info,snapshot,infos,client,admin,cluster,prepare,get,snapshots,test,repo,get,get,snapshots,assert,that,snapshot,infos,size,equal,to,1,assert,that,snapshot,infos,get,0,state,equal,to,snapshot,state,success,assert,that,snapshot,infos,get,0,snapshot,id,get,name,equal,to,test,snap,snapshots,status,response,snapshot,status,response,client,admin,cluster,prepare,snapshot,status,test,repo,set,snapshots,test,snap,get,assert,that,snapshot,status,response,get,snapshots,has,size,1,assert,that,snapshot,status,response,get,snapshots,get,0,get,snapshot,get,snapshot,id,get,name,equal,to,test,snap,assert,acked,client,admin,cluster,prepare,delete,snapshot,test,repo,test,snap,get,assert,throws,client,admin,cluster,prepare,get,snapshots,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,assert,throws,client,admin,cluster,prepare,snapshot,status,test,repo,add,snapshots,test,snap,snapshot,missing,exception,class,create,snapshot,response,client,admin,cluster,prepare,create,snapshot,test,repo,test,snap,set,include,global,state,true,set,wait,for,completion,true,get,snapshot,info,create,snapshot,response,get,snapshot,info,assert,that,snapshot,info,successful,shards,greater,than,0,assert,that,snapshot,info,successful,shards,equal,to,snapshot,info,total,shards
