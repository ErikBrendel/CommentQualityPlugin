commented;modifiers;parameterAmount;loc;comment;code
false;protected,abstract;1;1;;protected abstract ClusterState getMockClusterState(DiscoveryNode node).
false;public;0;4;;@Override public DiscoveryNode getNode() {     return node. }
false;public;4;47;;@Override public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws TransportException {     // we make sure that nodes get added to the connected ones when calling addTransportAddress, by returning proper nodes info     if (connectMode) {         if (TransportLivenessAction.NAME.equals(action)) {             TransportResponseHandler transportResponseHandler = responseHandlers.onResponseReceived(requestId, listener).             ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY).             transportResponseHandler.handleResponse(new LivenessResponse(clusterName, node)).         } else if (ClusterStateAction.NAME.equals(action)) {             TransportResponseHandler transportResponseHandler = responseHandlers.onResponseReceived(requestId, listener).             ClusterState clusterState = getMockClusterState(node).             transportResponseHandler.handleResponse(new ClusterStateResponse(clusterName, clusterState, 0L, false)).         } else if (TransportService.HANDSHAKE_ACTION_NAME.equals(action)) {             TransportResponseHandler transportResponseHandler = responseHandlers.onResponseReceived(requestId, listener).             Version version = node.getVersion().             transportResponseHandler.handleResponse(new TransportService.HandshakeResponse(node, clusterName, version)).         } else {             throw new UnsupportedOperationException("Mock transport does not understand action " + action).         }         return.     }     // once nodes are connected we'll just return errors for each sendRequest call     triedNodes.add(node).     if (random.nextInt(100) > 10) {         connectTransportExceptions.incrementAndGet().         throw new ConnectTransportException(node, "node not available").     } else {         if (random.nextBoolean()) {             failures.incrementAndGet().             // throw whatever exception that is not a subclass of ConnectTransportException             throw new IllegalStateException().         } else {             TransportResponseHandler transportResponseHandler = responseHandlers.onResponseReceived(requestId, listener).             if (random.nextBoolean()) {                 successes.incrementAndGet().                 transportResponseHandler.handleResponse(newResponse()).             } else {                 failures.incrementAndGet().                 transportResponseHandler.handleException(new TransportException("transport exception")).             }         }     } }
false;public;3;60;;@Override public Releasable openConnection(DiscoveryNode node, ConnectionProfile profile, ActionListener<Connection> connectionListener) {     connectionListener.onResponse(new CloseableConnection() {          @Override         public DiscoveryNode getNode() {             return node.         }          @Override         public void sendRequest(long requestId, String action, TransportRequest request, TransportRequestOptions options) throws TransportException {             // we make sure that nodes get added to the connected ones when calling addTransportAddress, by returning proper nodes info             if (connectMode) {                 if (TransportLivenessAction.NAME.equals(action)) {                     TransportResponseHandler transportResponseHandler = responseHandlers.onResponseReceived(requestId, listener).                     ClusterName clusterName = ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY).                     transportResponseHandler.handleResponse(new LivenessResponse(clusterName, node)).                 } else if (ClusterStateAction.NAME.equals(action)) {                     TransportResponseHandler transportResponseHandler = responseHandlers.onResponseReceived(requestId, listener).                     ClusterState clusterState = getMockClusterState(node).                     transportResponseHandler.handleResponse(new ClusterStateResponse(clusterName, clusterState, 0L, false)).                 } else if (TransportService.HANDSHAKE_ACTION_NAME.equals(action)) {                     TransportResponseHandler transportResponseHandler = responseHandlers.onResponseReceived(requestId, listener).                     Version version = node.getVersion().                     transportResponseHandler.handleResponse(new TransportService.HandshakeResponse(node, clusterName, version)).                 } else {                     throw new UnsupportedOperationException("Mock transport does not understand action " + action).                 }                 return.             }             // once nodes are connected we'll just return errors for each sendRequest call             triedNodes.add(node).             if (random.nextInt(100) > 10) {                 connectTransportExceptions.incrementAndGet().                 throw new ConnectTransportException(node, "node not available").             } else {                 if (random.nextBoolean()) {                     failures.incrementAndGet().                     // throw whatever exception that is not a subclass of ConnectTransportException                     throw new IllegalStateException().                 } else {                     TransportResponseHandler transportResponseHandler = responseHandlers.onResponseReceived(requestId, listener).                     if (random.nextBoolean()) {                         successes.incrementAndGet().                         transportResponseHandler.handleResponse(newResponse()).                     } else {                         failures.incrementAndGet().                         transportResponseHandler.handleException(new TransportException("transport exception")).                     }                 }             }         }     }).     return () -> {     }. }
false;protected,abstract;0;1;;protected abstract Response newResponse().
false;public;0;3;;public void endConnectMode() {     this.connectMode = false. }
false;public;0;3;;public int connectTransportExceptions() {     return connectTransportExceptions.get(). }
false;public;0;3;;public int failures() {     return failures.get(). }
false;public;0;3;;public int successes() {     return successes.get(). }
false;public;0;3;;public Set<DiscoveryNode> triedNodes() {     return triedNodes. }
false;public;0;4;;@Override public BoundTransportAddress boundAddress() {     return null. }
false;public;2;4;;@Override public TransportAddress[] addressesFromString(String address, int perAddressLimit) throws UnknownHostException {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Lifecycle.State lifecycleState() {     return null. }
false;public;1;4;;@Override public void addLifecycleListener(LifecycleListener listener) {     throw new UnsupportedOperationException(). }
false;public;1;4;;@Override public void removeLifecycleListener(LifecycleListener listener) {     throw new UnsupportedOperationException(). }
false;public;0;2;;@Override public void start() { }
false;public;0;2;;@Override public void stop() { }
false;public;0;2;;@Override public void close() { }
false;public;0;4;;@Override public Map<String, BoundTransportAddress> profileBoundAddresses() {     return Collections.emptyMap(). }
false;public;0;4;;@Override public TransportStats getStats() {     throw new UnsupportedOperationException(). }
false;public;1;9;;@Override public <Request extends TransportRequest> void registerRequestHandler(RequestHandlerRegistry<Request> reg) {     synchronized (requestHandlerMutex) {         if (requestHandlers.containsKey(reg.getAction())) {             throw new IllegalArgumentException("transport handlers for action " + reg.getAction() + " is already registered").         }         requestHandlers = MapBuilder.newMapBuilder(requestHandlers).put(reg.getAction(), reg).immutableMap().     } }
false;public;0;4;;@Override public ResponseHandlers getResponseHandlers() {     return responseHandlers. }
false;public;1;4;;@Override public RequestHandlerRegistry getRequestHandler(String action) {     return requestHandlers.get(action). }
false;public;1;4;;@Override public void addMessageListener(TransportMessageListener listener) {     this.listener = listener. }
false;public;1;4;;@Override public boolean removeMessageListener(TransportMessageListener listener) {     throw new UnsupportedOperationException(). }
