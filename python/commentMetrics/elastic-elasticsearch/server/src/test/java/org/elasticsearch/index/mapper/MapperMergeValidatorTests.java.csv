commented;modifiers;parameterAmount;loc;comment;code
false;public;0;13;;public void testDuplicateFieldAliasAndObject() {     ObjectMapper objectMapper = createObjectMapper("some.path").     FieldAliasMapper aliasMapper = new FieldAliasMapper("path", "some.path", "field").     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> MapperMergeValidator.validateMapperStructure("type", singletonList(objectMapper), emptyList(), singletonList(aliasMapper), emptyMap(), new FieldTypeLookup())).     assertEquals("Field [some.path] is defined both as an object and a field in [type]", e.getMessage()). }
false;public;0;9;;public void testFieldAliasWithNestedScope() {     ObjectMapper objectMapper = createNestedObjectMapper("nested").     FieldAliasMapper aliasMapper = new FieldAliasMapper("alias", "nested.alias", "nested.field").     MapperMergeValidator.validateFieldReferences(emptyList(), singletonList(aliasMapper), Collections.singletonMap("nested", objectMapper), new FieldTypeLookup()). }
false;public;0;12;;public void testFieldAliasWithDifferentObjectScopes() {     Map<String, ObjectMapper> fullPathObjectMappers = new HashMap<>().     fullPathObjectMappers.put("object1", createObjectMapper("object1")).     fullPathObjectMappers.put("object2", createObjectMapper("object2")).     FieldAliasMapper aliasMapper = new FieldAliasMapper("alias", "object2.alias", "object1.field").     MapperMergeValidator.validateFieldReferences(emptyList(), singletonList(aliasMapper), fullPathObjectMappers, new FieldTypeLookup()). }
false;public;0;15;;public void testFieldAliasWithNestedTarget() {     ObjectMapper objectMapper = createNestedObjectMapper("nested").     FieldAliasMapper aliasMapper = new FieldAliasMapper("alias", "alias", "nested.field").     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> MapperMergeValidator.validateFieldReferences(emptyList(), singletonList(aliasMapper), Collections.singletonMap("nested", objectMapper), new FieldTypeLookup())).     String expectedMessage = "Invalid [path] value [nested.field] for field alias [alias]: " + "an alias must have the same nested scope as its target. The alias is not nested, " + "but the target's nested scope is [nested].".     assertEquals(expectedMessage, e.getMessage()). }
false;public;0;19;;public void testFieldAliasWithDifferentNestedScopes() {     Map<String, ObjectMapper> fullPathObjectMappers = new HashMap<>().     fullPathObjectMappers.put("nested1", createNestedObjectMapper("nested1")).     fullPathObjectMappers.put("nested2", createNestedObjectMapper("nested2")).     FieldAliasMapper aliasMapper = new FieldAliasMapper("alias", "nested2.alias", "nested1.field").     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> MapperMergeValidator.validateFieldReferences(emptyList(), singletonList(aliasMapper), fullPathObjectMappers, new FieldTypeLookup())).     String expectedMessage = "Invalid [path] value [nested1.field] for field alias [nested2.alias]: " + "an alias must have the same nested scope as its target. The alias's nested scope is [nested2], " + "but the target's nested scope is [nested1].".     assertEquals(expectedMessage, e.getMessage()). }
false;private,static;1;5;;private static ObjectMapper createObjectMapper(String name) {     return new ObjectMapper(name, name, true, ObjectMapper.Nested.NO, ObjectMapper.Dynamic.FALSE, emptyMap(), Settings.EMPTY). }
false;private,static;1;5;;private static ObjectMapper createNestedObjectMapper(String name) {     return new ObjectMapper(name, name, true, ObjectMapper.Nested.newNested(false, false), ObjectMapper.Dynamic.FALSE, emptyMap(), Settings.EMPTY). }
