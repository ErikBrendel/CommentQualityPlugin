commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected CancelTasksResponse createTestInstance() {     List<TaskInfo> randomTasks = randomTasks().     return new CancelTasksResponse(randomTasks, Collections.emptyList(), Collections.emptyList()). }
false;private,static;0;7;;private static List<TaskInfo> randomTasks() {     List<TaskInfo> randomTasks = new ArrayList<>().     for (int i = 0. i < randomInt(10). i++) {         randomTasks.add(TaskInfoTests.randomTaskInfo()).     }     return randomTasks. }
false;protected;0;5;;@Override protected Predicate<String> getRandomFieldsExcludeFilter() {     // status and headers hold arbitrary content, we can't inject random fields in them     return field -> field.endsWith("status") || field.endsWith("headers"). }
false;protected;2;7;;@Override protected void assertEqualInstances(CancelTasksResponse expectedInstance, CancelTasksResponse newInstance) {     assertNotSame(expectedInstance, newInstance).     assertThat(newInstance.getTasks(), equalTo(expectedInstance.getTasks())).     ListTasksResponseTests.assertOnNodeFailures(newInstance.getNodeFailures(), expectedInstance.getNodeFailures()).     ListTasksResponseTests.assertOnTaskFailures(newInstance.getTaskFailures(), expectedInstance.getTaskFailures()). }
false;protected;1;4;;@Override protected CancelTasksResponse doParseInstance(XContentParser parser) {     return CancelTasksResponse.fromXContent(parser). }
false;protected;0;4;;@Override protected boolean supportsUnknownFields() {     return true. }
false;protected;0;4;;@Override protected boolean assertToXContentEquivalence() {     return true. }
true;public;0;11;/**  * Test parsing {@link ListTasksResponse} with inner failures as they don't support asserting on xcontent equivalence, given that  * exceptions are not parsed back as the same original class. We run the usual {@link AbstractXContentTestCase#testFromXContent()}  * without failures, and this other test with failures where we disable asserting on xcontent equivalence at the end.  */ ;/**  * Test parsing {@link ListTasksResponse} with inner failures as they don't support asserting on xcontent equivalence, given that  * exceptions are not parsed back as the same original class. We run the usual {@link AbstractXContentTestCase#testFromXContent()}  * without failures, and this other test with failures where we disable asserting on xcontent equivalence at the end.  */ public void testFromXContentWithFailures() throws IOException {     Supplier<CancelTasksResponse> instanceSupplier = CancelTasksResponseTests::createTestInstanceWithFailures.     // with random fields insertion in the inner exceptions, some random stuff may be parsed back as metadata,     // but that does not bother our assertions, as we only want to test that we don't break.     boolean supportsUnknownFields = true.     // exceptions are not of the same type whenever parsed back     boolean assertToXContentEquivalence = false.     AbstractXContentTestCase.testFromXContent(NUMBER_OF_TEST_RUNS, instanceSupplier, supportsUnknownFields, Strings.EMPTY_ARRAY, getRandomFieldsExcludeFilter(), this::createParser, this::doParseInstance, this::assertEqualInstances, assertToXContentEquivalence, ToXContent.EMPTY_PARAMS). }
false;private,static;0;13;;private static CancelTasksResponse createTestInstanceWithFailures() {     int numNodeFailures = randomIntBetween(0, 3).     List<FailedNodeException> nodeFailures = new ArrayList<>(numNodeFailures).     for (int i = 0. i < numNodeFailures. i++) {         nodeFailures.add(new FailedNodeException(randomAlphaOfLength(5), "error message", new ConnectException())).     }     int numTaskFailures = randomIntBetween(0, 3).     List<TaskOperationFailure> taskFailures = new ArrayList<>(numTaskFailures).     for (int i = 0. i < numTaskFailures. i++) {         taskFailures.add(new TaskOperationFailure(randomAlphaOfLength(5), randomLong(), new IllegalStateException())).     }     return new CancelTasksResponse(randomTasks(), taskFailures, nodeFailures). }
