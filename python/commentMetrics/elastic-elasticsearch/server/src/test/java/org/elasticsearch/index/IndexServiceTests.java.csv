commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return Collections.singleton(InternalSettingsPlugin.class). }
false;public,static;1;6;;public static CompressedXContent filter(QueryBuilder filterBuilder) throws IOException {     XContentBuilder builder = XContentFactory.jsonBuilder().     filterBuilder.toXContent(builder, ToXContent.EMPTY_PARAMS).     builder.close().     return new CompressedXContent(Strings.toString(builder)). }
false;protected;0;20;;@Override protected void runInternal() {     final CountDownLatch l1 = latch.get().     final CountDownLatch l2 = latch2.get().     count.incrementAndGet().     assertTrue("generic threadpool is configured", Thread.currentThread().getName().contains("[generic]")).     l1.countDown().     try {         l2.await().     } catch (InterruptedException e) {         fail("interrupted").     }     if (randomBoolean()) {         // task can throw exceptions!!         if (randomBoolean()) {             throw new RuntimeException("foo").         } else {             throw new RuntimeException("bar").         }     } }
false;protected;0;4;;@Override protected String getThreadPool() {     return ThreadPool.Names.GENERIC. }
false;protected;0;4;;@Override protected void runInternal() { }
false;protected;0;4;;@Override protected void runInternal() { }
false;public;0;86;;public void testBaseAsyncTask() throws InterruptedException, IOException {     IndexService indexService = createIndex("test", Settings.EMPTY).     AtomicReference<CountDownLatch> latch = new AtomicReference<>(new CountDownLatch(1)).     AtomicReference<CountDownLatch> latch2 = new AtomicReference<>(new CountDownLatch(1)).     final AtomicInteger count = new AtomicInteger().     IndexService.BaseAsyncTask task = new IndexService.BaseAsyncTask(indexService, TimeValue.timeValueMillis(1)) {          @Override         protected void runInternal() {             final CountDownLatch l1 = latch.get().             final CountDownLatch l2 = latch2.get().             count.incrementAndGet().             assertTrue("generic threadpool is configured", Thread.currentThread().getName().contains("[generic]")).             l1.countDown().             try {                 l2.await().             } catch (InterruptedException e) {                 fail("interrupted").             }             if (randomBoolean()) {                 // task can throw exceptions!!                 if (randomBoolean()) {                     throw new RuntimeException("foo").                 } else {                     throw new RuntimeException("bar").                 }             }         }          @Override         protected String getThreadPool() {             return ThreadPool.Names.GENERIC.         }     }.     latch.get().await().     latch.set(new CountDownLatch(1)).     assertEquals(1, count.get()).     // here we need to swap first before we let it go otherwise threads might be very fast and run that task twice due to     // random exception and the schedule interval is 1ms     latch2.getAndSet(new CountDownLatch(1)).countDown().     latch.get().await().     assertEquals(2, count.get()).     task.close().     latch2.get().countDown().     assertEquals(2, count.get()).     task = new IndexService.BaseAsyncTask(indexService, TimeValue.timeValueMillis(1000000)) {          @Override         protected void runInternal() {         }     }.     assertTrue(task.mustReschedule()).     // now close the index     final Index index = indexService.index().     assertAcked(client().admin().indices().prepareClose(index.getName())).     awaitBusy(() -> getInstanceFromNode(IndicesService.class).hasIndex(index)).     final IndexService closedIndexService = getInstanceFromNode(IndicesService.class).indexServiceSafe(index).     assertNotSame(indexService, closedIndexService).     assertFalse(task.mustReschedule()).     assertFalse(task.isClosed()).     assertEquals(1000000, task.getInterval().millis()).     // now reopen the index     assertAcked(client().admin().indices().prepareOpen(index.getName())).     awaitBusy(() -> getInstanceFromNode(IndicesService.class).hasIndex(index)).     indexService = getInstanceFromNode(IndicesService.class).indexServiceSafe(index).     assertNotSame(closedIndexService, indexService).     task = new IndexService.BaseAsyncTask(indexService, TimeValue.timeValueMillis(100000)) {          @Override         protected void runInternal() {         }     }.     assertTrue(task.mustReschedule()).     assertFalse(task.isClosed()).     assertTrue(task.isScheduled()).     indexService.close("simon says", false).     assertFalse("no shards left", task.mustReschedule()).     assertTrue(task.isScheduled()).     task.close().     assertFalse(task.isScheduled()). }
false;public;0;70;;public void testRefreshTaskIsUpdated() throws Exception {     IndexService indexService = createIndex("test", Settings.EMPTY).     IndexService.AsyncRefreshTask refreshTask = indexService.getRefreshTask().     assertEquals(1000, refreshTask.getInterval().millis()).     assertTrue(indexService.getRefreshTask().mustReschedule()).     // now disable     client().admin().indices().prepareUpdateSettings("test").setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), -1)).get().     assertNotSame(refreshTask, indexService.getRefreshTask()).     assertTrue(refreshTask.isClosed()).     assertFalse(refreshTask.isScheduled()).     // set it to 100ms     client().admin().indices().prepareUpdateSettings("test").setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), "100ms")).get().     assertNotSame(refreshTask, indexService.getRefreshTask()).     assertTrue(refreshTask.isClosed()).     refreshTask = indexService.getRefreshTask().     assertTrue(refreshTask.mustReschedule()).     assertTrue(refreshTask.isScheduled()).     assertEquals(100, refreshTask.getInterval().millis()).     // set it to 200ms     client().admin().indices().prepareUpdateSettings("test").setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), "200ms")).get().     assertNotSame(refreshTask, indexService.getRefreshTask()).     assertTrue(refreshTask.isClosed()).     refreshTask = indexService.getRefreshTask().     assertTrue(refreshTask.mustReschedule()).     assertTrue(refreshTask.isScheduled()).     assertEquals(200, refreshTask.getInterval().millis()).     // set it to 200ms again     client().admin().indices().prepareUpdateSettings("test").setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), "200ms")).get().     assertSame(refreshTask, indexService.getRefreshTask()).     assertTrue(indexService.getRefreshTask().mustReschedule()).     assertTrue(refreshTask.isScheduled()).     assertFalse(refreshTask.isClosed()).     assertEquals(200, refreshTask.getInterval().millis()).     // now close the index     final Index index = indexService.index().     assertAcked(client().admin().indices().prepareClose(index.getName())).     awaitBusy(() -> getInstanceFromNode(IndicesService.class).hasIndex(index)).     final IndexService closedIndexService = getInstanceFromNode(IndicesService.class).indexServiceSafe(index).     assertNotSame(indexService, closedIndexService).     assertNotSame(refreshTask, closedIndexService.getRefreshTask()).     assertFalse(closedIndexService.getRefreshTask().mustReschedule()).     assertFalse(closedIndexService.getRefreshTask().isClosed()).     assertEquals(200, closedIndexService.getRefreshTask().getInterval().millis()).     // now reopen the index     assertAcked(client().admin().indices().prepareOpen(index.getName())).     awaitBusy(() -> getInstanceFromNode(IndicesService.class).hasIndex(index)).     indexService = getInstanceFromNode(IndicesService.class).indexServiceSafe(index).     assertNotSame(closedIndexService, indexService).     refreshTask = indexService.getRefreshTask().     assertTrue(indexService.getRefreshTask().mustReschedule()).     assertTrue(refreshTask.isScheduled()).     assertFalse(refreshTask.isClosed()).     indexService.close("simon says", false).     assertFalse(refreshTask.isScheduled()).     assertTrue(refreshTask.isClosed()). }
false;public;0;39;;public void testFsyncTaskIsRunning() throws Exception {     Settings settings = Settings.builder().put(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey(), Translog.Durability.ASYNC).build().     IndexService indexService = createIndex("test", settings).     IndexService.AsyncTranslogFSync fsyncTask = indexService.getFsyncTask().     assertNotNull(fsyncTask).     assertEquals(5000, fsyncTask.getInterval().millis()).     assertTrue(fsyncTask.mustReschedule()).     assertTrue(fsyncTask.isScheduled()).     // now close the index     final Index index = indexService.index().     assertAcked(client().admin().indices().prepareClose(index.getName())).     awaitBusy(() -> getInstanceFromNode(IndicesService.class).hasIndex(index)).     final IndexService closedIndexService = getInstanceFromNode(IndicesService.class).indexServiceSafe(index).     assertNotSame(indexService, closedIndexService).     assertNotSame(fsyncTask, closedIndexService.getFsyncTask()).     assertFalse(closedIndexService.getFsyncTask().mustReschedule()).     assertFalse(closedIndexService.getFsyncTask().isClosed()).     assertEquals(5000, closedIndexService.getFsyncTask().getInterval().millis()).     // now reopen the index     assertAcked(client().admin().indices().prepareOpen(index.getName())).     awaitBusy(() -> getInstanceFromNode(IndicesService.class).hasIndex(index)).     indexService = getInstanceFromNode(IndicesService.class).indexServiceSafe(index).     assertNotSame(closedIndexService, indexService).     fsyncTask = indexService.getFsyncTask().     assertTrue(indexService.getRefreshTask().mustReschedule()).     assertTrue(fsyncTask.isScheduled()).     assertFalse(fsyncTask.isClosed()).     indexService.close("simon says", false).     assertFalse(fsyncTask.isScheduled()).     assertTrue(fsyncTask.isClosed()).     indexService = createIndex("test1", Settings.EMPTY).     assertNull(indexService.getFsyncTask()). }
false;public;0;45;;public void testRefreshActuallyWorks() throws Exception {     IndexService indexService = createIndex("test", Settings.EMPTY).     ensureGreen("test").     IndexService.AsyncRefreshTask refreshTask = indexService.getRefreshTask().     assertEquals(1000, refreshTask.getInterval().millis()).     assertTrue(indexService.getRefreshTask().mustReschedule()).     IndexShard shard = indexService.getShard(0).     client().prepareIndex("test", "test", "0").setSource("{\"foo\": \"bar\"}", XContentType.JSON).get().     // now disable the refresh     client().admin().indices().prepareUpdateSettings("test").setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), -1)).get().     // when we update we reschedule the existing task AND fire off an async refresh to make sure we make everything visible     // before that this is why we need to wait for the refresh task to be unscheduled and the first doc to be visible     assertTrue(refreshTask.isClosed()).     refreshTask = indexService.getRefreshTask().     assertBusy(() -> {         // we are running on updateMetaData if the interval changes         try (Engine.Searcher searcher = shard.acquireSearcher("test")) {             TopDocs search = searcher.searcher().search(new MatchAllDocsQuery(), 10).             assertEquals(1, search.totalHits.value).         }     }).     assertFalse(refreshTask.isClosed()).     // refresh every millisecond     client().prepareIndex("test", "test", "1").setSource("{\"foo\": \"bar\"}", XContentType.JSON).get().     client().admin().indices().prepareUpdateSettings("test").setSettings(Settings.builder().put(IndexSettings.INDEX_REFRESH_INTERVAL_SETTING.getKey(), "1ms")).get().     assertTrue(refreshTask.isClosed()).     assertBusy(() -> {         // this one becomes visible due to the force refresh we are running on updateMetaData if the interval changes         try (Engine.Searcher searcher = shard.acquireSearcher("test")) {             TopDocs search = searcher.searcher().search(new MatchAllDocsQuery(), 10).             assertEquals(2, search.totalHits.value).         }     }).     client().prepareIndex("test", "test", "2").setSource("{\"foo\": \"bar\"}", XContentType.JSON).get().     assertBusy(() -> {         // this one becomes visible due to the scheduled refresh         try (Engine.Searcher searcher = shard.acquireSearcher("test")) {             TopDocs search = searcher.searcher().search(new MatchAllDocsQuery(), 10).             assertEquals(3, search.totalHits.value).         }     }). }
false;public;0;14;;public void testAsyncFsyncActuallyWorks() throws Exception {     Settings settings = Settings.builder().put(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey(), // very often :)     "100ms").put(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey(), Translog.Durability.ASYNC).build().     IndexService indexService = createIndex("test", settings).     ensureGreen("test").     assertTrue(indexService.getRefreshTask().mustReschedule()).     client().prepareIndex("test", "test", "1").setSource("{\"foo\": \"bar\"}", XContentType.JSON).get().     IndexShard shard = indexService.getShard(0).     assertBusy(() -> {         assertFalse(shard.isSyncNeeded()).     }). }
false;public;0;39;;public void testRescheduleAsyncFsync() throws Exception {     final Settings settings = Settings.builder().put(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey(), "100ms").put(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey(), Translog.Durability.REQUEST).build().     final IndexService indexService = createIndex("test", settings).     ensureGreen("test").     assertNull(indexService.getFsyncTask()).     client().admin().indices().prepareUpdateSettings("test").setSettings(Settings.builder().put(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey(), Translog.Durability.ASYNC)).get().     assertNotNull(indexService.getFsyncTask()).     assertTrue(indexService.getFsyncTask().mustReschedule()).     client().prepareIndex("test", "test", "1").setSource("{\"foo\": \"bar\"}", XContentType.JSON).get().     assertNotNull(indexService.getFsyncTask()).     final IndexShard shard = indexService.getShard(0).     assertBusy(() -> assertFalse(shard.isSyncNeeded())).     client().admin().indices().prepareUpdateSettings("test").setSettings(Settings.builder().put(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey(), Translog.Durability.REQUEST)).get().     assertNull(indexService.getFsyncTask()).     client().admin().indices().prepareUpdateSettings("test").setSettings(Settings.builder().put(IndexSettings.INDEX_TRANSLOG_DURABILITY_SETTING.getKey(), Translog.Durability.ASYNC)).get().     assertNotNull(indexService.getFsyncTask()). }
false;public;0;17;;public void testAsyncTranslogTrimActuallyWorks() throws Exception {     Settings settings = Settings.builder().put(TRANSLOG_RETENTION_CHECK_INTERVAL_SETTING.getKey(), // very often :)     "100ms").build().     IndexService indexService = createIndex("test", settings).     ensureGreen("test").     assertTrue(indexService.getRefreshTask().mustReschedule()).     client().prepareIndex("test", "test", "1").setSource("{\"foo\": \"bar\"}", XContentType.JSON).get().     client().admin().indices().prepareFlush("test").get().     client().admin().indices().prepareUpdateSettings("test").setSettings(Settings.builder().put(IndexSettings.INDEX_TRANSLOG_RETENTION_SIZE_SETTING.getKey(), -1).put(IndexSettings.INDEX_TRANSLOG_RETENTION_AGE_SETTING.getKey(), -1)).get().     IndexShard shard = indexService.getShard(0).     assertBusy(() -> assertThat(IndexShardTestCase.getTranslog(shard).totalOperations(), equalTo(0))). }
false;public;0;11;;public void testIllegalFsyncInterval() {     Settings settings = Settings.builder().put(IndexSettings.INDEX_TRANSLOG_SYNC_INTERVAL_SETTING.getKey(), // disable     "0ms").build().     try {         createIndex("test", settings).         fail().     } catch (IllegalArgumentException ex) {         assertEquals("failed to parse value [0ms] for setting [index.translog.sync_interval], must be >= [100ms]", ex.getMessage()).     } }
