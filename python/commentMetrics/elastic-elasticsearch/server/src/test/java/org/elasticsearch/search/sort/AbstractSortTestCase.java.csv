commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;13;;@BeforeClass public static void init() {     Settings baseSettings = Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toString()).build().     Map<String, Function<Map<String, Object>, Object>> scripts = Collections.singletonMap(MOCK_SCRIPT_NAME, p -> null).     ScriptEngine engine = new MockScriptEngine(MockScriptEngine.NAME, scripts, Collections.emptyMap()).     scriptService = new ScriptService(baseSettings, Collections.singletonMap(engine.getType(), engine), ScriptModule.CORE_CONTEXTS).     SearchModule searchModule = new SearchModule(Settings.EMPTY, false, emptyList()).     namedWriteableRegistry = new NamedWriteableRegistry(searchModule.getNamedWriteables()).     xContentRegistry = new NamedXContentRegistry(searchModule.getNamedXContents()). }
false;public,static;0;6;;@AfterClass public static void afterClass() throws Exception {     namedWriteableRegistry = null.     xContentRegistry = null.     scriptService = null. }
true;protected,abstract;0;1;/**  * Returns random sort that is put under test  */ ;/**  * Returns random sort that is put under test  */ protected abstract T createTestItem().
true;protected,abstract;1;1;/**  * Returns mutated version of original so the returned sort is different in terms of equals/hashcode  */ ;/**  * Returns mutated version of original so the returned sort is different in terms of equals/hashcode  */ protected abstract T mutate(T original) throws IOException.
true;protected,abstract;2;1;/**  * Parse the sort from xContent. Just delegate to the SortBuilder's static fromXContent method.  */ ;/**  * Parse the sort from xContent. Just delegate to the SortBuilder's static fromXContent method.  */ protected abstract T fromXContent(XContentParser parser, String fieldName) throws IOException.
true;public;0;28;/**  * Test that creates new sort from a random test sort and checks both for equality  */ ;/**  * Test that creates new sort from a random test sort and checks both for equality  */ public void testFromXContent() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         T testItem = createTestItem().         XContentBuilder builder = XContentFactory.contentBuilder(randomFrom(XContentType.values())).         if (randomBoolean()) {             builder.prettyPrint().         }         testItem.toXContent(builder, ToXContent.EMPTY_PARAMS).         XContentBuilder shuffled = shuffleXContent(builder).         try (XContentParser itemParser = createParser(shuffled)) {             itemParser.nextToken().             /*                  * filter out name of sort, or field name to sort on for element fieldSort                  */             itemParser.nextToken().             String elementName = itemParser.currentName().             itemParser.nextToken().             T parsedItem = fromXContent(itemParser, elementName).             assertNotSame(testItem, parsedItem).             assertEquals(testItem, parsedItem).             assertEquals(testItem.hashCode(), parsedItem.hashCode()).             assertWarnings(testItem).         }     } }
false;protected;1;3;;protected void assertWarnings(T testItem) { // assert potential warnings based on the test sort configuration. Do nothing by default, subtests can overwrite }
true;public;0;8;/**  * test that build() outputs a {@link SortField} that is similar to the one  * we would get when parsing the xContent the sort builder is rendering out  */ ;/**  * test that build() outputs a {@link SortField} that is similar to the one  * we would get when parsing the xContent the sort builder is rendering out  */ public void testBuildSortField() throws IOException {     QueryShardContext mockShardContext = createMockShardContext().     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         T sortBuilder = createTestItem().         SortFieldAndFormat sortField = sortBuilder.build(mockShardContext).         sortFieldAssertions(sortBuilder, sortField.field, sortField.format).     } }
false;protected,abstract;3;1;;protected abstract void sortFieldAssertions(T builder, SortField sortField, DocValueFormat format) throws IOException.
true;public;0;9;/**  * Test serialization and deserialization of the test sort.  */ ;/**  * Test serialization and deserialization of the test sort.  */ public void testSerialization() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         T testsort = createTestItem().         T deserializedsort = copy(testsort).         assertEquals(testsort, deserializedsort).         assertEquals(testsort.hashCode(), deserializedsort.hashCode()).         assertNotSame(testsort, deserializedsort).     } }
true;public;0;5;/**  * Test equality and hashCode properties  */ ;/**  * Test equality and hashCode properties  */ public void testEqualsAndHashcode() {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         checkEqualsAndHashCode(createTestItem(), this::copy, this::mutate).     } }
false;public;1;4;;@Override public MappedFieldType fieldMapper(String name) {     return provideMappedFieldType(name). }
false;public;1;5;;@Override public ObjectMapper getObjectMapper(String name) {     BuilderContext context = new BuilderContext(this.getIndexSettings().getSettings(), new ContentPath()).     return new ObjectMapper.Builder<>(name).nested(Nested.newNested(false, false)).build(context). }
false;protected;0;24;;protected QueryShardContext createMockShardContext() {     Index index = new Index(randomAlphaOfLengthBetween(1, 10), "_na_").     IndexSettings idxSettings = IndexSettingsModule.newIndexSettings(index, Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build()).     BitsetFilterCache bitsetFilterCache = new BitsetFilterCache(idxSettings, Mockito.mock(BitsetFilterCache.Listener.class)).     BiFunction<MappedFieldType, String, IndexFieldData<?>> indexFieldDataLookup = (fieldType, fieldIndexName) -> {         IndexFieldData.Builder builder = fieldType.fielddataBuilder(fieldIndexName).         return builder.build(idxSettings, fieldType, new IndexFieldDataCache.None(), null, null).     }.     return new QueryShardContext(0, idxSettings, bitsetFilterCache, indexFieldDataLookup, null, null, scriptService, xContentRegistry(), namedWriteableRegistry, null, null, () -> randomNonNegativeLong(), null) {          @Override         public MappedFieldType fieldMapper(String name) {             return provideMappedFieldType(name).         }          @Override         public ObjectMapper getObjectMapper(String name) {             BuilderContext context = new BuilderContext(this.getIndexSettings().getSettings(), new ContentPath()).             return new ObjectMapper.Builder<>(name).nested(Nested.newNested(false, false)).build(context).         }     }. }
true;protected;1;6;/**  * Return a field type. We use {@link NumberFieldMapper.NumberFieldType} by default since it is compatible with all sort modes  * Tests that require other field types can override this.  */ ;/**  * Return a field type. We use {@link NumberFieldMapper.NumberFieldType} by default since it is compatible with all sort modes  * Tests that require other field types can override this.  */ protected MappedFieldType provideMappedFieldType(String name) {     NumberFieldMapper.NumberFieldType doubleFieldType = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE).     doubleFieldType.setName(name).     doubleFieldType.setHasDocValues(true).     return doubleFieldType. }
false;protected;0;4;;@Override protected NamedXContentRegistry xContentRegistry() {     return xContentRegistry. }
false;protected,static;0;11;;protected static QueryBuilder randomNestedFilter() {     int id = randomIntBetween(0, 2).     switch(id) {         case 0:             return (new MatchAllQueryBuilder()).boost(randomFloat()).         case 1:             return (new IdsQueryBuilder()).boost(randomFloat()).         case 2:             return (new TermQueryBuilder(randomAlphaOfLengthBetween(1, 10), randomDouble()).boost(randomFloat())).         default:             throw new IllegalStateException("Only three query builders supported for testing sort").     } }
false;private;1;7;;@SuppressWarnings("unchecked") private T copy(T original) throws IOException {     /* The cast below is required to make Java 9 happy. Java 8 infers the T in copyWriterable to be the same as AbstractSortTestCase's          * T but Java 9 infers it to be SortBuilder. */     return (T) copyWriteable(original, namedWriteableRegistry, namedWriteableRegistry.getReader(SortBuilder.class, original.getWriteableName())). }
