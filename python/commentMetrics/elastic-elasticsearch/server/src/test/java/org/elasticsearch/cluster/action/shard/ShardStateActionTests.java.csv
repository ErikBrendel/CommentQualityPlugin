commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setOnBeforeWaitForNewMasterAndRetry(Runnable onBeforeWaitForNewMasterAndRetry) {     this.onBeforeWaitForNewMasterAndRetry = onBeforeWaitForNewMasterAndRetry. }
false;public;1;3;;public void setOnAfterWaitForNewMasterAndRetry(Runnable onAfterWaitForNewMasterAndRetry) {     this.onAfterWaitForNewMasterAndRetry = onAfterWaitForNewMasterAndRetry. }
false;protected;5;7;;@Override protected void waitForNewMasterAndRetry(String actionName, ClusterStateObserver observer, TransportRequest request, ActionListener<Void> listener, Predicate<ClusterState> changePredicate) {     onBeforeWaitForNewMasterAndRetry.run().     super.waitForNewMasterAndRetry(actionName, observer, request, listener, changePredicate).     onAfterWaitForNewMasterAndRetry.run(). }
false;public,static;0;4;;@BeforeClass public static void startThreadPool() {     THREAD_POOL = new TestThreadPool("ShardStateActionTest"). }
false;public;0;16;;@Override @Before public void setUp() throws Exception {     super.setUp().     this.transport = new CapturingTransport().     clusterService = createClusterService(THREAD_POOL).     transportService = transport.createTransportService(clusterService.getSettings(), THREAD_POOL, TransportService.NOOP_TRANSPORT_INTERCEPTOR, x -> clusterService.localNode(), null, Collections.emptySet()).     transportService.start().     transportService.acceptIncomingRequests().     shardStateAction = new TestShardStateAction(clusterService, transportService, null, null).     shardStateAction.setOnBeforeWaitForNewMasterAndRetry(() -> {     }).     shardStateAction.setOnAfterWaitForNewMasterAndRetry(() -> {     }). }
false;public;0;8;;@Override @After public void tearDown() throws Exception {     clusterService.close().     transportService.close().     super.tearDown().     assertThat(shardStateAction.remoteShardFailedCacheSize(), equalTo(0)). }
false;public,static;0;5;;@AfterClass public static void stopThreadPool() {     ThreadPool.terminate(THREAD_POOL, 30, TimeUnit.SECONDS).     THREAD_POOL = null. }
false;public;0;25;;public void testSuccess() throws InterruptedException {     final String index = "test".     setState(clusterService, ClusterStateCreationUtils.stateWithActivePrimary(index, true, randomInt(5))).     final TestListener listener = new TestListener().     ShardRouting shardRouting = getRandomShardRouting(index).     shardStateAction.localShardFailed(shardRouting, "test", getSimulatedFailure(), listener).     CapturingTransport.CapturedRequest[] capturedRequests = transport.getCapturedRequestsAndClear().     assertEquals(1, capturedRequests.length).     // the request is a shard failed request     assertThat(capturedRequests[0].request, is(instanceOf(ShardStateAction.FailedShardEntry.class))).     ShardStateAction.FailedShardEntry shardEntry = (ShardStateAction.FailedShardEntry) capturedRequests[0].request.     // for the right shard     assertEquals(shardEntry.shardId, shardRouting.shardId()).     assertEquals(shardEntry.allocationId, shardRouting.allocationId().getId()).     // sent to the master     assertEquals(clusterService.state().nodes().getMasterNode().getId(), capturedRequests[0].node.getId()).     transport.handleResponse(capturedRequests[0].requestId, TransportResponse.Empty.INSTANCE).     listener.await().     assertNull(listener.failure.get()). }
false;public;1;5;;@Override public void onResponse(Void aVoid) {     success.set(true).     latch.countDown(). }
false;public;1;6;;@Override public void onFailure(Exception e) {     success.set(false).     latch.countDown().     assert false. }
false;public;0;37;;public void testNoMaster() throws InterruptedException {     final String index = "test".     setState(clusterService, ClusterStateCreationUtils.stateWithActivePrimary(index, true, randomInt(5))).     DiscoveryNodes.Builder noMasterBuilder = DiscoveryNodes.builder(clusterService.state().nodes()).     noMasterBuilder.masterNodeId(null).     setState(clusterService, ClusterState.builder(clusterService.state()).nodes(noMasterBuilder)).     CountDownLatch latch = new CountDownLatch(1).     AtomicInteger retries = new AtomicInteger().     AtomicBoolean success = new AtomicBoolean().     setUpMasterRetryVerification(1, retries, latch, requestId -> {     }).     ShardRouting failedShard = getRandomShardRouting(index).     shardStateAction.localShardFailed(failedShard, "test", getSimulatedFailure(), new ActionListener<Void>() {          @Override         public void onResponse(Void aVoid) {             success.set(true).             latch.countDown().         }          @Override         public void onFailure(Exception e) {             success.set(false).             latch.countDown().             assert false.         }     }).     latch.await().     assertThat(retries.get(), equalTo(1)).     assertTrue(success.get()). }
false;public;1;5;;@Override public void onResponse(Void aVoid) {     success.set(true).     latch.countDown(). }
false;public;1;7;;@Override public void onFailure(Exception e) {     success.set(false).     throwable.set(e).     latch.countDown().     assert false. }
false;public;0;55;;public void testMasterChannelException() throws InterruptedException {     final String index = "test".     setState(clusterService, ClusterStateCreationUtils.stateWithActivePrimary(index, true, randomInt(5))).     CountDownLatch latch = new CountDownLatch(1).     AtomicInteger retries = new AtomicInteger().     AtomicBoolean success = new AtomicBoolean().     AtomicReference<Throwable> throwable = new AtomicReference<>().     LongConsumer retryLoop = requestId -> {         if (randomBoolean()) {             transport.handleRemoteError(requestId, randomFrom(new NotMasterException("simulated"), new FailedToCommitClusterStateException("simulated"))).         } else {             if (randomBoolean()) {                 transport.handleLocalError(requestId, new NodeNotConnectedException(null, "simulated")).             } else {                 transport.handleError(requestId, new NodeDisconnectedException(null, ShardStateAction.SHARD_FAILED_ACTION_NAME)).             }         }     }.     final int numberOfRetries = randomIntBetween(1, 256).     setUpMasterRetryVerification(numberOfRetries, retries, latch, retryLoop).     ShardRouting failedShard = getRandomShardRouting(index).     shardStateAction.localShardFailed(failedShard, "test", getSimulatedFailure(), new ActionListener<Void>() {          @Override         public void onResponse(Void aVoid) {             success.set(true).             latch.countDown().         }          @Override         public void onFailure(Exception e) {             success.set(false).             throwable.set(e).             latch.countDown().             assert false.         }     }).     final CapturingTransport.CapturedRequest[] capturedRequests = transport.getCapturedRequestsAndClear().     assertThat(capturedRequests.length, equalTo(1)).     assertFalse(success.get()).     assertThat(retries.get(), equalTo(0)).     retryLoop.accept(capturedRequests[0].requestId).     latch.await().     assertNull(throwable.get()).     assertThat(retries.get(), equalTo(numberOfRetries)).     assertTrue(success.get()). }
false;public;0;14;;public void testUnhandledFailure() {     final String index = "test".     setState(clusterService, ClusterStateCreationUtils.stateWithActivePrimary(index, true, randomInt(5))).     final TestListener listener = new TestListener().     ShardRouting failedShard = getRandomShardRouting(index).     shardStateAction.localShardFailed(failedShard, "test", getSimulatedFailure(), listener).     final CapturingTransport.CapturedRequest[] capturedRequests = transport.getCapturedRequestsAndClear().     assertThat(capturedRequests.length, equalTo(1)).     transport.handleRemoteError(capturedRequests[0].requestId, new TransportException("simulated")).     assertNotNull(listener.failure.get()). }
false;public;0;17;;public void testShardNotFound() throws InterruptedException {     final String index = "test".     setState(clusterService, ClusterStateCreationUtils.stateWithActivePrimary(index, true, randomInt(5))).     final TestListener listener = new TestListener().     ShardRouting failedShard = getRandomShardRouting(index).     RoutingTable routingTable = RoutingTable.builder(clusterService.state().getRoutingTable()).remove(index).build().     setState(clusterService, ClusterState.builder(clusterService.state()).routingTable(routingTable)).     shardStateAction.localShardFailed(failedShard, "test", getSimulatedFailure(), listener).     CapturingTransport.CapturedRequest[] capturedRequests = transport.getCapturedRequestsAndClear().     transport.handleResponse(capturedRequests[0].requestId, TransportResponse.Empty.INSTANCE).     listener.await().     assertNull(listener.failure.get()). }
false;public;0;25;;public void testNoLongerPrimaryShardException() throws InterruptedException {     final String index = "test".     setState(clusterService, ClusterStateCreationUtils.stateWithActivePrimary(index, true, randomInt(5))).     ShardRouting failedShard = getRandomShardRouting(index).     final TestListener listener = new TestListener().     long primaryTerm = clusterService.state().metaData().index(index).primaryTerm(failedShard.id()).     assertThat(primaryTerm, greaterThanOrEqualTo(1L)).     shardStateAction.remoteShardFailed(failedShard.shardId(), failedShard.allocationId().getId(), primaryTerm + 1, randomBoolean(), "test", getSimulatedFailure(), listener).     ShardStateAction.NoLongerPrimaryShardException catastrophicError = new ShardStateAction.NoLongerPrimaryShardException(failedShard.shardId(), "dummy failure").     CapturingTransport.CapturedRequest[] capturedRequests = transport.getCapturedRequestsAndClear().     transport.handleRemoteError(capturedRequests[0].requestId, catastrophicError).     listener.await().     final Exception failure = listener.failure.get().     assertNotNull(failure).     assertThat(failure, instanceOf(ShardStateAction.NoLongerPrimaryShardException.class)).     assertThat(failure.getMessage(), equalTo(catastrophicError.getMessage())). }
false;public;1;4;;@Override public void onResponse(Void aVoid) {     latch.countDown(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     latch.countDown(). }
false;public;0;27;;public void testCacheRemoteShardFailed() throws Exception {     final String index = "test".     setState(clusterService, ClusterStateCreationUtils.stateWithActivePrimary(index, true, randomInt(5))).     ShardRouting failedShard = getRandomShardRouting(index).     boolean markAsStale = randomBoolean().     int numListeners = between(1, 100).     CountDownLatch latch = new CountDownLatch(numListeners).     long primaryTerm = randomLongBetween(1, Long.MAX_VALUE).     for (int i = 0. i < numListeners. i++) {         shardStateAction.remoteShardFailed(failedShard.shardId(), failedShard.allocationId().getId(), primaryTerm, markAsStale, "test", getSimulatedFailure(), new ActionListener<Void>() {              @Override             public void onResponse(Void aVoid) {                 latch.countDown().             }              @Override             public void onFailure(Exception e) {                 latch.countDown().             }         }).     }     CapturingTransport.CapturedRequest[] capturedRequests = transport.getCapturedRequestsAndClear().     assertThat(capturedRequests, arrayWithSize(1)).     transport.handleResponse(capturedRequests[0].requestId, TransportResponse.Empty.INSTANCE).     latch.await().     assertThat(transport.capturedRequests(), arrayWithSize(0)). }
false;public;1;4;;@Override public void onResponse(Void aVoid) {     notifiedResponses.incrementAndGet(). }
false;public;1;4;;@Override public void onFailure(Exception e) {     notifiedResponses.incrementAndGet(). }
false;public;0;55;;public void testRemoteShardFailedConcurrently() throws Exception {     final String index = "test".     final AtomicBoolean shutdown = new AtomicBoolean(false).     setState(clusterService, ClusterStateCreationUtils.stateWithActivePrimary(index, true, randomInt(5))).     ShardRouting[] failedShards = new ShardRouting[between(1, 5)].     for (int i = 0. i < failedShards.length. i++) {         failedShards[i] = getRandomShardRouting(index).     }     Thread[] clientThreads = new Thread[between(1, 6)].     int iterationsPerThread = scaledRandomIntBetween(50, 500).     // one for master thread, one for the main thread     Phaser barrier = new Phaser(clientThreads.length + 2).     Thread masterThread = new Thread(() -> {         barrier.arriveAndAwaitAdvance().         while (shutdown.get() == false) {             for (CapturingTransport.CapturedRequest request : transport.getCapturedRequestsAndClear()) {                 if (randomBoolean()) {                     transport.handleResponse(request.requestId, TransportResponse.Empty.INSTANCE).                 } else {                     transport.handleRemoteError(request.requestId, randomFrom(getSimulatedFailure())).                 }             }         }     }).     masterThread.start().     AtomicInteger notifiedResponses = new AtomicInteger().     for (int t = 0. t < clientThreads.length. t++) {         clientThreads[t] = new Thread(() -> {             barrier.arriveAndAwaitAdvance().             for (int i = 0. i < iterationsPerThread. i++) {                 ShardRouting failedShard = randomFrom(failedShards).                 shardStateAction.remoteShardFailed(failedShard.shardId(), failedShard.allocationId().getId(), randomLongBetween(1, Long.MAX_VALUE), randomBoolean(), "test", getSimulatedFailure(), new ActionListener<Void>() {                      @Override                     public void onResponse(Void aVoid) {                         notifiedResponses.incrementAndGet().                     }                      @Override                     public void onFailure(Exception e) {                         notifiedResponses.incrementAndGet().                     }                 }).             }         }).         clientThreads[t].start().     }     barrier.arriveAndAwaitAdvance().     for (Thread t : clientThreads) {         t.join().     }     assertBusy(() -> assertThat(notifiedResponses.get(), equalTo(clientThreads.length * iterationsPerThread))).     shutdown.set(true).     masterThread.join(). }
false;public;0;21;;public void testShardStarted() throws InterruptedException {     final String index = "test".     setState(clusterService, ClusterStateCreationUtils.stateWithActivePrimary(index, true, randomInt(5))).     final ShardRouting shardRouting = getRandomShardRouting(index).     final long primaryTerm = clusterService.state().metaData().index(shardRouting.index()).primaryTerm(shardRouting.id()).     final TestListener listener = new TestListener().     shardStateAction.shardStarted(shardRouting, primaryTerm, "testShardStarted", listener).     final CapturingTransport.CapturedRequest[] capturedRequests = transport.getCapturedRequestsAndClear().     assertThat(capturedRequests[0].request, instanceOf(ShardStateAction.StartedShardEntry.class)).     ShardStateAction.StartedShardEntry entry = (ShardStateAction.StartedShardEntry) capturedRequests[0].request.     assertThat(entry.shardId, equalTo(shardRouting.shardId())).     assertThat(entry.allocationId, equalTo(shardRouting.allocationId().getId())).     assertThat(entry.primaryTerm, equalTo(primaryTerm)).     transport.handleResponse(capturedRequests[0].requestId, TransportResponse.Empty.INSTANCE).     listener.await().     assertNull(listener.failure.get()). }
false;private;1;7;;private ShardRouting getRandomShardRouting(String index) {     IndexRoutingTable indexRoutingTable = clusterService.state().routingTable().index(index).     ShardsIterator shardsIterator = indexRoutingTable.randomAllActiveShardsIt().     ShardRouting shardRouting = shardsIterator.nextOrNull().     assert shardRouting != null.     return shardRouting. }
false;private;4;9;;private void setUpMasterRetryVerification(int numberOfRetries, AtomicInteger retries, CountDownLatch latch, LongConsumer retryLoop) {     shardStateAction.setOnBeforeWaitForNewMasterAndRetry(() -> {         DiscoveryNodes.Builder masterBuilder = DiscoveryNodes.builder(clusterService.state().nodes()).         masterBuilder.masterNodeId(clusterService.state().nodes().getMasterNodes().iterator().next().value.getId()).         setState(clusterService, ClusterState.builder(clusterService.state()).nodes(masterBuilder)).     }).     shardStateAction.setOnAfterWaitForNewMasterAndRetry(() -> verifyRetry(numberOfRetries, retries, latch, retryLoop)). }
false;private;4;17;;private void verifyRetry(int numberOfRetries, AtomicInteger retries, CountDownLatch latch, LongConsumer retryLoop) {     // assert a retry request was sent     final CapturingTransport.CapturedRequest[] capturedRequests = transport.getCapturedRequestsAndClear().     if (capturedRequests.length == 1) {         retries.incrementAndGet().         if (retries.get() == numberOfRetries) {             // finish the request             transport.handleResponse(capturedRequests[0].requestId, TransportResponse.Empty.INSTANCE).         } else {             retryLoop.accept(capturedRequests[0].requestId).         }     } else {         // there failed to be a retry request         // release the driver thread to fail the test         latch.countDown().     } }
false;private;0;3;;private Exception getSimulatedFailure() {     return new CorruptIndexException("simulated", (String) null). }
false;public;0;23;;public void testShardEntryBWCSerialize() throws Exception {     final Version bwcVersion = randomValueOtherThanMany(version -> version.onOrAfter(Version.V_6_3_0), () -> VersionUtils.randomVersion(random())).     final ShardId shardId = new ShardId(randomRealisticUnicodeOfLengthBetween(10, 100), UUID.randomUUID().toString(), between(0, 1000)).     final String allocationId = randomRealisticUnicodeOfCodepointLengthBetween(10, 100).     final String reason = randomRealisticUnicodeOfCodepointLengthBetween(10, 100).     try (StreamInput in = serialize(new StartedShardEntry(shardId, allocationId, 0L, reason), bwcVersion).streamInput()) {         in.setVersion(bwcVersion).         final FailedShardEntry failedShardEntry = new FailedShardEntry(in).         assertThat(failedShardEntry.shardId, equalTo(shardId)).         assertThat(failedShardEntry.allocationId, equalTo(allocationId)).         assertThat(failedShardEntry.message, equalTo(reason)).         assertThat(failedShardEntry.failure, nullValue()).         assertThat(failedShardEntry.markAsStale, equalTo(true)).     }     try (StreamInput in = serialize(new FailedShardEntry(shardId, allocationId, 0L, reason, null, false), bwcVersion).streamInput()) {         in.setVersion(bwcVersion).         final StartedShardEntry startedShardEntry = new StartedShardEntry(in).         assertThat(startedShardEntry.shardId, equalTo(shardId)).         assertThat(startedShardEntry.allocationId, equalTo(allocationId)).         assertThat(startedShardEntry.message, equalTo(reason)).     } }
false;public;0;28;;public void testFailedShardEntrySerialization() throws Exception {     final ShardId shardId = new ShardId(randomRealisticUnicodeOfLengthBetween(10, 100), UUID.randomUUID().toString(), between(0, 1000)).     final String allocationId = randomRealisticUnicodeOfCodepointLengthBetween(10, 100).     final long primaryTerm = randomIntBetween(0, 100).     final String message = randomRealisticUnicodeOfCodepointLengthBetween(10, 100).     final Exception failure = randomBoolean() ? null : getSimulatedFailure().     final boolean markAsStale = randomBoolean().     final Version version = randomFrom(randomCompatibleVersion(random(), Version.CURRENT)).     final FailedShardEntry failedShardEntry = new FailedShardEntry(shardId, allocationId, primaryTerm, message, failure, markAsStale).     try (StreamInput in = serialize(failedShardEntry, version).streamInput()) {         in.setVersion(version).         final FailedShardEntry deserialized = new FailedShardEntry(in).         assertThat(deserialized.shardId, equalTo(shardId)).         assertThat(deserialized.allocationId, equalTo(allocationId)).         assertThat(deserialized.primaryTerm, equalTo(primaryTerm)).         assertThat(deserialized.message, equalTo(message)).         if (failure != null) {             assertThat(deserialized.failure, notNullValue()).             assertThat(deserialized.failure.getClass(), equalTo(failure.getClass())).             assertThat(deserialized.failure.getMessage(), equalTo(failure.getMessage())).         } else {             assertThat(deserialized.failure, nullValue()).         }         assertThat(deserialized.markAsStale, equalTo(markAsStale)).         assertEquals(failedShardEntry, deserialized).     } }
false;public;0;20;;public void testStartedShardEntrySerialization() throws Exception {     final ShardId shardId = new ShardId(randomRealisticUnicodeOfLengthBetween(10, 100), UUID.randomUUID().toString(), between(0, 1000)).     final String allocationId = randomRealisticUnicodeOfCodepointLengthBetween(10, 100).     final long primaryTerm = randomIntBetween(0, 100).     final String message = randomRealisticUnicodeOfCodepointLengthBetween(10, 100).     final Version version = randomFrom(randomCompatibleVersion(random(), Version.CURRENT)).     try (StreamInput in = serialize(new StartedShardEntry(shardId, allocationId, primaryTerm, message), version).streamInput()) {         in.setVersion(version).         final StartedShardEntry deserialized = new StartedShardEntry(in).         assertThat(deserialized.shardId, equalTo(shardId)).         assertThat(deserialized.allocationId, equalTo(allocationId)).         if (version.onOrAfter(Version.V_6_7_0)) {             assertThat(deserialized.primaryTerm, equalTo(primaryTerm)).         } else {             assertThat(deserialized.primaryTerm, equalTo(0L)).         }         assertThat(deserialized.message, equalTo(message)).     } }
false;;2;7;;BytesReference serialize(Writeable writeable, Version version) throws IOException {     try (BytesStreamOutput out = new BytesStreamOutput()) {         out.setVersion(version).         writeable.writeTo(out).         return out.bytes().     } }
false;public;1;8;;@Override public void onResponse(Void aVoid) {     try {         failure.set(null).     } finally {         latch.countDown().     } }
false;public;1;8;;@Override public void onFailure(final Exception e) {     try {         failure.set(e).     } finally {         latch.countDown().     } }
false;;0;3;;void await() throws InterruptedException {     latch.await(). }
