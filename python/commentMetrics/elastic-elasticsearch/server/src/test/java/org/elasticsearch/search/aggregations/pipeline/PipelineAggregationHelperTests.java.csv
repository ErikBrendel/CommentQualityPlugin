commented;modifiers;parameterAmount;loc;comment;code
true;public,static;4;48;/**  * Generates a mock histogram to use for testing.  Each MockBucket holds a doc count, key and document values  * which can later be used to compute metrics and compare against the real aggregation results.  Gappiness can be  * controlled via parameters  *  * @param interval          Interval between bucket keys  * @param size              Size of mock histogram to generate (in buckets)  * @param gapProbability    Probability of generating an empty bucket. 0.0-1.0 inclusive  * @param runProbability    Probability of extending a gap once one has been created.  0.0-1.0 inclusive  */ ;/**  * Generates a mock histogram to use for testing.  Each MockBucket holds a doc count, key and document values  * which can later be used to compute metrics and compare against the real aggregation results.  Gappiness can be  * controlled via parameters  *  * @param interval          Interval between bucket keys  * @param size              Size of mock histogram to generate (in buckets)  * @param gapProbability    Probability of generating an empty bucket. 0.0-1.0 inclusive  * @param runProbability    Probability of extending a gap once one has been created.  0.0-1.0 inclusive  */ public static ArrayList<MockBucket> generateHistogram(int interval, int size, double gapProbability, double runProbability) {     ArrayList<MockBucket> values = new ArrayList<>(size).     boolean lastWasGap = false.     boolean emptyHisto = true.     for (int i = 0. i < size. i++) {         MockBucket bucket = new MockBucket().         if (randomDouble() < gapProbability) {             // start a gap             bucket.count = 0.             bucket.docValues = new double[0].             lastWasGap = true.         } else if (lastWasGap && randomDouble() < runProbability) {             // add to the existing gap             bucket.count = 0.             bucket.docValues = new double[0].             lastWasGap = true.         } else {             bucket.count = randomIntBetween(1, 50).             bucket.docValues = new double[bucket.count].             for (int j = 0. j < bucket.count. j++) {                 bucket.docValues[j] = randomDouble() * randomIntBetween(-20, 20).             }             lastWasGap = false.             emptyHisto = false.         }         bucket.key = i * interval.         values.add(bucket).     }     if (emptyHisto) {         int idx = randomIntBetween(0, values.size() - 1).         MockBucket bucket = values.get(idx).         bucket.count = randomIntBetween(1, 50).         bucket.docValues = new double[bucket.count].         for (int j = 0. j < bucket.count. j++) {             bucket.docValues[j] = randomDouble() * randomIntBetween(-20, 20).         }         values.set(idx, bucket).     }     return values. }
true;public,static;2;30;/**  * Computes a simple agg metric (min, sum, etc) from the provided values  *  * @param values Array of values to compute metric for  * @param metric A metric builder which defines what kind of metric should be returned for the values  */ ;/**  * Computes a simple agg metric (min, sum, etc) from the provided values  *  * @param values Array of values to compute metric for  * @param metric A metric builder which defines what kind of metric should be returned for the values  */ public static double calculateMetric(double[] values, ValuesSourceAggregationBuilder<?, ?> metric) {     if (metric instanceof MinAggregationBuilder) {         double accumulator = Double.POSITIVE_INFINITY.         for (double value : values) {             accumulator = Math.min(accumulator, value).         }         return accumulator.     } else if (metric instanceof MaxAggregationBuilder) {         double accumulator = Double.NEGATIVE_INFINITY.         for (double value : values) {             accumulator = Math.max(accumulator, value).         }         return accumulator.     } else if (metric instanceof SumAggregationBuilder) {         double accumulator = 0.         for (double value : values) {             accumulator += value.         }         return accumulator.     } else if (metric instanceof AvgAggregationBuilder) {         double accumulator = 0.         for (double value : values) {             accumulator += value.         }         return accumulator / values.length.     }     return 0.0. }
false;static;0;23;;static AggregatorFactory getRandomSequentiallyOrderedParentAgg() throws IOException {     AggregatorFactory factory = null.     switch(randomIntBetween(0, 2)) {         case 0:             factory = new HistogramAggregatorFactory("name", mock(ValuesSourceConfig.class), 0.0d, 0.0d, mock(InternalOrder.class), false, 0L, 0.0d, 1.0d, mock(SearchContext.class), null, new AggregatorFactories.Builder(), Collections.emptyMap()).             break.         case 1:             factory = new DateHistogramAggregatorFactory("name", mock(ValuesSourceConfig.class), 0L, mock(InternalOrder.class), false, 0L, mock(Rounding.class), mock(Rounding.class), mock(ExtendedBounds.class), mock(SearchContext.class), mock(AggregatorFactory.class), new AggregatorFactories.Builder(), Collections.emptyMap()).             break.         case 2:         default:             AutoDateHistogramAggregationBuilder.RoundingInfo[] roundings = new AutoDateHistogramAggregationBuilder.RoundingInfo[1].             factory = new AutoDateHistogramAggregatorFactory("name", mock(ValuesSourceConfig.class), 1, roundings, mock(SearchContext.class), null, new AggregatorFactories.Builder(), Collections.emptyMap()).     }     return factory. }
