commented;modifiers;parameterAmount;loc;comment;code
false;public;0;25;;@Override public void setUp() throws Exception {     super.setUp().     final int interval = randomFrom(1, 5, 10, 25, 50, 100).     final int numRanges = randomNumberOfBuckets().     final double max = (double) numRanges * interval.     List<Tuple<Double, Double>> listOfRanges = new ArrayList<>(numRanges).     for (int i = 0. i < numRanges. i++) {         double from = i * interval.         double to = from + interval.         Tuple<Double, Double> range.         if (randomBoolean()) {             range = Tuple.tuple(from, to).         } else {             // Add some overlapping range             range = Tuple.tuple(randomFrom(0.0, max / 3), randomFrom(max, max / 2, max / 3 * 2)).         }         listOfRanges.add(range).     }     Collections.shuffle(listOfRanges, random()).     geoDistanceRanges = Collections.unmodifiableList(listOfRanges). }
false;protected;0;4;;@Override protected Writeable.Reader<InternalGeoDistance> instanceReader() {     return InternalGeoDistance::new. }
false;protected;5;16;;@Override protected InternalGeoDistance createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData, InternalAggregations aggregations, boolean keyed) {     final List<InternalGeoDistance.Bucket> buckets = new ArrayList<>().     for (int i = 0. i < geoDistanceRanges.size(). ++i) {         Tuple<Double, Double> range = geoDistanceRanges.get(i).         int docCount = randomIntBetween(0, 1000).         double from = range.v1().         double to = range.v2().         buckets.add(new InternalGeoDistance.Bucket("range_" + i, from, to, docCount, aggregations, keyed)).     }     return new InternalGeoDistance(name, buckets, keyed, pipelineAggregators, metaData). }
false;protected;0;4;;@Override protected Class<? extends ParsedMultiBucketAggregation> implementationClass() {     return ParsedGeoDistance.class. }
false;protected;0;4;;@Override protected Class<? extends InternalMultiBucketAggregation.InternalBucket> internalRangeBucketClass() {     return InternalGeoDistance.Bucket.class. }
false;protected;0;4;;@Override protected Class<? extends ParsedMultiBucketAggregation.ParsedBucket> parsedRangeBucketClass() {     return ParsedGeoDistance.ParsedBucket.class. }
false;protected;1;33;;@Override protected InternalGeoDistance mutateInstance(InternalGeoDistance instance) {     String name = instance.getName().     boolean keyed = instance.keyed.     List<InternalGeoDistance.Bucket> buckets = instance.getBuckets().     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 3)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             keyed = keyed == false.             break.         case 2:             buckets = new ArrayList<>(buckets).             double from = randomDouble().             buckets.add(new InternalGeoDistance.Bucket("range_a", from, from + randomDouble(), randomNonNegativeLong(), InternalAggregations.EMPTY, false)).             break.         case 3:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new InternalGeoDistance(name, buckets, keyed, pipelineAggregators, metaData). }
