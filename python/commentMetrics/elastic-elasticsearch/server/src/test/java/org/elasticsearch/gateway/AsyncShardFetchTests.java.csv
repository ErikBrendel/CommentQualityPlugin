commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override @Before public void setUp() throws Exception {     super.setUp().     this.threadPool = new TestThreadPool(getTestName()).     this.test = new TestFetch(threadPool). }
false;public;0;4;;@After public void terminate() throws Exception {     terminate(threadPool). }
false;public;0;21;;public void testClose() throws Exception {     DiscoveryNodes nodes = DiscoveryNodes.builder().add(node1).build().     test.addSimulation(node1.getId(), response1).     // first fetch, no data, still on going     AsyncShardFetch.FetchResult<Response> fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     assertThat(test.reroute.get(), equalTo(0)).     // fire a response, wait on reroute incrementing     test.fireSimulationAndWait(node1.getId()).     // verify we get back the data node     assertThat(test.reroute.get(), equalTo(1)).     test.close().     try {         test.fetchData(nodes, emptySet()).         fail("fetch data should fail when closed").     } catch (IllegalStateException e) {     // all is well     } }
false;public;0;18;;public void testFullCircleSingleNodeSuccess() throws Exception {     DiscoveryNodes nodes = DiscoveryNodes.builder().add(node1).build().     test.addSimulation(node1.getId(), response1).     // first fetch, no data, still on going     AsyncShardFetch.FetchResult<Response> fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     assertThat(test.reroute.get(), equalTo(0)).     // fire a response, wait on reroute incrementing     test.fireSimulationAndWait(node1.getId()).     // verify we get back the data node     assertThat(test.reroute.get(), equalTo(1)).     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(true)).     assertThat(fetchData.getData().size(), equalTo(1)).     assertThat(fetchData.getData().get(node1), sameInstance(response1)). }
false;public;0;31;;public void testFullCircleSingleNodeFailure() throws Exception {     DiscoveryNodes nodes = DiscoveryNodes.builder().add(node1).build().     // add a failed response for node1     test.addSimulation(node1.getId(), failure1).     // first fetch, no data, still on going     AsyncShardFetch.FetchResult<Response> fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     assertThat(test.reroute.get(), equalTo(0)).     // fire a response, wait on reroute incrementing     test.fireSimulationAndWait(node1.getId()).     // failure, fetched data exists, but has no data     assertThat(test.reroute.get(), equalTo(1)).     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(true)).     assertThat(fetchData.getData().size(), equalTo(0)).     // on failure, we reset the failure on a successive call to fetchData, and try again afterwards     test.addSimulation(node1.getId(), response1).     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     test.fireSimulationAndWait(node1.getId()).     // 2 reroutes, cause we have a failure that we clear     assertThat(test.reroute.get(), equalTo(3)).     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(true)).     assertThat(fetchData.getData().size(), equalTo(1)).     assertThat(fetchData.getData().get(node1), sameInstance(response1)). }
false;public;0;23;;public void testIgnoreResponseFromDifferentRound() throws Exception {     DiscoveryNodes nodes = DiscoveryNodes.builder().add(node1).build().     test.addSimulation(node1.getId(), response1).     // first fetch, no data, still on going     AsyncShardFetch.FetchResult<Response> fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     assertThat(test.reroute.get(), equalTo(0)).     // handle a response with incorrect round id, wait on reroute incrementing     test.processAsyncFetch(Collections.singletonList(response1), Collections.emptyList(), 0).     assertThat(fetchData.hasData(), equalTo(false)).     assertThat(test.reroute.get(), equalTo(1)).     // fire a response (with correct round id), wait on reroute incrementing     test.fireSimulationAndWait(node1.getId()).     // verify we get back the data node     assertThat(test.reroute.get(), equalTo(2)).     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(true)).     assertThat(fetchData.getData().size(), equalTo(1)).     assertThat(fetchData.getData().get(node1), sameInstance(response1)). }
false;public;0;24;;public void testIgnoreFailureFromDifferentRound() throws Exception {     DiscoveryNodes nodes = DiscoveryNodes.builder().add(node1).build().     // add a failed response for node1     test.addSimulation(node1.getId(), failure1).     // first fetch, no data, still on going     AsyncShardFetch.FetchResult<Response> fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     assertThat(test.reroute.get(), equalTo(0)).     // handle a failure with incorrect round id, wait on reroute incrementing     test.processAsyncFetch(Collections.emptyList(), Collections.singletonList(new FailedNodeException(node1.getId(), "dummy failure", failure1)), 0).     assertThat(fetchData.hasData(), equalTo(false)).     assertThat(test.reroute.get(), equalTo(1)).     // fire a response, wait on reroute incrementing     test.fireSimulationAndWait(node1.getId()).     // failure, fetched data exists, but has no data     assertThat(test.reroute.get(), equalTo(2)).     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(true)).     assertThat(fetchData.getData().size(), equalTo(0)). }
false;public;0;27;;public void testTwoNodesOnSetup() throws Exception {     DiscoveryNodes nodes = DiscoveryNodes.builder().add(node1).add(node2).build().     test.addSimulation(node1.getId(), response1).     test.addSimulation(node2.getId(), response2).     // no fetched data, 2 requests still on going     AsyncShardFetch.FetchResult<Response> fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     assertThat(test.reroute.get(), equalTo(0)).     // fire the first response, it should trigger a reroute     test.fireSimulationAndWait(node1.getId()).     // there is still another on going request, so no data     assertThat(test.getNumberOfInFlightFetches(), equalTo(1)).     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     // fire the second simulation, this should allow us to get the data     test.fireSimulationAndWait(node2.getId()).     // no more ongoing requests, we should fetch the data     assertThat(test.reroute.get(), equalTo(2)).     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(true)).     assertThat(fetchData.getData().size(), equalTo(2)).     assertThat(fetchData.getData().get(node1), sameInstance(response1)).     assertThat(fetchData.getData().get(node2), sameInstance(response2)). }
false;public;0;25;;public void testTwoNodesOnSetupAndFailure() throws Exception {     DiscoveryNodes nodes = DiscoveryNodes.builder().add(node1).add(node2).build().     test.addSimulation(node1.getId(), response1).     test.addSimulation(node2.getId(), failure2).     // no fetched data, 2 requests still on going     AsyncShardFetch.FetchResult<Response> fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     assertThat(test.reroute.get(), equalTo(0)).     // fire the first response, it should trigger a reroute     test.fireSimulationAndWait(node1.getId()).     assertThat(test.reroute.get(), equalTo(1)).     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     // fire the second simulation, this should allow us to get the data     test.fireSimulationAndWait(node2.getId()).     assertThat(test.reroute.get(), equalTo(2)).     // since one of those failed, we should only have one entry     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(true)).     assertThat(fetchData.getData().size(), equalTo(1)).     assertThat(fetchData.getData().get(node1), sameInstance(response1)). }
false;public;0;29;;public void testTwoNodesAddedInBetween() throws Exception {     DiscoveryNodes nodes = DiscoveryNodes.builder().add(node1).build().     test.addSimulation(node1.getId(), response1).     // no fetched data, 2 requests still on going     AsyncShardFetch.FetchResult<Response> fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     assertThat(test.reroute.get(), equalTo(0)).     // fire the first response, it should trigger a reroute     test.fireSimulationAndWait(node1.getId()).     // now, add a second node to the nodes, it should add it to the ongoing requests     nodes = DiscoveryNodes.builder(nodes).add(node2).build().     test.addSimulation(node2.getId(), response2).     // no fetch data, has a new node introduced     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(false)).     // fire the second simulation, this should allow us to get the data     test.fireSimulationAndWait(node2.getId()).     // since one of those failed, we should only have one entry     fetchData = test.fetchData(nodes, emptySet()).     assertThat(fetchData.hasData(), equalTo(true)).     assertThat(fetchData.getData().size(), equalTo(2)).     assertThat(fetchData.getData().get(node1), sameInstance(response1)).     assertThat(fetchData.getData().get(node2), sameInstance(response2)). }
false;public;2;3;;public void addSimulation(String nodeId, Response response) {     simulations.put(nodeId, new Entry(response, null)). }
false;public;2;3;;public void addSimulation(String nodeId, Throwable t) {     simulations.put(nodeId, new Entry(null, t)). }
false;public;1;5;;public void fireSimulationAndWait(String nodeId) throws InterruptedException {     simulations.get(nodeId).executeLatch.countDown().     simulations.get(nodeId).waitLatch.await().     simulations.remove(nodeId). }
false;protected;2;4;;@Override protected void reroute(ShardId shardId, String reason) {     reroute.incrementAndGet(). }
false;public;0;25;;@Override public void run() {     Entry entry = null.     try {         entry = simulations.get(nodeId).         if (entry == null) {             // we are simulating a master node switch, wait for it to not be null             awaitBusy(() -> simulations.containsKey(nodeId)).         }         assert entry != null.         entry.executeLatch.await().         if (entry.failure != null) {             processAsyncFetch(null, Collections.singletonList(new FailedNodeException(nodeId, "unexpected", entry.failure)), fetchingRound).         } else {             processAsyncFetch(Collections.singletonList(entry.response), null, fetchingRound).         }     } catch (Exception e) {         logger.error("unexpected failure", e).     } finally {         if (entry != null) {             entry.waitLatch.countDown().         }     } }
false;protected;2;33;;@Override protected void asyncFetch(DiscoveryNode[] nodes, long fetchingRound) {     for (final DiscoveryNode node : nodes) {         final String nodeId = node.getId().         threadPool.generic().execute(new Runnable() {              @Override             public void run() {                 Entry entry = null.                 try {                     entry = simulations.get(nodeId).                     if (entry == null) {                         // we are simulating a master node switch, wait for it to not be null                         awaitBusy(() -> simulations.containsKey(nodeId)).                     }                     assert entry != null.                     entry.executeLatch.await().                     if (entry.failure != null) {                         processAsyncFetch(null, Collections.singletonList(new FailedNodeException(nodeId, "unexpected", entry.failure)), fetchingRound).                     } else {                         processAsyncFetch(Collections.singletonList(entry.response), null, fetchingRound).                     }                 } catch (Exception e) {                     logger.error("unexpected failure", e).                 } finally {                     if (entry != null) {                         entry.waitLatch.countDown().                     }                 }             }         }).     } }
