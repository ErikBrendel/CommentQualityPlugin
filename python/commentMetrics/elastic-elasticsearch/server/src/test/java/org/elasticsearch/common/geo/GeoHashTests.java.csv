commented;modifiers;parameterAmount;loc;comment;code
false;public;0;33;;public void testGeohashAsLongRoutines() {     final GeoPoint expected = new GeoPoint().     final GeoPoint actual = new GeoPoint().     // String based counterpart     for (double lat = -90. lat < 90. lat++) {         for (double lng = -180. lng < 180. lng++) {             for (int p = 1. p <= 12. p++) {                 long geoAsLong = GeoHashUtils.longEncode(lng, lat, p).                 // string encode from geohashlong encoded location                 String geohashFromLong = GeoHashUtils.stringEncode(geoAsLong).                 // string encode from full res lat lon                 String geohash = GeoHashUtils.stringEncode(lng, lat, p).                 // ensure both strings are the same                 assertEquals(geohash, geohashFromLong).                 // decode from the full-res geohash string                 expected.resetFromGeoHash(geohash).                 // decode from the geohash encoded long                 actual.resetFromGeoHash(geoAsLong).                 assertEquals(expected, actual).             }         }     } }
false;public;0;11;;public void testBboxFromHash() {     String hash = randomGeohash(1, 12).     int level = hash.length().     Rectangle bbox = GeoHashUtils.bbox(hash).     // check that the length is as expected     double expectedLonDiff = 360.0 / (Math.pow(8.0, (level + 1) / 2) * Math.pow(4.0, level / 2)).     double expectedLatDiff = 180.0 / (Math.pow(4.0, (level + 1) / 2) * Math.pow(8.0, level / 2)).     assertEquals(expectedLonDiff, bbox.maxLon - bbox.minLon, 0.00001).     assertEquals(expectedLatDiff, bbox.maxLat - bbox.minLat, 0.00001).     assertEquals(hash, GeoHashUtils.stringEncode(bbox.minLon, bbox.minLat, level)). }
false;public;0;11;;public void testGeohashExtremes() {     assertEquals("000000000000", GeoHashUtils.stringEncode(-180, -90)).     assertEquals("800000000000", GeoHashUtils.stringEncode(-180, 0)).     assertEquals("bpbpbpbpbpbp", GeoHashUtils.stringEncode(-180, 90)).     assertEquals("h00000000000", GeoHashUtils.stringEncode(0, -90)).     assertEquals("s00000000000", GeoHashUtils.stringEncode(0, 0)).     assertEquals("upbpbpbpbpbp", GeoHashUtils.stringEncode(0, 90)).     assertEquals("pbpbpbpbpbpb", GeoHashUtils.stringEncode(180, -90)).     assertEquals("xbpbpbpbpbpb", GeoHashUtils.stringEncode(180, 0)).     assertEquals("zzzzzzzzzzzz", GeoHashUtils.stringEncode(180, 90)). }
false;public;0;14;;public void testLongGeohashes() {     for (int i = 0. i < 100000. i++) {         String geohash = randomGeohash(12, 12).         GeoPoint expected = GeoPoint.fromGeohash(geohash).         // Adding some random geohash characters at the end         String extendedGeohash = geohash + randomGeohash(1, 10).         GeoPoint actual = GeoPoint.fromGeohash(extendedGeohash).         assertEquals("Additional data points above 12 should be ignored [" + extendedGeohash + "]", expected, actual).         Rectangle expectedBbox = GeoHashUtils.bbox(geohash).         Rectangle actualBbox = GeoHashUtils.bbox(extendedGeohash).         assertEquals("Additional data points above 12 should be ignored [" + extendedGeohash + "]", expectedBbox, actualBbox).     } }
false;public;0;4;;public void testNorthPoleBoundingBox() {     // Bounding box with maximum precision touching north pole     Rectangle bbox = GeoHashUtils.bbox("zzbxfpgzupbx").     // Should be 90 degrees     assertEquals(90.0, bbox.maxLat, 0.0000001). }
false;public;0;9;;public void testInvalidGeohashes() {     IllegalArgumentException ex.     ex = expectThrows(IllegalArgumentException.class, () -> GeoHashUtils.mortonEncode("55.5")).     assertEquals("unsupported symbol [.] in geohash [55.5]", ex.getMessage()).     ex = expectThrows(IllegalArgumentException.class, () -> GeoHashUtils.mortonEncode("")).     assertEquals("empty geohash", ex.getMessage()). }
