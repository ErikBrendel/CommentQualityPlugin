# id;timestamp;commentText;codeText;commentWords;codeWords
InSyncAllocationIdTests -> public void testPrimaryFailureBatchedWithReplicaFailure() throws Exception;1524684173;Assume following scenario: indexing request is written to primary, but fails to be replicated to active replica._The primary instructs master to fail replica before acknowledging write to client. In the meanwhile, primary fails for an unrelated_reason. Master now batches both requests to fail primary and replica. We have to make sure that only the allocation id of the primary_is kept in the in-sync allocation set before we acknowledge request to client. Otherwise we would acknowledge a write that made it_into the primary but not the replica but the replica is still considered non-stale.;public void testPrimaryFailureBatchedWithReplicaFailure() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        long primaryTerm = clusterState.metaData().index("test").primaryTerm(0)___        List<FailedShardEntry> failureEntries = new ArrayList<>()__        failureEntries.add(new FailedShardEntry(_            shardRoutingTable.shardId(), primaryShard.allocationId().getId(), 0L, "dummy", null, true))__        failureEntries.add(new FailedShardEntry(_            shardRoutingTable.shardId(), replicaShard.allocationId().getId(), primaryTerm, "dummy", null, true))__        Collections.shuffle(failureEntries, random())__        logger.info("Failing {}", failureEntries)___        clusterState = failedClusterStateTaskExecutor.execute(clusterState, failureEntries).resultingState___        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0),_            equalTo(Collections.singleton(primaryShard.allocationId().getId())))___        _        clusterState = failedClusterStateTaskExecutor.execute(clusterState, failureEntries).resultingState___        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0),_            equalTo(Collections.singleton(primaryShard.allocationId().getId())))__    };assume,following,scenario,indexing,request,is,written,to,primary,but,fails,to,be,replicated,to,active,replica,the,primary,instructs,master,to,fail,replica,before,acknowledging,write,to,client,in,the,meanwhile,primary,fails,for,an,unrelated,reason,master,now,batches,both,requests,to,fail,primary,and,replica,we,have,to,make,sure,that,only,the,allocation,id,of,the,primary,is,kept,in,the,in,sync,allocation,set,before,we,acknowledge,request,to,client,otherwise,we,would,acknowledge,a,write,that,made,it,into,the,primary,but,not,the,replica,but,the,replica,is,still,considered,non,stale;public,void,test,primary,failure,batched,with,replica,failure,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,long,primary,term,cluster,state,meta,data,index,test,primary,term,0,list,failed,shard,entry,failure,entries,new,array,list,failure,entries,add,new,failed,shard,entry,shard,routing,table,shard,id,primary,shard,allocation,id,get,id,0l,dummy,null,true,failure,entries,add,new,failed,shard,entry,shard,routing,table,shard,id,replica,shard,allocation,id,get,id,primary,term,dummy,null,true,collections,shuffle,failure,entries,random,logger,info,failing,failure,entries,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,failure,entries,resulting,state,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,equal,to,collections,singleton,primary,shard,allocation,id,get,id,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,failure,entries,resulting,state,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,equal,to,collections,singleton,primary,shard,allocation,id,get,id
InSyncAllocationIdTests -> public void testPrimaryFailureBatchedWithReplicaFailure() throws Exception;1539723533;Assume following scenario: indexing request is written to primary, but fails to be replicated to active replica._The primary instructs master to fail replica before acknowledging write to client. In the meanwhile, primary fails for an unrelated_reason. Master now batches both requests to fail primary and replica. We have to make sure that only the allocation id of the primary_is kept in the in-sync allocation set before we acknowledge request to client. Otherwise we would acknowledge a write that made it_into the primary but not the replica but the replica is still considered non-stale.;public void testPrimaryFailureBatchedWithReplicaFailure() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        long primaryTerm = clusterState.metaData().index("test").primaryTerm(0)___        List<FailedShardEntry> failureEntries = new ArrayList<>()__        failureEntries.add(new FailedShardEntry(_            shardRoutingTable.shardId(), primaryShard.allocationId().getId(), 0L, "dummy", null, true))__        failureEntries.add(new FailedShardEntry(_            shardRoutingTable.shardId(), replicaShard.allocationId().getId(), primaryTerm, "dummy", null, true))__        Collections.shuffle(failureEntries, random())__        logger.info("Failing {}", failureEntries)___        clusterState = failedClusterStateTaskExecutor.execute(clusterState, failureEntries).resultingState___        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0),_            equalTo(Collections.singleton(primaryShard.allocationId().getId())))___        _        clusterState = failedClusterStateTaskExecutor.execute(clusterState, failureEntries).resultingState___        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0),_            equalTo(Collections.singleton(primaryShard.allocationId().getId())))__    };assume,following,scenario,indexing,request,is,written,to,primary,but,fails,to,be,replicated,to,active,replica,the,primary,instructs,master,to,fail,replica,before,acknowledging,write,to,client,in,the,meanwhile,primary,fails,for,an,unrelated,reason,master,now,batches,both,requests,to,fail,primary,and,replica,we,have,to,make,sure,that,only,the,allocation,id,of,the,primary,is,kept,in,the,in,sync,allocation,set,before,we,acknowledge,request,to,client,otherwise,we,would,acknowledge,a,write,that,made,it,into,the,primary,but,not,the,replica,but,the,replica,is,still,considered,non,stale;public,void,test,primary,failure,batched,with,replica,failure,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,long,primary,term,cluster,state,meta,data,index,test,primary,term,0,list,failed,shard,entry,failure,entries,new,array,list,failure,entries,add,new,failed,shard,entry,shard,routing,table,shard,id,primary,shard,allocation,id,get,id,0l,dummy,null,true,failure,entries,add,new,failed,shard,entry,shard,routing,table,shard,id,replica,shard,allocation,id,get,id,primary,term,dummy,null,true,collections,shuffle,failure,entries,random,logger,info,failing,failure,entries,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,failure,entries,resulting,state,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,equal,to,collections,singleton,primary,shard,allocation,id,get,id,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,failure,entries,resulting,state,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,equal,to,collections,singleton,primary,shard,allocation,id,get,id
InSyncAllocationIdTests -> public void testPrimaryFailureBatchedWithReplicaFailure() throws Exception;1548259585;Assume following scenario: indexing request is written to primary, but fails to be replicated to active replica._The primary instructs master to fail replica before acknowledging write to client. In the meanwhile, primary fails for an unrelated_reason. Master now batches both requests to fail primary and replica. We have to make sure that only the allocation id of the primary_is kept in the in-sync allocation set before we acknowledge request to client. Otherwise we would acknowledge a write that made it_into the primary but not the replica but the replica is still considered non-stale.;public void testPrimaryFailureBatchedWithReplicaFailure() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        long primaryTerm = clusterState.metaData().index("test").primaryTerm(0)___        List<FailedShardEntry> failureEntries = new ArrayList<>()__        failureEntries.add(new FailedShardEntry(_            shardRoutingTable.shardId(), primaryShard.allocationId().getId(), 0L, "dummy", null, true))__        failureEntries.add(new FailedShardEntry(_            shardRoutingTable.shardId(), replicaShard.allocationId().getId(), primaryTerm, "dummy", null, true))__        Collections.shuffle(failureEntries, random())__        logger.info("Failing {}", failureEntries)___        clusterState = failedClusterStateTaskExecutor.execute(clusterState, failureEntries).resultingState___        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0),_            equalTo(Collections.singleton(primaryShard.allocationId().getId())))___        _        clusterState = failedClusterStateTaskExecutor.execute(clusterState, failureEntries).resultingState___        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0),_            equalTo(Collections.singleton(primaryShard.allocationId().getId())))__    };assume,following,scenario,indexing,request,is,written,to,primary,but,fails,to,be,replicated,to,active,replica,the,primary,instructs,master,to,fail,replica,before,acknowledging,write,to,client,in,the,meanwhile,primary,fails,for,an,unrelated,reason,master,now,batches,both,requests,to,fail,primary,and,replica,we,have,to,make,sure,that,only,the,allocation,id,of,the,primary,is,kept,in,the,in,sync,allocation,set,before,we,acknowledge,request,to,client,otherwise,we,would,acknowledge,a,write,that,made,it,into,the,primary,but,not,the,replica,but,the,replica,is,still,considered,non,stale;public,void,test,primary,failure,batched,with,replica,failure,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,long,primary,term,cluster,state,meta,data,index,test,primary,term,0,list,failed,shard,entry,failure,entries,new,array,list,failure,entries,add,new,failed,shard,entry,shard,routing,table,shard,id,primary,shard,allocation,id,get,id,0l,dummy,null,true,failure,entries,add,new,failed,shard,entry,shard,routing,table,shard,id,replica,shard,allocation,id,get,id,primary,term,dummy,null,true,collections,shuffle,failure,entries,random,logger,info,failing,failure,entries,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,failure,entries,resulting,state,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,equal,to,collections,singleton,primary,shard,allocation,id,get,id,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,failure,entries,resulting,state,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,equal,to,collections,singleton,primary,shard,allocation,id,get,id
InSyncAllocationIdTests -> public void testInSyncIdsNotTrimmedWhenNotGrowing() throws Exception;1524684173;Only trim set of allocation ids when the set grows;public void testInSyncIdsNotTrimmedWhenNotGrowing() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        Set<String> inSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(inSyncSet.size(), equalTo(2))___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        logger.info("remove replica node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("remove primary node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(primaryShard.currentNodeId()))_            .build()__        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("decrease number of replicas to 0")__        clusterState = ClusterState.builder(clusterState)_            .routingTable(RoutingTable.builder(clusterState.routingTable()).updateNumberOfReplicas(0, "test").build())_            .metaData(MetaData.builder(clusterState.metaData()).updateNumberOfReplicas(0, "test")).build()___        logger.info("add back node 1")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(_            newNode("node1"))).build()__        clusterState = allocation.reroute(clusterState, "reroute")___        assertThat(clusterState.routingTable().index("test").shard(0).assignedShards().size(), equalTo(1))__        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("start primary shard")__        clusterState = allocation.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING))__        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))__    };only,trim,set,of,allocation,ids,when,the,set,grows;public,void,test,in,sync,ids,not,trimmed,when,not,growing,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,set,string,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,in,sync,set,size,equal,to,2,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,logger,info,remove,replica,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,remove,primary,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,primary,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,decrease,number,of,replicas,to,0,cluster,state,cluster,state,builder,cluster,state,routing,table,routing,table,builder,cluster,state,routing,table,update,number,of,replicas,0,test,build,meta,data,meta,data,builder,cluster,state,meta,data,update,number,of,replicas,0,test,build,logger,info,add,back,node,1,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,add,new,node,node1,build,cluster,state,allocation,reroute,cluster,state,reroute,assert,that,cluster,state,routing,table,index,test,shard,0,assigned,shards,size,equal,to,1,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,start,primary,shard,cluster,state,allocation,apply,started,shards,cluster,state,cluster,state,get,routing,nodes,shards,with,state,initializing,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0
InSyncAllocationIdTests -> public void testInSyncIdsNotTrimmedWhenNotGrowing() throws Exception;1539723533;Only trim set of allocation ids when the set grows;public void testInSyncIdsNotTrimmedWhenNotGrowing() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        Set<String> inSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(inSyncSet.size(), equalTo(2))___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        logger.info("remove replica node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("remove primary node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(primaryShard.currentNodeId()))_            .build()__        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("decrease number of replicas to 0")__        clusterState = ClusterState.builder(clusterState)_            .routingTable(RoutingTable.builder(clusterState.routingTable()).updateNumberOfReplicas(0, new String[]{"test"}).build())_            .metaData(MetaData.builder(clusterState.metaData()).updateNumberOfReplicas(0, new String[]{"test"})).build()___        logger.info("add back node 1")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(_            newNode("node1"))).build()__        clusterState = allocation.reroute(clusterState, "reroute")___        assertThat(clusterState.routingTable().index("test").shard(0).assignedShards().size(), equalTo(1))__        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("start primary shard")__        clusterState = allocation.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING))__        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))__    };only,trim,set,of,allocation,ids,when,the,set,grows;public,void,test,in,sync,ids,not,trimmed,when,not,growing,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,set,string,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,in,sync,set,size,equal,to,2,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,logger,info,remove,replica,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,remove,primary,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,primary,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,decrease,number,of,replicas,to,0,cluster,state,cluster,state,builder,cluster,state,routing,table,routing,table,builder,cluster,state,routing,table,update,number,of,replicas,0,new,string,test,build,meta,data,meta,data,builder,cluster,state,meta,data,update,number,of,replicas,0,new,string,test,build,logger,info,add,back,node,1,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,add,new,node,node1,build,cluster,state,allocation,reroute,cluster,state,reroute,assert,that,cluster,state,routing,table,index,test,shard,0,assigned,shards,size,equal,to,1,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,start,primary,shard,cluster,state,allocation,apply,started,shards,cluster,state,cluster,state,get,routing,nodes,shards,with,state,initializing,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0
InSyncAllocationIdTests -> public void testInSyncIdsNotTrimmedWhenNotGrowing() throws Exception;1548259585;Only trim set of allocation ids when the set grows;public void testInSyncIdsNotTrimmedWhenNotGrowing() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        Set<String> inSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(inSyncSet.size(), equalTo(2))___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        logger.info("remove replica node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.disassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("remove primary node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(primaryShard.currentNodeId()))_            .build()__        clusterState = allocation.disassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("decrease number of replicas to 0")__        clusterState = ClusterState.builder(clusterState)_            .routingTable(RoutingTable.builder(clusterState.routingTable()).updateNumberOfReplicas(0, new String[]{"test"}).build())_            .metaData(MetaData.builder(clusterState.metaData()).updateNumberOfReplicas(0, new String[]{"test"})).build()___        logger.info("add back node 1")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder().add(_            newNode("node1"))).build()__        clusterState = allocation.reroute(clusterState, "reroute")___        assertThat(clusterState.routingTable().index("test").shard(0).assignedShards().size(), equalTo(1))__        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("start primary shard")__        clusterState = allocation.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING))__        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))__    };only,trim,set,of,allocation,ids,when,the,set,grows;public,void,test,in,sync,ids,not,trimmed,when,not,growing,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,set,string,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,in,sync,set,size,equal,to,2,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,logger,info,remove,replica,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,disassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,remove,primary,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,primary,shard,current,node,id,build,cluster,state,allocation,disassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,decrease,number,of,replicas,to,0,cluster,state,cluster,state,builder,cluster,state,routing,table,routing,table,builder,cluster,state,routing,table,update,number,of,replicas,0,new,string,test,build,meta,data,meta,data,builder,cluster,state,meta,data,update,number,of,replicas,0,new,string,test,build,logger,info,add,back,node,1,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,add,new,node,node1,build,cluster,state,allocation,reroute,cluster,state,reroute,assert,that,cluster,state,routing,table,index,test,shard,0,assigned,shards,size,equal,to,1,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,start,primary,shard,cluster,state,allocation,apply,started,shards,cluster,state,cluster,state,get,routing,nodes,shards,with,state,initializing,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0
InSyncAllocationIdTests -> public void testPrimaryAllocationIdNotRemovedFromInSyncSetWhenNoFailOver() throws Exception;1524684173;Don't remove allocation id of failed active primary if there is no replica to promote as primary.;public void testPrimaryAllocationIdNotRemovedFromInSyncSetWhenNoFailOver() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        Set<String> inSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(inSyncSet.size(), equalTo(2))___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        logger.info("remove replica node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("fail primary shard")__        clusterState = failedClusterStateTaskExecutor.execute(clusterState, Collections.singletonList(new FailedShardEntry(_            shardRoutingTable.shardId(), primaryShard.allocationId().getId(), 0L, "dummy", null, true))).resultingState___        assertThat(clusterState.routingTable().index("test").shard(0).assignedShards().size(), equalTo(0))__        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))__    };don,t,remove,allocation,id,of,failed,active,primary,if,there,is,no,replica,to,promote,as,primary;public,void,test,primary,allocation,id,not,removed,from,in,sync,set,when,no,fail,over,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,set,string,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,in,sync,set,size,equal,to,2,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,logger,info,remove,replica,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,fail,primary,shard,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,collections,singleton,list,new,failed,shard,entry,shard,routing,table,shard,id,primary,shard,allocation,id,get,id,0l,dummy,null,true,resulting,state,assert,that,cluster,state,routing,table,index,test,shard,0,assigned,shards,size,equal,to,0,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0
InSyncAllocationIdTests -> public void testPrimaryAllocationIdNotRemovedFromInSyncSetWhenNoFailOver() throws Exception;1539723533;Don't remove allocation id of failed active primary if there is no replica to promote as primary.;public void testPrimaryAllocationIdNotRemovedFromInSyncSetWhenNoFailOver() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        Set<String> inSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(inSyncSet.size(), equalTo(2))___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        logger.info("remove replica node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("fail primary shard")__        clusterState = failedClusterStateTaskExecutor.execute(clusterState, Collections.singletonList(new FailedShardEntry(_            shardRoutingTable.shardId(), primaryShard.allocationId().getId(), 0L, "dummy", null, true))).resultingState___        assertThat(clusterState.routingTable().index("test").shard(0).assignedShards().size(), equalTo(0))__        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))__    };don,t,remove,allocation,id,of,failed,active,primary,if,there,is,no,replica,to,promote,as,primary;public,void,test,primary,allocation,id,not,removed,from,in,sync,set,when,no,fail,over,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,set,string,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,in,sync,set,size,equal,to,2,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,logger,info,remove,replica,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,fail,primary,shard,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,collections,singleton,list,new,failed,shard,entry,shard,routing,table,shard,id,primary,shard,allocation,id,get,id,0l,dummy,null,true,resulting,state,assert,that,cluster,state,routing,table,index,test,shard,0,assigned,shards,size,equal,to,0,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0
InSyncAllocationIdTests -> public void testPrimaryAllocationIdNotRemovedFromInSyncSetWhenNoFailOver() throws Exception;1548259585;Don't remove allocation id of failed active primary if there is no replica to promote as primary.;public void testPrimaryAllocationIdNotRemovedFromInSyncSetWhenNoFailOver() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        Set<String> inSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(inSyncSet.size(), equalTo(2))___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        logger.info("remove replica node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.disassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        logger.info("fail primary shard")__        clusterState = failedClusterStateTaskExecutor.execute(clusterState, Collections.singletonList(new FailedShardEntry(_            shardRoutingTable.shardId(), primaryShard.allocationId().getId(), 0L, "dummy", null, true))).resultingState___        assertThat(clusterState.routingTable().index("test").shard(0).assignedShards().size(), equalTo(0))__        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))__    };don,t,remove,allocation,id,of,failed,active,primary,if,there,is,no,replica,to,promote,as,primary;public,void,test,primary,allocation,id,not,removed,from,in,sync,set,when,no,fail,over,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,set,string,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,in,sync,set,size,equal,to,2,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,logger,info,remove,replica,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,disassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,logger,info,fail,primary,shard,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,collections,singleton,list,new,failed,shard,entry,shard,routing,table,shard,id,primary,shard,allocation,id,get,id,0l,dummy,null,true,resulting,state,assert,that,cluster,state,routing,table,index,test,shard,0,assigned,shards,size,equal,to,0,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0
InSyncAllocationIdTests -> public void testInSyncIdsNotGrowingWithoutBounds() throws Exception;1524684173;Prevent set of inSyncAllocationIds to grow unboundedly. This can happen for example if we don't write to a primary_but repeatedly shut down nodes that have active replicas._We use number_of_replicas + 1 (= possible active shard copies) to bound the inSyncAllocationIds set;public void testInSyncIdsNotGrowingWithoutBounds() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        Set<String> inSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(inSyncSet.size(), equalTo(2))___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        logger.info("remove a node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        _        for (int i = 0_ i < 5_ i++) {_            logger.info("add back node")__            clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_                .add(newNode(replicaShard.currentNodeId())))_                .build()__            clusterState = allocation.reroute(clusterState, "reroute")___            logger.info("start replica shards")__            clusterState = allocation.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING))___            logger.info("remove the node")__            clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_                .remove(replicaShard.currentNodeId()))_                .build()__            clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")__            }__        _        Set<String> newInSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(newInSyncSet.size(), equalTo(2))__        _        assertFalse(Sets.haveEmptyIntersection(inSyncSet, newInSyncSet))__        assertThat(newInSyncSet, hasItem(primaryShard.allocationId().getId()))__    };prevent,set,of,in,sync,allocation,ids,to,grow,unboundedly,this,can,happen,for,example,if,we,don,t,write,to,a,primary,but,repeatedly,shut,down,nodes,that,have,active,replicas,we,use,1,possible,active,shard,copies,to,bound,the,in,sync,allocation,ids,set;public,void,test,in,sync,ids,not,growing,without,bounds,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,set,string,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,in,sync,set,size,equal,to,2,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,logger,info,remove,a,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,for,int,i,0,i,5,i,logger,info,add,back,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,add,new,node,replica,shard,current,node,id,build,cluster,state,allocation,reroute,cluster,state,reroute,logger,info,start,replica,shards,cluster,state,allocation,apply,started,shards,cluster,state,cluster,state,get,routing,nodes,shards,with,state,initializing,logger,info,remove,the,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,set,string,new,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,new,in,sync,set,size,equal,to,2,assert,false,sets,have,empty,intersection,in,sync,set,new,in,sync,set,assert,that,new,in,sync,set,has,item,primary,shard,allocation,id,get,id
InSyncAllocationIdTests -> public void testInSyncIdsNotGrowingWithoutBounds() throws Exception;1539723533;Prevent set of inSyncAllocationIds to grow unboundedly. This can happen for example if we don't write to a primary_but repeatedly shut down nodes that have active replicas._We use number_of_replicas + 1 (= possible active shard copies) to bound the inSyncAllocationIds set;public void testInSyncIdsNotGrowingWithoutBounds() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        Set<String> inSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(inSyncSet.size(), equalTo(2))___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        logger.info("remove a node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        _        for (int i = 0_ i < 5_ i++) {_            logger.info("add back node")__            clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_                .add(newNode(replicaShard.currentNodeId())))_                .build()__            clusterState = allocation.reroute(clusterState, "reroute")___            logger.info("start replica shards")__            clusterState = allocation.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING))___            logger.info("remove the node")__            clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_                .remove(replicaShard.currentNodeId()))_                .build()__            clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")__            }__        _        Set<String> newInSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(newInSyncSet.size(), equalTo(2))__        _        assertFalse(Sets.haveEmptyIntersection(inSyncSet, newInSyncSet))__        assertThat(newInSyncSet, hasItem(primaryShard.allocationId().getId()))__    };prevent,set,of,in,sync,allocation,ids,to,grow,unboundedly,this,can,happen,for,example,if,we,don,t,write,to,a,primary,but,repeatedly,shut,down,nodes,that,have,active,replicas,we,use,1,possible,active,shard,copies,to,bound,the,in,sync,allocation,ids,set;public,void,test,in,sync,ids,not,growing,without,bounds,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,set,string,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,in,sync,set,size,equal,to,2,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,logger,info,remove,a,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,for,int,i,0,i,5,i,logger,info,add,back,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,add,new,node,replica,shard,current,node,id,build,cluster,state,allocation,reroute,cluster,state,reroute,logger,info,start,replica,shards,cluster,state,allocation,apply,started,shards,cluster,state,cluster,state,get,routing,nodes,shards,with,state,initializing,logger,info,remove,the,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,set,string,new,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,new,in,sync,set,size,equal,to,2,assert,false,sets,have,empty,intersection,in,sync,set,new,in,sync,set,assert,that,new,in,sync,set,has,item,primary,shard,allocation,id,get,id
InSyncAllocationIdTests -> public void testInSyncIdsNotGrowingWithoutBounds() throws Exception;1548259585;Prevent set of inSyncAllocationIds to grow unboundedly. This can happen for example if we don't write to a primary_but repeatedly shut down nodes that have active replicas._We use number_of_replicas + 1 (= possible active shard copies) to bound the inSyncAllocationIds set;public void testInSyncIdsNotGrowingWithoutBounds() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        Set<String> inSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(inSyncSet.size(), equalTo(2))___        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting primaryShard = shardRoutingTable.primaryShard()__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)___        logger.info("remove a node")__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.disassociateDeadNodes(clusterState, true, "reroute")___        _        assertEquals(inSyncSet, clusterState.metaData().index("test").inSyncAllocationIds(0))___        _        for (int i = 0_ i < 5_ i++) {_            logger.info("add back node")__            clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_                .add(newNode(replicaShard.currentNodeId())))_                .build()__            clusterState = allocation.reroute(clusterState, "reroute")___            logger.info("start replica shards")__            clusterState = allocation.applyStartedShards(clusterState, clusterState.getRoutingNodes().shardsWithState(INITIALIZING))___            logger.info("remove the node")__            clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_                .remove(replicaShard.currentNodeId()))_                .build()__            clusterState = allocation.disassociateDeadNodes(clusterState, true, "reroute")__            }__        _        Set<String> newInSyncSet = clusterState.metaData().index("test").inSyncAllocationIds(0)__        assertThat(newInSyncSet.size(), equalTo(2))__        _        assertFalse(Sets.haveEmptyIntersection(inSyncSet, newInSyncSet))__        assertThat(newInSyncSet, hasItem(primaryShard.allocationId().getId()))__    };prevent,set,of,in,sync,allocation,ids,to,grow,unboundedly,this,can,happen,for,example,if,we,don,t,write,to,a,primary,but,repeatedly,shut,down,nodes,that,have,active,replicas,we,use,1,possible,active,shard,copies,to,bound,the,in,sync,allocation,ids,set;public,void,test,in,sync,ids,not,growing,without,bounds,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,set,string,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,in,sync,set,size,equal,to,2,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,primary,shard,shard,routing,table,primary,shard,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,logger,info,remove,a,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,disassociate,dead,nodes,cluster,state,true,reroute,assert,equals,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,for,int,i,0,i,5,i,logger,info,add,back,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,add,new,node,replica,shard,current,node,id,build,cluster,state,allocation,reroute,cluster,state,reroute,logger,info,start,replica,shards,cluster,state,allocation,apply,started,shards,cluster,state,cluster,state,get,routing,nodes,shards,with,state,initializing,logger,info,remove,the,node,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,disassociate,dead,nodes,cluster,state,true,reroute,set,string,new,in,sync,set,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,assert,that,new,in,sync,set,size,equal,to,2,assert,false,sets,have,empty,intersection,in,sync,set,new,in,sync,set,assert,that,new,in,sync,set,has,item,primary,shard,allocation,id,get,id
InSyncAllocationIdTests -> public void testDeadNodesBeforeReplicaFailed() throws Exception;1524684173;Assume following scenario: indexing request is written to primary, but fails to be replicated to active replica._The primary instructs master to fail replica before acknowledging write to client. In the meanwhile, the node of the replica was_removed from the cluster (deassociateDeadNodes). This means that the ShardRouting of the replica was failed, but it's allocation_id is still part of the in-sync set. We have to make sure that the failShard request from the primary removes the allocation id_from the in-sync set.;public void testDeadNodesBeforeReplicaFailed() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        logger.info("remove replica node")__        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")__        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0).size(), equalTo(2))___        logger.info("fail replica (for which there is no shard routing in the CS anymore)")__        assertNull(clusterState.getRoutingNodes().getByAllocationId(replicaShard.shardId(), replicaShard.allocationId().getId()))__        ShardStateAction.ShardFailedClusterStateTaskExecutor failedClusterStateTaskExecutor =_            new ShardStateAction.ShardFailedClusterStateTaskExecutor(allocation, null, logger)__        long primaryTerm = clusterState.metaData().index("test").primaryTerm(0)__        clusterState = failedClusterStateTaskExecutor.execute(clusterState, Arrays.asList(_                new FailedShardEntry(shardRoutingTable.shardId(), replicaShard.allocationId().getId(), primaryTerm, "dummy", null, true))_            ).resultingState___        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0).size(), equalTo(1))__    };assume,following,scenario,indexing,request,is,written,to,primary,but,fails,to,be,replicated,to,active,replica,the,primary,instructs,master,to,fail,replica,before,acknowledging,write,to,client,in,the,meanwhile,the,node,of,the,replica,was,removed,from,the,cluster,deassociate,dead,nodes,this,means,that,the,shard,routing,of,the,replica,was,failed,but,it,s,allocation,id,is,still,part,of,the,in,sync,set,we,have,to,make,sure,that,the,fail,shard,request,from,the,primary,removes,the,allocation,id,from,the,in,sync,set;public,void,test,dead,nodes,before,replica,failed,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,logger,info,remove,replica,node,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,size,equal,to,2,logger,info,fail,replica,for,which,there,is,no,shard,routing,in,the,cs,anymore,assert,null,cluster,state,get,routing,nodes,get,by,allocation,id,replica,shard,shard,id,replica,shard,allocation,id,get,id,shard,state,action,shard,failed,cluster,state,task,executor,failed,cluster,state,task,executor,new,shard,state,action,shard,failed,cluster,state,task,executor,allocation,null,logger,long,primary,term,cluster,state,meta,data,index,test,primary,term,0,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,arrays,as,list,new,failed,shard,entry,shard,routing,table,shard,id,replica,shard,allocation,id,get,id,primary,term,dummy,null,true,resulting,state,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,size,equal,to,1
InSyncAllocationIdTests -> public void testDeadNodesBeforeReplicaFailed() throws Exception;1539723533;Assume following scenario: indexing request is written to primary, but fails to be replicated to active replica._The primary instructs master to fail replica before acknowledging write to client. In the meanwhile, the node of the replica was_removed from the cluster (deassociateDeadNodes). This means that the ShardRouting of the replica was failed, but it's allocation_id is still part of the in-sync set. We have to make sure that the failShard request from the primary removes the allocation id_from the in-sync set.;public void testDeadNodesBeforeReplicaFailed() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        logger.info("remove replica node")__        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.deassociateDeadNodes(clusterState, true, "reroute")__        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0).size(), equalTo(2))___        logger.info("fail replica (for which there is no shard routing in the CS anymore)")__        assertNull(clusterState.getRoutingNodes().getByAllocationId(replicaShard.shardId(), replicaShard.allocationId().getId()))__        ShardStateAction.ShardFailedClusterStateTaskExecutor failedClusterStateTaskExecutor =_            new ShardStateAction.ShardFailedClusterStateTaskExecutor(allocation, null, logger)__        long primaryTerm = clusterState.metaData().index("test").primaryTerm(0)__        clusterState = failedClusterStateTaskExecutor.execute(clusterState, Arrays.asList(_                new FailedShardEntry(shardRoutingTable.shardId(), replicaShard.allocationId().getId(), primaryTerm, "dummy", null, true))_            ).resultingState___        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0).size(), equalTo(1))__    };assume,following,scenario,indexing,request,is,written,to,primary,but,fails,to,be,replicated,to,active,replica,the,primary,instructs,master,to,fail,replica,before,acknowledging,write,to,client,in,the,meanwhile,the,node,of,the,replica,was,removed,from,the,cluster,deassociate,dead,nodes,this,means,that,the,shard,routing,of,the,replica,was,failed,but,it,s,allocation,id,is,still,part,of,the,in,sync,set,we,have,to,make,sure,that,the,fail,shard,request,from,the,primary,removes,the,allocation,id,from,the,in,sync,set;public,void,test,dead,nodes,before,replica,failed,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,logger,info,remove,replica,node,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,deassociate,dead,nodes,cluster,state,true,reroute,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,size,equal,to,2,logger,info,fail,replica,for,which,there,is,no,shard,routing,in,the,cs,anymore,assert,null,cluster,state,get,routing,nodes,get,by,allocation,id,replica,shard,shard,id,replica,shard,allocation,id,get,id,shard,state,action,shard,failed,cluster,state,task,executor,failed,cluster,state,task,executor,new,shard,state,action,shard,failed,cluster,state,task,executor,allocation,null,logger,long,primary,term,cluster,state,meta,data,index,test,primary,term,0,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,arrays,as,list,new,failed,shard,entry,shard,routing,table,shard,id,replica,shard,allocation,id,get,id,primary,term,dummy,null,true,resulting,state,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,size,equal,to,1
InSyncAllocationIdTests -> public void testDeadNodesBeforeReplicaFailed() throws Exception;1548259585;Assume following scenario: indexing request is written to primary, but fails to be replicated to active replica._The primary instructs master to fail replica before acknowledging write to client. In the meanwhile, the node of the replica was_removed from the cluster (disassociateDeadNodes). This means that the ShardRouting of the replica was failed, but it's allocation_id is still part of the in-sync set. We have to make sure that the failShard request from the primary removes the allocation id_from the in-sync set.;public void testDeadNodesBeforeReplicaFailed() throws Exception {_        ClusterState clusterState = createOnePrimaryOneReplicaClusterState(allocation)___        logger.info("remove replica node")__        IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index("test").shard(0)__        ShardRouting replicaShard = shardRoutingTable.replicaShards().get(0)__        clusterState = ClusterState.builder(clusterState).nodes(DiscoveryNodes.builder(clusterState.nodes())_            .remove(replicaShard.currentNodeId()))_            .build()__        clusterState = allocation.disassociateDeadNodes(clusterState, true, "reroute")__        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0).size(), equalTo(2))___        logger.info("fail replica (for which there is no shard routing in the CS anymore)")__        assertNull(clusterState.getRoutingNodes().getByAllocationId(replicaShard.shardId(), replicaShard.allocationId().getId()))__        ShardStateAction.ShardFailedClusterStateTaskExecutor failedClusterStateTaskExecutor =_            new ShardStateAction.ShardFailedClusterStateTaskExecutor(allocation, null, logger)__        long primaryTerm = clusterState.metaData().index("test").primaryTerm(0)__        clusterState = failedClusterStateTaskExecutor.execute(clusterState, Arrays.asList(_                new FailedShardEntry(shardRoutingTable.shardId(), replicaShard.allocationId().getId(), primaryTerm, "dummy", null, true))_            ).resultingState___        assertThat(clusterState.metaData().index("test").inSyncAllocationIds(0).size(), equalTo(1))__    };assume,following,scenario,indexing,request,is,written,to,primary,but,fails,to,be,replicated,to,active,replica,the,primary,instructs,master,to,fail,replica,before,acknowledging,write,to,client,in,the,meanwhile,the,node,of,the,replica,was,removed,from,the,cluster,disassociate,dead,nodes,this,means,that,the,shard,routing,of,the,replica,was,failed,but,it,s,allocation,id,is,still,part,of,the,in,sync,set,we,have,to,make,sure,that,the,fail,shard,request,from,the,primary,removes,the,allocation,id,from,the,in,sync,set;public,void,test,dead,nodes,before,replica,failed,throws,exception,cluster,state,cluster,state,create,one,primary,one,replica,cluster,state,allocation,logger,info,remove,replica,node,index,shard,routing,table,shard,routing,table,cluster,state,routing,table,index,test,shard,0,shard,routing,replica,shard,shard,routing,table,replica,shards,get,0,cluster,state,cluster,state,builder,cluster,state,nodes,discovery,nodes,builder,cluster,state,nodes,remove,replica,shard,current,node,id,build,cluster,state,allocation,disassociate,dead,nodes,cluster,state,true,reroute,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,size,equal,to,2,logger,info,fail,replica,for,which,there,is,no,shard,routing,in,the,cs,anymore,assert,null,cluster,state,get,routing,nodes,get,by,allocation,id,replica,shard,shard,id,replica,shard,allocation,id,get,id,shard,state,action,shard,failed,cluster,state,task,executor,failed,cluster,state,task,executor,new,shard,state,action,shard,failed,cluster,state,task,executor,allocation,null,logger,long,primary,term,cluster,state,meta,data,index,test,primary,term,0,cluster,state,failed,cluster,state,task,executor,execute,cluster,state,arrays,as,list,new,failed,shard,entry,shard,routing,table,shard,id,replica,shard,allocation,id,get,id,primary,term,dummy,null,true,resulting,state,assert,that,cluster,state,meta,data,index,test,in,sync,allocation,ids,0,size,equal,to,1
