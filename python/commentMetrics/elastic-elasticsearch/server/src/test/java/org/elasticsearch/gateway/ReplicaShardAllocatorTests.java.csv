# id;timestamp;commentText;codeText;commentWords;codeWords
ReplicaShardAllocatorTests -> public void testNoAsyncFetchOnIndexCreation();1524684173;Verifies that on index creation, we don't go and fetch data, but keep the replica shard unassigned to let_the shard allocator to allocate it. There isn't a copy around to find anyhow.;public void testNoAsyncFetchOnIndexCreation() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY, UnassignedInfo.Reason.INDEX_CREATED)__        testAllocator.clean()__        testAllocator.allocateUnassigned(allocation)__        assertThat(testAllocator.getFetchDataCalledAndClean(), equalTo(false))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };verifies,that,on,index,creation,we,don,t,go,and,fetch,data,but,keep,the,replica,shard,unassigned,to,let,the,shard,allocator,to,allocate,it,there,isn,t,a,copy,around,to,find,anyhow;public,void,test,no,async,fetch,on,index,creation,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,settings,empty,unassigned,info,reason,test,allocator,clean,test,allocator,allocate,unassigned,allocation,assert,that,test,allocator,get,fetch,data,called,and,clean,equal,to,false,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoAsyncFetchOnIndexCreation();1540847035;Verifies that on index creation, we don't go and fetch data, but keep the replica shard unassigned to let_the shard allocator to allocate it. There isn't a copy around to find anyhow.;public void testNoAsyncFetchOnIndexCreation() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY,_            UnassignedInfo.Reason.INDEX_CREATED)__        testAllocator.clean()__        testAllocator.allocateUnassigned(allocation)__        assertThat(testAllocator.getFetchDataCalledAndClean(), equalTo(false))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };verifies,that,on,index,creation,we,don,t,go,and,fetch,data,but,keep,the,replica,shard,unassigned,to,let,the,shard,allocator,to,allocate,it,there,isn,t,a,copy,around,to,find,anyhow;public,void,test,no,async,fetch,on,index,creation,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,settings,empty,unassigned,info,reason,test,allocator,clean,test,allocator,allocate,unassigned,allocation,assert,that,test,allocator,get,fetch,data,called,and,clean,equal,to,false,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoAsyncFetchOnIndexCreation();1541092382;Verifies that on index creation, we don't go and fetch data, but keep the replica shard unassigned to let_the shard allocator to allocate it. There isn't a copy around to find anyhow.;public void testNoAsyncFetchOnIndexCreation() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY,_            UnassignedInfo.Reason.INDEX_CREATED)__        testAllocator.clean()__        testAllocator.allocateUnassigned(allocation)__        assertThat(testAllocator.getFetchDataCalledAndClean(), equalTo(false))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };verifies,that,on,index,creation,we,don,t,go,and,fetch,data,but,keep,the,replica,shard,unassigned,to,let,the,shard,allocator,to,allocate,it,there,isn,t,a,copy,around,to,find,anyhow;public,void,test,no,async,fetch,on,index,creation,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,settings,empty,unassigned,info,reason,test,allocator,clean,test,allocator,allocate,unassigned,allocation,assert,that,test,allocator,get,fetch,data,called,and,clean,equal,to,false,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testSyncIdMatch();1524684173;Verifies that when there is a sync id match but no files match, we allocate it to matching node.;public void testSyncIdMatch() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(nodeToMatch, "MATCH", new StoreFileMetaData("file1", 10, "NO_MATCH_CHECKSUM" ,MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(nodeToMatch.getId()))__    };verifies,that,when,there,is,a,sync,id,match,but,no,files,match,we,allocate,it,to,matching,node;public,void,test,sync,id,match,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,discovery,node,node,to,match,random,boolean,node2,node3,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node,to,match,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node,to,match,get,id
ReplicaShardAllocatorTests -> public void testSyncIdMatch();1540847035;Verifies that when there is a sync id match but no files match, we allocate it to matching node.;public void testSyncIdMatch() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(nodeToMatch, "MATCH", new StoreFileMetaData("file1", 10, "NO_MATCH_CHECKSUM" ,MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(nodeToMatch.getId()))__    };verifies,that,when,there,is,a,sync,id,match,but,no,files,match,we,allocate,it,to,matching,node;public,void,test,sync,id,match,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,discovery,node,node,to,match,random,boolean,node2,node3,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node,to,match,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node,to,match,get,id
ReplicaShardAllocatorTests -> public void testSyncIdMatch();1541092382;Verifies that when there is a sync id match but no files match, we allocate it to matching node.;public void testSyncIdMatch() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(nodeToMatch, "MATCH", new StoreFileMetaData("file1", 10, "NO_MATCH_CHECKSUM" ,MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(nodeToMatch.getId()))__    };verifies,that,when,there,is,a,sync,id,match,but,no,files,match,we,allocate,it,to,matching,node;public,void,test,sync,id,match,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,discovery,node,node,to,match,random,boolean,node2,node3,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node,to,match,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node,to,match,get,id
ReplicaShardAllocatorTests -> public void testNoPrimaryData();1524684173;When we can't find primary data, but still find replica data, we go ahead and keep it unassigned_to be allocated. This is today behavior, which relies on a primary corruption identified with_adding a replica and having that replica actually recover and cause the corruption to be identified_See CorruptFileTest#;public void testNoPrimaryData() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.addData(node2, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };when,we,can,t,find,primary,data,but,still,find,replica,data,we,go,ahead,and,keep,it,unassigned,to,be,allocated,this,is,today,behavior,which,relies,on,a,primary,corruption,identified,with,adding,a,replica,and,having,that,replica,actually,recover,and,cause,the,corruption,to,be,identified,see,corrupt,file,test;public,void,test,no,primary,data,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,add,data,node2,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoPrimaryData();1540847035;When we can't find primary data, but still find replica data, we go ahead and keep it unassigned_to be allocated. This is today behavior, which relies on a primary corruption identified with_adding a replica and having that replica actually recover and cause the corruption to be identified_See CorruptFileTest#;public void testNoPrimaryData() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.addData(node2, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };when,we,can,t,find,primary,data,but,still,find,replica,data,we,go,ahead,and,keep,it,unassigned,to,be,allocated,this,is,today,behavior,which,relies,on,a,primary,corruption,identified,with,adding,a,replica,and,having,that,replica,actually,recover,and,cause,the,corruption,to,be,identified,see,corrupt,file,test;public,void,test,no,primary,data,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,add,data,node2,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoPrimaryData();1541092382;When we can't find primary data, but still find replica data, we go ahead and keep it unassigned_to be allocated. This is today behavior, which relies on a primary corruption identified with_adding a replica and having that replica actually recover and cause the corruption to be identified_See CorruptFileTest#;public void testNoPrimaryData() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.addData(node2, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };when,we,can,t,find,primary,data,but,still,find,replica,data,we,go,ahead,and,keep,it,unassigned,to,be,allocated,this,is,today,behavior,which,relies,on,a,primary,corruption,identified,with,adding,a,replica,and,having,that,replica,actually,recover,and,cause,the,corruption,to,be,identified,see,corrupt,file,test;public,void,test,no,primary,data,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,add,data,node2,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testAsyncFetchOnAnythingButIndexCreation();1524684173;Verifies that for anything but index creation, fetch data ends up being called, since we need to go and try_and find a better copy for the shard.;public void testAsyncFetchOnAnythingButIndexCreation() {_        UnassignedInfo.Reason reason = RandomPicks.randomFrom(random(), EnumSet.complementOf(EnumSet.of(UnassignedInfo.Reason.INDEX_CREATED)))__        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY, reason)__        testAllocator.clean()__        testAllocator.allocateUnassigned(allocation)__        assertThat("failed with reason " + reason, testAllocator.getFetchDataCalledAndClean(), equalTo(true))__    };verifies,that,for,anything,but,index,creation,fetch,data,ends,up,being,called,since,we,need,to,go,and,try,and,find,a,better,copy,for,the,shard;public,void,test,async,fetch,on,anything,but,index,creation,unassigned,info,reason,reason,random,picks,random,from,random,enum,set,complement,of,enum,set,of,unassigned,info,reason,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,settings,empty,reason,test,allocator,clean,test,allocator,allocate,unassigned,allocation,assert,that,failed,with,reason,reason,test,allocator,get,fetch,data,called,and,clean,equal,to,true
ReplicaShardAllocatorTests -> public void testAsyncFetchOnAnythingButIndexCreation();1540847035;Verifies that for anything but index creation, fetch data ends up being called, since we need to go and try_and find a better copy for the shard.;public void testAsyncFetchOnAnythingButIndexCreation() {_        UnassignedInfo.Reason reason = RandomPicks.randomFrom(random(),_            EnumSet.complementOf(EnumSet.of(UnassignedInfo.Reason.INDEX_CREATED)))__        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY, reason)__        testAllocator.clean()__        testAllocator.allocateUnassigned(allocation)__        assertThat("failed with reason " + reason, testAllocator.getFetchDataCalledAndClean(), equalTo(true))__    };verifies,that,for,anything,but,index,creation,fetch,data,ends,up,being,called,since,we,need,to,go,and,try,and,find,a,better,copy,for,the,shard;public,void,test,async,fetch,on,anything,but,index,creation,unassigned,info,reason,reason,random,picks,random,from,random,enum,set,complement,of,enum,set,of,unassigned,info,reason,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,settings,empty,reason,test,allocator,clean,test,allocator,allocate,unassigned,allocation,assert,that,failed,with,reason,reason,test,allocator,get,fetch,data,called,and,clean,equal,to,true
ReplicaShardAllocatorTests -> public void testAsyncFetchOnAnythingButIndexCreation();1541092382;Verifies that for anything but index creation, fetch data ends up being called, since we need to go and try_and find a better copy for the shard.;public void testAsyncFetchOnAnythingButIndexCreation() {_        UnassignedInfo.Reason reason = RandomPicks.randomFrom(random(),_            EnumSet.complementOf(EnumSet.of(UnassignedInfo.Reason.INDEX_CREATED)))__        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders(), Settings.EMPTY, reason)__        testAllocator.clean()__        testAllocator.allocateUnassigned(allocation)__        assertThat("failed with reason " + reason, testAllocator.getFetchDataCalledAndClean(), equalTo(true))__    };verifies,that,for,anything,but,index,creation,fetch,data,ends,up,being,called,since,we,need,to,go,and,try,and,find,a,better,copy,for,the,shard;public,void,test,async,fetch,on,anything,but,index,creation,unassigned,info,reason,reason,random,picks,random,from,random,enum,set,complement,of,enum,set,of,unassigned,info,reason,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,settings,empty,reason,test,allocator,clean,test,allocator,allocate,unassigned,allocation,assert,that,failed,with,reason,reason,test,allocator,get,fetch,data,called,and,clean,equal,to,true
ReplicaShardAllocatorTests -> public void testFileChecksumMatch();1524684173;Verifies that when there is no sync id match but files match, we allocate it to matching node.;public void testFileChecksumMatch() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(nodeToMatch, "NO_MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(nodeToMatch.getId()))__    };verifies,that,when,there,is,no,sync,id,match,but,files,match,we,allocate,it,to,matching,node;public,void,test,file,checksum,match,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,discovery,node,node,to,match,random,boolean,node2,node3,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node,to,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node,to,match,get,id
ReplicaShardAllocatorTests -> public void testFileChecksumMatch();1540847035;Verifies that when there is no sync id match but files match, we allocate it to matching node.;public void testFileChecksumMatch() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(nodeToMatch, "NO_MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(nodeToMatch.getId()))__    };verifies,that,when,there,is,no,sync,id,match,but,files,match,we,allocate,it,to,matching,node;public,void,test,file,checksum,match,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,discovery,node,node,to,match,random,boolean,node2,node3,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node,to,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node,to,match,get,id
ReplicaShardAllocatorTests -> public void testFileChecksumMatch();1541092382;Verifies that when there is no sync id match but files match, we allocate it to matching node.;public void testFileChecksumMatch() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(nodeToMatch, "NO_MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(nodeToMatch.getId()))__    };verifies,that,when,there,is,no,sync,id,match,but,files,match,we,allocate,it,to,matching,node;public,void,test,file,checksum,match,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,discovery,node,node,to,match,random,boolean,node2,node3,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node,to,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node,to,match,get,id
ReplicaShardAllocatorTests -> public void testNoAsyncFetchData();1524684173;Verifies that when we are still fetching data in an async manner, the replica shard moves to ignore unassigned.;public void testNoAsyncFetchData() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.clean()__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__    };verifies,that,when,we,are,still,fetching,data,in,an,async,manner,the,replica,shard,moves,to,ignore,unassigned;public,void,test,no,async,fetch,data,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,clean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoAsyncFetchData();1540847035;Verifies that when we are still fetching data in an async manner, the replica shard moves to ignore unassigned.;public void testNoAsyncFetchData() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.clean()__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__    };verifies,that,when,we,are,still,fetching,data,in,an,async,manner,the,replica,shard,moves,to,ignore,unassigned;public,void,test,no,async,fetch,data,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,clean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoAsyncFetchData();1541092382;Verifies that when we are still fetching data in an async manner, the replica shard moves to ignore unassigned.;public void testNoAsyncFetchData() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.clean()__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__    };verifies,that,when,we,are,still,fetching,data,in,an,async,manner,the,replica,shard,moves,to,ignore,unassigned;public,void,test,no,async,fetch,data,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,clean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testSimpleFullMatchAllocation();1524684173;Verifies that when there is a full match (syncId and files) we allocate it to matching node.;public void testSimpleFullMatchAllocation() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(nodeToMatch, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(nodeToMatch.getId()))__    };verifies,that,when,there,is,a,full,match,sync,id,and,files,we,allocate,it,to,matching,node;public,void,test,simple,full,match,allocation,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,discovery,node,node,to,match,random,boolean,node2,node3,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node,to,match,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node,to,match,get,id
ReplicaShardAllocatorTests -> public void testSimpleFullMatchAllocation();1540847035;Verifies that when there is a full match (syncId and files) we allocate it to matching node.;public void testSimpleFullMatchAllocation() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(nodeToMatch, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(nodeToMatch.getId()))__    };verifies,that,when,there,is,a,full,match,sync,id,and,files,we,allocate,it,to,matching,node;public,void,test,simple,full,match,allocation,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,discovery,node,node,to,match,random,boolean,node2,node3,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node,to,match,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node,to,match,get,id
ReplicaShardAllocatorTests -> public void testSimpleFullMatchAllocation();1541092382;Verifies that when there is a full match (syncId and files) we allocate it to matching node.;public void testSimpleFullMatchAllocation() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        DiscoveryNode nodeToMatch = randomBoolean() ? node2 : node3__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(nodeToMatch, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(nodeToMatch.getId()))__    };verifies,that,when,there,is,a,full,match,sync,id,and,files,we,allocate,it,to,matching,node;public,void,test,simple,full,match,allocation,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,discovery,node,node,to,match,random,boolean,node2,node3,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node,to,match,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node,to,match,get,id
ReplicaShardAllocatorTests -> public void testNoOrThrottleDecidersRemainsInUnassigned();1524684173;When there is no decision or throttle decision across all nodes for the shard, make sure the shard_moves to the ignore unassigned list.;public void testNoOrThrottleDecidersRemainsInUnassigned() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(randomBoolean() ? noAllocationDeciders() : throttleAllocationDeciders())__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(node2, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__    };when,there,is,no,decision,or,throttle,decision,across,all,nodes,for,the,shard,make,sure,the,shard,moves,to,the,ignore,unassigned,list;public,void,test,no,or,throttle,deciders,remains,in,unassigned,routing,allocation,allocation,one,primary,on,node1and1replica,random,boolean,no,allocation,deciders,throttle,allocation,deciders,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node2,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoOrThrottleDecidersRemainsInUnassigned();1540847035;When there is no decision or throttle decision across all nodes for the shard, make sure the shard_moves to the ignore unassigned list.;public void testNoOrThrottleDecidersRemainsInUnassigned() {_        RoutingAllocation allocation =_            onePrimaryOnNode1And1Replica(randomBoolean() ? noAllocationDeciders() : throttleAllocationDeciders())__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(node2, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__    };when,there,is,no,decision,or,throttle,decision,across,all,nodes,for,the,shard,make,sure,the,shard,moves,to,the,ignore,unassigned,list;public,void,test,no,or,throttle,deciders,remains,in,unassigned,routing,allocation,allocation,one,primary,on,node1and1replica,random,boolean,no,allocation,deciders,throttle,allocation,deciders,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node2,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoOrThrottleDecidersRemainsInUnassigned();1541092382;When there is no decision or throttle decision across all nodes for the shard, make sure the shard_moves to the ignore unassigned list.;public void testNoOrThrottleDecidersRemainsInUnassigned() {_        RoutingAllocation allocation =_            onePrimaryOnNode1And1Replica(randomBoolean() ? noAllocationDeciders() : throttleAllocationDeciders())__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(node2, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__    };when,there,is,no,decision,or,throttle,decision,across,all,nodes,for,the,shard,make,sure,the,shard,moves,to,the,ignore,unassigned,list;public,void,test,no,or,throttle,deciders,remains,in,unassigned,routing,allocation,allocation,one,primary,on,node1and1replica,random,boolean,no,allocation,deciders,throttle,allocation,deciders,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node2,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoMatchingFilesForReplicaOnAnyNode();1524684173;Verifies that when there is primary data, but no matching data at all on other nodes, the shard keeps_unassigned to be allocated later on.;public void testNoMatchingFilesForReplicaOnAnyNode() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(node2, "NO_MATCH", new StoreFileMetaData("file1", 10, "NO_MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };verifies,that,when,there,is,primary,data,but,no,matching,data,at,all,on,other,nodes,the,shard,keeps,unassigned,to,be,allocated,later,on;public,void,test,no,matching,files,for,replica,on,any,node,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node2,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoMatchingFilesForReplicaOnAnyNode();1540847035;Verifies that when there is primary data, but no matching data at all on other nodes, the shard keeps_unassigned to be allocated later on.;public void testNoMatchingFilesForReplicaOnAnyNode() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(node2, "NO_MATCH", new StoreFileMetaData("file1", 10, "NO_MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };verifies,that,when,there,is,primary,data,but,no,matching,data,at,all,on,other,nodes,the,shard,keeps,unassigned,to,be,allocated,later,on;public,void,test,no,matching,files,for,replica,on,any,node,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node2,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoMatchingFilesForReplicaOnAnyNode();1541092382;Verifies that when there is primary data, but no matching data at all on other nodes, the shard keeps_unassigned to be allocated later on.;public void testNoMatchingFilesForReplicaOnAnyNode() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(node2, "NO_MATCH", new StoreFileMetaData("file1", 10, "NO_MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };verifies,that,when,there,is,primary,data,but,no,matching,data,at,all,on,other,nodes,the,shard,keeps,unassigned,to,be,allocated,later,on;public,void,test,no,matching,files,for,replica,on,any,node,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node2,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testThrottleWhenAllocatingToMatchingNode();1524684173;Tests when the node to allocate to due to matching is being throttled, we move the shard to ignored_to wait till throttling on it is done.;public void testThrottleWhenAllocatingToMatchingNode() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(Settings.EMPTY,_            Arrays.asList(new TestAllocateDecision(Decision.YES),_                new SameShardAllocationDecider(_                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),_                new AllocationDecider(Settings.EMPTY) {_                    @Override_                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {_                        if (node.node().equals(node2)) {_                            return Decision.THROTTLE__                        }_                        return Decision.YES__                    }_                })))__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(node2, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__    };tests,when,the,node,to,allocate,to,due,to,matching,is,being,throttled,we,move,the,shard,to,ignored,to,wait,till,throttling,on,it,is,done;public,void,test,throttle,when,allocating,to,matching,node,routing,allocation,allocation,one,primary,on,node1and1replica,new,allocation,deciders,settings,empty,arrays,as,list,new,test,allocate,decision,decision,yes,new,same,shard,allocation,decider,settings,empty,new,cluster,settings,settings,empty,cluster,settings,new,allocation,decider,settings,empty,override,public,decision,can,allocate,shard,routing,shard,routing,routing,node,node,routing,allocation,allocation,if,node,node,equals,node2,return,decision,throttle,return,decision,yes,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node2,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testThrottleWhenAllocatingToMatchingNode();1540847035;Tests when the node to allocate to due to matching is being throttled, we move the shard to ignored_to wait till throttling on it is done.;public void testThrottleWhenAllocatingToMatchingNode() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(Settings.EMPTY,_            Arrays.asList(new TestAllocateDecision(Decision.YES),_                new SameShardAllocationDecider(_                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),_                new AllocationDecider(Settings.EMPTY) {_                    @Override_                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {_                        if (node.node().equals(node2)) {_                            return Decision.THROTTLE__                        }_                        return Decision.YES__                    }_                })))__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(node2, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__    };tests,when,the,node,to,allocate,to,due,to,matching,is,being,throttled,we,move,the,shard,to,ignored,to,wait,till,throttling,on,it,is,done;public,void,test,throttle,when,allocating,to,matching,node,routing,allocation,allocation,one,primary,on,node1and1replica,new,allocation,deciders,settings,empty,arrays,as,list,new,test,allocate,decision,decision,yes,new,same,shard,allocation,decider,settings,empty,new,cluster,settings,settings,empty,cluster,settings,new,allocation,decider,settings,empty,override,public,decision,can,allocate,shard,routing,shard,routing,routing,node,node,routing,allocation,allocation,if,node,node,equals,node2,return,decision,throttle,return,decision,yes,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node2,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testThrottleWhenAllocatingToMatchingNode();1541092382;Tests when the node to allocate to due to matching is being throttled, we move the shard to ignored_to wait till throttling on it is done.;public void testThrottleWhenAllocatingToMatchingNode() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(new AllocationDeciders(_            Arrays.asList(new TestAllocateDecision(Decision.YES),_                new SameShardAllocationDecider(_                    Settings.EMPTY, new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS)),_                new AllocationDecider() {_                    @Override_                    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {_                        if (node.node().equals(node2)) {_                            return Decision.THROTTLE__                        }_                        return Decision.YES__                    }_                })))__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))_                .addData(node2, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__    };tests,when,the,node,to,allocate,to,due,to,matching,is,being,throttled,we,move,the,shard,to,ignored,to,wait,till,throttling,on,it,is,done;public,void,test,throttle,when,allocating,to,matching,node,routing,allocation,allocation,one,primary,on,node1and1replica,new,allocation,deciders,arrays,as,list,new,test,allocate,decision,decision,yes,new,same,shard,allocation,decider,settings,empty,new,cluster,settings,settings,empty,cluster,settings,new,allocation,decider,override,public,decision,can,allocate,shard,routing,shard,routing,routing,node,node,routing,allocation,allocation,if,node,node,equals,node2,return,decision,throttle,return,decision,yes,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,add,data,node2,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoDataForReplicaOnAnyNode();1524684173;Verifies that when there is primary data, but no data at all on other nodes, the shard keeps_unassigned to be allocated later on.;public void testNoDataForReplicaOnAnyNode() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };verifies,that,when,there,is,primary,data,but,no,data,at,all,on,other,nodes,the,shard,keeps,unassigned,to,be,allocated,later,on;public,void,test,no,data,for,replica,on,any,node,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoDataForReplicaOnAnyNode();1540847035;Verifies that when there is primary data, but no data at all on other nodes, the shard keeps_unassigned to be allocated later on.;public void testNoDataForReplicaOnAnyNode() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };verifies,that,when,there,is,primary,data,but,no,data,at,all,on,other,nodes,the,shard,keeps,unassigned,to,be,allocated,later,on;public,void,test,no,data,for,replica,on,any,node,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
ReplicaShardAllocatorTests -> public void testNoDataForReplicaOnAnyNode();1541092382;Verifies that when there is primary data, but no data at all on other nodes, the shard keeps_unassigned to be allocated later on.;public void testNoDataForReplicaOnAnyNode() {_        RoutingAllocation allocation = onePrimaryOnNode1And1Replica(yesAllocationDeciders())__        testAllocator.addData(node1, "MATCH", new StoreFileMetaData("file1", 10, "MATCH_CHECKSUM", MIN_SUPPORTED_LUCENE_VERSION))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.UNASSIGNED).get(0).shardId(), equalTo(shardId))__    };verifies,that,when,there,is,primary,data,but,no,data,at,all,on,other,nodes,the,shard,keeps,unassigned,to,be,allocated,later,on;public,void,test,no,data,for,replica,on,any,node,routing,allocation,allocation,one,primary,on,node1and1replica,yes,allocation,deciders,test,allocator,add,data,node1,match,new,store,file,meta,data,file1,10,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,unassigned,get,0,shard,id,equal,to,shard,id
