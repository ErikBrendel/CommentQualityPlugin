commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;15;;@Override protected PersistentTasksCustomMetaData createTestInstance() {     int numberOfTasks = randomInt(10).     PersistentTasksCustomMetaData.Builder tasks = PersistentTasksCustomMetaData.builder().     for (int i = 0. i < numberOfTasks. i++) {         String taskId = UUIDs.base64UUID().         tasks.addTask(taskId, TestPersistentTasksExecutor.NAME, new TestParams(randomAlphaOfLength(10)), randomAssignment()).         if (randomBoolean()) {             // From time to time update status             tasks.updateTaskState(taskId, new State(randomAlphaOfLength(10))).         }     }     return tasks.build(). }
false;protected;0;4;;@Override protected Writeable.Reader<Custom> instanceReader() {     return PersistentTasksCustomMetaData::new. }
false;protected;0;9;;@Override protected NamedWriteableRegistry getNamedWriteableRegistry() {     return new NamedWriteableRegistry(Arrays.asList(new Entry(MetaData.Custom.class, PersistentTasksCustomMetaData.TYPE, PersistentTasksCustomMetaData::new), new Entry(NamedDiff.class, PersistentTasksCustomMetaData.TYPE, PersistentTasksCustomMetaData::readDiffFrom), new Entry(PersistentTaskParams.class, TestPersistentTasksExecutor.NAME, TestParams::new), new Entry(PersistentTaskState.class, TestPersistentTasksExecutor.NAME, State::new))). }
false;protected;1;31;;@Override protected Custom makeTestChanges(Custom testInstance) {     Builder builder = PersistentTasksCustomMetaData.builder((PersistentTasksCustomMetaData) testInstance).     switch(randomInt(3)) {         case 0:             addRandomTask(builder).             break.         case 1:             if (builder.getCurrentTaskIds().isEmpty()) {                 addRandomTask(builder).             } else {                 builder.reassignTask(pickRandomTask(builder), randomAssignment()).             }             break.         case 2:             if (builder.getCurrentTaskIds().isEmpty()) {                 addRandomTask(builder).             } else {                 builder.updateTaskState(pickRandomTask(builder), randomBoolean() ? new State(randomAlphaOfLength(10)) : null).             }             break.         case 3:             if (builder.getCurrentTaskIds().isEmpty()) {                 addRandomTask(builder).             } else {                 builder.removeTask(pickRandomTask(builder)).             }             break.     }     return builder.build(). }
false;protected;0;4;;@Override protected Writeable.Reader<Diff<Custom>> diffReader() {     return PersistentTasksCustomMetaData::readDiffFrom. }
false;protected;1;4;;@Override protected PersistentTasksCustomMetaData doParseInstance(XContentParser parser) {     return PersistentTasksCustomMetaData.fromXContent(parser). }
false;private;1;5;;private String addRandomTask(Builder builder) {     String taskId = UUIDs.base64UUID().     builder.addTask(taskId, TestPersistentTasksExecutor.NAME, new TestParams(randomAlphaOfLength(10)), randomAssignment()).     return taskId. }
false;private;1;3;;private String pickRandomTask(PersistentTasksCustomMetaData.Builder testInstance) {     return randomFrom(new ArrayList<>(testInstance.getCurrentTaskIds())). }
false;protected;0;9;;@Override protected NamedXContentRegistry xContentRegistry() {     return new NamedXContentRegistry(Arrays.asList(new NamedXContentRegistry.Entry(PersistentTaskParams.class, new ParseField(TestPersistentTasksExecutor.NAME), TestParams::fromXContent), new NamedXContentRegistry.Entry(PersistentTaskState.class, new ParseField(TestPersistentTasksExecutor.NAME), State::fromXContent))). }
false;public;0;35;;@SuppressWarnings("unchecked") public void testSerializationContext() throws Exception {     PersistentTasksCustomMetaData testInstance = createTestInstance().     for (int i = 0. i < randomInt(10). i++) {         testInstance = (PersistentTasksCustomMetaData) makeTestChanges(testInstance).     }     ToXContent.MapParams params = new ToXContent.MapParams(Collections.singletonMap(MetaData.CONTEXT_MODE_PARAM, randomFrom(CONTEXT_MODE_SNAPSHOT, CONTEXT_MODE_GATEWAY))).     XContentType xContentType = randomFrom(XContentType.values()).     BytesReference shuffled = toShuffledXContent(testInstance, xContentType, params, false).     PersistentTasksCustomMetaData newInstance.     try (XContentParser parser = createParser(XContentFactory.xContent(xContentType), shuffled)) {         newInstance = doParseInstance(parser).     }     assertNotSame(newInstance, testInstance).     assertEquals(testInstance.tasks().size(), newInstance.tasks().size()).     for (PersistentTask<?> testTask : testInstance.tasks()) {         PersistentTask<TestParams> newTask = (PersistentTask<TestParams>) newInstance.getTask(testTask.getId()).         assertNotNull(newTask).         // Things that should be serialized         assertEquals(testTask.getTaskName(), newTask.getTaskName()).         assertEquals(testTask.getId(), newTask.getId()).         assertEquals(testTask.getState(), newTask.getState()).         assertEquals(testTask.getParams(), newTask.getParams()).         // Things that shouldn't be serialized         assertEquals(0, newTask.getAllocationId()).         assertNull(newTask.getExecutorNode()).     } }
false;public;0;50;;public void testBuilder() {     PersistentTasksCustomMetaData persistentTasks = null.     String lastKnownTask = "".     for (int i = 0. i < randomIntBetween(10, 100). i++) {         final Builder builder.         if (randomBoolean()) {             builder = PersistentTasksCustomMetaData.builder().         } else {             builder = PersistentTasksCustomMetaData.builder(persistentTasks).         }         boolean changed = false.         for (int j = 0. j < randomIntBetween(1, 10). j++) {             switch(randomInt(3)) {                 case 0:                     lastKnownTask = addRandomTask(builder).                     changed = true.                     break.                 case 1:                     if (builder.hasTask(lastKnownTask)) {                         changed = true.                         builder.reassignTask(lastKnownTask, randomAssignment()).                     } else {                         String fLastKnownTask = lastKnownTask.                         expectThrows(ResourceNotFoundException.class, () -> builder.reassignTask(fLastKnownTask, randomAssignment())).                     }                     break.                 case 2:                     if (builder.hasTask(lastKnownTask)) {                         changed = true.                         builder.updateTaskState(lastKnownTask, randomBoolean() ? new State(randomAlphaOfLength(10)) : null).                     } else {                         String fLastKnownTask = lastKnownTask.                         expectThrows(ResourceNotFoundException.class, () -> builder.updateTaskState(fLastKnownTask, null)).                     }                     break.                 case 3:                     if (builder.hasTask(lastKnownTask)) {                         changed = true.                         builder.removeTask(lastKnownTask).                     } else {                         String fLastKnownTask = lastKnownTask.                         expectThrows(ResourceNotFoundException.class, () -> builder.removeTask(fLastKnownTask)).                     }                     break.             }         }         assertEquals(changed, builder.isChanged()).         persistentTasks = builder.build().     } }
false;public;0;34;;public void testMinVersionSerialization() throws IOException {     PersistentTasksCustomMetaData.Builder tasks = PersistentTasksCustomMetaData.builder().     Version minVersion = allReleasedVersions().stream().filter(Version::isRelease).findFirst().orElseThrow(NoSuchElementException::new).     final Version streamVersion = randomVersionBetween(random(), minVersion, getPreviousVersion(Version.CURRENT)).     tasks.addTask("test_compatible_version", TestPersistentTasksExecutor.NAME, new TestParams(null, randomVersionBetween(random(), minVersion, streamVersion), randomBoolean() ? Optional.empty() : Optional.of("test")), randomAssignment()).     tasks.addTask("test_incompatible_version", TestPersistentTasksExecutor.NAME, new TestParams(null, randomVersionBetween(random(), compatibleFutureVersion(streamVersion), Version.CURRENT), randomBoolean() ? Optional.empty() : Optional.of("test")), randomAssignment()).     final BytesStreamOutput out = new BytesStreamOutput().     out.setVersion(streamVersion).     Set<String> features = new HashSet<>().     final boolean transportClient = randomBoolean().     if (transportClient) {         features.add(TransportClient.TRANSPORT_CLIENT_FEATURE).     }     // if a transport client, then it must have the feature otherwise we add the feature randomly     if (transportClient || randomBoolean()) {         features.add("test").     }     out.setFeatures(features).     tasks.build().writeTo(out).     final StreamInput input = out.bytes().streamInput().     input.setVersion(streamVersion).     PersistentTasksCustomMetaData read = new PersistentTasksCustomMetaData(new NamedWriteableAwareStreamInput(input, getNamedWriteableRegistry())).     assertThat(read.taskMap().keySet(), equalTo(Collections.singleton("test_compatible_version"))). }
false;public;0;23;;public void testFeatureSerialization() throws IOException {     PersistentTasksCustomMetaData.Builder tasks = PersistentTasksCustomMetaData.builder().     Version minVersion = getFirstVersion().     tasks.addTask("test_compatible", TestPersistentTasksExecutor.NAME, new TestParams(null, randomVersionBetween(random(), minVersion, Version.CURRENT), randomBoolean() ? Optional.empty() : Optional.of("existing")), randomAssignment()).     tasks.addTask("test_incompatible", TestPersistentTasksExecutor.NAME, new TestParams(null, randomVersionBetween(random(), minVersion, Version.CURRENT), Optional.of("non_existing")), randomAssignment()).     final BytesStreamOutput out = new BytesStreamOutput().     out.setVersion(Version.CURRENT).     Set<String> features = new HashSet<>().     features.add("existing").     features.add(TransportClient.TRANSPORT_CLIENT_FEATURE).     out.setFeatures(features).     tasks.build().writeTo(out).     PersistentTasksCustomMetaData read = new PersistentTasksCustomMetaData(new NamedWriteableAwareStreamInput(out.bytes().streamInput(), getNamedWriteableRegistry())).     assertThat(read.taskMap().keySet(), equalTo(Collections.singleton("test_compatible"))). }
false;public;0;5;;public void testDisassociateDeadNodes_givenNoPersistentTasks() {     ClusterState originalState = ClusterState.builder(new ClusterName("persistent-tasks-tests")).build().     ClusterState returnedState = PersistentTasksCustomMetaData.disassociateDeadNodes(originalState).     assertThat(originalState, sameInstance(returnedState)). }
false;public;0;23;;public void testDisassociateDeadNodes_givenAssignedPersistentTask() {     DiscoveryNodes nodes = DiscoveryNodes.builder().add(new DiscoveryNode("node1", buildNewFakeTransportAddress(), Version.CURRENT)).localNodeId("node1").masterNodeId("node1").build().     String taskName = "test/task".     PersistentTasksCustomMetaData.Builder tasksBuilder = PersistentTasksCustomMetaData.builder().addTask("task-id", taskName, emptyTaskParams(taskName), new PersistentTasksCustomMetaData.Assignment("node1", "test assignment")).     ClusterState originalState = ClusterState.builder(new ClusterName("persistent-tasks-tests")).nodes(nodes).metaData(MetaData.builder().putCustom(PersistentTasksCustomMetaData.TYPE, tasksBuilder.build())).build().     ClusterState returnedState = PersistentTasksCustomMetaData.disassociateDeadNodes(originalState).     assertThat(originalState, sameInstance(returnedState)).     PersistentTasksCustomMetaData originalTasks = PersistentTasksCustomMetaData.getPersistentTasksCustomMetaData(originalState).     PersistentTasksCustomMetaData returnedTasks = PersistentTasksCustomMetaData.getPersistentTasksCustomMetaData(returnedState).     assertEquals(originalTasks, returnedTasks). }
false;public;0;29;;public void testDisassociateDeadNodes() {     DiscoveryNodes nodes = DiscoveryNodes.builder().add(new DiscoveryNode("node1", buildNewFakeTransportAddress(), Version.CURRENT)).localNodeId("node1").masterNodeId("node1").build().     String taskName = "test/task".     PersistentTasksCustomMetaData.Builder tasksBuilder = PersistentTasksCustomMetaData.builder().addTask("assigned-task", taskName, emptyTaskParams(taskName), new PersistentTasksCustomMetaData.Assignment("node1", "test assignment")).addTask("task-on-deceased-node", taskName, emptyTaskParams(taskName), new PersistentTasksCustomMetaData.Assignment("left-the-cluster", "test assignment")).     ClusterState originalState = ClusterState.builder(new ClusterName("persistent-tasks-tests")).nodes(nodes).metaData(MetaData.builder().putCustom(PersistentTasksCustomMetaData.TYPE, tasksBuilder.build())).build().     ClusterState returnedState = PersistentTasksCustomMetaData.disassociateDeadNodes(originalState).     assertThat(originalState, not(sameInstance(returnedState))).     PersistentTasksCustomMetaData originalTasks = PersistentTasksCustomMetaData.getPersistentTasksCustomMetaData(originalState).     PersistentTasksCustomMetaData returnedTasks = PersistentTasksCustomMetaData.getPersistentTasksCustomMetaData(returnedState).     assertNotEquals(originalTasks, returnedTasks).     assertEquals(originalTasks.getTask("assigned-task"), returnedTasks.getTask("assigned-task")).     assertNotEquals(originalTasks.getTask("task-on-deceased-node"), returnedTasks.getTask("task-on-deceased-node")).     assertEquals(PersistentTasksCustomMetaData.LOST_NODE_ASSIGNMENT, returnedTasks.getTask("task-on-deceased-node").getAssignment()). }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) {     return builder. }
false;public;1;4;;@Override public void writeTo(StreamOutput out) { }
false;public;0;4;;@Override public String getWriteableName() {     return taskName. }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return Version.CURRENT. }
false;private;1;24;;private PersistentTaskParams emptyTaskParams(String taskName) {     return new PersistentTaskParams() {          @Override         public XContentBuilder toXContent(XContentBuilder builder, Params params) {             return builder.         }          @Override         public void writeTo(StreamOutput out) {         }          @Override         public String getWriteableName() {             return taskName.         }          @Override         public Version getMinimalSupportedVersion() {             return Version.CURRENT.         }     }. }
false;private;0;10;;private Assignment randomAssignment() {     if (randomBoolean()) {         if (randomBoolean()) {             return NO_NODE_FOUND.         } else {             return new Assignment(null, randomAlphaOfLength(10)).         }     }     return new Assignment(randomAlphaOfLength(10), randomAlphaOfLength(10)). }
