commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void beforeClass() {     threadPool = new TestThreadPool(getTestClass().getName()). }
false;public;0;27;;@Override @Before public void setUp() throws Exception {     super.setUp().     indexShard = mock(IndexShard.class).     when(indexShard.getActiveOperationsCount()).thenReturn(0).     final ShardId shardId = new ShardId("index", "_na_", randomIntBetween(0, 3)).     when(indexShard.shardId()).thenReturn(shardId).     clusterService = createClusterService(threadPool).     clusterBlock = MetaDataIndexStateService.createIndexClosingBlock().     setState(clusterService, new ClusterState.Builder(clusterService.state()).blocks(ClusterBlocks.builder().blocks(clusterService.state().blocks()).addIndexBlock("index", clusterBlock).build()).build()).     transport = new CapturingTransport().     TransportService transportService = transport.createTransportService(Settings.EMPTY, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, x -> clusterService.localNode(), null, Collections.emptySet()).     transportService.start().     transportService.acceptIncomingRequests().     ShardStateAction shardStateAction = new ShardStateAction(clusterService, transportService, null, null, threadPool).     action = new TransportVerifyShardBeforeCloseAction(Settings.EMPTY, transportService, clusterService, mock(IndicesService.class), mock(ThreadPool.class), shardStateAction, mock(ActionFilters.class), mock(IndexNameExpressionResolver.class)). }
false;public;0;6;;@Override @After public void tearDown() throws Exception {     super.tearDown().     clusterService.close(). }
false;public,static;0;5;;@AfterClass public static void afterClass() {     ThreadPool.terminate(threadPool, 30, TimeUnit.SECONDS).     threadPool = null. }
false;private;0;10;;private void executeOnPrimaryOrReplica() throws Exception {     final TaskId taskId = new TaskId("_node_id", randomNonNegativeLong()).     final TransportVerifyShardBeforeCloseAction.ShardRequest request = new TransportVerifyShardBeforeCloseAction.ShardRequest(indexShard.shardId(), clusterBlock, taskId).     if (randomBoolean()) {         assertNotNull(action.shardOperationOnPrimary(request, indexShard)).     } else {         assertNotNull(action.shardOperationOnPrimary(request, indexShard)).     } }
false;public;0;8;;public void testShardIsFlushed() throws Exception {     final ArgumentCaptor<FlushRequest> flushRequest = ArgumentCaptor.forClass(FlushRequest.class).     when(indexShard.flush(flushRequest.capture())).thenReturn(new Engine.CommitId(new byte[0])).     executeOnPrimaryOrReplica().     verify(indexShard, times(1)).flush(any(FlushRequest.class)).     assertThat(flushRequest.getValue().force(), is(true)). }
false;public;0;8;;public void testOperationFailsWithOnGoingOps() {     when(indexShard.getActiveOperationsCount()).thenReturn(randomIntBetween(1, 10)).     IllegalStateException exception = expectThrows(IllegalStateException.class, this::executeOnPrimaryOrReplica).     assertThat(exception.getMessage(), equalTo("On-going operations in progress while checking index shard " + indexShard.shardId() + " before closing")).     verify(indexShard, times(0)).flush(any(FlushRequest.class)). }
false;public;0;8;;public void testOperationFailsWithNoBlock() {     setState(clusterService, new ClusterState.Builder(new ClusterName("test")).build()).     IllegalStateException exception = expectThrows(IllegalStateException.class, this::executeOnPrimaryOrReplica).     assertThat(exception.getMessage(), equalTo("Index shard " + indexShard.shardId() + " must be blocked by " + clusterBlock + " before closing")).     verify(indexShard, times(0)).flush(any(FlushRequest.class)). }
false;public;0;5;;public void testVerifyShardBeforeIndexClosing() throws Exception {     executeOnPrimaryOrReplica().     verify(indexShard, times(1)).verifyShardBeforeIndexClosing().     verify(indexShard, times(1)).flush(any(FlushRequest.class)). }
false;public;0;6;;public void testVerifyShardBeforeIndexClosingFailed() {     doThrow(new IllegalStateException("test")).when(indexShard).verifyShardBeforeIndexClosing().     expectThrows(IllegalStateException.class, this::executeOnPrimaryOrReplica).     verify(indexShard, times(1)).verifyShardBeforeIndexClosing().     verify(indexShard, times(0)).flush(any(FlushRequest.class)). }
false;public;0;66;;public void testUnavailableShardsMarkedAsStale() throws Exception {     final String index = "test".     final ShardId shardId = new ShardId(index, "_na_", 0).     final int nbReplicas = randomIntBetween(1, 10).     final ShardRoutingState[] replicaStates = new ShardRoutingState[nbReplicas].     for (int i = 0. i < replicaStates.length. i++) {         replicaStates[i] = ShardRoutingState.STARTED.     }     final ClusterState clusterState = state(index, true, ShardRoutingState.STARTED, replicaStates).     setState(clusterService, clusterState).     IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().index(index).shard(shardId.id()).     final IndexMetaData indexMetaData = clusterState.getMetaData().index(index).     final ShardRouting primaryRouting = shardRoutingTable.primaryShard().     final long primaryTerm = indexMetaData.primaryTerm(0).     final Set<String> inSyncAllocationIds = indexMetaData.inSyncAllocationIds(0).     final Set<String> trackedShards = shardRoutingTable.getAllAllocationIds().     List<ShardRouting> unavailableShards = randomSubsetOf(randomIntBetween(1, nbReplicas), shardRoutingTable.replicaShards()).     IndexShardRoutingTable.Builder shardRoutingTableBuilder = new IndexShardRoutingTable.Builder(shardRoutingTable).     unavailableShards.forEach(shardRoutingTableBuilder::removeShard).     shardRoutingTable = shardRoutingTableBuilder.build().     final ReplicationGroup replicationGroup = new ReplicationGroup(shardRoutingTable, inSyncAllocationIds, trackedShards).     assertThat(replicationGroup.getUnavailableInSyncShards().size(), greaterThan(0)).     final PlainActionFuture<PrimaryResult> listener = new PlainActionFuture<>().     TaskId taskId = new TaskId(clusterService.localNode().getId(), 0L).     TransportVerifyShardBeforeCloseAction.ShardRequest request = new TransportVerifyShardBeforeCloseAction.ShardRequest(shardId, clusterBlock, taskId).     ReplicationOperation.Replicas<TransportVerifyShardBeforeCloseAction.ShardRequest> proxy = action.newReplicasProxy(primaryTerm).     ReplicationOperation<TransportVerifyShardBeforeCloseAction.ShardRequest, TransportVerifyShardBeforeCloseAction.ShardRequest, PrimaryResult> operation = new ReplicationOperation<>(request, createPrimary(primaryRouting, replicationGroup), listener, proxy, logger, "test").     operation.execute().     final CapturingTransport.CapturedRequest[] capturedRequests = transport.getCapturedRequestsAndClear().     assertThat(capturedRequests.length, equalTo(nbReplicas)).     for (CapturingTransport.CapturedRequest capturedRequest : capturedRequests) {         final String actionName = capturedRequest.action.         if (actionName.startsWith(ShardStateAction.SHARD_FAILED_ACTION_NAME)) {             assertThat(capturedRequest.request, instanceOf(ShardStateAction.FailedShardEntry.class)).             String allocationId = ((ShardStateAction.FailedShardEntry) capturedRequest.request).getAllocationId().             assertTrue(unavailableShards.stream().anyMatch(shardRouting -> shardRouting.allocationId().getId().equals(allocationId))).             transport.handleResponse(capturedRequest.requestId, TransportResponse.Empty.INSTANCE).         } else if (actionName.startsWith(TransportVerifyShardBeforeCloseAction.NAME)) {             assertThat(capturedRequest.request, instanceOf(ConcreteShardRequest.class)).             String allocationId = ((ConcreteShardRequest) capturedRequest.request).getTargetAllocationID().             assertFalse(unavailableShards.stream().anyMatch(shardRouting -> shardRouting.allocationId().getId().equals(allocationId))).             assertTrue(inSyncAllocationIds.stream().anyMatch(inSyncAllocationId -> inSyncAllocationId.equals(allocationId))).             transport.handleResponse(capturedRequest.requestId, new TransportReplicationAction.ReplicaResponse(0L, 0L)).         } else {             fail("Test does not support action " + capturedRequest.action).         }     }     final ReplicationResponse.ShardInfo shardInfo = listener.get().getShardInfo().     assertThat(shardInfo.getFailed(), equalTo(0)).     assertThat(shardInfo.getFailures(), arrayWithSize(0)).     assertThat(shardInfo.getSuccessful(), equalTo(1 + nbReplicas - unavailableShards.size())). }
false;public;0;4;;@Override public ShardRouting routingEntry() {     return primary. }
false;public;0;4;;@Override public ReplicationGroup getReplicationGroup() {     return replicationGroup. }
false;public;1;4;;@Override public PrimaryResult perform(TransportVerifyShardBeforeCloseAction.ShardRequest request) throws Exception {     return new PrimaryResult(request). }
false;public;2;4;;@Override public void failShard(String message, Exception exception) { }
false;public;2;3;;@Override public void updateLocalCheckpointForShard(String allocationId, long checkpoint) { }
false;public;2;3;;@Override public void updateGlobalCheckpointForShard(String allocationId, long globalCheckpoint) { }
false;public;0;4;;@Override public long localCheckpoint() {     return 0. }
false;public;0;4;;@Override public long globalCheckpoint() {     return 0. }
false;public;0;4;;@Override public long maxSeqNoOfUpdatesOrDeletes() {     return 0. }
false;private,static;2;53;;private static ReplicationOperation.Primary<TransportVerifyShardBeforeCloseAction.ShardRequest, TransportVerifyShardBeforeCloseAction.ShardRequest, PrimaryResult> createPrimary(final ShardRouting primary, final ReplicationGroup replicationGroup) {     return new ReplicationOperation.Primary<TransportVerifyShardBeforeCloseAction.ShardRequest, TransportVerifyShardBeforeCloseAction.ShardRequest, PrimaryResult>() {          @Override         public ShardRouting routingEntry() {             return primary.         }          @Override         public ReplicationGroup getReplicationGroup() {             return replicationGroup.         }          @Override         public PrimaryResult perform(TransportVerifyShardBeforeCloseAction.ShardRequest request) throws Exception {             return new PrimaryResult(request).         }          @Override         public void failShard(String message, Exception exception) {         }          @Override         public void updateLocalCheckpointForShard(String allocationId, long checkpoint) {         }          @Override         public void updateGlobalCheckpointForShard(String allocationId, long globalCheckpoint) {         }          @Override         public long localCheckpoint() {             return 0.         }          @Override         public long globalCheckpoint() {             return 0.         }          @Override         public long maxSeqNoOfUpdatesOrDeletes() {             return 0.         }     }. }
false;public;0;4;;@Override public TransportVerifyShardBeforeCloseAction.ShardRequest replicaRequest() {     return replicaRequest. }
false;public;1;4;;@Override public void setShardInfo(ReplicationResponse.ShardInfo shardInfo) {     this.shardInfo.set(shardInfo). }
false;public;0;3;;public ReplicationResponse.ShardInfo getShardInfo() {     return shardInfo.get(). }
