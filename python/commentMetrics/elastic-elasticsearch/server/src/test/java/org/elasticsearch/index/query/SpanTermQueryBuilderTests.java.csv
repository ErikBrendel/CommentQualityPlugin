commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;16;;@Override protected SpanTermQueryBuilder doCreateTestQueryBuilder() {     String fieldName = randomFrom(STRING_FIELD_NAME, STRING_ALIAS_FIELD_NAME, randomAlphaOfLengthBetween(1, 10)).     Object value.     if (frequently()) {         value = randomAlphaOfLengthBetween(1, 10).     } else {         // generate unicode string in 10% of cases         JsonStringEncoder encoder = JsonStringEncoder.getInstance().         value = new String(encoder.quoteAsString(randomUnicodeOfLength(10))).     }     return createQueryBuilder(fieldName, value). }
false;protected;2;4;;@Override protected SpanTermQueryBuilder createQueryBuilder(String fieldName, Object value) {     return new SpanTermQueryBuilder(fieldName, value). }
false;protected;3;16;;@Override protected void doAssertLuceneQuery(SpanTermQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     assertThat(query, instanceOf(SpanTermQuery.class)).     SpanTermQuery spanTermQuery = (SpanTermQuery) query.     String expectedFieldName = expectedFieldName(queryBuilder.fieldName).     assertThat(spanTermQuery.getTerm().field(), equalTo(expectedFieldName)).     MappedFieldType mapper = context.getQueryShardContext().fieldMapper(queryBuilder.fieldName()).     if (mapper != null) {         Term term = ((TermQuery) mapper.termQuery(queryBuilder.value(), null)).getTerm().         assertThat(spanTermQuery.getTerm(), equalTo(term)).     } else {         assertThat(spanTermQuery.getTerm().bytes(), equalTo(BytesRefs.toBytesRef(queryBuilder.value()))).     } }
true;public;1;14;/**  * @param amount a number of clauses that will be returned  * @return the array of random {@link SpanTermQueryBuilder} with same field name  */ ;/**  * @param amount a number of clauses that will be returned  * @return the array of random {@link SpanTermQueryBuilder} with same field name  */ public SpanTermQueryBuilder[] createSpanTermQueryBuilders(int amount) {     SpanTermQueryBuilder[] clauses = new SpanTermQueryBuilder[amount].     SpanTermQueryBuilder first = createTestQueryBuilder(false, true).     clauses[0] = first.     for (int i = 1. i < amount. i++) {         // we need same field name in all clauses, so we only randomize value         SpanTermQueryBuilder spanTermQuery = new SpanTermQueryBuilder(first.fieldName(), getRandomValueForFieldName(first.fieldName())).         if (randomBoolean()) {             spanTermQuery.queryName(randomAlphaOfLengthBetween(1, 10)).         }         clauses[i] = spanTermQuery.     }     return clauses. }
false;public;0;7;;public void testFromJson() throws IOException {     String json = "{    \"span_term\" : { \"user\" : { \"value\" : \"kimchy\", \"boost\" : 2.0 } }}".     SpanTermQueryBuilder parsed = (SpanTermQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     assertEquals(json, "kimchy", parsed.value()).     assertEquals(json, 2.0, parsed.boost(), 0.0001). }
false;public;0;23;;public void testParseFailsWithMultipleFields() throws IOException {     String json = "{\n" + "  \"span_term\" : {\n" + "    \"message1\" : {\n" + "      \"term\" : \"this\"\n" + "    },\n" + "    \"message2\" : {\n" + "      \"term\" : \"this\"\n" + "    }\n" + "  }\n" + "}".     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(json)).     assertEquals("[span_term] query doesn't support multiple fields, found [message1] and [message2]", e.getMessage()).     String shortJson = "{\n" + "  \"span_term\" : {\n" + "    \"message1\" : \"this\",\n" + "    \"message2\" : \"this\"\n" + "  }\n" + "}".     e = expectThrows(ParsingException.class, () -> parseQuery(shortJson)).     assertEquals("[span_term] query doesn't support multiple fields, found [message1] and [message2]", e.getMessage()). }
false;public;0;9;;public void testWithMetaDataField() throws IOException {     QueryShardContext context = createShardContext().     for (String field : new String[] { "field1", "field2" }) {         SpanTermQueryBuilder spanTermQueryBuilder = new SpanTermQueryBuilder(field, "toto").         Query query = spanTermQueryBuilder.toQuery(context).         Query expected = new SpanTermQuery(new Term(field, "toto")).         assertEquals(expected, query).     } }
