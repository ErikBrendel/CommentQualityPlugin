commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return Arrays.asList(MockTransportService.TestPlugin.class, MockEngineFactoryPlugin.class). }
false;public;0;35;;public void testCorruptTranslogFiles() throws Exception {     internalCluster().startNodes(1, Settings.EMPTY).     assertAcked(prepareCreate("test").setSettings(Settings.builder().put("index.number_of_shards", 1).put("index.number_of_replicas", 0).put("index.refresh_interval", "-1").put(MockEngineSupport.DISABLE_FLUSH_ON_CLOSE.getKey(), // never flush - always recover from translog     true))).     // Index some documents     int numDocs = scaledRandomIntBetween(100, 1000).     IndexRequestBuilder[] builders = new IndexRequestBuilder[numDocs].     for (int i = 0. i < builders.length. i++) {         builders[i] = client().prepareIndex("test", "type").setSource("foo", "bar").     }     disableTranslogFlush("test").     // this one     indexRandom(false, false, false, Arrays.asList(builders)).     // Corrupt the translog file(s)     corruptRandomTranslogFile().     // Restart the single node     internalCluster().fullRestart().     client().admin().cluster().prepareHealth().setWaitForYellowStatus().setTimeout(new TimeValue(1000, TimeUnit.MILLISECONDS)).setWaitForEvents(Priority.LANGUID).get().     try {         client().prepareSearch("test").setQuery(matchAllQuery()).get().         fail("all shards should be failed due to a corrupted translog").     } catch (SearchPhaseExecutionException e) {     // Good, all shards should be failed because there is only a     // single shard and its translog is corrupt     } }
false;private;0;24;;private void corruptRandomTranslogFile() throws IOException {     ClusterState state = client().admin().cluster().prepareState().get().getState().     GroupShardsIterator shardIterators = state.getRoutingTable().activePrimaryShardsGrouped(new String[] { "test" }, false).     final Index test = state.metaData().index("test").getIndex().     List<ShardIterator> iterators = iterableAsArrayList(shardIterators).     ShardIterator shardIterator = RandomPicks.randomFrom(random(), iterators).     ShardRouting shardRouting = shardIterator.nextOrNull().     assertNotNull(shardRouting).     assertTrue(shardRouting.primary()).     assertTrue(shardRouting.assignedToNode()).     String nodeId = shardRouting.currentNodeId().     NodesStatsResponse nodeStatses = client().admin().cluster().prepareNodesStats(nodeId).setFs(true).get().     Set<Path> translogDirs = new HashSet<>().     for (FsInfo.Path fsPath : nodeStatses.getNodes().get(0).getFs()) {         String path = fsPath.getPath().         String relativeDataLocationPath = "indices/" + test.getUUID() + "/" + Integer.toString(shardRouting.getId()) + "/translog".         Path translogDir = PathUtils.get(path).resolve(relativeDataLocationPath).         if (Files.isDirectory(translogDir)) {             translogDirs.add(translogDir).         }     }     Path translogDir = RandomPicks.randomFrom(random(), translogDirs).     TestTranslog.corruptRandomTranslogFile(logger, random(), Arrays.asList(translogDir)). }
true;private,static;1;5;/**  * Disables translog flushing for the specified index  */ ;/**  * Disables translog flushing for the specified index  */ private static void disableTranslogFlush(String index) {     Settings settings = Settings.builder().put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(1, ByteSizeUnit.PB)).build().     client().admin().indices().prepareUpdateSettings(index).setSettings(settings).get(). }
true;private,static;1;5;/**  * Enables translog flushing for the specified index  */ ;/**  * Enables translog flushing for the specified index  */ private static void enableTranslogFlush(String index) {     Settings settings = Settings.builder().put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), new ByteSizeValue(512, ByteSizeUnit.MB)).build().     client().admin().indices().prepareUpdateSettings(index).setSettings(settings).get(). }
