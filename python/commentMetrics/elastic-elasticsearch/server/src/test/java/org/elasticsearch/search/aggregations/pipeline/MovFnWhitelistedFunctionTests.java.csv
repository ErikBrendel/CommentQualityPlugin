commented;modifiers;parameterAmount;loc;comment;code
false;public;0;24;;public void testWindowMax() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         double randValue = randomDouble().         double expected = -Double.MAX_VALUE.         if (i == 0) {             window.offer(randValue).             continue.         }         for (double value : window) {             expected = Math.max(expected, value).         }         double actual = MovingFunctions.max(window.stream().mapToDouble(Double::doubleValue).toArray()).         assertEquals(expected, actual, 0.01 * Math.abs(expected)).         window.offer(randValue).     } }
false;public;0;23;;public void testNullWindowMax() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         Double randValue = randomBoolean() ? Double.NaN : null.         if (i == 0) {             if (randValue != null) {                 window.offer(randValue).             }             continue.         }         double actual = MovingFunctions.max(window.stream().mapToDouble(Double::doubleValue).toArray()).         assertThat(actual, equalTo(Double.NaN)).         if (randValue != null) {             window.offer(randValue).         }     } }
false;public;0;5;;public void testEmptyWindowMax() {     EvictingQueue<Double> window = new EvictingQueue<>(0).     double actual = MovingFunctions.max(window.stream().mapToDouble(Double::doubleValue).toArray()).     assertThat(actual, equalTo(Double.NaN)). }
false;public;0;24;;public void testWindowMin() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         double randValue = randomDouble().         double expected = Double.MAX_VALUE.         if (i == 0) {             window.offer(randValue).             continue.         }         for (double value : window) {             expected = Math.min(expected, value).         }         double actual = MovingFunctions.min(window.stream().mapToDouble(Double::doubleValue).toArray()).         assertEquals(expected, actual, 0.01 * Math.abs(expected)).         window.offer(randValue).     } }
false;public;0;23;;public void testNullWindowMin() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         Double randValue = randomBoolean() ? Double.NaN : null.         if (i == 0) {             if (randValue != null) {                 window.offer(randValue).             }             continue.         }         double actual = MovingFunctions.min(window.stream().mapToDouble(Double::doubleValue).toArray()).         assertThat(actual, equalTo(Double.NaN)).         if (randValue != null) {             window.offer(randValue).         }     } }
false;public;0;5;;public void testEmptyWindowMin() {     EvictingQueue<Double> window = new EvictingQueue<>(0).     double actual = MovingFunctions.min(window.stream().mapToDouble(Double::doubleValue).toArray()).     assertThat(actual, equalTo(Double.NaN)). }
false;public;0;24;;public void testWindowSum() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         double randValue = randomDouble().         double expected = 0.         if (i == 0) {             window.offer(randValue).             continue.         }         for (double value : window) {             expected += value.         }         double actual = MovingFunctions.sum(window.stream().mapToDouble(Double::doubleValue).toArray()).         assertEquals(expected, actual, 0.01 * Math.abs(expected)).         window.offer(randValue).     } }
false;public;0;23;;public void testNullWindowSum() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         Double randValue = randomBoolean() ? Double.NaN : null.         if (i == 0) {             if (randValue != null) {                 window.offer(randValue).             }             continue.         }         double actual = MovingFunctions.sum(window.stream().mapToDouble(Double::doubleValue).toArray()).         assertThat(actual, equalTo(0.0)).         if (randValue != null) {             window.offer(randValue).         }     } }
false;public;0;5;;public void testEmptyWindowSum() {     EvictingQueue<Double> window = new EvictingQueue<>(0).     double actual = MovingFunctions.sum(window.stream().mapToDouble(Double::doubleValue).toArray()).     assertThat(actual, equalTo(0.0)). }
false;public;0;25;;public void testSimpleMovAvg() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         double randValue = randomDouble().         double expected = 0.         if (i == 0) {             window.offer(randValue).             continue.         }         for (double value : window) {             expected += value.         }         expected /= window.size().         double actual = MovingFunctions.unweightedAvg(window.stream().mapToDouble(Double::doubleValue).toArray()).         assertEquals(expected, actual, 0.01 * Math.abs(expected)).         window.offer(randValue).     } }
false;public;0;23;;public void testNullSimpleMovAvg() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         Double randValue = randomBoolean() ? Double.NaN : null.         if (i == 0) {             if (randValue != null) {                 window.offer(randValue).             }             continue.         }         double actual = MovingFunctions.unweightedAvg(window.stream().mapToDouble(Double::doubleValue).toArray()).         assertThat(actual, equalTo(Double.NaN)).         if (randValue != null) {             window.offer(randValue).         }     } }
false;public;0;5;;public void testEmptySimpleMovAvg() {     EvictingQueue<Double> window = new EvictingQueue<>(0).     double actual = MovingFunctions.unweightedAvg(window.stream().mapToDouble(Double::doubleValue).toArray()).     assertThat(actual, equalTo(Double.NaN)). }
false;public;0;31;;public void testSimpleMovStdDev() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         double randValue = randomDouble().         double mean = 0.         if (i == 0) {             window.offer(randValue).             continue.         }         for (double value : window) {             mean += value.         }         mean /= window.size().         double expected = 0.0.         for (double value : window) {             expected += Math.pow(value - mean, 2).         }         expected = Math.sqrt(expected / window.size()).         double actual = MovingFunctions.stdDev(window.stream().mapToDouble(Double::doubleValue).toArray(), mean).         assertEquals(expected, actual, 0.01 * Math.abs(expected)).         window.offer(randValue).     } }
false;public;0;24;;public void testNullSimpleStdDev() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         Double randValue = randomBoolean() ? Double.NaN : null.         if (i == 0) {             if (randValue != null) {                 window.offer(randValue).             }             continue.         }         double actual = MovingFunctions.stdDev(window.stream().mapToDouble(Double::doubleValue).toArray(), MovingFunctions.unweightedAvg(window.stream().mapToDouble(Double::doubleValue).toArray())).         assertThat(actual, equalTo(Double.NaN)).         if (randValue != null) {             window.offer(randValue).         }     } }
false;public;0;6;;public void testEmptySimpleStdDev() {     EvictingQueue<Double> window = new EvictingQueue<>(0).     double actual = MovingFunctions.stdDev(window.stream().mapToDouble(Double::doubleValue).toArray(), MovingFunctions.unweightedAvg(window.stream().mapToDouble(Double::doubleValue).toArray())).     assertThat(actual, equalTo(Double.NaN)). }
false;public;0;3;;public void testStdDevNaNAvg() {     assertThat(MovingFunctions.stdDev(new double[] { 1.0, 2.0, 3.0 }, Double.NaN), equalTo(Double.NaN)). }
false;public;0;29;;public void testLinearMovAvg() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         double randValue = randomDouble().         if (i == 0) {             window.offer(randValue).             continue.         }         double avg = 0.         long totalWeight = 1.         long current = 1.         for (double value : window) {             avg += value * current.             totalWeight += current.             current += 1.         }         double expected = avg / totalWeight.         double actual = MovingFunctions.linearWeightedAvg(window.stream().mapToDouble(Double::doubleValue).toArray()).         assertEquals(expected, actual, 0.01 * Math.abs(expected)).         window.offer(randValue).     } }
false;public;0;23;;public void testNullLinearMovAvg() {     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         Double randValue = randomBoolean() ? Double.NaN : null.         if (i == 0) {             if (randValue != null) {                 window.offer(randValue).             }             continue.         }         double actual = MovingFunctions.linearWeightedAvg(window.stream().mapToDouble(Double::doubleValue).toArray()).         assertThat(actual, equalTo(Double.NaN)).         if (randValue != null) {             window.offer(randValue).         }     } }
false;public;0;5;;public void testEmptyLinearMovAvg() {     EvictingQueue<Double> window = new EvictingQueue<>(0).     double actual = MovingFunctions.linearWeightedAvg(window.stream().mapToDouble(Double::doubleValue).toArray()).     assertThat(actual, equalTo(Double.NaN)). }
false;public;0;32;;public void testEWMAMovAvg() {     double alpha = randomDouble().     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         double randValue = randomDouble().         if (i == 0) {             window.offer(randValue).             continue.         }         double avg = 0.         boolean first = true.         for (double value : window) {             if (first) {                 avg = value.                 first = false.             } else {                 avg = (value * alpha) + (avg * (1 - alpha)).             }         }         double expected = avg.         double actual = MovingFunctions.ewma(window.stream().mapToDouble(Double::doubleValue).toArray(), alpha).         assertEquals(expected, actual, 0.01 * Math.abs(expected)).         window.offer(randValue).     } }
false;public;0;24;;public void testNullEwmaMovAvg() {     double alpha = randomDouble().     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         Double randValue = randomBoolean() ? Double.NaN : null.         if (i == 0) {             if (randValue != null) {                 window.offer(randValue).             }             continue.         }         double actual = MovingFunctions.ewma(window.stream().mapToDouble(Double::doubleValue).toArray(), alpha).         assertThat(actual, equalTo(Double.NaN)).         if (randValue != null) {             window.offer(randValue).         }     } }
false;public;0;6;;public void testEmptyEwmaMovAvg() {     double alpha = randomDouble().     EvictingQueue<Double> window = new EvictingQueue<>(0).     double actual = MovingFunctions.ewma(window.stream().mapToDouble(Double::doubleValue).toArray(), alpha).     assertThat(actual, equalTo(Double.NaN)). }
false;public;0;46;;public void testHoltLinearMovAvg() {     double alpha = randomDouble().     double beta = randomDouble().     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         double randValue = randomDouble().         if (i == 0) {             window.offer(randValue).             continue.         }         double s = 0.         double last_s = 0.         // Trend value         double b = 0.         double last_b = 0.         int counter = 0.         double last.         for (double value : window) {             last = value.             if (counter == 0) {                 s = value.                 b = value - last.             } else {                 s = alpha * value + (1.0d - alpha) * (last_s + last_b).                 b = beta * (s - last_s) + (1 - beta) * last_b.             }             counter += 1.             last_s = s.             last_b = b.         }         double expected = s + (0 * b).         double actual = MovingFunctions.holt(window.stream().mapToDouble(Double::doubleValue).toArray(), alpha, beta).         assertEquals(expected, actual, 0.01 * Math.abs(expected)).         window.offer(randValue).     } }
false;public;0;25;;public void testNullHoltMovAvg() {     double alpha = randomDouble().     double beta = randomDouble().     int numValues = randomIntBetween(1, 100).     int windowSize = randomIntBetween(1, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < numValues. i++) {         Double randValue = randomBoolean() ? Double.NaN : null.         if (i == 0) {             if (randValue != null) {                 window.offer(randValue).             }             continue.         }         double actual = MovingFunctions.holt(window.stream().mapToDouble(Double::doubleValue).toArray(), alpha, beta).         assertThat(actual, equalTo(Double.NaN)).         if (randValue != null) {             window.offer(randValue).         }     } }
false;public;0;7;;public void testEmptyHoltMovAvg() {     double alpha = randomDouble().     double beta = randomDouble().     EvictingQueue<Double> window = new EvictingQueue<>(0).     double actual = MovingFunctions.holt(window.stream().mapToDouble(Double::doubleValue).toArray(), alpha, beta).     assertThat(actual, equalTo(Double.NaN)). }
false;public;0;64;;public void testHoltWintersMultiplicative() {     double alpha = randomDouble().     double beta = randomDouble().     double gamma = randomDouble().     int period = randomIntBetween(1, 10).     // HW requires at least two periods of data     int windowSize = randomIntBetween(period * 2, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < windowSize. i++) {         window.offer(randomDouble()).     }     // Smoothed value     double s = 0.     double last_s = 0.     // Trend value     double b = 0.     double last_b = 0.     // Seasonal value     double[] seasonal = new double[windowSize].     int counter = 0.     double[] vs = new double[windowSize].     for (double v : window) {         vs[counter] = v + 0.0000000001.         counter += 1.     }     // Calculate the slopes between first and second season for each period     for (int i = 0. i < period. i++) {         s += vs[i].         b += (vs[i + period] - vs[i]) / period.     }     s /= period.     b /= period.     last_s = s.     // Calculate first seasonal     if (Double.compare(s, 0.0) == 0 || Double.compare(s, -0.0) == 0) {         Arrays.fill(seasonal, 0.0).     } else {         for (int i = 0. i < period. i++) {             seasonal[i] = vs[i] / s.         }     }     for (int i = period. i < vs.length. i++) {         s = alpha * (vs[i] / seasonal[i - period]) + (1.0d - alpha) * (last_s + last_b).         b = beta * (s - last_s) + (1 - beta) * last_b.         seasonal[i] = gamma * (vs[i] / (last_s + last_b)) + (1 - gamma) * seasonal[i - period].         last_s = s.         last_b = b.     }     int idx = window.size() - period + (0 % period).     double expected = (s + (1 * b)) * seasonal[idx].     double actual = MovingFunctions.holtWinters(window.stream().mapToDouble(Double::doubleValue).toArray(), alpha, beta, gamma, period, true).     assertEquals(expected, actual, 0.01 * Math.abs(expected)). }
false;public;0;19;;public void testNullHoltWintersMovAvg() {     double alpha = randomDouble().     double beta = randomDouble().     double gamma = randomDouble().     int period = randomIntBetween(1, 10).     int numValues = randomIntBetween(1, 100).     // HW requires at least two periods of data     int windowSize = randomIntBetween(period * 2, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < windowSize. i++) {         window.offer(Double.NaN).     }     for (int i = 0. i < numValues. i++) {         double actual = MovingFunctions.holtWinters(window.stream().mapToDouble(Double::doubleValue).toArray(), alpha, beta, gamma, period, false).         assertThat(actual, equalTo(Double.NaN)).     } }
false;public;0;10;;public void testEmptyHoltWintersMovAvg() {     double alpha = randomDouble().     double beta = randomDouble().     double gamma = randomDouble().     int period = randomIntBetween(1, 10).     EvictingQueue<Double> window = new EvictingQueue<>(0).     double actual = MovingFunctions.holtWinters(window.stream().mapToDouble(Double::doubleValue).toArray(), alpha, beta, gamma, period, false).     assertThat(actual, equalTo(Double.NaN)). }
false;public;0;65;;public void testHoltWintersAdditive() {     double alpha = randomDouble().     double beta = randomDouble().     double gamma = randomDouble().     int period = randomIntBetween(1, 10).     // HW requires at least two periods of data     int windowSize = randomIntBetween(period * 2, 50).     EvictingQueue<Double> window = new EvictingQueue<>(windowSize).     for (int i = 0. i < windowSize. i++) {         window.offer(randomDouble()).     }     // Smoothed value     double s = 0.     double last_s = 0.     // Trend value     double b = 0.     double last_b = 0.     // Seasonal value     double[] seasonal = new double[windowSize].     int counter = 0.     double[] vs = new double[windowSize].     for (double v : window) {         vs[counter] = v.         counter += 1.     }     // Calculate the slopes between first and second season for each period     for (int i = 0. i < period. i++) {         s += vs[i].         b += (vs[i + period] - vs[i]) / period.     }     s /= period.     b /= period.     last_s = s.     // Calculate first seasonal     if (Double.compare(s, 0.0) == 0 || Double.compare(s, -0.0) == 0) {         Arrays.fill(seasonal, 0.0).     } else {         for (int i = 0. i < period. i++) {             seasonal[i] = vs[i] / s.         }     }     for (int i = period. i < vs.length. i++) {         s = alpha * (vs[i] - seasonal[i - period]) + (1.0d - alpha) * (last_s + last_b).         b = beta * (s - last_s) + (1 - beta) * last_b.         seasonal[i] = gamma * (vs[i] - (last_s - last_b)) + (1 - gamma) * seasonal[i - period].         last_s = s.         last_b = b.     }     int idx = window.size() - period + (0 % period).     double expected = s + (1 * b) + seasonal[idx].     double actual = MovingFunctions.holtWinters(window.stream().mapToDouble(Double::doubleValue).toArray(), alpha, beta, gamma, period, false).     assertEquals(expected, actual, 0.01 * Math.abs(expected)). }
