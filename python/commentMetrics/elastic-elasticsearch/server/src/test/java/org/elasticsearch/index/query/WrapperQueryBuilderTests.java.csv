commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected boolean supportsBoost() {     return false. }
false;protected;0;4;;@Override protected boolean supportsQueryName() {     return false. }
false;protected;0;22;;@Override protected WrapperQueryBuilder doCreateTestQueryBuilder() {     QueryBuilder wrappedQuery = RandomQueryBuilder.createQuery(random()).     BytesReference bytes.     try {         bytes = XContentHelper.toXContent(wrappedQuery, XContentType.JSON, false).     } catch (IOException e) {         throw new UncheckedIOException(e).     }     switch(randomInt(2)) {         case 0:             return new WrapperQueryBuilder(wrappedQuery.toString()).         case 1:             return new WrapperQueryBuilder(BytesReference.toBytes(bytes)).         case 2:             return new WrapperQueryBuilder(bytes).         default:             throw new UnsupportedOperationException().     } }
false;protected;3;6;;@Override protected void doAssertLuceneQuery(WrapperQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     QueryBuilder innerQuery = queryBuilder.rewrite(createShardContext()).     Query expected = rewrite(innerQuery.toQuery(context.getQueryShardContext())).     assertEquals(rewrite(query), expected). }
false;public;0;8;;public void testIllegalArgument() {     expectThrows(IllegalArgumentException.class, () -> new WrapperQueryBuilder((byte[]) null)).     expectThrows(IllegalArgumentException.class, () -> new WrapperQueryBuilder(new byte[0])).     expectThrows(IllegalArgumentException.class, () -> new WrapperQueryBuilder((String) null)).     expectThrows(IllegalArgumentException.class, () -> new WrapperQueryBuilder("")).     expectThrows(IllegalArgumentException.class, () -> new WrapperQueryBuilder((BytesReference) null)).     expectThrows(IllegalArgumentException.class, () -> new WrapperQueryBuilder(new BytesArray(new byte[0]))). }
true;public;0;6;/**  * Replace the generic test from superclass, wrapper query only expects  * to find `query` field with nested query and should throw exception for  * anything else.  */ ;/**  * Replace the generic test from superclass, wrapper query only expects  * to find `query` field with nested query and should throw exception for  * anything else.  */ @Override public void testUnknownField() {     String json = "{ \"" + WrapperQueryBuilder.NAME + "\" : {\"bogusField\" : \"someValue\"} }".     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(json)).     assertTrue(e.getMessage().contains("bogusField")). }
false;public;0;18;;public void testFromJson() throws IOException {     String json = "{\n" + "  \"wrapper\" : {\n" + "    \"query\" : \"e30=\"\n" + "  }\n" + "}".     WrapperQueryBuilder parsed = (WrapperQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     try {         assertEquals(json, "{}", new String(parsed.source(), "UTF-8")).     } catch (UnsupportedEncodingException e) {         throw new RuntimeException(e).     } }
false;public;0;9;;@Override public void testMustRewrite() throws IOException {     TermQueryBuilder tqb = new TermQueryBuilder("foo", "bar").     WrapperQueryBuilder qb = new WrapperQueryBuilder(tqb.toString()).     UnsupportedOperationException e = expectThrows(UnsupportedOperationException.class, () -> qb.toQuery(createShardContext())).     assertEquals("this query must be rewritten first", e.getMessage()).     QueryBuilder rewrite = qb.rewrite(createShardContext()).     assertEquals(tqb, rewrite). }
false;public;0;8;;public void testRewriteWithInnerName() throws IOException {     QueryBuilder builder = new WrapperQueryBuilder("{ \"match_all\" : {\"_name\" : \"foobar\"}}").     QueryShardContext shardContext = createShardContext().     assertEquals(new MatchAllQueryBuilder().queryName("foobar"), builder.rewrite(shardContext)).     builder = new WrapperQueryBuilder("{ \"match_all\" : {\"_name\" : \"foobar\"}}").queryName("outer").     assertEquals(new BoolQueryBuilder().must(new MatchAllQueryBuilder().queryName("foobar")).queryName("outer"), builder.rewrite(shardContext)). }
false;public;0;8;;public void testRewriteWithInnerBoost() throws IOException {     final TermQueryBuilder query = new TermQueryBuilder("foo", "bar").boost(2).     QueryBuilder builder = new WrapperQueryBuilder(query.toString()).     QueryShardContext shardContext = createShardContext().     assertEquals(query, builder.rewrite(shardContext)).     builder = new WrapperQueryBuilder(query.toString()).boost(3).     assertEquals(new BoolQueryBuilder().must(query).boost(3), builder.rewrite(shardContext)). }
false;public;0;17;;public void testRewriteInnerQueryToo() throws IOException {     QueryShardContext shardContext = createShardContext().     QueryBuilder qb = new WrapperQueryBuilder(new WrapperQueryBuilder(new TermQueryBuilder("foo", "bar").toString()).toString()).     assertEquals(new TermQuery(new Term("foo", "bar")), qb.rewrite(shardContext).toQuery(shardContext)).     qb = new WrapperQueryBuilder(new WrapperQueryBuilder(new WrapperQueryBuilder(new TermQueryBuilder("foo", "bar").toString()).toString()).toString()).     assertEquals(new TermQuery(new Term("foo", "bar")), qb.rewrite(shardContext).toQuery(shardContext)).     qb = new WrapperQueryBuilder(new BoolQueryBuilder().toString()).     assertEquals(new MatchAllDocsQuery(), qb.rewrite(shardContext).toQuery(shardContext)). }
false;protected;1;11;;@Override protected Query rewrite(Query query) throws IOException {     // this causes some queries to be not exactly equal but equivalent such that we need to rewrite them before comparing.     if (query != null) {         MemoryIndex idx = new MemoryIndex().         return idx.createSearcher().rewrite(query).     }     // null == *:*     return new MatchAllDocsQuery(). }
