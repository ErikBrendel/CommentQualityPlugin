commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;11;;@Override protected InternalBucketMetricValue createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) {     double value = frequently() ? randomDoubleBetween(-10000, 100000, true) : randomFrom(new Double[] { Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, Double.NaN }).     String[] keys = new String[randomIntBetween(0, 5)].     for (int i = 0. i < keys.length. i++) {         keys[i] = randomAlphaOfLength(10).     }     return new InternalBucketMetricValue(name, keys, value, randomNumericDocValueFormat(), pipelineAggregators, metaData). }
false;public;0;6;;@Override public void testReduceRandom() {     expectThrows(UnsupportedOperationException.class, () -> createTestInstance("name", Collections.emptyList(), null).reduce(null, null)). }
false;protected;2;4;;@Override protected void assertReduced(InternalBucketMetricValue reduced, List<InternalBucketMetricValue> inputs) { // no test since reduce operation is unsupported }
false;protected;0;4;;@Override protected Reader<InternalBucketMetricValue> instanceReader() {     return InternalBucketMetricValue::new. }
false;protected;2;13;;@Override protected void assertFromXContent(InternalBucketMetricValue bucketMetricValue, ParsedAggregation parsedAggregation) {     BucketMetricValue parsed = ((BucketMetricValue) parsedAggregation).     assertArrayEquals(bucketMetricValue.keys(), parsed.keys()).     if (Double.isInfinite(bucketMetricValue.value()) == false) {         assertEquals(bucketMetricValue.value(), parsed.value(), 0).         assertEquals(bucketMetricValue.getValueAsString(), parsed.getValueAsString()).     } else {         // we write Double.NEGATIVE_INFINITY and Double.POSITIVE_INFINITY to xContent as 'null', so we         // cannot differentiate between them. Also we cannot recreate the exact String representation         assertEquals(parsed.value(), Double.NEGATIVE_INFINITY, 0).     } }
false;protected;1;36;;@Override protected InternalBucketMetricValue mutateInstance(InternalBucketMetricValue instance) {     String name = instance.getName().     String[] keys = instance.keys().     double value = instance.value().     DocValueFormat formatter = instance.formatter().     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 3)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             if (Double.isFinite(value)) {                 value += between(1, 100).             } else {                 value = randomDoubleBetween(0, 100000, true).             }             break.         case 2:             keys = Arrays.copyOf(keys, keys.length + 1).             keys[keys.length - 1] = randomAlphaOfLengthBetween(1, 20).             break.         case 3:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new InternalBucketMetricValue(name, keys, value, formatter, pipelineAggregators, metaData). }
