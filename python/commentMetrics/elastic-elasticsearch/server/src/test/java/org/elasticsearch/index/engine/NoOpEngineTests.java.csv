commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;public void testNoopEngine() throws IOException {     engine.close().     final NoOpEngine engine = new NoOpEngine(noOpConfig(INDEX_SETTINGS, store, primaryTranslogDir)).     expectThrows(UnsupportedOperationException.class, () -> engine.syncFlush(null, null)).     assertThat(engine.refreshNeeded(), equalTo(false)).     assertThat(engine.shouldPeriodicallyFlush(), equalTo(false)).     engine.close(). }
false;public;0;9;;public void testTwoNoopEngines() throws IOException {     engine.close().     // Ensure that we can't open two noop engines for the same store     final EngineConfig engineConfig = noOpConfig(INDEX_SETTINGS, store, primaryTranslogDir).     try (NoOpEngine ignored = new NoOpEngine(engineConfig)) {         UncheckedIOException e = expectThrows(UncheckedIOException.class, () -> new NoOpEngine(engineConfig)).         assertThat(e.getCause(), instanceOf(LockObtainFailedException.class)).     } }
false;public;0;30;;public void testNoopAfterRegularEngine() throws IOException {     int docs = randomIntBetween(1, 10).     ReplicationTracker tracker = (ReplicationTracker) engine.config().getGlobalCheckpointSupplier().     ShardRouting routing = TestShardRouting.newShardRouting("test", shardId.id(), "node", null, true, ShardRoutingState.STARTED, allocationId).     IndexShardRoutingTable table = new IndexShardRoutingTable.Builder(shardId).addShard(routing).build().     tracker.updateFromMaster(1L, Collections.singleton(allocationId.getId()), table, Collections.emptySet()).     tracker.activatePrimaryMode(SequenceNumbers.NO_OPS_PERFORMED).     for (int i = 0. i < docs. i++) {         ParsedDocument doc = testParsedDocument("" + i, null, testDocumentWithTextField(), B_1, null).         engine.index(indexForDoc(doc)).         tracker.updateLocalCheckpoint(allocationId.getId(), i).     }     flushAndTrimTranslog(engine).     long localCheckpoint = engine.getLocalCheckpoint().     long maxSeqNo = engine.getSeqNoStats(100L).getMaxSeqNo().     engine.close().     final NoOpEngine noOpEngine = new NoOpEngine(noOpConfig(INDEX_SETTINGS, store, primaryTranslogDir, tracker)).     assertThat(noOpEngine.getLocalCheckpoint(), equalTo(localCheckpoint)).     assertThat(noOpEngine.getSeqNoStats(100L).getMaxSeqNo(), equalTo(maxSeqNo)).     try (Engine.IndexCommitRef ref = noOpEngine.acquireLastIndexCommit(false)) {         try (IndexReader reader = DirectoryReader.open(ref.getIndexCommit())) {             assertThat(reader.numDocs(), equalTo(docs)).         }     }     noOpEngine.close(). }
false;public;0;46;;public void testNoOpEngineDocStats() throws Exception {     IOUtils.close(engine, store).     final AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED).     try (Store store = createStore()) {         Path translogPath = createTempDir().         EngineConfig config = config(defaultSettings, store, translogPath, NoMergePolicy.INSTANCE, null, null, globalCheckpoint::get).         final int numDocs = scaledRandomIntBetween(10, 3000).         int deletions = 0.         try (InternalEngine engine = createEngine(config)) {             for (int i = 0. i < numDocs. i++) {                 engine.index(indexForDoc(createParsedDoc(Integer.toString(i), null))).                 if (rarely()) {                     engine.flush().                 }                 globalCheckpoint.set(engine.getLocalCheckpoint()).             }             for (int i = 0. i < numDocs. i++) {                 if (randomBoolean()) {                     String delId = Integer.toString(i).                     Engine.DeleteResult result = engine.delete(new Engine.Delete("test", delId, newUid(delId), primaryTerm.get())).                     assertTrue(result.isFound()).                     globalCheckpoint.set(engine.getLocalCheckpoint()).                     deletions += 1.                 }             }             engine.getLocalCheckpointTracker().waitForOpsToComplete(numDocs + deletions - 1).             flushAndTrimTranslog(engine).         }         final DocsStats expectedDocStats.         try (InternalEngine engine = createEngine(config)) {             expectedDocStats = engine.docStats().         }         try (NoOpEngine noOpEngine = new NoOpEngine(config)) {             assertEquals(expectedDocStats.getCount(), noOpEngine.docStats().getCount()).             assertEquals(expectedDocStats.getDeleted(), noOpEngine.docStats().getDeleted()).             assertEquals(expectedDocStats.getTotalSizeInBytes(), noOpEngine.docStats().getTotalSizeInBytes()).             assertEquals(expectedDocStats.getAverageSizeInBytes(), noOpEngine.docStats().getAverageSizeInBytes()).         } catch (AssertionError e) {             logger.error(config.getMergePolicy()).             throw e.         }     } }
false;private;1;8;;private void flushAndTrimTranslog(final InternalEngine engine) {     engine.flush(true, true).     final TranslogDeletionPolicy deletionPolicy = engine.getTranslog().getDeletionPolicy().     deletionPolicy.setRetentionSizeInBytes(-1).     deletionPolicy.setRetentionAgeInMillis(-1).     deletionPolicy.setMinTranslogGenerationForRecovery(engine.getTranslog().getGeneration().translogFileGeneration).     engine.flush(true, true). }
