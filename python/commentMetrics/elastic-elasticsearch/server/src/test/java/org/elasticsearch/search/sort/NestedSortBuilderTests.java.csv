commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;6;;@BeforeClass public static void init() {     SearchModule searchModule = new SearchModule(Settings.EMPTY, false, emptyList()).     namedWriteableRegistry = new NamedWriteableRegistry(searchModule.getNamedWriteables()).     xContentRegistry = new NamedXContentRegistry(searchModule.getNamedXContents()). }
false;public,static;0;5;;@AfterClass public static void afterClass() throws Exception {     namedWriteableRegistry = null.     xContentRegistry = null. }
false;protected;0;4;;@Override protected NamedXContentRegistry xContentRegistry() {     return xContentRegistry. }
false;public;0;15;;public void testFromXContent() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         NestedSortBuilder testItem = createRandomNestedSort(3).         XContentBuilder builder = XContentFactory.contentBuilder(randomFrom(XContentType.values())).         testItem.toXContent(builder, ToXContent.EMPTY_PARAMS).         XContentBuilder shuffled = shuffleXContent(builder).         try (XContentParser parser = createParser(shuffled)) {             parser.nextToken().             NestedSortBuilder parsedItem = NestedSortBuilder.fromXContent(parser).             assertNotSame(testItem, parsedItem).             assertEquals(testItem, parsedItem).             assertEquals(testItem.hashCode(), parsedItem.hashCode()).         }     } }
true;public,static;1;10;/**  * Create a {@link NestedSortBuilder} with random path and filter of the given depth.  */ ;/**  * Create a {@link NestedSortBuilder} with random path and filter of the given depth.  */ public static NestedSortBuilder createRandomNestedSort(int depth) {     NestedSortBuilder nestedSort = new NestedSortBuilder(randomAlphaOfLengthBetween(3, 10)).     if (randomBoolean()) {         nestedSort.setFilter(AbstractSortTestCase.randomNestedFilter()).     }     if (depth > 0) {         nestedSort.setNestedSort(createRandomNestedSort(depth - 1)).     }     return nestedSort. }
true;public;0;9;/**  * Test serialization of the test nested sort.  */ ;/**  * Test serialization of the test nested sort.  */ public void testSerialization() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         NestedSortBuilder testsort = createRandomNestedSort(3).         NestedSortBuilder deserializedsort = copy(testsort).         assertEquals(testsort, deserializedsort).         assertEquals(testsort.hashCode(), deserializedsort.hashCode()).         assertNotSame(testsort, deserializedsort).     } }
false;private,static;1;3;;private static NestedSortBuilder copy(NestedSortBuilder nestedSort) throws IOException {     return copyWriteable(nestedSort, namedWriteableRegistry, NestedSortBuilder::new). }
false;private,static;1;19;;private static NestedSortBuilder mutate(NestedSortBuilder original) throws IOException {     NestedSortBuilder mutated = original.getNestedSort().     int parameter = randomIntBetween(0, 2).     switch(parameter) {         case 0:             mutated = new NestedSortBuilder(original.getPath() + "_suffix").             mutated.setFilter(original.getFilter()).             mutated.setNestedSort(original.getNestedSort()).             break.         case 1:             mutated.setFilter(randomValueOtherThan(original.getFilter(), AbstractSortTestCase::randomNestedFilter)).             break.         case 2:         default:             mutated.setNestedSort(randomValueOtherThan(original.getNestedSort(), () -> NestedSortBuilderTests.createRandomNestedSort(3))).             break.     }     return mutated. }
true;public;0;6;/**  * Test equality and hashCode properties  */ ;/**  * Test equality and hashCode properties  */ public void testEqualsAndHashcode() {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         EqualsHashCodeTestUtils.checkEqualsAndHashCode(createRandomNestedSort(3), NestedSortBuilderTests::copy, NestedSortBuilderTests::mutate).     } }
false;protected;1;4;;@Override protected QueryBuilder doRewrite(org.elasticsearch.index.query.QueryRewriteContext queryShardContext) throws IOException {     return new MatchAllQueryBuilder(). }
true;public;0;56;/**  * Test that filters and inner nested sorts get rewritten  */ ;/**  * Test that filters and inner nested sorts get rewritten  */ public void testRewrite() throws IOException {     QueryBuilder filterThatRewrites = new MatchNoneQueryBuilder() {          @Override         protected QueryBuilder doRewrite(org.elasticsearch.index.query.QueryRewriteContext queryShardContext) throws IOException {             return new MatchAllQueryBuilder().         }     }.     // test that filter gets rewritten     NestedSortBuilder original = new NestedSortBuilder("path").setFilter(filterThatRewrites).     QueryRewriteContext mockRewriteContext = Mockito.mock(QueryRewriteContext.class).     NestedSortBuilder rewritten = original.rewrite(mockRewriteContext).     assertNotSame(rewritten, original).     assertNotSame(rewritten.getFilter(), original.getFilter()).     // test that inner nested sort gets rewritten     original = new NestedSortBuilder("path").     original.setNestedSort(new NestedSortBuilder("otherPath").setFilter(filterThatRewrites)).     rewritten = original.rewrite(mockRewriteContext).     assertNotSame(rewritten, original).     assertNotSame(rewritten.getNestedSort(), original.getNestedSort()).     // test that both filter and inner nested sort get rewritten     original = new NestedSortBuilder("path").     original.setFilter(filterThatRewrites).     original.setNestedSort(new NestedSortBuilder("otherPath").setFilter(filterThatRewrites)).     rewritten = original.rewrite(mockRewriteContext).     assertNotSame(rewritten, original).     assertNotSame(rewritten.getFilter(), original.getFilter()).     assertNotSame(rewritten.getNestedSort(), original.getNestedSort()).     // test that original stays unchanged if no element rewrites     original = new NestedSortBuilder("path").     original.setFilter(new MatchNoneQueryBuilder()).     original.setNestedSort(new NestedSortBuilder("otherPath").setFilter(new MatchNoneQueryBuilder())).     rewritten = original.rewrite(mockRewriteContext).     assertSame(rewritten, original).     assertSame(rewritten.getFilter(), original.getFilter()).     assertSame(rewritten.getNestedSort(), original.getNestedSort()).     // test that rewrite works recursively     original = new NestedSortBuilder("firstLevel").     ConstantScoreQueryBuilder constantScoreQueryBuilder = new ConstantScoreQueryBuilder(filterThatRewrites).     original.setFilter(constantScoreQueryBuilder).     NestedSortBuilder nestedSortThatRewrites = new NestedSortBuilder("thirdLevel").setFilter(filterThatRewrites).     original.setNestedSort(new NestedSortBuilder("secondLevel").setNestedSort(nestedSortThatRewrites)).     rewritten = original.rewrite(mockRewriteContext).     assertNotSame(rewritten, original).     assertNotSame(rewritten.getFilter(), constantScoreQueryBuilder).     assertNotSame(((ConstantScoreQueryBuilder) rewritten.getFilter()).innerQuery(), constantScoreQueryBuilder.innerQuery()).     assertEquals("secondLevel", rewritten.getNestedSort().getPath()).     assertNotSame(rewritten.getNestedSort(), original.getNestedSort()).     assertEquals("thirdLevel", rewritten.getNestedSort().getNestedSort().getPath()).     assertNotSame(rewritten.getNestedSort().getNestedSort(), nestedSortThatRewrites). }
