commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void createThreadPool() {     threadPool = new TestThreadPool(getTestClass().getName()). }
false;public,static;0;7;;@AfterClass public static void stopThreadPool() {     if (threadPool != null) {         threadPool.shutdownNow().         threadPool = null.     } }
false;public;0;5;;@Before public void setUpExecutor() {     threadExecutor = EsExecutors.newSinglePrioritizing(getClass().getName() + "/" + getTestName(), daemonThreadFactory(Settings.EMPTY, "test_thread"), threadPool.getThreadContext(), threadPool.scheduler()). }
false;public;0;4;;@After public void shutDownThreadExecutor() {     ThreadPool.terminate(threadExecutor, 10, TimeUnit.SECONDS). }
false;;2;1;;void onFailure(String source, Exception e).
false;default;1;3;;default void processed(String source) { // do nothing by default }
false;;1;1;;void execute(List<T> tasks).
false;default;1;11;;default String describeTasks(List<T> tasks) {     return tasks.stream().map(T::toString).reduce((s1, s2) -> {         if (s1.isEmpty()) {             return s2.         } else if (s2.isEmpty()) {             return s1.         } else {             return s1 + ", " + s2.         }     }).orElse(""). }
false;public;1;4;;@Override public void execute(List<TestTask> tasks) {     tasks.forEach(TestTask::run). }
false;public;0;5;;@Nullable @Override public TimeValue timeout() {     return null. }
false;public;0;4;;@Override public Priority priority() {     return Priority.NORMAL. }
false;public,abstract;0;1;;public abstract void run().
false;public;0;6;;@Override public void run() {     logger.trace("will process {}", source).     testTask.execute(Collections.singletonList(testTask)).     testTask.processed(source). }
true;protected;2;12;// can be overridden by TaskBatcherTests ;// can be overridden by TaskBatcherTests protected void submitTask(String source, TestTask testTask) {     SourcePrioritizedRunnable task = new UpdateTask(source, testTask).     TimeValue timeout = testTask.timeout().     if (timeout != null) {         threadExecutor.execute(task, timeout, () -> threadPool.generic().execute(() -> {             logger.debug("task [{}] timed out after [{}]", task, timeout).             testTask.onFailure(source, new ProcessClusterEventTimeoutException(timeout, source)).         })).     } else {         threadExecutor.execute(task).     } }
false;public;0;9;;@Override public void run() {     try {         block.await().     } catch (InterruptedException e) {         throw new RuntimeException(e).     }     blockCompleted.countDown(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     throw new RuntimeException(e). }
false;public;0;4;;@Override public void run() {     block2.countDown(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     block2.countDown(). }
false;public;0;4;;@Override public TimeValue timeout() {     return TimeValue.ZERO. }
false;public;0;46;;public void testTimedOutTaskCleanedUp() throws Exception {     final CountDownLatch block = new CountDownLatch(1).     final CountDownLatch blockCompleted = new CountDownLatch(1).     TestTask blockTask = new TestTask() {          @Override         public void run() {             try {                 block.await().             } catch (InterruptedException e) {                 throw new RuntimeException(e).             }             blockCompleted.countDown().         }          @Override         public void onFailure(String source, Exception e) {             throw new RuntimeException(e).         }     }.     submitTask("block-task", blockTask).     final CountDownLatch block2 = new CountDownLatch(1).     TestTask unblockTask = new TestTask() {          @Override         public void run() {             block2.countDown().         }          @Override         public void onFailure(String source, Exception e) {             block2.countDown().         }          @Override         public TimeValue timeout() {             return TimeValue.ZERO.         }     }.     submitTask("unblock-task", unblockTask).     block.countDown().     block2.await().     blockCompleted.await(). }
false;public;0;8;;@Override public void run() {     try {         block.await().     } catch (InterruptedException e) {         throw new RuntimeException(e).     } }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     throw new RuntimeException(e). }
false;public;0;4;;@Override public TimeValue timeout() {     return TimeValue.timeValueMillis(2). }
false;public;0;4;;@Override public void run() {     executeCalled.set(true). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     timedOut.countDown(). }
false;public;0;4;;@Override public void run() {     allProcessed.countDown(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     throw new RuntimeException(e). }
false;public;0;59;;public void testTimeoutTask() throws Exception {     final CountDownLatch block = new CountDownLatch(1).     TestTask test1 = new TestTask() {          @Override         public void run() {             try {                 block.await().             } catch (InterruptedException e) {                 throw new RuntimeException(e).             }         }          @Override         public void onFailure(String source, Exception e) {             throw new RuntimeException(e).         }     }.     submitTask("block-task", test1).     final CountDownLatch timedOut = new CountDownLatch(1).     final AtomicBoolean executeCalled = new AtomicBoolean().     TestTask test2 = new TestTask() {          @Override         public TimeValue timeout() {             return TimeValue.timeValueMillis(2).         }          @Override         public void run() {             executeCalled.set(true).         }          @Override         public void onFailure(String source, Exception e) {             timedOut.countDown().         }     }.     submitTask("block-task", test2).     timedOut.await().     block.countDown().     final CountDownLatch allProcessed = new CountDownLatch(1).     TestTask test3 = new TestTask() {          @Override         public void run() {             allProcessed.countDown().         }          @Override         public void onFailure(String source, Exception e) {             throw new RuntimeException(e).         }     }.     submitTask("block-task", test3).     // executed another task to double check that execute on the timed out update task is not called...     allProcessed.await().     assertThat(executeCalled.get(), equalTo(false)). }
false;public;1;4;;@Override public void execute(List<Integer> tasks) {     this.tasks.addAll(tasks). }
true;public;0;26;/**  * Note, this test can only work as long as we have a single thread executor executing the state update tasks!  */ ;/**  * Note, this test can only work as long as we have a single thread executor executing the state update tasks!  */ public void testPrioritizedTasks() throws Exception {     BlockingTask block = new BlockingTask(Priority.IMMEDIATE).     submitTask("test", block).     int taskCount = randomIntBetween(5, 20).     // will hold all the tasks in the order in which they were executed     List<PrioritizedTask> tasks = new ArrayList<>(taskCount).     CountDownLatch latch = new CountDownLatch(taskCount).     for (int i = 0. i < taskCount. i++) {         Priority priority = randomFrom(Priority.values()).         PrioritizedTask task = new PrioritizedTask(priority, latch, tasks).         submitTask("test", task).     }     block.close().     latch.await().     Priority prevPriority = null.     for (PrioritizedTask task : tasks) {         if (prevPriority == null) {             prevPriority = task.priority().         } else {             assertThat(task.priority().sameOrAfter(prevPriority), is(true)).         }     } }
false;public;0;8;;@Override public void run() {     try {         latch.await().     } catch (InterruptedException e) {         throw new RuntimeException(e).     } }
false;public;2;3;;@Override public void onFailure(String source, Exception e) { }
false;public;0;4;;@Override public Priority priority() {     return priority. }
false;public;0;3;;public void close() {     latch.countDown(). }
false;public;0;5;;@Override public void run() {     tasks.add(this).     latch.countDown(). }
false;public;0;4;;@Override public Priority priority() {     return priority. }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     latch.countDown(). }
