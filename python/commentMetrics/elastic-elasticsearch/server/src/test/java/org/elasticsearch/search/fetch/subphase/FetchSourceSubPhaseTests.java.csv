commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;public void testFetchSource() throws IOException {     XContentBuilder source = XContentFactory.jsonBuilder().startObject().field("field", "value").endObject().     FetchSubPhase.HitContext hitContext = hitExecute(source, true, null, null).     assertEquals(Collections.singletonMap("field", "value"), hitContext.hit().getSourceAsMap()). }
false;public;0;17;;public void testBasicFiltering() throws IOException {     XContentBuilder source = XContentFactory.jsonBuilder().startObject().field("field1", "value").field("field2", "value2").endObject().     FetchSubPhase.HitContext hitContext = hitExecute(source, false, null, null).     assertNull(hitContext.hit().getSourceAsMap()).     hitContext = hitExecute(source, true, "field1", null).     assertEquals(Collections.singletonMap("field1", "value"), hitContext.hit().getSourceAsMap()).     hitContext = hitExecute(source, true, "hello", null).     assertEquals(Collections.emptyMap(), hitContext.hit().getSourceAsMap()).     hitContext = hitExecute(source, true, "*", "field2").     assertEquals(Collections.singletonMap("field1", "value"), hitContext.hit().getSourceAsMap()). }
false;public;0;11;;public void testMultipleFiltering() throws IOException {     XContentBuilder source = XContentFactory.jsonBuilder().startObject().field("field", "value").field("field2", "value2").endObject().     FetchSubPhase.HitContext hitContext = hitExecuteMultiple(source, true, new String[] { "*.notexisting", "field" }, null).     assertEquals(Collections.singletonMap("field", "value"), hitContext.hit().getSourceAsMap()).     hitContext = hitExecuteMultiple(source, true, new String[] { "field.notexisting.*", "field" }, null).     assertEquals(Collections.singletonMap("field", "value"), hitContext.hit().getSourceAsMap()). }
false;public;0;22;;public void testNestedSource() throws IOException {     Map<String, Object> expectedNested = Collections.singletonMap("nested2", Collections.singletonMap("field", "value0")).     XContentBuilder source = XContentFactory.jsonBuilder().startObject().field("field", "value").field("field2", "value2").field("nested1", expectedNested).endObject().     FetchSubPhase.HitContext hitContext = hitExecuteMultiple(source, true, null, null, new SearchHit.NestedIdentity("nested1", 0, null)).     assertEquals(expectedNested, hitContext.hit().getSourceAsMap()).     hitContext = hitExecuteMultiple(source, true, new String[] { "invalid" }, null, new SearchHit.NestedIdentity("nested1", 0, null)).     assertEquals(Collections.emptyMap(), hitContext.hit().getSourceAsMap()).     hitContext = hitExecuteMultiple(source, true, null, null, new SearchHit.NestedIdentity("nested1", 0, new SearchHit.NestedIdentity("nested2", 0, null))).     assertEquals(Collections.singletonMap("field", "value0"), hitContext.hit().getSourceAsMap()).     hitContext = hitExecuteMultiple(source, true, new String[] { "invalid" }, null, new SearchHit.NestedIdentity("nested1", 0, new SearchHit.NestedIdentity("nested2", 0, null))).     assertEquals(Collections.emptyMap(), hitContext.hit().getSourceAsMap()). }
false;public;0;16;;public void testSourceDisabled() throws IOException {     FetchSubPhase.HitContext hitContext = hitExecute(null, true, null, null).     assertNull(hitContext.hit().getSourceAsMap()).     hitContext = hitExecute(null, false, null, null).     assertNull(hitContext.hit().getSourceAsMap()).     IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> hitExecute(null, true, "field1", null)).     assertEquals("unable to fetch fields from _source field: _source is disabled in the mappings " + "for index [index]", exception.getMessage()).     exception = expectThrows(IllegalArgumentException.class, () -> hitExecuteMultiple(null, true, new String[] { "*" }, new String[] { "field2" })).     assertEquals("unable to fetch fields from _source field: _source is disabled in the mappings " + "for index [index]", exception.getMessage()). }
false;private;4;3;;private FetchSubPhase.HitContext hitExecute(XContentBuilder source, boolean fetchSource, String include, String exclude) {     return hitExecute(source, fetchSource, include, exclude, null). }
false;private;5;6;;private FetchSubPhase.HitContext hitExecute(XContentBuilder source, boolean fetchSource, String include, String exclude, SearchHit.NestedIdentity nestedIdentity) {     return hitExecuteMultiple(source, fetchSource, include == null ? Strings.EMPTY_ARRAY : new String[] { include }, exclude == null ? Strings.EMPTY_ARRAY : new String[] { exclude }, nestedIdentity). }
false;private;4;3;;private FetchSubPhase.HitContext hitExecuteMultiple(XContentBuilder source, boolean fetchSource, String[] includes, String[] excludes) {     return hitExecuteMultiple(source, fetchSource, includes, excludes, null). }
false;private;5;12;;private FetchSubPhase.HitContext hitExecuteMultiple(XContentBuilder source, boolean fetchSource, String[] includes, String[] excludes, SearchHit.NestedIdentity nestedIdentity) {     FetchSourceContext fetchSourceContext = new FetchSourceContext(fetchSource, includes, excludes).     SearchContext searchContext = new FetchSourceSubPhaseTestSearchContext(fetchSourceContext, source == null ? null : BytesReference.bytes(source)).     FetchSubPhase.HitContext hitContext = new FetchSubPhase.HitContext().     final SearchHit searchHit = new SearchHit(1, null, null, nestedIdentity, null).     hitContext.reset(searchHit, null, 1, null).     FetchSourceSubPhase phase = new FetchSourceSubPhase().     phase.hitExecute(searchContext, hitContext).     return hitContext. }
false;public;0;4;;@Override public boolean sourceRequested() {     return context != null && context.fetchSource(). }
false;public;0;4;;@Override public FetchSourceContext fetchSourceContext() {     return context. }
false;public;0;6;;@Override public SearchLookup lookup() {     SearchLookup lookup = new SearchLookup(this.mapperService(), this::getForField, null).     lookup.source().setSource(source).     return lookup. }
false;public;0;4;;@Override public IndexShard indexShard() {     return indexShard. }
