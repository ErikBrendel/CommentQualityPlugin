commented;modifiers;parameterAmount;loc;comment;code
false;public;1;7;;@Override public byte[] newInstance(int sizing) {     byte[] value = new byte[10].     // "fresh" is intentionally not 0 to ensure we covered this code path     Arrays.fill(value, FRESH).     return value. }
false;public;1;4;;@Override public void recycle(byte[] value) {     Arrays.fill(value, RECYCLED). }
false;public;1;5;;@Override public void destroy(byte[] value) {     // we cannot really free the internals of a byte[], so mark it for verification     Arrays.fill(value, DEAD). }
false;protected;1;6;;protected void assertFresh(byte[] data) {     assertNotNull(data).     for (int i = 0. i < data.length. ++i) {         assertEquals(FRESH, data[i]).     } }
false;protected;1;6;;protected void assertRecycled(byte[] data) {     assertNotNull(data).     for (int i = 0. i < data.length. ++i) {         assertEquals(RECYCLED, data[i]).     } }
false;protected;1;6;;protected void assertDead(byte[] data) {     assertNotNull(data).     for (int i = 0. i < data.length. ++i) {         assertEquals(DEAD, data[i]).     } }
false;protected,abstract;1;1;;protected abstract Recycler<byte[]> newRecycler(int limit).
false;public;0;20;;public void testReuse() {     Recycler<byte[]> r = newRecycler(limit).     Recycler.V<byte[]> o = r.obtain().     assertFalse(o.isRecycled()).     final byte[] b1 = o.v().     assertFresh(b1).     o.close().     assertRecycled(b1).     o = r.obtain().     final byte[] b2 = o.v().     if (o.isRecycled()) {         assertRecycled(b2).         assertSame(b1, b2).     } else {         assertFresh(b2).         assertNotSame(b1, b2).     }     o.close().     r.close(). }
false;public;0;11;;public void testRecycle() {     Recycler<byte[]> r = newRecycler(limit).     Recycler.V<byte[]> o = r.obtain().     assertFresh(o.v()).     random().nextBytes(o.v()).     o.close().     o = r.obtain().     assertRecycled(o.v()).     o.close().     r.close(). }
false;public;0;16;;public void testDoubleRelease() {     final Recycler<byte[]> r = newRecycler(limit).     final Recycler.V<byte[]> v1 = r.obtain().     v1.close().     try {         v1.close().     } catch (IllegalStateException e) {         // impl has protection against double release: ok         return.     }     // otherwise ensure that the impl may not be returned twice     final Recycler.V<byte[]> v2 = r.obtain().     final Recycler.V<byte[]> v3 = r.obtain().     assertNotSame(v2.v(), v3.v()).     r.close(). }
false;public;0;25;;public void testDestroyWhenOverCapacity() {     Recycler<byte[]> r = newRecycler(limit).     // get & keep reference to new/recycled data     Recycler.V<byte[]> o = r.obtain().     byte[] data = o.v().     assertFresh(data).     // now exhaust the recycler     List<V<byte[]>> vals = new ArrayList<>(limit).     for (int i = 0. i < limit. ++i) {         vals.add(r.obtain()).     }     // Recycler size increases on release, not on obtain!     for (V<byte[]> v : vals) {         v.close().     }     // release first ref, verify for destruction     o.close().     assertDead(data).     // close the rest     r.close(). }
false;public;0;19;;public void testClose() {     Recycler<byte[]> r = newRecycler(limit).     // get & keep reference to pooled data     Recycler.V<byte[]> o = r.obtain().     byte[] data = o.v().     assertFresh(data).     // randomize & return to pool     random().nextBytes(data).     o.close().     // verify that recycle() ran     assertRecycled(data).     // closing the recycler should mark recycled instances via destroy()     r.close().     assertDead(data). }
