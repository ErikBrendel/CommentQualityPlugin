# id;timestamp;commentText;codeText;commentWords;codeWords
SoftDeletesPolicyTests -> public void testSoftDeletesRetentionLock();1535723122;Makes sure we won't advance the retained seq# if the retention lock is held;public void testSoftDeletesRetentionLock() {_        long retainedOps = between(0, 10000)__        AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        long safeCommitCheckpoint = globalCheckpoint.get()__        SoftDeletesPolicy policy = new SoftDeletesPolicy(globalCheckpoint::get, between(1, 10000), retainedOps)__        long minRetainedSeqNo = policy.getMinRetainedSeqNo()__        List<Releasable> locks = new ArrayList<>()__        int iters = scaledRandomIntBetween(10, 1000)__        for (int i = 0_ i < iters_ i++) {_            if (randomBoolean()) {_                locks.add(policy.acquireRetentionLock())__            }_            _            globalCheckpoint.addAndGet(between(0, 1000))__            safeCommitCheckpoint = randomLongBetween(safeCommitCheckpoint, globalCheckpoint.get())__            policy.setLocalCheckpointOfSafeCommit(safeCommitCheckpoint)__            if (rarely()) {_                retainedOps = between(0, 10000)__                policy.setRetentionOperations(retainedOps)__            }_            _            List<Releasable> releasingLocks = randomSubsetOf(locks)__            locks.removeAll(releasingLocks)__            releasingLocks.forEach(Releasable::close)___            _            policy.getRetentionQuery()__            if (locks.isEmpty()) {_                long retainedSeqNo = Math.min(safeCommitCheckpoint, globalCheckpoint.get() - retainedOps) + 1__                minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__            }_            assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__        }__        locks.forEach(Releasable::close)__        long retainedSeqNo = Math.min(safeCommitCheckpoint, globalCheckpoint.get() - retainedOps) + 1__        minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__        assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__    };makes,sure,we,won,t,advance,the,retained,seq,if,the,retention,lock,is,held;public,void,test,soft,deletes,retention,lock,long,retained,ops,between,0,10000,atomic,long,global,checkpoint,new,atomic,long,sequence,numbers,long,safe,commit,checkpoint,global,checkpoint,get,soft,deletes,policy,policy,new,soft,deletes,policy,global,checkpoint,get,between,1,10000,retained,ops,long,min,retained,seq,no,policy,get,min,retained,seq,no,list,releasable,locks,new,array,list,int,iters,scaled,random,int,between,10,1000,for,int,i,0,i,iters,i,if,random,boolean,locks,add,policy,acquire,retention,lock,global,checkpoint,add,and,get,between,0,1000,safe,commit,checkpoint,random,long,between,safe,commit,checkpoint,global,checkpoint,get,policy,set,local,checkpoint,of,safe,commit,safe,commit,checkpoint,if,rarely,retained,ops,between,0,10000,policy,set,retention,operations,retained,ops,list,releasable,releasing,locks,random,subset,of,locks,locks,remove,all,releasing,locks,releasing,locks,for,each,releasable,close,policy,get,retention,query,if,locks,is,empty,long,retained,seq,no,math,min,safe,commit,checkpoint,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no,locks,for,each,releasable,close,long,retained,seq,no,math,min,safe,commit,checkpoint,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no
SoftDeletesPolicyTests -> public void testSoftDeletesRetentionLock();1546875837;Makes sure we won't advance the retained seq# if the retention lock is held;public void testSoftDeletesRetentionLock() {_        long retainedOps = between(0, 10000)__        AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final AtomicLong[] retainingSequenceNumbers = new AtomicLong[randomIntBetween(0, 8)]__        for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_            retainingSequenceNumbers[i] = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        }_        final Supplier<Collection<RetentionLease>> retentionLeasesSupplier =_                () -> {_                    final Set<RetentionLease> leases = new HashSet<>(retainingSequenceNumbers.length)__                    for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_                        leases.add(new RetentionLease(Integer.toString(i), retainingSequenceNumbers[i].get(), "test"))__                    }_                    return leases__                }__        long safeCommitCheckpoint = globalCheckpoint.get()__        SoftDeletesPolicy policy = new SoftDeletesPolicy(globalCheckpoint::get, between(1, 10000), retainedOps, retentionLeasesSupplier)__        long minRetainedSeqNo = policy.getMinRetainedSeqNo()__        List<Releasable> locks = new ArrayList<>()__        int iters = scaledRandomIntBetween(10, 1000)__        for (int i = 0_ i < iters_ i++) {_            if (randomBoolean()) {_                locks.add(policy.acquireRetentionLock())__            }_            _            globalCheckpoint.addAndGet(between(0, 1000))__            for (final AtomicLong retainingSequenceNumber : retainingSequenceNumbers) {_                retainingSequenceNumber.set(randomLongBetween(retainingSequenceNumber.get(), globalCheckpoint.get()))__            }_            safeCommitCheckpoint = randomLongBetween(safeCommitCheckpoint, globalCheckpoint.get())__            policy.setLocalCheckpointOfSafeCommit(safeCommitCheckpoint)__            if (rarely()) {_                retainedOps = between(0, 10000)__                policy.setRetentionOperations(retainedOps)__            }_            _            List<Releasable> releasingLocks = randomSubsetOf(locks)__            locks.removeAll(releasingLocks)__            releasingLocks.forEach(Releasable::close)___            _            final Query query = policy.getRetentionQuery()__            assertThat(query, instanceOf(PointRangeQuery.class))__            final PointRangeQuery retentionQuery = (PointRangeQuery) query___            _            if (locks.isEmpty()) {_                final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                        .mapToLong(AtomicLong::get)_                        .min()_                        .orElse(Long.MAX_VALUE)__                long retainedSeqNo =_                        Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__                minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__            }_            assertThat(retentionQuery.getNumDims(), equalTo(1))__            assertThat(LongPoint.decodeDimension(retentionQuery.getLowerPoint(), 0), equalTo(minRetainedSeqNo))__            assertThat(LongPoint.decodeDimension(retentionQuery.getUpperPoint(), 0), equalTo(Long.MAX_VALUE))__            assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__        }__        locks.forEach(Releasable::close)__        final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                .mapToLong(AtomicLong::get)_                .min()_                .orElse(Long.MAX_VALUE)__        long retainedSeqNo =_                Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__        minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__        assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__    };makes,sure,we,won,t,advance,the,retained,seq,if,the,retention,lock,is,held;public,void,test,soft,deletes,retention,lock,long,retained,ops,between,0,10000,atomic,long,global,checkpoint,new,atomic,long,sequence,numbers,final,atomic,long,retaining,sequence,numbers,new,atomic,long,random,int,between,0,8,for,int,i,0,i,retaining,sequence,numbers,length,i,retaining,sequence,numbers,i,new,atomic,long,sequence,numbers,final,supplier,collection,retention,lease,retention,leases,supplier,final,set,retention,lease,leases,new,hash,set,retaining,sequence,numbers,length,for,int,i,0,i,retaining,sequence,numbers,length,i,leases,add,new,retention,lease,integer,to,string,i,retaining,sequence,numbers,i,get,test,return,leases,long,safe,commit,checkpoint,global,checkpoint,get,soft,deletes,policy,policy,new,soft,deletes,policy,global,checkpoint,get,between,1,10000,retained,ops,retention,leases,supplier,long,min,retained,seq,no,policy,get,min,retained,seq,no,list,releasable,locks,new,array,list,int,iters,scaled,random,int,between,10,1000,for,int,i,0,i,iters,i,if,random,boolean,locks,add,policy,acquire,retention,lock,global,checkpoint,add,and,get,between,0,1000,for,final,atomic,long,retaining,sequence,number,retaining,sequence,numbers,retaining,sequence,number,set,random,long,between,retaining,sequence,number,get,global,checkpoint,get,safe,commit,checkpoint,random,long,between,safe,commit,checkpoint,global,checkpoint,get,policy,set,local,checkpoint,of,safe,commit,safe,commit,checkpoint,if,rarely,retained,ops,between,0,10000,policy,set,retention,operations,retained,ops,list,releasable,releasing,locks,random,subset,of,locks,locks,remove,all,releasing,locks,releasing,locks,for,each,releasable,close,final,query,query,policy,get,retention,query,assert,that,query,instance,of,point,range,query,class,final,point,range,query,retention,query,point,range,query,query,if,locks,is,empty,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,retention,query,get,num,dims,equal,to,1,assert,that,long,point,decode,dimension,retention,query,get,lower,point,0,equal,to,min,retained,seq,no,assert,that,long,point,decode,dimension,retention,query,get,upper,point,0,equal,to,long,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no,locks,for,each,releasable,close,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no
SoftDeletesPolicyTests -> public void testSoftDeletesRetentionLock();1546927432;Makes sure we won't advance the retained seq# if the retention lock is held;public void testSoftDeletesRetentionLock() {_        long retainedOps = between(0, 10000)__        AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final AtomicLong[] retainingSequenceNumbers = new AtomicLong[randomIntBetween(0, 8)]__        for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_            retainingSequenceNumbers[i] = new AtomicLong(SequenceNumbers.UNASSIGNED_SEQ_NO)__        }_        final Supplier<Collection<RetentionLease>> retentionLeasesSupplier =_                () -> {_                    final Set<RetentionLease> leases = new HashSet<>(retainingSequenceNumbers.length)__                    for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_                        leases.add(new RetentionLease(Integer.toString(i), retainingSequenceNumbers[i].get(), 0L, "test"))__                    }_                    return leases__                }__        long safeCommitCheckpoint = globalCheckpoint.get()__        SoftDeletesPolicy policy = new SoftDeletesPolicy(globalCheckpoint::get, between(1, 10000), retainedOps, retentionLeasesSupplier)__        long minRetainedSeqNo = policy.getMinRetainedSeqNo()__        List<Releasable> locks = new ArrayList<>()__        int iters = scaledRandomIntBetween(10, 1000)__        for (int i = 0_ i < iters_ i++) {_            if (randomBoolean()) {_                locks.add(policy.acquireRetentionLock())__            }_            _            globalCheckpoint.addAndGet(between(0, 1000))__            for (final AtomicLong retainingSequenceNumber : retainingSequenceNumbers) {_                retainingSequenceNumber.set(randomLongBetween(retainingSequenceNumber.get(), globalCheckpoint.get()))__            }_            safeCommitCheckpoint = randomLongBetween(safeCommitCheckpoint, globalCheckpoint.get())__            policy.setLocalCheckpointOfSafeCommit(safeCommitCheckpoint)__            if (rarely()) {_                retainedOps = between(0, 10000)__                policy.setRetentionOperations(retainedOps)__            }_            _            List<Releasable> releasingLocks = randomSubsetOf(locks)__            locks.removeAll(releasingLocks)__            releasingLocks.forEach(Releasable::close)___            _            final Query query = policy.getRetentionQuery()__            assertThat(query, instanceOf(PointRangeQuery.class))__            final PointRangeQuery retentionQuery = (PointRangeQuery) query___            _            if (locks.isEmpty()) {_                final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                        .mapToLong(AtomicLong::get)_                        .min()_                        .orElse(Long.MAX_VALUE)__                long retainedSeqNo =_                        Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__                minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__            }_            assertThat(retentionQuery.getNumDims(), equalTo(1))__            assertThat(LongPoint.decodeDimension(retentionQuery.getLowerPoint(), 0), equalTo(minRetainedSeqNo))__            assertThat(LongPoint.decodeDimension(retentionQuery.getUpperPoint(), 0), equalTo(Long.MAX_VALUE))__            assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__        }__        locks.forEach(Releasable::close)__        final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                .mapToLong(AtomicLong::get)_                .min()_                .orElse(Long.MAX_VALUE)__        long retainedSeqNo =_                Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__        minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__        assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__    };makes,sure,we,won,t,advance,the,retained,seq,if,the,retention,lock,is,held;public,void,test,soft,deletes,retention,lock,long,retained,ops,between,0,10000,atomic,long,global,checkpoint,new,atomic,long,sequence,numbers,final,atomic,long,retaining,sequence,numbers,new,atomic,long,random,int,between,0,8,for,int,i,0,i,retaining,sequence,numbers,length,i,retaining,sequence,numbers,i,new,atomic,long,sequence,numbers,final,supplier,collection,retention,lease,retention,leases,supplier,final,set,retention,lease,leases,new,hash,set,retaining,sequence,numbers,length,for,int,i,0,i,retaining,sequence,numbers,length,i,leases,add,new,retention,lease,integer,to,string,i,retaining,sequence,numbers,i,get,0l,test,return,leases,long,safe,commit,checkpoint,global,checkpoint,get,soft,deletes,policy,policy,new,soft,deletes,policy,global,checkpoint,get,between,1,10000,retained,ops,retention,leases,supplier,long,min,retained,seq,no,policy,get,min,retained,seq,no,list,releasable,locks,new,array,list,int,iters,scaled,random,int,between,10,1000,for,int,i,0,i,iters,i,if,random,boolean,locks,add,policy,acquire,retention,lock,global,checkpoint,add,and,get,between,0,1000,for,final,atomic,long,retaining,sequence,number,retaining,sequence,numbers,retaining,sequence,number,set,random,long,between,retaining,sequence,number,get,global,checkpoint,get,safe,commit,checkpoint,random,long,between,safe,commit,checkpoint,global,checkpoint,get,policy,set,local,checkpoint,of,safe,commit,safe,commit,checkpoint,if,rarely,retained,ops,between,0,10000,policy,set,retention,operations,retained,ops,list,releasable,releasing,locks,random,subset,of,locks,locks,remove,all,releasing,locks,releasing,locks,for,each,releasable,close,final,query,query,policy,get,retention,query,assert,that,query,instance,of,point,range,query,class,final,point,range,query,retention,query,point,range,query,query,if,locks,is,empty,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,retention,query,get,num,dims,equal,to,1,assert,that,long,point,decode,dimension,retention,query,get,lower,point,0,equal,to,min,retained,seq,no,assert,that,long,point,decode,dimension,retention,query,get,upper,point,0,equal,to,long,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no,locks,for,each,releasable,close,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no
SoftDeletesPolicyTests -> public void testSoftDeletesRetentionLock();1548843917;Makes sure we won't advance the retained seq# if the retention lock is held;public void testSoftDeletesRetentionLock() {_        long retainedOps = between(0, 10000)__        AtomicLong globalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final AtomicLong[] retainingSequenceNumbers = new AtomicLong[randomIntBetween(0, 8)]__        for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_            retainingSequenceNumbers[i] = new AtomicLong()__        }_        final Supplier<Collection<RetentionLease>> retentionLeasesSupplier =_                () -> {_                    final Set<RetentionLease> leases = new HashSet<>(retainingSequenceNumbers.length)__                    for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_                        leases.add(new RetentionLease(Integer.toString(i), retainingSequenceNumbers[i].get(), 0L, "test"))__                    }_                    return leases__                }__        long safeCommitCheckpoint = globalCheckpoint.get()__        SoftDeletesPolicy policy = new SoftDeletesPolicy(globalCheckpoint::get, between(1, 10000), retainedOps, retentionLeasesSupplier)__        long minRetainedSeqNo = policy.getMinRetainedSeqNo()__        List<Releasable> locks = new ArrayList<>()__        int iters = scaledRandomIntBetween(10, 1000)__        for (int i = 0_ i < iters_ i++) {_            if (randomBoolean()) {_                locks.add(policy.acquireRetentionLock())__            }_            _            globalCheckpoint.addAndGet(between(0, 1000))__            for (final AtomicLong retainingSequenceNumber : retainingSequenceNumbers) {_                retainingSequenceNumber.set(randomLongBetween(retainingSequenceNumber.get(), globalCheckpoint.get()))__            }_            safeCommitCheckpoint = randomLongBetween(safeCommitCheckpoint, globalCheckpoint.get())__            policy.setLocalCheckpointOfSafeCommit(safeCommitCheckpoint)__            if (rarely()) {_                retainedOps = between(0, 10000)__                policy.setRetentionOperations(retainedOps)__            }_            _            List<Releasable> releasingLocks = randomSubsetOf(locks)__            locks.removeAll(releasingLocks)__            releasingLocks.forEach(Releasable::close)___            _            final Query query = policy.getRetentionQuery()__            assertThat(query, instanceOf(PointRangeQuery.class))__            final PointRangeQuery retentionQuery = (PointRangeQuery) query___            _            if (locks.isEmpty()) {_                final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                        .mapToLong(AtomicLong::get)_                        .min()_                        .orElse(Long.MAX_VALUE)__                long retainedSeqNo =_                        Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__                minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__            }_            assertThat(retentionQuery.getNumDims(), equalTo(1))__            assertThat(LongPoint.decodeDimension(retentionQuery.getLowerPoint(), 0), equalTo(minRetainedSeqNo))__            assertThat(LongPoint.decodeDimension(retentionQuery.getUpperPoint(), 0), equalTo(Long.MAX_VALUE))__            assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__        }__        locks.forEach(Releasable::close)__        final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                .mapToLong(AtomicLong::get)_                .min()_                .orElse(Long.MAX_VALUE)__        long retainedSeqNo =_                Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__        minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__        assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__    };makes,sure,we,won,t,advance,the,retained,seq,if,the,retention,lock,is,held;public,void,test,soft,deletes,retention,lock,long,retained,ops,between,0,10000,atomic,long,global,checkpoint,new,atomic,long,sequence,numbers,final,atomic,long,retaining,sequence,numbers,new,atomic,long,random,int,between,0,8,for,int,i,0,i,retaining,sequence,numbers,length,i,retaining,sequence,numbers,i,new,atomic,long,final,supplier,collection,retention,lease,retention,leases,supplier,final,set,retention,lease,leases,new,hash,set,retaining,sequence,numbers,length,for,int,i,0,i,retaining,sequence,numbers,length,i,leases,add,new,retention,lease,integer,to,string,i,retaining,sequence,numbers,i,get,0l,test,return,leases,long,safe,commit,checkpoint,global,checkpoint,get,soft,deletes,policy,policy,new,soft,deletes,policy,global,checkpoint,get,between,1,10000,retained,ops,retention,leases,supplier,long,min,retained,seq,no,policy,get,min,retained,seq,no,list,releasable,locks,new,array,list,int,iters,scaled,random,int,between,10,1000,for,int,i,0,i,iters,i,if,random,boolean,locks,add,policy,acquire,retention,lock,global,checkpoint,add,and,get,between,0,1000,for,final,atomic,long,retaining,sequence,number,retaining,sequence,numbers,retaining,sequence,number,set,random,long,between,retaining,sequence,number,get,global,checkpoint,get,safe,commit,checkpoint,random,long,between,safe,commit,checkpoint,global,checkpoint,get,policy,set,local,checkpoint,of,safe,commit,safe,commit,checkpoint,if,rarely,retained,ops,between,0,10000,policy,set,retention,operations,retained,ops,list,releasable,releasing,locks,random,subset,of,locks,locks,remove,all,releasing,locks,releasing,locks,for,each,releasable,close,final,query,query,policy,get,retention,query,assert,that,query,instance,of,point,range,query,class,final,point,range,query,retention,query,point,range,query,query,if,locks,is,empty,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,retention,query,get,num,dims,equal,to,1,assert,that,long,point,decode,dimension,retention,query,get,lower,point,0,equal,to,min,retained,seq,no,assert,that,long,point,decode,dimension,retention,query,get,upper,point,0,equal,to,long,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no,locks,for,each,releasable,close,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no
SoftDeletesPolicyTests -> public void testSoftDeletesRetentionLock();1548954177;Makes sure we won't advance the retained seq# if the retention lock is held;public void testSoftDeletesRetentionLock() {_        long retainedOps = between(0, 10000)__        AtomicLong globalCheckpoint = new AtomicLong(NO_OPS_PERFORMED)__        final AtomicLong[] retainingSequenceNumbers = new AtomicLong[randomIntBetween(0, 8)]__        for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_            retainingSequenceNumbers[i] = new AtomicLong()__        }_        final Supplier<Collection<RetentionLease>> retentionLeasesSupplier =_                () -> {_                    final Set<RetentionLease> leases = new HashSet<>(retainingSequenceNumbers.length)__                    for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_                        leases.add(new RetentionLease(Integer.toString(i), retainingSequenceNumbers[i].get(), 0L, "test"))__                    }_                    return leases__                }__        long safeCommitCheckpoint = globalCheckpoint.get()__        SoftDeletesPolicy policy = new SoftDeletesPolicy(globalCheckpoint::get, between(1, 10000), retainedOps, retentionLeasesSupplier)__        long minRetainedSeqNo = policy.getMinRetainedSeqNo()__        List<Releasable> locks = new ArrayList<>()__        int iters = scaledRandomIntBetween(10, 1000)__        for (int i = 0_ i < iters_ i++) {_            if (randomBoolean()) {_                locks.add(policy.acquireRetentionLock())__            }_            _            globalCheckpoint.addAndGet(between(0, 1000))__            for (final AtomicLong retainingSequenceNumber : retainingSequenceNumbers) {_                retainingSequenceNumber.set(randomLongBetween(retainingSequenceNumber.get(), globalCheckpoint.get()))__            }_            safeCommitCheckpoint = randomLongBetween(safeCommitCheckpoint, globalCheckpoint.get())__            policy.setLocalCheckpointOfSafeCommit(safeCommitCheckpoint)__            if (rarely()) {_                retainedOps = between(0, 10000)__                policy.setRetentionOperations(retainedOps)__            }_            _            List<Releasable> releasingLocks = randomSubsetOf(locks)__            locks.removeAll(releasingLocks)__            releasingLocks.forEach(Releasable::close)___            _            final Query query = policy.getRetentionQuery()__            assertThat(query, instanceOf(PointRangeQuery.class))__            final PointRangeQuery retentionQuery = (PointRangeQuery) query___            _            if (locks.isEmpty()) {_                final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                        .mapToLong(AtomicLong::get)_                        .min()_                        .orElse(Long.MAX_VALUE)__                long retainedSeqNo =_                        Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__                minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__            }_            assertThat(retentionQuery.getNumDims(), equalTo(1))__            assertThat(LongPoint.decodeDimension(retentionQuery.getLowerPoint(), 0), equalTo(minRetainedSeqNo))__            assertThat(LongPoint.decodeDimension(retentionQuery.getUpperPoint(), 0), equalTo(Long.MAX_VALUE))__            assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__        }__        locks.forEach(Releasable::close)__        final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                .mapToLong(AtomicLong::get)_                .min()_                .orElse(Long.MAX_VALUE)__        long retainedSeqNo =_                Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__        minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__        assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__    };makes,sure,we,won,t,advance,the,retained,seq,if,the,retention,lock,is,held;public,void,test,soft,deletes,retention,lock,long,retained,ops,between,0,10000,atomic,long,global,checkpoint,new,atomic,long,final,atomic,long,retaining,sequence,numbers,new,atomic,long,random,int,between,0,8,for,int,i,0,i,retaining,sequence,numbers,length,i,retaining,sequence,numbers,i,new,atomic,long,final,supplier,collection,retention,lease,retention,leases,supplier,final,set,retention,lease,leases,new,hash,set,retaining,sequence,numbers,length,for,int,i,0,i,retaining,sequence,numbers,length,i,leases,add,new,retention,lease,integer,to,string,i,retaining,sequence,numbers,i,get,0l,test,return,leases,long,safe,commit,checkpoint,global,checkpoint,get,soft,deletes,policy,policy,new,soft,deletes,policy,global,checkpoint,get,between,1,10000,retained,ops,retention,leases,supplier,long,min,retained,seq,no,policy,get,min,retained,seq,no,list,releasable,locks,new,array,list,int,iters,scaled,random,int,between,10,1000,for,int,i,0,i,iters,i,if,random,boolean,locks,add,policy,acquire,retention,lock,global,checkpoint,add,and,get,between,0,1000,for,final,atomic,long,retaining,sequence,number,retaining,sequence,numbers,retaining,sequence,number,set,random,long,between,retaining,sequence,number,get,global,checkpoint,get,safe,commit,checkpoint,random,long,between,safe,commit,checkpoint,global,checkpoint,get,policy,set,local,checkpoint,of,safe,commit,safe,commit,checkpoint,if,rarely,retained,ops,between,0,10000,policy,set,retention,operations,retained,ops,list,releasable,releasing,locks,random,subset,of,locks,locks,remove,all,releasing,locks,releasing,locks,for,each,releasable,close,final,query,query,policy,get,retention,query,assert,that,query,instance,of,point,range,query,class,final,point,range,query,retention,query,point,range,query,query,if,locks,is,empty,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,retention,query,get,num,dims,equal,to,1,assert,that,long,point,decode,dimension,retention,query,get,lower,point,0,equal,to,min,retained,seq,no,assert,that,long,point,decode,dimension,retention,query,get,upper,point,0,equal,to,long,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no,locks,for,each,releasable,close,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no
SoftDeletesPolicyTests -> public void testSoftDeletesRetentionLock();1548985841;Makes sure we won't advance the retained seq# if the retention lock is held;public void testSoftDeletesRetentionLock() {_        long retainedOps = between(0, 10000)__        AtomicLong globalCheckpoint = new AtomicLong(NO_OPS_PERFORMED)__        final AtomicLong[] retainingSequenceNumbers = new AtomicLong[randomIntBetween(0, 8)]__        for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_            retainingSequenceNumbers[i] = new AtomicLong()__        }_        final Supplier<Collection<RetentionLease>> retentionLeasesSupplier =_                () -> {_                    final Set<RetentionLease> leases = new HashSet<>(retainingSequenceNumbers.length)__                    for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_                        leases.add(new RetentionLease(Integer.toString(i), retainingSequenceNumbers[i].get(), 0L, "test"))__                    }_                    return leases__                }__        long safeCommitCheckpoint = globalCheckpoint.get()__        SoftDeletesPolicy policy = new SoftDeletesPolicy(globalCheckpoint::get, between(1, 10000), retainedOps, retentionLeasesSupplier)__        long minRetainedSeqNo = policy.getMinRetainedSeqNo()__        List<Releasable> locks = new ArrayList<>()__        int iters = scaledRandomIntBetween(10, 1000)__        for (int i = 0_ i < iters_ i++) {_            if (randomBoolean()) {_                locks.add(policy.acquireRetentionLock())__            }_            _            globalCheckpoint.addAndGet(between(0, 1000))__            for (final AtomicLong retainingSequenceNumber : retainingSequenceNumbers) {_                retainingSequenceNumber.set(randomLongBetween(retainingSequenceNumber.get(), Math.max(globalCheckpoint.get(), 0L)))__            }_            safeCommitCheckpoint = randomLongBetween(safeCommitCheckpoint, globalCheckpoint.get())__            policy.setLocalCheckpointOfSafeCommit(safeCommitCheckpoint)__            if (rarely()) {_                retainedOps = between(0, 10000)__                policy.setRetentionOperations(retainedOps)__            }_            _            List<Releasable> releasingLocks = randomSubsetOf(locks)__            locks.removeAll(releasingLocks)__            releasingLocks.forEach(Releasable::close)___            _            final Query query = policy.getRetentionQuery()__            assertThat(query, instanceOf(PointRangeQuery.class))__            final PointRangeQuery retentionQuery = (PointRangeQuery) query___            _            if (locks.isEmpty()) {_                final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                        .mapToLong(AtomicLong::get)_                        .min()_                        .orElse(Long.MAX_VALUE)__                long retainedSeqNo =_                        Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__                minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__            }_            assertThat(retentionQuery.getNumDims(), equalTo(1))__            assertThat(LongPoint.decodeDimension(retentionQuery.getLowerPoint(), 0), equalTo(minRetainedSeqNo))__            assertThat(LongPoint.decodeDimension(retentionQuery.getUpperPoint(), 0), equalTo(Long.MAX_VALUE))__            assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__        }__        locks.forEach(Releasable::close)__        final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                .mapToLong(AtomicLong::get)_                .min()_                .orElse(Long.MAX_VALUE)__        long retainedSeqNo =_                Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__        minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__        assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__    };makes,sure,we,won,t,advance,the,retained,seq,if,the,retention,lock,is,held;public,void,test,soft,deletes,retention,lock,long,retained,ops,between,0,10000,atomic,long,global,checkpoint,new,atomic,long,final,atomic,long,retaining,sequence,numbers,new,atomic,long,random,int,between,0,8,for,int,i,0,i,retaining,sequence,numbers,length,i,retaining,sequence,numbers,i,new,atomic,long,final,supplier,collection,retention,lease,retention,leases,supplier,final,set,retention,lease,leases,new,hash,set,retaining,sequence,numbers,length,for,int,i,0,i,retaining,sequence,numbers,length,i,leases,add,new,retention,lease,integer,to,string,i,retaining,sequence,numbers,i,get,0l,test,return,leases,long,safe,commit,checkpoint,global,checkpoint,get,soft,deletes,policy,policy,new,soft,deletes,policy,global,checkpoint,get,between,1,10000,retained,ops,retention,leases,supplier,long,min,retained,seq,no,policy,get,min,retained,seq,no,list,releasable,locks,new,array,list,int,iters,scaled,random,int,between,10,1000,for,int,i,0,i,iters,i,if,random,boolean,locks,add,policy,acquire,retention,lock,global,checkpoint,add,and,get,between,0,1000,for,final,atomic,long,retaining,sequence,number,retaining,sequence,numbers,retaining,sequence,number,set,random,long,between,retaining,sequence,number,get,math,max,global,checkpoint,get,0l,safe,commit,checkpoint,random,long,between,safe,commit,checkpoint,global,checkpoint,get,policy,set,local,checkpoint,of,safe,commit,safe,commit,checkpoint,if,rarely,retained,ops,between,0,10000,policy,set,retention,operations,retained,ops,list,releasable,releasing,locks,random,subset,of,locks,locks,remove,all,releasing,locks,releasing,locks,for,each,releasable,close,final,query,query,policy,get,retention,query,assert,that,query,instance,of,point,range,query,class,final,point,range,query,retention,query,point,range,query,query,if,locks,is,empty,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,retention,query,get,num,dims,equal,to,1,assert,that,long,point,decode,dimension,retention,query,get,lower,point,0,equal,to,min,retained,seq,no,assert,that,long,point,decode,dimension,retention,query,get,upper,point,0,equal,to,long,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no,locks,for,each,releasable,close,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no
SoftDeletesPolicyTests -> public void testSoftDeletesRetentionLock();1549059559;Makes sure we won't advance the retained seq# if the retention lock is held;public void testSoftDeletesRetentionLock() {_        long retainedOps = between(0, 10000)__        AtomicLong globalCheckpoint = new AtomicLong(NO_OPS_PERFORMED)__        final AtomicLong[] retainingSequenceNumbers = new AtomicLong[randomIntBetween(0, 8)]__        for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_            retainingSequenceNumbers[i] = new AtomicLong()__        }_        final Supplier<RetentionLeases> retentionLeasesSupplier =_                () -> {_                    final List<RetentionLease> leases = new ArrayList<>(retainingSequenceNumbers.length)__                    for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_                        leases.add(new RetentionLease(Integer.toString(i), retainingSequenceNumbers[i].get(), 0L, "test"))__                    }_                    return new RetentionLeases(1, 1, leases)__                }__        long safeCommitCheckpoint = globalCheckpoint.get()__        SoftDeletesPolicy policy = new SoftDeletesPolicy(globalCheckpoint::get, between(1, 10000), retainedOps, retentionLeasesSupplier)__        long minRetainedSeqNo = policy.getMinRetainedSeqNo()__        List<Releasable> locks = new ArrayList<>()__        int iters = scaledRandomIntBetween(10, 1000)__        for (int i = 0_ i < iters_ i++) {_            if (randomBoolean()) {_                locks.add(policy.acquireRetentionLock())__            }_            _            globalCheckpoint.addAndGet(between(0, 1000))__            for (final AtomicLong retainingSequenceNumber : retainingSequenceNumbers) {_                retainingSequenceNumber.set(randomLongBetween(retainingSequenceNumber.get(), Math.max(globalCheckpoint.get(), 0L)))__            }_            safeCommitCheckpoint = randomLongBetween(safeCommitCheckpoint, globalCheckpoint.get())__            policy.setLocalCheckpointOfSafeCommit(safeCommitCheckpoint)__            if (rarely()) {_                retainedOps = between(0, 10000)__                policy.setRetentionOperations(retainedOps)__            }_            _            List<Releasable> releasingLocks = randomSubsetOf(locks)__            locks.removeAll(releasingLocks)__            releasingLocks.forEach(Releasable::close)___            _            final Query query = policy.getRetentionQuery()__            assertThat(query, instanceOf(PointRangeQuery.class))__            final PointRangeQuery retentionQuery = (PointRangeQuery) query___            _            if (locks.isEmpty()) {_                final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                        .mapToLong(AtomicLong::get)_                        .min()_                        .orElse(Long.MAX_VALUE)__                long retainedSeqNo =_                        Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__                minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__            }_            assertThat(retentionQuery.getNumDims(), equalTo(1))__            assertThat(LongPoint.decodeDimension(retentionQuery.getLowerPoint(), 0), equalTo(minRetainedSeqNo))__            assertThat(LongPoint.decodeDimension(retentionQuery.getUpperPoint(), 0), equalTo(Long.MAX_VALUE))__            assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__        }__        locks.forEach(Releasable::close)__        final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                .mapToLong(AtomicLong::get)_                .min()_                .orElse(Long.MAX_VALUE)__        long retainedSeqNo =_                Math.min(safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, globalCheckpoint.get() - retainedOps)) + 1__        minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__        assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__    };makes,sure,we,won,t,advance,the,retained,seq,if,the,retention,lock,is,held;public,void,test,soft,deletes,retention,lock,long,retained,ops,between,0,10000,atomic,long,global,checkpoint,new,atomic,long,final,atomic,long,retaining,sequence,numbers,new,atomic,long,random,int,between,0,8,for,int,i,0,i,retaining,sequence,numbers,length,i,retaining,sequence,numbers,i,new,atomic,long,final,supplier,retention,leases,retention,leases,supplier,final,list,retention,lease,leases,new,array,list,retaining,sequence,numbers,length,for,int,i,0,i,retaining,sequence,numbers,length,i,leases,add,new,retention,lease,integer,to,string,i,retaining,sequence,numbers,i,get,0l,test,return,new,retention,leases,1,1,leases,long,safe,commit,checkpoint,global,checkpoint,get,soft,deletes,policy,policy,new,soft,deletes,policy,global,checkpoint,get,between,1,10000,retained,ops,retention,leases,supplier,long,min,retained,seq,no,policy,get,min,retained,seq,no,list,releasable,locks,new,array,list,int,iters,scaled,random,int,between,10,1000,for,int,i,0,i,iters,i,if,random,boolean,locks,add,policy,acquire,retention,lock,global,checkpoint,add,and,get,between,0,1000,for,final,atomic,long,retaining,sequence,number,retaining,sequence,numbers,retaining,sequence,number,set,random,long,between,retaining,sequence,number,get,math,max,global,checkpoint,get,0l,safe,commit,checkpoint,random,long,between,safe,commit,checkpoint,global,checkpoint,get,policy,set,local,checkpoint,of,safe,commit,safe,commit,checkpoint,if,rarely,retained,ops,between,0,10000,policy,set,retention,operations,retained,ops,list,releasable,releasing,locks,random,subset,of,locks,locks,remove,all,releasing,locks,releasing,locks,for,each,releasable,close,final,query,query,policy,get,retention,query,assert,that,query,instance,of,point,range,query,class,final,point,range,query,retention,query,point,range,query,query,if,locks,is,empty,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,retention,query,get,num,dims,equal,to,1,assert,that,long,point,decode,dimension,retention,query,get,lower,point,0,equal,to,min,retained,seq,no,assert,that,long,point,decode,dimension,retention,query,get,upper,point,0,equal,to,long,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no,locks,for,each,releasable,close,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,global,checkpoint,get,retained,ops,1,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no
SoftDeletesPolicyTests -> public void testSoftDeletesRetentionLock();1550084651;Makes sure we won't advance the retained seq# if the retention lock is held;public void testSoftDeletesRetentionLock() {_        long retainedOps = between(0, 10000)__        AtomicLong globalCheckpoint = new AtomicLong(NO_OPS_PERFORMED)__        final AtomicLong[] retainingSequenceNumbers = new AtomicLong[randomIntBetween(0, 8)]__        for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_            retainingSequenceNumbers[i] = new AtomicLong()__        }_        final Supplier<RetentionLeases> retentionLeasesSupplier =_                () -> {_                    final List<RetentionLease> leases = new ArrayList<>(retainingSequenceNumbers.length)__                    for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_                        leases.add(new RetentionLease(Integer.toString(i), retainingSequenceNumbers[i].get(), 0L, "test"))__                    }_                    return new RetentionLeases(1, 1, leases)__                }__        long safeCommitCheckpoint = globalCheckpoint.get()__        SoftDeletesPolicy policy = new SoftDeletesPolicy(globalCheckpoint::get, between(1, 10000), retainedOps, retentionLeasesSupplier)__        long minRetainedSeqNo = policy.getMinRetainedSeqNo()__        List<Releasable> locks = new ArrayList<>()__        int iters = scaledRandomIntBetween(10, 1000)__        for (int i = 0_ i < iters_ i++) {_            if (randomBoolean()) {_                locks.add(policy.acquireRetentionLock())__            }_            _            globalCheckpoint.addAndGet(between(0, 1000))__            for (final AtomicLong retainingSequenceNumber : retainingSequenceNumbers) {_                retainingSequenceNumber.set(randomLongBetween(retainingSequenceNumber.get(), Math.max(globalCheckpoint.get(), 0L)))__            }_            safeCommitCheckpoint = randomLongBetween(safeCommitCheckpoint, globalCheckpoint.get())__            policy.setLocalCheckpointOfSafeCommit(safeCommitCheckpoint)__            if (rarely()) {_                retainedOps = between(0, 10000)__                policy.setRetentionOperations(retainedOps)__            }_            _            List<Releasable> releasingLocks = randomSubsetOf(locks)__            locks.removeAll(releasingLocks)__            releasingLocks.forEach(Releasable::close)___            _            final Query query = policy.getRetentionQuery()__            assertThat(query, instanceOf(PointRangeQuery.class))__            final PointRangeQuery retentionQuery = (PointRangeQuery) query___            _            if (locks.isEmpty()) {_                final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                        .mapToLong(AtomicLong::get)_                        .min()_                        .orElse(Long.MAX_VALUE)__                long retainedSeqNo =_                        Math.min(_                                1 + safeCommitCheckpoint,_                                Math.min(minimumRetainingSequenceNumber, 1 + globalCheckpoint.get() - retainedOps))__                minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__            }_            assertThat(retentionQuery.getNumDims(), equalTo(1))__            assertThat(LongPoint.decodeDimension(retentionQuery.getLowerPoint(), 0), equalTo(minRetainedSeqNo))__            assertThat(LongPoint.decodeDimension(retentionQuery.getUpperPoint(), 0), equalTo(Long.MAX_VALUE))__            assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__        }__        locks.forEach(Releasable::close)__        final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                .mapToLong(AtomicLong::get)_                .min()_                .orElse(Long.MAX_VALUE)__        long retainedSeqNo =_                Math.min(1 + safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, 1 + globalCheckpoint.get() - retainedOps))__        minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__        assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__    };makes,sure,we,won,t,advance,the,retained,seq,if,the,retention,lock,is,held;public,void,test,soft,deletes,retention,lock,long,retained,ops,between,0,10000,atomic,long,global,checkpoint,new,atomic,long,final,atomic,long,retaining,sequence,numbers,new,atomic,long,random,int,between,0,8,for,int,i,0,i,retaining,sequence,numbers,length,i,retaining,sequence,numbers,i,new,atomic,long,final,supplier,retention,leases,retention,leases,supplier,final,list,retention,lease,leases,new,array,list,retaining,sequence,numbers,length,for,int,i,0,i,retaining,sequence,numbers,length,i,leases,add,new,retention,lease,integer,to,string,i,retaining,sequence,numbers,i,get,0l,test,return,new,retention,leases,1,1,leases,long,safe,commit,checkpoint,global,checkpoint,get,soft,deletes,policy,policy,new,soft,deletes,policy,global,checkpoint,get,between,1,10000,retained,ops,retention,leases,supplier,long,min,retained,seq,no,policy,get,min,retained,seq,no,list,releasable,locks,new,array,list,int,iters,scaled,random,int,between,10,1000,for,int,i,0,i,iters,i,if,random,boolean,locks,add,policy,acquire,retention,lock,global,checkpoint,add,and,get,between,0,1000,for,final,atomic,long,retaining,sequence,number,retaining,sequence,numbers,retaining,sequence,number,set,random,long,between,retaining,sequence,number,get,math,max,global,checkpoint,get,0l,safe,commit,checkpoint,random,long,between,safe,commit,checkpoint,global,checkpoint,get,policy,set,local,checkpoint,of,safe,commit,safe,commit,checkpoint,if,rarely,retained,ops,between,0,10000,policy,set,retention,operations,retained,ops,list,releasable,releasing,locks,random,subset,of,locks,locks,remove,all,releasing,locks,releasing,locks,for,each,releasable,close,final,query,query,policy,get,retention,query,assert,that,query,instance,of,point,range,query,class,final,point,range,query,retention,query,point,range,query,query,if,locks,is,empty,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,1,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,1,global,checkpoint,get,retained,ops,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,retention,query,get,num,dims,equal,to,1,assert,that,long,point,decode,dimension,retention,query,get,lower,point,0,equal,to,min,retained,seq,no,assert,that,long,point,decode,dimension,retention,query,get,upper,point,0,equal,to,long,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no,locks,for,each,releasable,close,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,1,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,1,global,checkpoint,get,retained,ops,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no
SoftDeletesPolicyTests -> public void testSoftDeletesRetentionLock();1550526771;Makes sure we won't advance the retained seq# if the retention lock is held;public void testSoftDeletesRetentionLock() {_        long retainedOps = between(0, 10000)__        AtomicLong globalCheckpoint = new AtomicLong(NO_OPS_PERFORMED)__        final AtomicLong[] retainingSequenceNumbers = new AtomicLong[randomIntBetween(0, 8)]__        for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_            retainingSequenceNumbers[i] = new AtomicLong()__        }_        final Supplier<RetentionLeases> retentionLeasesSupplier =_                () -> {_                    final List<RetentionLease> leases = new ArrayList<>(retainingSequenceNumbers.length)__                    for (int i = 0_ i < retainingSequenceNumbers.length_ i++) {_                        leases.add(new RetentionLease(Integer.toString(i), retainingSequenceNumbers[i].get(), 0L, "test"))__                    }_                    return new RetentionLeases(1, 1, leases)__                }__        long safeCommitCheckpoint = globalCheckpoint.get()__        SoftDeletesPolicy policy = new SoftDeletesPolicy(globalCheckpoint::get, between(1, 10000), retainedOps, retentionLeasesSupplier)__        long minRetainedSeqNo = policy.getMinRetainedSeqNo()__        List<Releasable> locks = new ArrayList<>()__        int iters = scaledRandomIntBetween(10, 1000)__        for (int i = 0_ i < iters_ i++) {_            if (randomBoolean()) {_                locks.add(policy.acquireRetentionLock())__            }_            _            globalCheckpoint.addAndGet(between(0, 1000))__            for (final AtomicLong retainingSequenceNumber : retainingSequenceNumbers) {_                retainingSequenceNumber.set(randomLongBetween(retainingSequenceNumber.get(), Math.max(globalCheckpoint.get(), 0L)))__            }_            safeCommitCheckpoint = randomLongBetween(safeCommitCheckpoint, globalCheckpoint.get())__            policy.setLocalCheckpointOfSafeCommit(safeCommitCheckpoint)__            if (rarely()) {_                retainedOps = between(0, 10000)__                policy.setRetentionOperations(retainedOps)__            }_            _            List<Releasable> releasingLocks = randomSubsetOf(locks)__            locks.removeAll(releasingLocks)__            releasingLocks.forEach(Releasable::close)___            _            final Query query = policy.getRetentionQuery()__            assertThat(query, instanceOf(PointRangeQuery.class))__            final PointRangeQuery retentionQuery = (PointRangeQuery) query___            _            if (locks.isEmpty()) {_                final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                        .mapToLong(AtomicLong::get)_                        .min()_                        .orElse(Long.MAX_VALUE)__                long retainedSeqNo =_                        Math.min(_                                1 + safeCommitCheckpoint,_                                Math.min(minimumRetainingSequenceNumber, 1 + globalCheckpoint.get() - retainedOps))__                minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__            }_            assertThat(retentionQuery.getNumDims(), equalTo(1))__            assertThat(LongPoint.decodeDimension(retentionQuery.getLowerPoint(), 0), equalTo(minRetainedSeqNo))__            assertThat(LongPoint.decodeDimension(retentionQuery.getUpperPoint(), 0), equalTo(Long.MAX_VALUE))__            assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__        }__        locks.forEach(Releasable::close)__        final long minimumRetainingSequenceNumber = Arrays.stream(retainingSequenceNumbers)_                .mapToLong(AtomicLong::get)_                .min()_                .orElse(Long.MAX_VALUE)__        long retainedSeqNo =_                Math.min(1 + safeCommitCheckpoint, Math.min(minimumRetainingSequenceNumber, 1 + globalCheckpoint.get() - retainedOps))__        minRetainedSeqNo = Math.max(minRetainedSeqNo, retainedSeqNo)__        assertThat(policy.getMinRetainedSeqNo(), equalTo(minRetainedSeqNo))__    };makes,sure,we,won,t,advance,the,retained,seq,if,the,retention,lock,is,held;public,void,test,soft,deletes,retention,lock,long,retained,ops,between,0,10000,atomic,long,global,checkpoint,new,atomic,long,final,atomic,long,retaining,sequence,numbers,new,atomic,long,random,int,between,0,8,for,int,i,0,i,retaining,sequence,numbers,length,i,retaining,sequence,numbers,i,new,atomic,long,final,supplier,retention,leases,retention,leases,supplier,final,list,retention,lease,leases,new,array,list,retaining,sequence,numbers,length,for,int,i,0,i,retaining,sequence,numbers,length,i,leases,add,new,retention,lease,integer,to,string,i,retaining,sequence,numbers,i,get,0l,test,return,new,retention,leases,1,1,leases,long,safe,commit,checkpoint,global,checkpoint,get,soft,deletes,policy,policy,new,soft,deletes,policy,global,checkpoint,get,between,1,10000,retained,ops,retention,leases,supplier,long,min,retained,seq,no,policy,get,min,retained,seq,no,list,releasable,locks,new,array,list,int,iters,scaled,random,int,between,10,1000,for,int,i,0,i,iters,i,if,random,boolean,locks,add,policy,acquire,retention,lock,global,checkpoint,add,and,get,between,0,1000,for,final,atomic,long,retaining,sequence,number,retaining,sequence,numbers,retaining,sequence,number,set,random,long,between,retaining,sequence,number,get,math,max,global,checkpoint,get,0l,safe,commit,checkpoint,random,long,between,safe,commit,checkpoint,global,checkpoint,get,policy,set,local,checkpoint,of,safe,commit,safe,commit,checkpoint,if,rarely,retained,ops,between,0,10000,policy,set,retention,operations,retained,ops,list,releasable,releasing,locks,random,subset,of,locks,locks,remove,all,releasing,locks,releasing,locks,for,each,releasable,close,final,query,query,policy,get,retention,query,assert,that,query,instance,of,point,range,query,class,final,point,range,query,retention,query,point,range,query,query,if,locks,is,empty,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,1,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,1,global,checkpoint,get,retained,ops,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,retention,query,get,num,dims,equal,to,1,assert,that,long,point,decode,dimension,retention,query,get,lower,point,0,equal,to,min,retained,seq,no,assert,that,long,point,decode,dimension,retention,query,get,upper,point,0,equal,to,long,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no,locks,for,each,releasable,close,final,long,minimum,retaining,sequence,number,arrays,stream,retaining,sequence,numbers,map,to,long,atomic,long,get,min,or,else,long,long,retained,seq,no,math,min,1,safe,commit,checkpoint,math,min,minimum,retaining,sequence,number,1,global,checkpoint,get,retained,ops,min,retained,seq,no,math,max,min,retained,seq,no,retained,seq,no,assert,that,policy,get,min,retained,seq,no,equal,to,min,retained,seq,no
