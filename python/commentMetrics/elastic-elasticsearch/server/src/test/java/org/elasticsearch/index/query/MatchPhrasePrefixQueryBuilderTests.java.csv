commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;30;;@Override protected MatchPhrasePrefixQueryBuilder doCreateTestQueryBuilder() {     String fieldName = randomFrom(STRING_FIELD_NAME, STRING_ALIAS_FIELD_NAME).     Object value.     if (isTextField(fieldName)) {         int terms = randomIntBetween(0, 3).         StringBuilder builder = new StringBuilder().         for (int i = 0. i < terms. i++) {             builder.append(randomAlphaOfLengthBetween(1, 10)).append(" ").         }         value = builder.toString().trim().     } else {         value = getRandomValueForFieldName(fieldName).     }     MatchPhrasePrefixQueryBuilder matchQuery = new MatchPhrasePrefixQueryBuilder(fieldName, value).     if (randomBoolean() && isTextField(fieldName)) {         matchQuery.analyzer(randomFrom("simple", "keyword", "whitespace")).     }     if (randomBoolean()) {         matchQuery.slop(randomIntBetween(0, 10)).     }     if (randomBoolean()) {         matchQuery.maxExpansions(randomIntBetween(1, 10000)).     }     return matchQuery. }
false;protected;0;13;;@Override protected Map<String, MatchPhrasePrefixQueryBuilder> getAlternateVersions() {     Map<String, MatchPhrasePrefixQueryBuilder> alternateVersions = new HashMap<>().     MatchPhrasePrefixQueryBuilder matchPhrasePrefixQuery = new MatchPhrasePrefixQueryBuilder(randomAlphaOfLengthBetween(1, 10), randomAlphaOfLengthBetween(1, 10)).     String contentString = "{\n" + "    \"match_phrase_prefix\" : {\n" + "        \"" + matchPhrasePrefixQuery.fieldName() + "\" : \"" + matchPhrasePrefixQuery.value() + "\"\n" + "    }\n" + "}".     alternateVersions.put(contentString, matchPhrasePrefixQuery).     return alternateVersions. }
false;protected;3;8;;@Override protected void doAssertLuceneQuery(MatchPhrasePrefixQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     assertThat(query, notNullValue()).     assertThat(query, either(instanceOf(MultiPhrasePrefixQuery.class)).or(instanceOf(SynonymQuery.class)).or(instanceOf(MatchNoDocsQuery.class))). }
false;public;0;10;;public void testIllegalValues() {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new MatchPhrasePrefixQueryBuilder(null, "value")).     assertEquals("[match_phrase_prefix] requires fieldName", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new MatchPhrasePrefixQueryBuilder("fieldName", null)).     assertEquals("[match_phrase_prefix] requires query value", e.getMessage()).     MatchPhrasePrefixQueryBuilder matchQuery = new MatchPhrasePrefixQueryBuilder("fieldName", "text").     e = expectThrows(IllegalArgumentException.class, () -> matchQuery.maxExpansions(-1)). }
false;public;0;7;;public void testBadAnalyzer() throws IOException {     MatchPhrasePrefixQueryBuilder matchQuery = new MatchPhrasePrefixQueryBuilder("fieldName", "text").     matchQuery.analyzer("bogusAnalyzer").     QueryShardException e = expectThrows(QueryShardException.class, () -> matchQuery.toQuery(createShardContext())).     assertThat(e.getMessage(), containsString("analyzer [bogusAnalyzer] not found")). }
false;public;0;5;;public void testPhraseOnFieldWithNoTerms() {     MatchPhrasePrefixQueryBuilder matchQuery = new MatchPhrasePrefixQueryBuilder(DATE_FIELD_NAME, "three term phrase").     matchQuery.analyzer("whitespace").     expectThrows(IllegalArgumentException.class, () -> matchQuery.doToQuery(createShardContext())). }
false;public;0;41;;public void testPhrasePrefixMatchQuery() throws IOException {     String json1 = "{\n" + "    \"match_phrase_prefix\" : {\n" + "        \"message\" : \"this is a test\"\n" + "    }\n" + "}".     String expected = "{\n" + "  \"match_phrase_prefix\" : {\n" + "    \"message\" : {\n" + "      \"query\" : \"this is a test\",\n" + "      \"slop\" : 0,\n" + "      \"max_expansions\" : 50,\n" + "      \"boost\" : 1.0\n" + "    }\n" + "  }\n" + "}".     MatchPhrasePrefixQueryBuilder qb = (MatchPhrasePrefixQueryBuilder) parseQuery(json1).     checkGeneratedJson(expected, qb).     String json3 = "{\n" + "    \"match_phrase_prefix\" : {\n" + "        \"message\" : {\n" + "            \"query\" : \"this is a test\",\n" + "            \"max_expansions\" : 10\n" + "        }\n" + "    }\n" + "}".     expected = "{\n" + "  \"match_phrase_prefix\" : {\n" + "    \"message\" : {\n" + "      \"query\" : \"this is a test\",\n" + "      \"slop\" : 0,\n" + "      \"max_expansions\" : 10,\n" + "      \"boost\" : 1.0\n" + "    }\n" + "  }\n" + "}".     qb = (MatchPhrasePrefixQueryBuilder) parseQuery(json3).     checkGeneratedJson(expected, qb). }
false;public;0;23;;public void testParseFailsWithMultipleFields() throws IOException {     String json = "{\n" + "  \"match_phrase_prefix\" : {\n" + "    \"message1\" : {\n" + "      \"query\" : \"this is a test\"\n" + "    },\n" + "    \"message2\" : {\n" + "      \"query\" : \"this is a test\"\n" + "    }\n" + "  }\n" + "}".     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(json)).     assertEquals("[match_phrase_prefix] query doesn't support multiple fields, found [message1] and [message2]", e.getMessage()).     String shortJson = "{\n" + "  \"match_phrase_prefix\" : {\n" + "    \"message1\" : \"this is a test\",\n" + "    \"message2\" : \"this is a test\"\n" + "  }\n" + "}".     e = expectThrows(ParsingException.class, () -> parseQuery(shortJson)).     assertEquals("[match_phrase_prefix] query doesn't support multiple fields, found [message1] and [message2]", e.getMessage()). }
