commented;modifiers;parameterAmount;loc;comment;code
false;public;0;38;;@Before public void setup() throws IOException {     shardId = new ShardId("index0", "_na_", 0).     final String nodeId = randomAlphaOfLength(10).     routing = TestShardRouting.newShardRouting(shardId, nodeId, true, ShardRoutingState.INITIALIZING, RecoverySource.EmptyStoreRecoverySource.INSTANCE).     dataDir = createTempDir().     environment = TestEnvironment.newEnvironment(Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), dataDir).putList(Environment.PATH_DATA_SETTING.getKey(), dataDir.toAbsolutePath().toString()).build()).     // create same directory structure as prod does     final Path path = NodeEnvironment.resolveNodePath(dataDir, 0).     Files.createDirectories(path).     settings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(MergePolicyConfig.INDEX_MERGE_ENABLED, false).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0).build().     final NodeEnvironment.NodePath nodePath = new NodeEnvironment.NodePath(path).     shardPath = new ShardPath(false, nodePath.resolve(shardId), nodePath.resolve(shardId), shardId).     final IndexMetaData.Builder metaData = IndexMetaData.builder(routing.getIndexName()).settings(settings).primaryTerm(0, randomIntBetween(1, 100)).putMapping("_doc", "{ \"properties\": {} }").     indexMetaData = metaData.build().     indexShard = newStartedShard(p -> newShard(routing, shardPath, indexMetaData, null, null, new InternalEngineFactory(), () -> {     }, RetentionLeaseSyncer.EMPTY, EMPTY_EVENT_LISTENER), true).     translogPath = shardPath.resolveTranslog().     indexPath = shardPath.resolveIndex(). }
false;public;0;29;;public void testShardLock() throws Exception {     indexDocs(indexShard, true).     final RemoveCorruptedShardDataCommand command = new RemoveCorruptedShardDataCommand().     final MockTerminal t = new MockTerminal().     final OptionParser parser = command.getParser().     // Try running it before the shard is closed, it should flip out because it can't acquire the lock     try {         final OptionSet options = parser.parse("-d", indexPath.toString()).         command.execute(t, options, environment).         fail("expected the command to fail not being able to acquire the lock").     } catch (Exception e) {         assertThat(e.getMessage(), containsString("Failed to lock shard's directory")).     }     // close shard     closeShards(indexShard).     // Try running it before the shard is corrupted     try {         final OptionSet options = parser.parse("-d", indexPath.toString()).         command.execute(t, options, environment).         fail("expected the command to fail not being able to find a corrupt file marker").     } catch (ElasticsearchException e) {         assertThat(e.getMessage(), startsWith("Shard does not seem to be corrupted at")).         assertThat(t.getOutput(), containsString("Lucene index is clean at")).     } }
false;public;0;61;;public void testCorruptedIndex() throws Exception {     final int numDocs = indexDocs(indexShard, true).     // close shard     closeShards(indexShard).     final boolean corruptSegments = randomBoolean().     CorruptionUtils.corruptIndex(random(), indexPath, corruptSegments).     // test corrupted shard     final IndexShard corruptedShard = reopenIndexShard(true).     allowShardFailures().     expectThrows(IndexShardRecoveryException.class, () -> newStartedShard(p -> corruptedShard, true)).     closeShards(corruptedShard).     final RemoveCorruptedShardDataCommand command = new RemoveCorruptedShardDataCommand().     final MockTerminal t = new MockTerminal().     final OptionParser parser = command.getParser().     // run command with dry-run     // mean dry run     t.addTextInput("n").     final OptionSet options = parser.parse("-d", indexPath.toString()).     t.setVerbosity(Terminal.Verbosity.VERBOSE).     try {         command.execute(t, options, environment).         fail().     } catch (ElasticsearchException e) {         if (corruptSegments) {             assertThat(e.getMessage(), either(is("Index is unrecoverable")).or(startsWith("unable to list commits"))).         } else {             assertThat(e.getMessage(), containsString("aborted by user")).         }     } finally {         logger.info("--> output:\n{}", t.getOutput()).     }     if (corruptSegments == false) {         // run command without dry-run         t.addTextInput("y").         command.execute(t, options, environment).         final String output = t.getOutput().         logger.info("--> output:\n{}", output).         // reopen shard         failOnShardFailures().         final IndexShard newShard = newStartedShard(p -> reopenIndexShard(false), true).         final Set<String> shardDocUIDs = getShardDocUIDs(newShard).         final Pattern pattern = Pattern.compile("Corrupted Lucene index segments found -\\s+(?<docs>\\d+) documents will be lost.").         final Matcher matcher = pattern.matcher(output).         assertThat(matcher.find(), equalTo(true)).         final int expectedNumDocs = numDocs - Integer.parseInt(matcher.group("docs")).         assertThat(shardDocUIDs.size(), equalTo(expectedNumDocs)).         closeShards(newShard).     } }
false;public;0;55;;public void testCorruptedTranslog() throws Exception {     final int numDocsToKeep = indexDocs(indexShard, false).     // close shard     closeShards(indexShard).     TestTranslog.corruptRandomTranslogFile(logger, random(), Arrays.asList(translogPath)).     // test corrupted shard     final IndexShard corruptedShard = reopenIndexShard(true).     allowShardFailures().     // it has to fail on start up due to index.shard.check_on_startup = checksum     final Exception exception = expectThrows(Exception.class, () -> newStartedShard(p -> corruptedShard, true)).     final Throwable cause = exception.getCause() instanceof EngineException ? exception.getCause().getCause() : exception.getCause().     assertThat(cause, instanceOf(TranslogCorruptedException.class)).     // translog is corrupted already - do not check consistency     closeShard(corruptedShard, false).     final RemoveCorruptedShardDataCommand command = new RemoveCorruptedShardDataCommand().     final MockTerminal t = new MockTerminal().     final OptionParser parser = command.getParser().     final OptionSet options = parser.parse("-d", translogPath.toString()).     // run command with dry-run     // mean dry run     t.addTextInput("n").     t.setVerbosity(Terminal.Verbosity.VERBOSE).     try {         command.execute(t, options, environment).         fail().     } catch (ElasticsearchException e) {         assertThat(e.getMessage(), containsString("aborted by user")).         assertThat(t.getOutput(), containsString("Continue and remove corrupted data from the shard ?")).     }     logger.info("--> output:\n{}", t.getOutput()).     // run command without dry-run     t.reset().     t.addTextInput("y").     command.execute(t, options, environment).     final String output = t.getOutput().     logger.info("--> output:\n{}", output).     // reopen shard     failOnShardFailures().     final IndexShard newShard = newStartedShard(p -> reopenIndexShard(false), true).     final Set<String> shardDocUIDs = getShardDocUIDs(newShard).     assertThat(shardDocUIDs.size(), equalTo(numDocsToKeep)).     closeShards(newShard). }
false;public;0;59;;public void testCorruptedBothIndexAndTranslog() throws Exception {     // index some docs in several segments     final int numDocsToKeep = indexDocs(indexShard, false).     // close shard     closeShards(indexShard).     CorruptionUtils.corruptIndex(random(), indexPath, false).     // test corrupted shard     final IndexShard corruptedShard = reopenIndexShard(true).     allowShardFailures().     expectThrows(IndexShardRecoveryException.class, () -> newStartedShard(p -> corruptedShard, true)).     closeShards(corruptedShard).     TestTranslog.corruptRandomTranslogFile(logger, random(), Arrays.asList(translogPath)).     final RemoveCorruptedShardDataCommand command = new RemoveCorruptedShardDataCommand().     final MockTerminal t = new MockTerminal().     final OptionParser parser = command.getParser().     final OptionSet options = parser.parse("-d", translogPath.toString()).     // run command with dry-run     // mean dry run     t.addTextInput("n").     // mean dry run     t.addTextInput("n").     t.setVerbosity(Terminal.Verbosity.VERBOSE).     try {         command.execute(t, options, environment).         fail().     } catch (ElasticsearchException e) {         assertThat(e.getMessage(), containsString("aborted by user")).         assertThat(t.getOutput(), containsString("Continue and remove corrupted data from the shard ?")).     }     logger.info("--> output:\n{}", t.getOutput()).     // run command without dry-run     t.reset().     t.addTextInput("y").     command.execute(t, options, environment).     final String output = t.getOutput().     logger.info("--> output:\n{}", output).     // reopen shard     failOnShardFailures().     final IndexShard newShard = newStartedShard(p -> reopenIndexShard(false), true).     final Set<String> shardDocUIDs = getShardDocUIDs(newShard).     final Pattern pattern = Pattern.compile("Corrupted Lucene index segments found -\\s+(?<docs>\\d+) documents will be lost.").     final Matcher matcher = pattern.matcher(output).     assertThat(matcher.find(), equalTo(true)).     final int expectedNumDocs = numDocsToKeep - Integer.parseInt(matcher.group("docs")).     assertThat(shardDocUIDs.size(), equalTo(expectedNumDocs)).     closeShards(newShard). }
false;public;0;23;;public void testResolveIndexDirectory() throws Exception {     // index a single doc to have files on a disk     indexDoc(indexShard, "_doc", "0", "{}").     flushShard(indexShard, true).     writeIndexState().     // close shard     closeShards(indexShard).     final RemoveCorruptedShardDataCommand command = new RemoveCorruptedShardDataCommand().     final OptionParser parser = command.getParser().     // `--index index_name --shard-id 0` has to be resolved to indexPath     final OptionSet options = parser.parse("--index", shardId.getIndex().getName(), "--shard-id", Integer.toString(shardId.id())).     command.findAndProcessShardPath(options, environment, shardPath -> assertThat(shardPath.resolveIndex(), equalTo(indexPath))).     final OptionSet options2 = parser.parse("--dir", indexPath.toAbsolutePath().toString()).     command.findAndProcessShardPath(options2, environment, shardPath -> assertThat(shardPath.resolveIndex(), equalTo(indexPath))). }
false;private;1;25;;private IndexShard reopenIndexShard(boolean corrupted) throws IOException {     // open shard with the same location     final ShardRouting shardRouting = ShardRoutingHelper.initWithSameId(indexShard.routingEntry(), RecoverySource.ExistingStoreRecoverySource.INSTANCE).     final IndexMetaData metaData = IndexMetaData.builder(indexMetaData).settings(Settings.builder().put(indexShard.indexSettings().getSettings()).put(IndexSettings.INDEX_CHECK_ON_STARTUP.getKey(), "checksum")).build().     CheckedFunction<IndexSettings, Store, IOException> storeProvider = corrupted == false ? null : indexSettings -> {         final ShardId shardId = shardPath.getShardId().         final BaseDirectoryWrapper baseDirectoryWrapper = newFSDirectory(shardPath.resolveIndex()).         baseDirectoryWrapper.setCheckIndexOnClose(false).         return new Store(shardId, indexSettings, baseDirectoryWrapper, new DummyShardLock(shardId)).     }.     return newShard(shardRouting, shardPath, metaData, storeProvider, null, indexShard.engineFactory, indexShard.getGlobalCheckpointSyncer(), indexShard.getRetentionLeaseSyncer(), EMPTY_EVENT_LISTENER). }
false;private;2;22;;private int indexDocs(IndexShard indexShard, boolean flushLast) throws IOException {     // index some docs in several segments     int numDocs = 0.     int numDocsToKeep = 0.     for (int i = 0, attempts = randomIntBetween(5, 10). i < attempts. i++) {         final int numExtraDocs = between(10, 100).         for (long j = 0. j < numExtraDocs. j++) {             indexDoc(indexShard, "_doc", Long.toString(numDocs + j), "{}").         }         numDocs += numExtraDocs.         if (flushLast || i < attempts - 1) {             numDocsToKeep += numExtraDocs.             flushShard(indexShard, true).         }     }     logger.info("--> indexed {} docs, {} to keep", numDocs, numDocsToKeep).     writeIndexState().     return numDocsToKeep. }
false;private;0;8;;private void writeIndexState() throws IOException {     // create _state of IndexMetaData     try (NodeEnvironment nodeEnvironment = new NodeEnvironment(environment.settings(), environment)) {         final Path[] paths = nodeEnvironment.indexPaths(indexMetaData.getIndex()).         IndexMetaData.FORMAT.writeAndCleanup(indexMetaData, paths).         logger.info("--> index metadata persisted to {} ", Arrays.toString(paths)).     } }
