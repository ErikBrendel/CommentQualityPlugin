# id;timestamp;commentText;codeText;commentWords;codeWords
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1524684173;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            assertThat(replica.estimateTranslogOperationsFromMinSeq(0), equalTo(numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,assert,that,replica,estimate,translog,operations,from,min,seq,0,equal,to,num,docs,shards,assert,all,equal,num,docs
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1525162917;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            assertThat(replica.estimateTranslogOperationsFromMinSeq(0), equalTo(numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,assert,that,replica,estimate,translog,operations,from,min,seq,0,equal,to,num,docs,shards,assert,all,equal,num,docs
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1531910483;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            assertThat(replica.estimateTranslogOperationsFromMinSeq(0), equalTo(numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,assert,that,replica,estimate,translog,operations,from,min,seq,0,equal,to,num,docs,shards,assert,all,equal,num,docs
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1533295538;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            assertThat(replica.estimateTranslogOperationsFromMinSeq(0), equalTo(numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,assert,that,replica,estimate,translog,operations,from,min,seq,0,equal,to,num,docs,shards,assert,all,equal,num,docs
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1534203100;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            assertThat(replica.estimateTranslogOperationsFromMinSeq(0), equalTo(numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,assert,that,replica,estimate,translog,operations,from,min,seq,0,equal,to,num,docs,shards,assert,all,equal,num,docs
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1534539448;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            assertThat(replica.estimateTranslogOperationsFromMinSeq(0), equalTo(numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,assert,that,replica,estimate,translog,operations,from,min,seq,0,equal,to,num,docs,shards,assert,all,equal,num,docs
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1534848846;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            assertThat(replica.estimateTranslogOperationsFromMinSeq(0), equalTo(numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,assert,that,replica,estimate,translog,operations,from,min,seq,0,equal,to,num,docs,shards,assert,all,equal,num,docs
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1535723122;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            boolean softDeletesEnabled = replica.indexSettings().isSoftDeleteEnabled()__            assertThat(getTranslog(replica).totalOperations(), equalTo(softDeletesEnabled ? 0 : numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,boolean,soft,deletes,enabled,replica,index,settings,is,soft,delete,enabled,assert,that,get,translog,replica,total,operations,equal,to,soft,deletes,enabled,0,num,docs,shards,assert,all,equal,num,docs
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1538067637;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            boolean softDeletesEnabled = replica.indexSettings().isSoftDeleteEnabled()__            assertThat(getTranslog(replica).totalOperations(), equalTo(softDeletesEnabled ? 0 : numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,boolean,soft,deletes,enabled,replica,index,settings,is,soft,delete,enabled,assert,that,get,translog,replica,total,operations,equal,to,soft,deletes,enabled,0,num,docs,shards,assert,all,equal,num,docs
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1544893197;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            boolean softDeletesEnabled = replica.indexSettings().isSoftDeleteEnabled()__            assertThat(getTranslog(replica).totalOperations(), equalTo(softDeletesEnabled ? 0 : numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,boolean,soft,deletes,enabled,replica,index,settings,is,soft,delete,enabled,assert,that,get,translog,replica,total,operations,equal,to,soft,deletes,enabled,0,num,docs,shards,assert,all,equal,num,docs
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1545678410;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            boolean softDeletesEnabled = replica.indexSettings().isSoftDeleteEnabled()__            assertThat(getTranslog(replica).totalOperations(), equalTo(softDeletesEnabled ? 0 : numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,boolean,soft,deletes,enabled,replica,index,settings,is,soft,delete,enabled,assert,that,get,translog,replica,total,operations,equal,to,soft,deletes,enabled,0,num,docs,shards,assert,all,equal,num,docs
RecoveryTests -> public void testShouldFlushAfterPeerRecovery() throws Exception;1550220204;This test makes sure that there is no infinite loop of flushing (the condition `shouldPeriodicallyFlush` eventually is false)_in peer-recovery if a primary sends a fully-baked index commit.;public void testShouldFlushAfterPeerRecovery() throws Exception {_        try (ReplicationGroup shards = createGroup(0)) {_            shards.startAll()__            int numDocs = shards.indexDocs(between(10, 100))__            final long translogSizeOnPrimary = shards.getPrimary().translogStats().getUncommittedSizeInBytes()__            shards.flush()___            final IndexShard replica = shards.addReplica()__            IndexMetaData.Builder builder = IndexMetaData.builder(replica.indexSettings().getIndexMetaData())__            long flushThreshold = RandomNumbers.randomLongBetween(random(), 100, translogSizeOnPrimary)__            builder.settings(Settings.builder().put(replica.indexSettings().getSettings())_                .put(IndexSettings.INDEX_TRANSLOG_FLUSH_THRESHOLD_SIZE_SETTING.getKey(), flushThreshold + "b")_            )__            replica.indexSettings().updateIndexMetaData(builder.build())__            replica.onSettingsChanged()__            shards.recoverReplica(replica)__            _            assertBusy(() -> assertThat(getEngine(replica).shouldPeriodicallyFlush(), equalTo(false)))__            assertThat(getTranslog(replica).totalOperations(), equalTo(numDocs))__            shards.assertAllEqual(numDocs)__        }_    };this,test,makes,sure,that,there,is,no,infinite,loop,of,flushing,the,condition,should,periodically,flush,eventually,is,false,in,peer,recovery,if,a,primary,sends,a,fully,baked,index,commit;public,void,test,should,flush,after,peer,recovery,throws,exception,try,replication,group,shards,create,group,0,shards,start,all,int,num,docs,shards,index,docs,between,10,100,final,long,translog,size,on,primary,shards,get,primary,translog,stats,get,uncommitted,size,in,bytes,shards,flush,final,index,shard,replica,shards,add,replica,index,meta,data,builder,builder,index,meta,data,builder,replica,index,settings,get,index,meta,data,long,flush,threshold,random,numbers,random,long,between,random,100,translog,size,on,primary,builder,settings,settings,builder,put,replica,index,settings,get,settings,put,index,settings,get,key,flush,threshold,b,replica,index,settings,update,index,meta,data,builder,build,replica,on,settings,changed,shards,recover,replica,replica,assert,busy,assert,that,get,engine,replica,should,periodically,flush,equal,to,false,assert,that,get,translog,replica,total,operations,equal,to,num,docs,shards,assert,all,equal,num,docs
