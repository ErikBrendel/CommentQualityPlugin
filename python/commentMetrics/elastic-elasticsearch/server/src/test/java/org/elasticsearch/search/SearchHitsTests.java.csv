# id;timestamp;commentText;codeText;commentWords;codeWords
SearchHitsTests -> public void testFromXContentLenientParsing() throws IOException;1524684173;This test adds randomized fields on all json objects and checks that we_can parse it to ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field_name since these objects allow arbitrary keys (the field names that are_queries). Also we want to exclude to add anything under "_source" since_it is not parsed.;public void testFromXContentLenientParsing() throws IOException {_        SearchHits searchHits = createTestItem()__        XContentType xcontentType = randomFrom(XContentType.values())__        BytesReference originalBytes = toXContent(searchHits, xcontentType, ToXContent.EMPTY_PARAMS, true)__        Predicate<String> pathsToExclude = path -> (path.isEmpty() || path.endsWith("highlight") || path.endsWith("fields")_                || path.contains("_source"))__        BytesReference withRandomFields = insertRandomFields(xcontentType, originalBytes, pathsToExclude, random())__        SearchHits parsed = null__        try (XContentParser parser = createParser(xcontentType.xContent(), withRandomFields)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(SearchHits.Fields.HITS, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            parsed = SearchHits.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertEquals(XContentParser.Token.END_OBJECT, parser.nextToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xcontentType, true), xcontentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,search,hits,search,hits,create,test,item,xcontent,type,xcontent,type,random,from,xcontent,type,values,bytes,reference,original,bytes,to,xcontent,search,hits,xcontent,type,to,xcontent,true,predicate,string,paths,to,exclude,path,path,is,empty,path,ends,with,highlight,path,ends,with,fields,path,contains,bytes,reference,with,random,fields,insert,random,fields,xcontent,type,original,bytes,paths,to,exclude,random,search,hits,parsed,null,try,xcontent,parser,parser,create,parser,xcontent,type,x,content,with,random,fields,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,search,hits,fields,hits,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,parsed,search,hits,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,equals,xcontent,parser,token,parser,next,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,xcontent,type,true,xcontent,type
SearchHitsTests -> public void testFromXContentLenientParsing() throws IOException;1536314350;This test adds randomized fields on all json objects and checks that we_can parse it to ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field_name since these objects allow arbitrary keys (the field names that are_queries). Also we want to exclude to add anything under "_source" since_it is not parsed.;public void testFromXContentLenientParsing() throws IOException {_        SearchHits searchHits = createTestItem()__        XContentType xcontentType = randomFrom(XContentType.values())__        BytesReference originalBytes = toXContent(searchHits, xcontentType, ToXContent.EMPTY_PARAMS, true)__        Predicate<String> pathsToExclude = path -> (path.isEmpty() || path.endsWith("highlight") || path.endsWith("fields")_                || path.contains("_source"))__        BytesReference withRandomFields = insertRandomFields(xcontentType, originalBytes, pathsToExclude, random())__        SearchHits parsed = null__        try (XContentParser parser = createParser(xcontentType.xContent(), withRandomFields)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(SearchHits.Fields.HITS, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            parsed = SearchHits.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertEquals(XContentParser.Token.END_OBJECT, parser.nextToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xcontentType, true), xcontentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,search,hits,search,hits,create,test,item,xcontent,type,xcontent,type,random,from,xcontent,type,values,bytes,reference,original,bytes,to,xcontent,search,hits,xcontent,type,to,xcontent,true,predicate,string,paths,to,exclude,path,path,is,empty,path,ends,with,highlight,path,ends,with,fields,path,contains,bytes,reference,with,random,fields,insert,random,fields,xcontent,type,original,bytes,paths,to,exclude,random,search,hits,parsed,null,try,xcontent,parser,parser,create,parser,xcontent,type,x,content,with,random,fields,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,search,hits,fields,hits,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,parsed,search,hits,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,equals,xcontent,parser,token,parser,next,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,xcontent,type,true,xcontent,type
SearchHitsTests -> public void testFromXContentLenientParsing() throws IOException;1544035746;This test adds randomized fields on all json objects and checks that we_can parse it to ensure the parsing is lenient for forward compatibility._We need to exclude json objects with the "highlight" and "fields" field_name since these objects allow arbitrary keys (the field names that are_queries). Also we want to exclude to add anything under "_source" since_it is not parsed.;public void testFromXContentLenientParsing() throws IOException {_        SearchHits searchHits = createTestItem()__        XContentType xcontentType = randomFrom(XContentType.values())__        BytesReference originalBytes = toXContent(searchHits, xcontentType, ToXContent.EMPTY_PARAMS, true)__        Predicate<String> pathsToExclude = path -> (path.isEmpty() || path.endsWith("highlight") || path.endsWith("fields")_                || path.contains("_source"))__        BytesReference withRandomFields = insertRandomFields(xcontentType, originalBytes, pathsToExclude, random())__        SearchHits parsed = null__        try (XContentParser parser = createParser(xcontentType.xContent(), withRandomFields)) {_            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            assertEquals(XContentParser.Token.FIELD_NAME, parser.nextToken())__            assertEquals(SearchHits.Fields.HITS, parser.currentName())__            assertEquals(XContentParser.Token.START_OBJECT, parser.nextToken())__            parsed = SearchHits.fromXContent(parser)__            assertEquals(XContentParser.Token.END_OBJECT, parser.currentToken())__            assertEquals(XContentParser.Token.END_OBJECT, parser.nextToken())__            assertNull(parser.nextToken())__        }_        assertToXContentEquivalent(originalBytes, toXContent(parsed, xcontentType, true), xcontentType)__    };this,test,adds,randomized,fields,on,all,json,objects,and,checks,that,we,can,parse,it,to,ensure,the,parsing,is,lenient,for,forward,compatibility,we,need,to,exclude,json,objects,with,the,highlight,and,fields,field,name,since,these,objects,allow,arbitrary,keys,the,field,names,that,are,queries,also,we,want,to,exclude,to,add,anything,under,since,it,is,not,parsed;public,void,test,from,xcontent,lenient,parsing,throws,ioexception,search,hits,search,hits,create,test,item,xcontent,type,xcontent,type,random,from,xcontent,type,values,bytes,reference,original,bytes,to,xcontent,search,hits,xcontent,type,to,xcontent,true,predicate,string,paths,to,exclude,path,path,is,empty,path,ends,with,highlight,path,ends,with,fields,path,contains,bytes,reference,with,random,fields,insert,random,fields,xcontent,type,original,bytes,paths,to,exclude,random,search,hits,parsed,null,try,xcontent,parser,parser,create,parser,xcontent,type,x,content,with,random,fields,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,xcontent,parser,token,parser,next,token,assert,equals,search,hits,fields,hits,parser,current,name,assert,equals,xcontent,parser,token,parser,next,token,parsed,search,hits,from,xcontent,parser,assert,equals,xcontent,parser,token,parser,current,token,assert,equals,xcontent,parser,token,parser,next,token,assert,null,parser,next,token,assert,to,xcontent,equivalent,original,bytes,to,xcontent,parsed,xcontent,type,true,xcontent,type
