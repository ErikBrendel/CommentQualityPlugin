commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;60;;@Override protected MovAvgPipelineAggregationBuilder createTestAggregatorFactory() {     String name = randomAlphaOfLengthBetween(3, 20).     String bucketsPath = randomAlphaOfLengthBetween(3, 20).     MovAvgPipelineAggregationBuilder factory = new MovAvgPipelineAggregationBuilder(name, bucketsPath).     if (randomBoolean()) {         factory.format(randomAlphaOfLengthBetween(1, 10)).     }     if (randomBoolean()) {         factory.gapPolicy(randomFrom(GapPolicy.values())).     }     if (randomBoolean()) {         switch(randomInt(4)) {             case 0:                 factory.modelBuilder(new SimpleModel.SimpleModelBuilder()).                 factory.window(randomIntBetween(1, 100)).                 break.             case 1:                 factory.modelBuilder(new LinearModel.LinearModelBuilder()).                 factory.window(randomIntBetween(1, 100)).                 break.             case 2:                 if (randomBoolean()) {                     factory.modelBuilder(new EwmaModel.EWMAModelBuilder()).                     factory.window(randomIntBetween(1, 100)).                 } else {                     factory.modelBuilder(new EwmaModel.EWMAModelBuilder().alpha(randomDouble())).                     factory.window(randomIntBetween(1, 100)).                 }                 break.             case 3:                 if (randomBoolean()) {                     factory.modelBuilder(new HoltLinearModel.HoltLinearModelBuilder()).                     factory.window(randomIntBetween(1, 100)).                 } else {                     factory.modelBuilder(new HoltLinearModel.HoltLinearModelBuilder().alpha(randomDouble()).beta(randomDouble())).                     factory.window(randomIntBetween(1, 100)).                 }                 break.             case 4:             default:                 if (randomBoolean()) {                     factory.modelBuilder(new HoltWintersModel.HoltWintersModelBuilder()).                     factory.window(randomIntBetween(2, 100)).                 } else {                     int period = randomIntBetween(1, 100).                     factory.modelBuilder(new HoltWintersModel.HoltWintersModelBuilder().alpha(randomDouble()).beta(randomDouble()).gamma(randomDouble()).period(period).seasonalityType(randomFrom(SeasonalityType.values())).pad(randomBoolean())).                     factory.window(randomIntBetween(2 * period, 200 * period)).                 }                 break.         }     }     factory.predict(randomIntBetween(1, 50)).     if (factory.model().canBeMinimized() && randomBoolean()) {         factory.minimize(randomBoolean()).     }     return factory. }
false;public;0;5;;@Override public void testFromXContent() throws IOException {     super.testFromXContent().     assertWarnings("The moving_avg aggregation has been deprecated in favor of the moving_fn aggregation."). }
false;public;0;15;;public void testDefaultParsing() throws Exception {     MovAvgPipelineAggregationBuilder expected = new MovAvgPipelineAggregationBuilder("commits_moving_avg", "commits").     String json = "{" + "    \"commits_moving_avg\": {" + "        \"moving_avg\": {" + "            \"buckets_path\": \"commits\"" + "        }" + "    }" + "}".     PipelineAggregationBuilder newAgg = parse(createParser(JsonXContent.jsonXContent, json)).     assertWarnings("The moving_avg aggregation has been deprecated in favor of the moving_fn aggregation.").     assertNotSame(newAgg, expected).     assertEquals(expected, newAgg).     assertEquals(expected.hashCode(), newAgg.hashCode()). }
true;public;0;7;/**  * The validation should verify the parent aggregation is allowed.  */ ;/**  * The validation should verify the parent aggregation is allowed.  */ public void testValidate() throws IOException {     final Set<PipelineAggregationBuilder> aggBuilders = new HashSet<>().     aggBuilders.add(createTestAggregatorFactory()).     final MovAvgPipelineAggregationBuilder builder = new MovAvgPipelineAggregationBuilder("name", "valid").     builder.validate(PipelineAggregationHelperTests.getRandomSequentiallyOrderedParentAgg(), Collections.emptySet(), aggBuilders). }
true;public;0;11;/**  * The validation should throw an IllegalArgumentException, since parent  * aggregation is not a type of HistogramAggregatorFactory,  * DateHistogramAggregatorFactory or AutoDateHistogramAggregatorFactory.  */ ;/**  * The validation should throw an IllegalArgumentException, since parent  * aggregation is not a type of HistogramAggregatorFactory,  * DateHistogramAggregatorFactory or AutoDateHistogramAggregatorFactory.  */ public void testValidateException() throws IOException {     final Set<PipelineAggregationBuilder> aggBuilders = new HashSet<>().     aggBuilders.add(createTestAggregatorFactory()).     TestAggregatorFactory parentFactory = TestAggregatorFactory.createInstance().     final MovAvgPipelineAggregationBuilder builder = new MovAvgPipelineAggregationBuilder("name", "invalid_agg>metric").     IllegalStateException ex = expectThrows(IllegalStateException.class, () -> builder.validate(parentFactory, Collections.emptySet(), aggBuilders)).     assertEquals("moving_avg aggregation [name] must have a histogram, date_histogram or auto_date_histogram as parent", ex.getMessage()). }
