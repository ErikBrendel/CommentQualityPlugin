commented;modifiers;parameterAmount;loc;comment;code
false;public;0;61;;@Override @Before public void setUp() throws Exception {     super.setUp().     globalBlock = randomBoolean().     RestStatus restStatus = randomFrom(RestStatus.values()).     block = new ClusterBlock(randomIntBetween(1, 10), randomAlphaOfLength(5), false, true, false, restStatus, ClusterBlockLevel.ALL).     clusterService = createClusterService(threadPool).     final ClusterState.Builder state = ClusterState.builder(clusterService.state()).     Set<DiscoveryNode.Role> roles = new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())).     DiscoveryNode node1 = new DiscoveryNode("_name1", "_node1", buildNewFakeTransportAddress(), emptyMap(), roles, Version.CURRENT).     DiscoveryNode node2 = new DiscoveryNode("_name2", "_node2", buildNewFakeTransportAddress(), emptyMap(), roles, Version.CURRENT).     state.nodes(DiscoveryNodes.builder().add(node1).add(node2).localNodeId(node1.getId()).masterNodeId(node1.getId())).     shardId = new ShardId("index", UUID.randomUUID().toString(), 0).     ShardRouting shardRouting = newShardRouting(shardId, node1.getId(), true, ShardRoutingState.INITIALIZING, RecoverySource.EmptyStoreRecoverySource.INSTANCE).     Settings indexSettings = Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).put(SETTING_INDEX_UUID, shardId.getIndex().getUUID()).put(SETTING_NUMBER_OF_SHARDS, 1).put(SETTING_NUMBER_OF_REPLICAS, 1).put(SETTING_CREATION_DATE, System.currentTimeMillis()).build().     primary = newStartedShard(p -> newShard(shardRouting, indexSettings, new InternalEngineFactory()), true).     for (int i = 0. i < 10. i++) {         final String id = Integer.toString(i).         indexDoc(primary, "_doc", id, "{\"value\":" + id + "}").     }     IndexMetaData indexMetaData = IndexMetaData.builder(shardId.getIndexName()).settings(indexSettings).primaryTerm(shardId.id(), primary.getOperationPrimaryTerm()).putMapping("_doc", "{ \"properties\": { \"value\":  { \"type\": \"short\"}}}").build().     state.metaData(MetaData.builder().put(indexMetaData, false).generateClusterUuidIfNeeded()).     replica = newShard(primary.shardId(), false, node2.getId(), indexMetaData, null).     recoverReplica(replica, primary, true).     IndexRoutingTable.Builder routing = IndexRoutingTable.builder(indexMetaData.getIndex()).     routing.addIndexShard(new IndexShardRoutingTable.Builder(shardId).addShard(primary.routingEntry()).build()).     state.routingTable(RoutingTable.builder().add(routing.build()).build()).     setState(clusterService, state.build()).     final Settings transportSettings = Settings.builder().put("node.name", node1.getId()).build().     transportService = MockTransportService.createNewService(transportSettings, Version.CURRENT, threadPool, null).     transportService.start().     transportService.acceptIncomingRequests().     shardStateAction = new ShardStateAction(clusterService, transportService, null, null, threadPool). }
false;public;0;8;;@Override @After public void tearDown() throws Exception {     closeShards(primary, replica).     transportService.stop().     clusterService.close().     super.tearDown(). }
false;protected;0;8;;@Override protected void doRun() throws Exception {     if (delayed) {         logger.trace("op [{}] has started and will resume execution once allPermitsAction is terminated", threadId).         delayedOperationsBarrier.await().     }     super.doRun(). }
false;;1;7;;@Override void runWithPrimaryShardReference(final TransportReplicationAction.PrimaryShardReference reference) {     assertThat(reference.indexShard.getActiveOperationsCount(), greaterThan(0)).     assertSame(primary, reference.indexShard).     assertBlockIsPresentForDelayedOp().     super.runWithPrimaryShardReference(reference). }
false;public;1;5;;@Override public void onFailure(Exception e) {     assertBlockIsPresentForDelayedOp().     super.onFailure(e). }
false;private;0;11;;private void assertBlockIsPresentForDelayedOp() {     if (delayed) {         final ClusterState clusterState = clusterService.state().         if (globalBlock) {             assertTrue("Global block must exist", clusterState.blocks().hasGlobalBlock(block)).         } else {             String indexName = primary.shardId().getIndexName().             assertTrue("Index block must exist", clusterState.blocks().hasIndexBlock(indexName, block)).         }     } }
false;;1;27;;@Override void runWithPrimaryShardReference(final TransportReplicationAction.PrimaryShardReference reference) {     assertEquals("All permits must be acquired", 0, reference.indexShard.getActiveOperationsCount()).     assertSame(primary, reference.indexShard).     final ClusterState clusterState = clusterService.state().     final ClusterBlocks.Builder blocks = ClusterBlocks.builder().     if (globalBlock) {         assertFalse("Global block must not exist yet", clusterState.blocks().hasGlobalBlock(block)).         blocks.addGlobalBlock(block).     } else {         String indexName = reference.indexShard.shardId().getIndexName().         assertFalse("Index block must not exist yet", clusterState.blocks().hasIndexBlock(indexName, block)).         blocks.addIndexBlock(indexName, block).     }     logger.trace("adding test block to cluster state {}", block).     setState(clusterService, ClusterState.builder(clusterState).blocks(blocks)).     try {         logger.trace("releasing delayed operations").         delayedOperationsBarrier.await().     } catch (InterruptedException | BrokenBarrierException e) {         onFailure(e).     }     super.runWithPrimaryShardReference(reference). }
false;public;0;136;;public void testTransportReplicationActionWithAllPermits() throws Exception {     final int numOperations = scaledRandomIntBetween(4, 32).     final int delayedOperations = randomIntBetween(1, numOperations).     logger.trace("starting [{}] operations, among which the first [{}] started ops should be blocked by [{}]", numOperations, delayedOperations, block).     final CyclicBarrier delayedOperationsBarrier = new CyclicBarrier(delayedOperations + 1).     final List<Thread> threads = new ArrayList<>(delayedOperationsBarrier.getParties()).     @SuppressWarnings("unchecked")     final PlainActionFuture<Response>[] futures = new PlainActionFuture[numOperations].     final TestAction[] actions = new TestAction[numOperations].     for (int i = 0. i < numOperations. i++) {         final int threadId = i.         final boolean delayed = (threadId < delayedOperations).         final PlainActionFuture<Response> listener = new PlainActionFuture<>().         futures[threadId] = listener.         final TestAction singlePermitAction = new SinglePermitWithBlocksAction(Settings.EMPTY, "internalSinglePermit[" + threadId + "]", transportService, clusterService, shardStateAction, threadPool, shardId, primary, replica, globalBlock).         actions[threadId] = singlePermitAction.         Thread thread = new Thread(() -> {             TransportReplicationAction.AsyncPrimaryAction asyncPrimaryAction = singlePermitAction.new AsyncPrimaryAction(request(), allocationId(), primaryTerm(), transportChannel(listener), null) {                  @Override                 protected void doRun() throws Exception {                     if (delayed) {                         logger.trace("op [{}] has started and will resume execution once allPermitsAction is terminated", threadId).                         delayedOperationsBarrier.await().                     }                     super.doRun().                 }                  @Override                 void runWithPrimaryShardReference(final TransportReplicationAction.PrimaryShardReference reference) {                     assertThat(reference.indexShard.getActiveOperationsCount(), greaterThan(0)).                     assertSame(primary, reference.indexShard).                     assertBlockIsPresentForDelayedOp().                     super.runWithPrimaryShardReference(reference).                 }                  @Override                 public void onFailure(Exception e) {                     assertBlockIsPresentForDelayedOp().                     super.onFailure(e).                 }                  private void assertBlockIsPresentForDelayedOp() {                     if (delayed) {                         final ClusterState clusterState = clusterService.state().                         if (globalBlock) {                             assertTrue("Global block must exist", clusterState.blocks().hasGlobalBlock(block)).                         } else {                             String indexName = primary.shardId().getIndexName().                             assertTrue("Index block must exist", clusterState.blocks().hasIndexBlock(indexName, block)).                         }                     }                 }             }.             asyncPrimaryAction.run().         }).         threads.add(thread).         thread.start().     }     logger.trace("now starting the operation that acquires all permits and sets the block in the cluster state").     // An action which acquires all operation permits during execution and set a block     final TestAction allPermitsAction = new AllPermitsThenBlockAction(Settings.EMPTY, "internalAllPermits", transportService, clusterService, shardStateAction, threadPool, shardId, primary, replica).     final PlainActionFuture<Response> allPermitFuture = new PlainActionFuture<>().     Thread thread = new Thread(() -> {         TransportReplicationAction.AsyncPrimaryAction asyncPrimaryAction = allPermitsAction.new AsyncPrimaryAction(request(), allocationId(), primaryTerm(), transportChannel(allPermitFuture), null) {              @Override             void runWithPrimaryShardReference(final TransportReplicationAction.PrimaryShardReference reference) {                 assertEquals("All permits must be acquired", 0, reference.indexShard.getActiveOperationsCount()).                 assertSame(primary, reference.indexShard).                 final ClusterState clusterState = clusterService.state().                 final ClusterBlocks.Builder blocks = ClusterBlocks.builder().                 if (globalBlock) {                     assertFalse("Global block must not exist yet", clusterState.blocks().hasGlobalBlock(block)).                     blocks.addGlobalBlock(block).                 } else {                     String indexName = reference.indexShard.shardId().getIndexName().                     assertFalse("Index block must not exist yet", clusterState.blocks().hasIndexBlock(indexName, block)).                     blocks.addIndexBlock(indexName, block).                 }                 logger.trace("adding test block to cluster state {}", block).                 setState(clusterService, ClusterState.builder(clusterState).blocks(blocks)).                 try {                     logger.trace("releasing delayed operations").                     delayedOperationsBarrier.await().                 } catch (InterruptedException | BrokenBarrierException e) {                     onFailure(e).                 }                 super.runWithPrimaryShardReference(reference).             }         }.         asyncPrimaryAction.run().     }).     threads.add(thread).     thread.start().     logger.trace("waiting for all operations to terminate").     for (Thread t : threads) {         t.join().     }     final Response allPermitsResponse = allPermitFuture.get().     assertSuccessfulOperation(allPermitsAction, allPermitsResponse).     for (int i = 0. i < numOperations. i++) {         final PlainActionFuture<Response> future = futures[i].         final TestAction action = actions[i].         if (i < delayedOperations) {             ExecutionException exception = expectThrows(ExecutionException.class, "delayed operation should have failed", future::get).             assertFailedOperation(action, exception).         } else {             // non delayed operation might fail depending on the order they were executed             try {                 assertSuccessfulOperation(action, futures[i].get()).             } catch (final ExecutionException e) {                 assertFailedOperation(action, e).             }         }     } }
false;private;2;7;;private void assertSuccessfulOperation(final TestAction action, final Response response) {     final String name = action.getActionName().     assertThat(name + " operation should have been executed on primary", action.executedOnPrimary.get(), is(true)).     assertThat(name + " operation should have been executed on replica", action.executedOnReplica.get(), is(true)).     assertThat(name + " operation must have a non null result", response, notNullValue()).     assertThat(name + " operation should have been successful on 2 shards", response.getShardInfo().getSuccessful(), equalTo(2)). }
false;private;2;8;;private void assertFailedOperation(final TestAction action, final ExecutionException exception) {     final String name = action.getActionName().     assertThat(name + " operation should not have been executed on primary", action.executedOnPrimary.get(), nullValue()).     assertThat(name + " operation should not have been executed on replica", action.executedOnReplica.get(), nullValue()).     assertThat(exception.getCause(), instanceOf(ClusterBlockException.class)).     ClusterBlockException clusterBlockException = (ClusterBlockException) exception.getCause().     assertThat(clusterBlockException.blocks(), hasItem(equalTo(block))). }
false;private;0;3;;private long primaryTerm() {     return primary.getOperationPrimaryTerm(). }
false;private;0;3;;private String allocationId() {     return primary.routingEntry().allocationId().getId(). }
false;private;0;3;;private Request request() {     return new Request().setShardId(primary.shardId()). }
false;protected;0;4;;@Override protected Response newResponseInstance() {     return new Response(). }
false;public;0;3;;public String getActionName() {     return this.actionName. }
false;protected;2;8;;@Override protected PrimaryResult<Request, Response> shardOperationOnPrimary(Request shardRequest, IndexShard shard) throws Exception {     executedOnPrimary.set(true).     // The TransportReplicationAction.getIndexShard() method is overridden for testing purpose but we double check here     // that the permit has been acquired on the primary shard     assertSame(primary, shard).     return new PrimaryResult<>(shardRequest, new Response()). }
false;protected;2;8;;@Override protected ReplicaResult shardOperationOnReplica(Request shardRequest, IndexShard shard) throws Exception {     executedOnReplica.set(true).     // The TransportReplicationAction.getIndexShard() method is overridden for testing purpose but we double check here     // that the permit has been acquired on the replica shard     assertSame(replica, shard).     return new ReplicaResult(). }
false;protected;1;7;;@Override protected IndexShard getIndexShard(final ShardId shardId) {     if (this.shardId.equals(shardId) == false) {         throw new AssertionError("shard id differs from " + shardId).     }     return (executedOnPrimary.get() == null) ? primary : replica. }
false;public;0;4;;@Override public String getProfileName() {     return null. }
false;public;0;4;;@Override public String getChannelType() {     return null. }
false;public;1;4;;@Override public void sendResponse(TransportResponse response) throws IOException {     listener.onResponse((ReplicationOperation.ReplicaResponse) response). }
false;public;1;4;;@Override public void sendResponse(Exception exception) throws IOException {     listener.onFailure(exception). }
false;protected;3;32;;@Override protected void sendReplicaRequest(final ConcreteReplicaRequest<Request> replicaRequest, final DiscoveryNode node, final ActionListener<ReplicationOperation.ReplicaResponse> listener) {     assertEquals("Replica is always assigned to node 2 in this test", clusterService.state().nodes().get("_node2"), node).     ReplicaOperationTransportHandler replicaOperationTransportHandler = new ReplicaOperationTransportHandler().     try {         replicaOperationTransportHandler.messageReceived(replicaRequest, new TransportChannel() {              @Override             public String getProfileName() {                 return null.             }              @Override             public String getChannelType() {                 return null.             }              @Override             public void sendResponse(TransportResponse response) throws IOException {                 listener.onResponse((ReplicationOperation.ReplicaResponse) response).             }              @Override             public void sendResponse(Exception exception) throws IOException {                 listener.onFailure(exception).             }         }, null).     } catch (Exception e) {         listener.onFailure(e).     } }
false;protected;0;4;;@Override protected ClusterBlockLevel globalBlockLevel() {     return globalBlock ? ClusterBlockLevel.WRITE : super.globalBlockLevel(). }
false;public;0;4;;@Override public ClusterBlockLevel indexBlockLevel() {     return globalBlock == false ? ClusterBlockLevel.WRITE : super.indexBlockLevel(). }
false;protected;2;6;;@Override protected PrimaryResult<Request, Response> shardOperationOnPrimary(Request shardRequest, IndexShard shard) throws Exception {     assertNoBlocks("block must not exist when executing the operation on primary shard: it should have been blocked before").     assertThat(shard.getActiveOperationsCount(), greaterThan(0)).     return super.shardOperationOnPrimary(shardRequest, shard). }
false;protected;2;6;;@Override protected ReplicaResult shardOperationOnReplica(Request shardRequest, IndexShard shard) throws Exception {     assertNoBlocks("block must not exist when executing the operation on replica shard: it should have been blocked before").     assertThat(shard.getActiveOperationsCount(), greaterThan(0)).     return super.shardOperationOnReplica(shardRequest, shard). }
false;private;1;5;;private void assertNoBlocks(final String error) {     final ClusterState clusterState = clusterService.state().     assertFalse("Global level " + error, clusterState.blocks().hasGlobalBlock(block)).     assertFalse("Index level " + error, clusterState.blocks().hasIndexBlock(shardId.getIndexName(), block)). }
false;protected;3;4;;@Override protected void acquirePrimaryOperationPermit(IndexShard shard, Request request, ActionListener<Releasable> onAcquired) {     shard.acquireAllPrimaryOperationsPermits(onAcquired, timeout). }
false;protected;6;5;;@Override protected void acquireReplicaOperationPermit(IndexShard shard, Request request, ActionListener<Releasable> onAcquired, long primaryTerm, long globalCheckpoint, long maxSeqNo) {     shard.acquireAllReplicaOperationsPermits(primaryTerm, globalCheckpoint, maxSeqNo, onAcquired, timeout). }
false;protected;2;5;;@Override protected PrimaryResult<Request, Response> shardOperationOnPrimary(Request shardRequest, IndexShard shard) throws Exception {     assertEquals("All permits must be acquired", 0, shard.getActiveOperationsCount()).     return super.shardOperationOnPrimary(shardRequest, shard). }
false;protected;2;5;;@Override protected ReplicaResult shardOperationOnReplica(Request shardRequest, IndexShard shard) throws Exception {     assertEquals("All permits must be acquired", 0, shard.getActiveOperationsCount()).     return super.shardOperationOnReplica(shardRequest, shard). }
false;public;0;4;;@Override public String toString() {     return getTestClass().getName() + ".Request". }
false;public;0;4;;@Override public String getProfileName() {     return "". }
false;public;1;4;;@Override public void sendResponse(TransportResponse response) throws IOException {     listener.onResponse(((Response) response)). }
false;public;1;4;;@Override public void sendResponse(Exception exception) throws IOException {     listener.onFailure(exception). }
false;public;0;4;;@Override public String getChannelType() {     return "replica_test". }
true;public;1;24;/**  * Transport channel that is needed for replica operation testing.  */ ;/**  * Transport channel that is needed for replica operation testing.  */ public TransportChannel transportChannel(final PlainActionFuture<Response> listener) {     return new TransportChannel() {          @Override         public String getProfileName() {             return "".         }          @Override         public void sendResponse(TransportResponse response) throws IOException {             listener.onResponse(((Response) response)).         }          @Override         public void sendResponse(Exception exception) throws IOException {             listener.onFailure(exception).         }          @Override         public String getChannelType() {             return "replica_test".         }     }. }
