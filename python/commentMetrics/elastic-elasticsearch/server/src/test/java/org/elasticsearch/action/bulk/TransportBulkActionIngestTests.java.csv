commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected boolean needToCheck() {     return needToCheck. }
false;;6;6;;@Override void executeBulk(Task task, final BulkRequest bulkRequest, final long startTimeNanos, final ActionListener<BulkResponse> listener, final AtomicArray<BulkItemResponse> responses, Map<String, IndexNotFoundException> indicesThatCannotBeCreated) {     assertTrue(indexCreated).     isExecuted = true. }
false;;3;5;;@Override void createIndex(String index, TimeValue timeout, ActionListener<CreateIndexResponse> listener) {     indexCreated = true.     listener.onResponse(null). }
false;protected;0;4;;@Override protected IndexResponse newResponseInstance() {     return new IndexResponse(). }
false;public;0;44;;@Before public void setupAction() {     // initialize captors, which must be members to use @Capture because of generics     MockitoAnnotations.initMocks(this).     // setup services that will be called by action     transportService = mock(TransportService.class).     clusterService = mock(ClusterService.class).     localIngest = true.     // setup nodes for local and remote     DiscoveryNode localNode = mock(DiscoveryNode.class).     when(localNode.isIngestNode()).thenAnswer(stub -> localIngest).     when(clusterService.localNode()).thenReturn(localNode).     remoteNode1 = mock(DiscoveryNode.class).     remoteNode2 = mock(DiscoveryNode.class).     nodes = mock(DiscoveryNodes.class).     ImmutableOpenMap<String, DiscoveryNode> ingestNodes = ImmutableOpenMap.<String, DiscoveryNode>builder(2).fPut("node1", remoteNode1).fPut("node2", remoteNode2).build().     when(nodes.getIngestNodes()).thenReturn(ingestNodes).     ClusterState state = mock(ClusterState.class).     when(state.getNodes()).thenReturn(nodes).     MetaData metaData = MetaData.builder().indices(ImmutableOpenMap.<String, IndexMetaData>builder().putAll(Collections.singletonMap(WITH_DEFAULT_PIPELINE, IndexMetaData.builder(WITH_DEFAULT_PIPELINE).settings(settings(Version.CURRENT).put(IndexSettings.DEFAULT_PIPELINE.getKey(), "default_pipeline").build()).putAlias(AliasMetaData.builder(WITH_DEFAULT_PIPELINE_ALIAS).build()).numberOfShards(1).numberOfReplicas(1).build())).build()).build().     when(state.getMetaData()).thenReturn(metaData).     when(state.metaData()).thenReturn(metaData).     when(clusterService.state()).thenReturn(state).     doAnswer(invocation -> {         ClusterChangedEvent event = mock(ClusterChangedEvent.class).         when(event.state()).thenReturn(state).         ((ClusterStateApplier) invocation.getArguments()[0]).applyClusterState(event).         return null.     }).when(clusterService).addStateApplier(any(ClusterStateApplier.class)).     // setup the mocked ingest service for capturing calls     ingestService = mock(IngestService.class).     action = new TestTransportBulkAction().     singleItemBulkWriteAction = new TestSingleItemBulkWriteAction(action).     // call on construction of action     reset(transportService). }
false;public;0;11;;public void testIngestSkipped() throws Exception {     BulkRequest bulkRequest = new BulkRequest().     IndexRequest indexRequest = new IndexRequest("index", "type", "id").     indexRequest.source(Collections.emptyMap()).     bulkRequest.add(indexRequest).     action.execute(null, bulkRequest, ActionListener.wrap(response -> {     }, exception -> {         throw new AssertionError(exception).     })).     assertTrue(action.isExecuted).     verifyZeroInteractions(ingestService). }
false;public;0;9;;public void testSingleItemBulkActionIngestSkipped() throws Exception {     IndexRequest indexRequest = new IndexRequest("index", "type", "id").     indexRequest.source(Collections.emptyMap()).     singleItemBulkWriteAction.execute(null, indexRequest, ActionListener.wrap(response -> {     }, exception -> {         throw new AssertionError(exception).     })).     assertTrue(action.isExecuted).     verifyZeroInteractions(ingestService). }
false;public;0;42;;public void testIngestLocal() throws Exception {     Exception exception = new Exception("fake exception").     BulkRequest bulkRequest = new BulkRequest().     IndexRequest indexRequest1 = new IndexRequest("index", "type", "id").     indexRequest1.source(Collections.emptyMap()).     indexRequest1.setPipeline("testpipeline").     IndexRequest indexRequest2 = new IndexRequest("index", "type", "id").     indexRequest2.source(Collections.emptyMap()).     indexRequest2.setPipeline("testpipeline").     bulkRequest.add(indexRequest1).     bulkRequest.add(indexRequest2).     AtomicBoolean responseCalled = new AtomicBoolean(false).     AtomicBoolean failureCalled = new AtomicBoolean(false).     action.execute(null, bulkRequest, ActionListener.wrap(response -> {         BulkItemResponse itemResponse = response.iterator().next().         assertThat(itemResponse.getFailure().getMessage(), containsString("fake exception")).         responseCalled.set(true).     }, e -> {         assertThat(e, sameInstance(exception)).         failureCalled.set(true).     })).     // check failure works, and passes through to the listener     // haven't executed yet     assertFalse(action.isExecuted).     assertFalse(responseCalled.get()).     assertFalse(failureCalled.get()).     verify(ingestService).executeBulkRequest(bulkDocsItr.capture(), failureHandler.capture(), completionHandler.capture(), any()).     completionHandler.getValue().accept(exception).     assertTrue(failureCalled.get()).     // now check success     Iterator<DocWriteRequest<?>> req = bulkDocsItr.getValue().iterator().     // have an exception for our one index request     failureHandler.getValue().accept((IndexRequest) req.next(), exception).     // this is done by the real pipeline execution service when processing     indexRequest2.setPipeline(IngestService.NOOP_PIPELINE_NAME).     completionHandler.getValue().accept(null).     assertTrue(action.isExecuted).     // listener would only be called by real index action, not our mocked one     assertFalse(responseCalled.get()).     verifyZeroInteractions(transportService). }
false;public;0;31;;public void testSingleItemBulkActionIngestLocal() throws Exception {     Exception exception = new Exception("fake exception").     IndexRequest indexRequest = new IndexRequest("index", "type", "id").     indexRequest.source(Collections.emptyMap()).     indexRequest.setPipeline("testpipeline").     AtomicBoolean responseCalled = new AtomicBoolean(false).     AtomicBoolean failureCalled = new AtomicBoolean(false).     singleItemBulkWriteAction.execute(null, indexRequest, ActionListener.wrap(response -> {         responseCalled.set(true).     }, e -> {         assertThat(e, sameInstance(exception)).         failureCalled.set(true).     })).     // check failure works, and passes through to the listener     // haven't executed yet     assertFalse(action.isExecuted).     assertFalse(responseCalled.get()).     assertFalse(failureCalled.get()).     verify(ingestService).executeBulkRequest(bulkDocsItr.capture(), failureHandler.capture(), completionHandler.capture(), any()).     completionHandler.getValue().accept(exception).     assertTrue(failureCalled.get()).     // now check success     // this is done by the real pipeline execution service when processing     indexRequest.setPipeline(IngestService.NOOP_PIPELINE_NAME).     completionHandler.getValue().accept(null).     assertTrue(action.isExecuted).     // listener would only be called by real index action, not our mocked one     assertFalse(responseCalled.get()).     verifyZeroInteractions(transportService). }
false;public;0;45;;public void testIngestForward() throws Exception {     localIngest = false.     BulkRequest bulkRequest = new BulkRequest().     IndexRequest indexRequest = new IndexRequest("index", "type", "id").     indexRequest.source(Collections.emptyMap()).     indexRequest.setPipeline("testpipeline").     bulkRequest.add(indexRequest).     BulkResponse bulkResponse = mock(BulkResponse.class).     AtomicBoolean responseCalled = new AtomicBoolean(false).     ActionListener<BulkResponse> listener = ActionListener.wrap(response -> {         responseCalled.set(true).         assertSame(bulkResponse, response).     }, e -> {         throw new AssertionError(e).     }).     action.execute(null, bulkRequest, listener).     // should not have executed ingest locally     verify(ingestService, never()).executeBulkRequest(any(), any(), any(), any()).     // but instead should have sent to a remote node with the transport service     ArgumentCaptor<DiscoveryNode> node = ArgumentCaptor.forClass(DiscoveryNode.class).     verify(transportService).sendRequest(node.capture(), eq(BulkAction.NAME), any(), remoteResponseHandler.capture()).     // make sure we used one of the nodes     boolean usedNode1 = node.getValue() == remoteNode1.     if (usedNode1 == false) {         assertSame(remoteNode2, node.getValue()).     }     // no local index execution     assertFalse(action.isExecuted).     // listener not called yet     assertFalse(responseCalled.get()).     // call the listener for the remote node     remoteResponseHandler.getValue().handleResponse(bulkResponse).     // now the listener we passed should have been delegated to by the remote listener     assertTrue(responseCalled.get()).     // still no local index execution     assertFalse(action.isExecuted).     // now make sure ingest nodes are rotated through with a subsequent request     reset(transportService).     action.execute(null, bulkRequest, listener).     verify(transportService).sendRequest(node.capture(), eq(BulkAction.NAME), any(), remoteResponseHandler.capture()).     if (usedNode1) {         assertSame(remoteNode2, node.getValue()).     } else {         assertSame(remoteNode1, node.getValue()).     } }
false;public;0;46;;public void testSingleItemBulkActionIngestForward() throws Exception {     localIngest = false.     IndexRequest indexRequest = new IndexRequest("index", "type", "id").     indexRequest.source(Collections.emptyMap()).     indexRequest.setPipeline("testpipeline").     IndexResponse indexResponse = mock(IndexResponse.class).     AtomicBoolean responseCalled = new AtomicBoolean(false).     ActionListener<IndexResponse> listener = ActionListener.wrap(response -> {         responseCalled.set(true).         assertSame(indexResponse, response).     }, e -> {         throw new AssertionError(e).     }).     singleItemBulkWriteAction.execute(null, indexRequest, listener).     // should not have executed ingest locally     verify(ingestService, never()).executeBulkRequest(any(), any(), any(), any()).     // but instead should have sent to a remote node with the transport service     ArgumentCaptor<DiscoveryNode> node = ArgumentCaptor.forClass(DiscoveryNode.class).     verify(transportService).sendRequest(node.capture(), eq(BulkAction.NAME), any(), remoteResponseHandler.capture()).     // make sure we used one of the nodes     boolean usedNode1 = node.getValue() == remoteNode1.     if (usedNode1 == false) {         assertSame(remoteNode2, node.getValue()).     }     // no local index execution     assertFalse(action.isExecuted).     // listener not called yet     assertFalse(responseCalled.get()).     BulkItemResponse itemResponse = new BulkItemResponse(0, DocWriteRequest.OpType.CREATE, indexResponse).     BulkItemResponse[] bulkItemResponses = new BulkItemResponse[1].     bulkItemResponses[0] = itemResponse.     // call the listener for the remote node     remoteResponseHandler.getValue().handleResponse(new BulkResponse(bulkItemResponses, 0)).     // now the listener we passed should have been delegated to by the remote listener     assertTrue(responseCalled.get()).     // still no local index execution     assertFalse(action.isExecuted).     // now make sure ingest nodes are rotated through with a subsequent request     reset(transportService).     singleItemBulkWriteAction.execute(null, indexRequest, listener).     verify(transportService).sendRequest(node.capture(), eq(BulkAction.NAME), any(), remoteResponseHandler.capture()).     if (usedNode1) {         assertSame(remoteNode2, node.getValue()).     } else {         assertSame(remoteNode1, node.getValue()).     } }
false;public;0;3;;public void testUseDefaultPipeline() throws Exception {     validateDefaultPipeline(new IndexRequest(WITH_DEFAULT_PIPELINE, "type", "id")). }
false;public;0;3;;public void testUseDefaultPipelineWithAlias() throws Exception {     validateDefaultPipeline(new IndexRequest(WITH_DEFAULT_PIPELINE_ALIAS, "type", "id")). }
false;public;0;50;;public void testUseDefaultPipelineWithBulkUpsert() throws Exception {     Exception exception = new Exception("fake exception").     BulkRequest bulkRequest = new BulkRequest().     IndexRequest indexRequest1 = new IndexRequest(WITH_DEFAULT_PIPELINE, "type", "id1").source(Collections.emptyMap()).     IndexRequest indexRequest2 = new IndexRequest(WITH_DEFAULT_PIPELINE, "type", "id2").source(Collections.emptyMap()).     IndexRequest indexRequest3 = new IndexRequest(WITH_DEFAULT_PIPELINE, "type", "id3").source(Collections.emptyMap()).     UpdateRequest upsertRequest = new UpdateRequest(WITH_DEFAULT_PIPELINE, "type", "id1").upsert(indexRequest1).script(mockScript("1")).     UpdateRequest docAsUpsertRequest = new UpdateRequest(WITH_DEFAULT_PIPELINE, "type", "id2").doc(indexRequest2).docAsUpsert(true).     // this test only covers the mechanics that scripted bulk upserts will execute a default pipeline. However, in practice scripted     // bulk upserts with a default pipeline are a bit surprising since the script executes AFTER the pipeline.     UpdateRequest scriptedUpsert = new UpdateRequest(WITH_DEFAULT_PIPELINE, "type", "id2").upsert(indexRequest3).script(mockScript("1")).scriptedUpsert(true).     bulkRequest.add(upsertRequest).add(docAsUpsertRequest).add(scriptedUpsert).     AtomicBoolean responseCalled = new AtomicBoolean(false).     AtomicBoolean failureCalled = new AtomicBoolean(false).     assertNull(indexRequest1.getPipeline()).     assertNull(indexRequest2.getPipeline()).     assertNull(indexRequest3.getPipeline()).     action.execute(null, bulkRequest, ActionListener.wrap(response -> {         BulkItemResponse itemResponse = response.iterator().next().         assertThat(itemResponse.getFailure().getMessage(), containsString("fake exception")).         responseCalled.set(true).     }, e -> {         assertThat(e, sameInstance(exception)).         failureCalled.set(true).     })).     // check failure works, and passes through to the listener     // haven't executed yet     assertFalse(action.isExecuted).     assertFalse(responseCalled.get()).     assertFalse(failureCalled.get()).     verify(ingestService).executeBulkRequest(bulkDocsItr.capture(), failureHandler.capture(), completionHandler.capture(), any()).     assertEquals(indexRequest1.getPipeline(), "default_pipeline").     assertEquals(indexRequest2.getPipeline(), "default_pipeline").     assertEquals(indexRequest3.getPipeline(), "default_pipeline").     completionHandler.getValue().accept(exception).     assertTrue(failureCalled.get()).     // now check success of the transport bulk action     // this is done by the real pipeline execution service when processing     indexRequest1.setPipeline(IngestService.NOOP_PIPELINE_NAME).     // this is done by the real pipeline execution service when processing     indexRequest2.setPipeline(IngestService.NOOP_PIPELINE_NAME).     // this is done by the real pipeline execution service when processing     indexRequest3.setPipeline(IngestService.NOOP_PIPELINE_NAME).     completionHandler.getValue().accept(null).     assertTrue(action.isExecuted).     // listener would only be called by real index action, not our mocked one     assertFalse(responseCalled.get()).     verifyZeroInteractions(transportService). }
false;public;0;31;;public void testCreateIndexBeforeRunPipeline() throws Exception {     Exception exception = new Exception("fake exception").     IndexRequest indexRequest = new IndexRequest("missing_index", "type", "id").     indexRequest.setPipeline("testpipeline").     indexRequest.source(Collections.emptyMap()).     AtomicBoolean responseCalled = new AtomicBoolean(false).     AtomicBoolean failureCalled = new AtomicBoolean(false).     action.needToCheck = true.     action.indexCreated = false.     singleItemBulkWriteAction.execute(null, indexRequest, ActionListener.wrap(response -> responseCalled.set(true), e -> {         assertThat(e, sameInstance(exception)).         failureCalled.set(true).     })).     // check failure works, and passes through to the listener     // haven't executed yet     assertFalse(action.isExecuted).     assertFalse(responseCalled.get()).     assertFalse(failureCalled.get()).     verify(ingestService).executeBulkRequest(bulkDocsItr.capture(), failureHandler.capture(), completionHandler.capture(), any()).     completionHandler.getValue().accept(exception).     assertTrue(failureCalled.get()).     // now check success     // this is done by the real pipeline execution service when processing     indexRequest.setPipeline(IngestService.NOOP_PIPELINE_NAME).     completionHandler.getValue().accept(null).     assertTrue(action.isExecuted).     // listener would only be called by real index action, not our mocked one     assertFalse(responseCalled.get()).     verifyZeroInteractions(transportService). }
false;private;1;31;;private void validateDefaultPipeline(IndexRequest indexRequest) {     Exception exception = new Exception("fake exception").     indexRequest.source(Collections.emptyMap()).     AtomicBoolean responseCalled = new AtomicBoolean(false).     AtomicBoolean failureCalled = new AtomicBoolean(false).     assertNull(indexRequest.getPipeline()).     singleItemBulkWriteAction.execute(null, indexRequest, ActionListener.wrap(response -> {         responseCalled.set(true).     }, e -> {         assertThat(e, sameInstance(exception)).         failureCalled.set(true).     })).     // check failure works, and passes through to the listener     // haven't executed yet     assertFalse(action.isExecuted).     assertFalse(responseCalled.get()).     assertFalse(failureCalled.get()).     verify(ingestService).executeBulkRequest(bulkDocsItr.capture(), failureHandler.capture(), completionHandler.capture(), any()).     assertEquals(indexRequest.getPipeline(), "default_pipeline").     completionHandler.getValue().accept(exception).     assertTrue(failureCalled.get()).     // now check success     // this is done by the real pipeline execution service when processing     indexRequest.setPipeline(IngestService.NOOP_PIPELINE_NAME).     completionHandler.getValue().accept(null).     assertTrue(action.isExecuted).     // listener would only be called by real index action, not our mocked one     assertFalse(responseCalled.get()).     verifyZeroInteractions(transportService). }
