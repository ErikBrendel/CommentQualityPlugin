# id;timestamp;commentText;codeText;commentWords;codeWords
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot1() throws Exception;1524684173;Checks that multiple levels of nested includes where a node is both directly and transitively_included in root by {@code include_in_root} and a chain of {@code include_in_parent} does not_lead to duplicate fields on the root document.;public void testMultipleLevelsIncludeRoot1() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested").field("include_in_root", true).field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested").field("include_in_root", true).field("include_in_parent", true)_            .endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser().parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };checks,that,multiple,levels,of,nested,includes,where,a,node,is,both,directly,and,transitively,included,in,root,by,code,and,a,chain,of,code,does,not,lead,to,duplicate,fields,on,the,root,document;public,void,test,multiple,levels,include,root1,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot1() throws Exception;1528762805;Checks that multiple levels of nested includes where a node is both directly and transitively_included in root by {@code include_in_root} and a chain of {@code include_in_parent} does not_lead to duplicate fields on the root document.;public void testMultipleLevelsIncludeRoot1() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested").field("include_in_root", true).field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested").field("include_in_root", true).field("include_in_parent", true)_            .endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser().parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };checks,that,multiple,levels,of,nested,includes,where,a,node,is,both,directly,and,transitively,included,in,root,by,code,and,a,chain,of,code,does,not,lead,to,duplicate,fields,on,the,root,document;public,void,test,multiple,levels,include,root1,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot1() throws Exception;1538579488;Checks that multiple levels of nested includes where a node is both directly and transitively_included in root by {@code include_in_root} and a chain of {@code include_in_parent} does not_lead to duplicate fields on the root document.;public void testMultipleLevelsIncludeRoot1() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested").field("include_in_root", true).field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested").field("include_in_root", true).field("include_in_parent", true)_            .endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser().parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };checks,that,multiple,levels,of,nested,includes,where,a,node,is,both,directly,and,transitively,included,in,root,by,code,and,a,chain,of,code,does,not,lead,to,duplicate,fields,on,the,root,document;public,void,test,multiple,levels,include,root1,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot1() throws Exception;1539615817;Checks that multiple levels of nested includes where a node is both directly and transitively_included in root by {@code include_in_root} and a chain of {@code include_in_parent} does not_lead to duplicate fields on the root document.;public void testMultipleLevelsIncludeRoot1() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested").field("include_in_root", true).field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested").field("include_in_root", true).field("include_in_parent", true)_            .endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser().parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };checks,that,multiple,levels,of,nested,includes,where,a,node,is,both,directly,and,transitively,included,in,root,by,code,and,a,chain,of,code,does,not,lead,to,duplicate,fields,on,the,root,document;public,void,test,multiple,levels,include,root1,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot1() throws Exception;1541008027;Checks that multiple levels of nested includes where a node is both directly and transitively_included in root by {@code include_in_root} and a chain of {@code include_in_parent} does not_lead to duplicate fields on the root document.;public void testMultipleLevelsIncludeRoot1() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested").field("include_in_root", true)_            .field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested").field("include_in_root", true)_            .field("include_in_parent", true)_            .endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser()_            .parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(SourceToParse.source("test", "type", "1",_            BytesReference.bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };checks,that,multiple,levels,of,nested,includes,where,a,node,is,both,directly,and,transitively,included,in,root,by,code,and,a,chain,of,code,does,not,lead,to,duplicate,fields,on,the,root,document;public,void,test,multiple,levels,include,root1,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot1() throws Exception;1545678410;Checks that multiple levels of nested includes where a node is both directly and transitively_included in root by {@code include_in_root} and a chain of {@code include_in_parent} does not_lead to duplicate fields on the root document.;public void testMultipleLevelsIncludeRoot1() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested").field("include_in_root", true)_            .field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested").field("include_in_root", true)_            .field("include_in_parent", true)_            .endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser()_            .parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(new SourceToParse("test", "type", "1",_            BytesReference.bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };checks,that,multiple,levels,of,nested,includes,where,a,node,is,both,directly,and,transitively,included,in,root,by,code,and,a,chain,of,code,does,not,lead,to,duplicate,fields,on,the,root,document;public,void,test,multiple,levels,include,root1,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,new,source,to,parse,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot2() throws Exception;1524684173;Same as {@link NestedObjectMapperTests#testMultipleLevelsIncludeRoot1()} but tests for the_case where the transitive {@code include_in_parent} and redundant {@code include_in_root}_happen on a chain of nodes that starts from a parent node that is not directly connected to_root by a chain of {@code include_in_parent}, i.e. that has {@code include_in_parent} set to_{@code false} and {@code include_in_root} set to {@code true}.;public void testMultipleLevelsIncludeRoot2() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", false).startObject("properties")_            .startObject("nested3").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true)_            .endObject().endObject().endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser().parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2")_                        .startObject().startArray("nested3").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };same,as,link,nested,object,mapper,tests,test,multiple,levels,include,root1,but,tests,for,the,case,where,the,transitive,code,and,redundant,code,happen,on,a,chain,of,nodes,that,starts,from,a,parent,node,that,is,not,directly,connected,to,root,by,a,chain,of,code,i,e,that,has,code,set,to,code,false,and,code,set,to,code,true;public,void,test,multiple,levels,include,root2,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,false,start,object,properties,start,object,nested3,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,start,array,nested3,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot2() throws Exception;1528762805;Same as {@link NestedObjectMapperTests#testMultipleLevelsIncludeRoot1()} but tests for the_case where the transitive {@code include_in_parent} and redundant {@code include_in_root}_happen on a chain of nodes that starts from a parent node that is not directly connected to_root by a chain of {@code include_in_parent}, i.e. that has {@code include_in_parent} set to_{@code false} and {@code include_in_root} set to {@code true}.;public void testMultipleLevelsIncludeRoot2() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", false).startObject("properties")_            .startObject("nested3").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true)_            .endObject().endObject().endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser().parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2")_                        .startObject().startArray("nested3").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };same,as,link,nested,object,mapper,tests,test,multiple,levels,include,root1,but,tests,for,the,case,where,the,transitive,code,and,redundant,code,happen,on,a,chain,of,nodes,that,starts,from,a,parent,node,that,is,not,directly,connected,to,root,by,a,chain,of,code,i,e,that,has,code,set,to,code,false,and,code,set,to,code,true;public,void,test,multiple,levels,include,root2,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,false,start,object,properties,start,object,nested3,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,start,array,nested3,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot2() throws Exception;1538579488;Same as {@link NestedObjectMapperTests#testMultipleLevelsIncludeRoot1()} but tests for the_case where the transitive {@code include_in_parent} and redundant {@code include_in_root}_happen on a chain of nodes that starts from a parent node that is not directly connected to_root by a chain of {@code include_in_parent}, i.e. that has {@code include_in_parent} set to_{@code false} and {@code include_in_root} set to {@code true}.;public void testMultipleLevelsIncludeRoot2() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", false).startObject("properties")_            .startObject("nested3").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true)_            .endObject().endObject().endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser().parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2")_                        .startObject().startArray("nested3").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };same,as,link,nested,object,mapper,tests,test,multiple,levels,include,root1,but,tests,for,the,case,where,the,transitive,code,and,redundant,code,happen,on,a,chain,of,nodes,that,starts,from,a,parent,node,that,is,not,directly,connected,to,root,by,a,chain,of,code,i,e,that,has,code,set,to,code,false,and,code,set,to,code,true;public,void,test,multiple,levels,include,root2,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,false,start,object,properties,start,object,nested3,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,start,array,nested3,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot2() throws Exception;1539615817;Same as {@link NestedObjectMapperTests#testMultipleLevelsIncludeRoot1()} but tests for the_case where the transitive {@code include_in_parent} and redundant {@code include_in_root}_happen on a chain of nodes that starts from a parent node that is not directly connected to_root by a chain of {@code include_in_parent}, i.e. that has {@code include_in_parent} set to_{@code false} and {@code include_in_root} set to {@code true}.;public void testMultipleLevelsIncludeRoot2() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", false).startObject("properties")_            .startObject("nested3").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true)_            .endObject().endObject().endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser().parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2")_                        .startObject().startArray("nested3").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };same,as,link,nested,object,mapper,tests,test,multiple,levels,include,root1,but,tests,for,the,case,where,the,transitive,code,and,redundant,code,happen,on,a,chain,of,nodes,that,starts,from,a,parent,node,that,is,not,directly,connected,to,root,by,a,chain,of,code,i,e,that,has,code,set,to,code,false,and,code,set,to,code,true;public,void,test,multiple,levels,include,root2,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,false,start,object,properties,start,object,nested3,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,start,array,nested3,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot2() throws Exception;1541008027;Same as {@link NestedObjectMapperTests#testMultipleLevelsIncludeRoot1()} but tests for the_case where the transitive {@code include_in_parent} and redundant {@code include_in_root}_happen on a chain of nodes that starts from a parent node that is not directly connected to_root by a chain of {@code include_in_parent}, i.e. that has {@code include_in_parent} set to_{@code false} and {@code include_in_root} set to {@code true}.;public void testMultipleLevelsIncludeRoot2() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", false).startObject("properties")_            .startObject("nested3").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true)_            .endObject().endObject().endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser()_            .parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(SourceToParse.source("test", "type", "1",_            BytesReference.bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2")_                        .startObject().startArray("nested3").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };same,as,link,nested,object,mapper,tests,test,multiple,levels,include,root1,but,tests,for,the,case,where,the,transitive,code,and,redundant,code,happen,on,a,chain,of,nodes,that,starts,from,a,parent,node,that,is,not,directly,connected,to,root,by,a,chain,of,code,i,e,that,has,code,set,to,code,false,and,code,set,to,code,true;public,void,test,multiple,levels,include,root2,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,false,start,object,properties,start,object,nested3,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,start,array,nested3,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
NestedObjectMapperTests -> public void testMultipleLevelsIncludeRoot2() throws Exception;1545678410;Same as {@link NestedObjectMapperTests#testMultipleLevelsIncludeRoot1()} but tests for the_case where the transitive {@code include_in_parent} and redundant {@code include_in_root}_happen on a chain of nodes that starts from a parent node that is not directly connected to_root by a chain of {@code include_in_parent}, i.e. that has {@code include_in_parent} set to_{@code false} and {@code include_in_root} set to {@code true}.;public void testMultipleLevelsIncludeRoot2() throws Exception {_        String mapping = Strings.toString(XContentFactory.jsonBuilder()_            .startObject().startObject("type").startObject("properties")_            .startObject("nested1").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true).startObject("properties")_            .startObject("nested2").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", false).startObject("properties")_            .startObject("nested3").field("type", "nested")_            .field("include_in_root", true).field("include_in_parent", true)_            .endObject().endObject().endObject().endObject().endObject()_            .endObject().endObject().endObject())___        DocumentMapper docMapper = createIndex("test").mapperService().documentMapperParser()_            .parse("type", new CompressedXContent(mapping))___        ParsedDocument doc = docMapper.parse(new SourceToParse("test", "type", "1",_            BytesReference.bytes(XContentFactory.jsonBuilder()_                        .startObject().startArray("nested1")_                        .startObject().startArray("nested2")_                        .startObject().startArray("nested3").startObject().field("foo", "bar")_                        .endObject().endArray().endObject().endArray().endObject().endArray()_                        .endObject()),_            XContentType.JSON))___        final Collection<IndexableField> fields = doc.rootDoc().getFields()__        assertThat(fields.size(), equalTo(new HashSet<>(fields).size()))__    };same,as,link,nested,object,mapper,tests,test,multiple,levels,include,root1,but,tests,for,the,case,where,the,transitive,code,and,redundant,code,happen,on,a,chain,of,nodes,that,starts,from,a,parent,node,that,is,not,directly,connected,to,root,by,a,chain,of,code,i,e,that,has,code,set,to,code,false,and,code,set,to,code,true;public,void,test,multiple,levels,include,root2,throws,exception,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,nested1,field,type,nested,field,true,field,true,start,object,properties,start,object,nested2,field,type,nested,field,true,field,false,start,object,properties,start,object,nested3,field,type,nested,field,true,field,true,end,object,end,object,end,object,end,object,end,object,end,object,end,object,end,object,document,mapper,doc,mapper,create,index,test,mapper,service,document,mapper,parser,parse,type,new,compressed,xcontent,mapping,parsed,document,doc,doc,mapper,parse,new,source,to,parse,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,start,array,nested1,start,object,start,array,nested2,start,object,start,array,nested3,start,object,field,foo,bar,end,object,end,array,end,object,end,array,end,object,end,array,end,object,xcontent,type,json,final,collection,indexable,field,fields,doc,root,doc,get,fields,assert,that,fields,size,equal,to,new,hash,set,fields,size
