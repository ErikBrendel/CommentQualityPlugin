# id;timestamp;commentText;codeText;commentWords;codeWords
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1524684173;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1528706846;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1531910483;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1533295538;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1533641732;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1534848846;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1535046779;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1537806831;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1538067637;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1539615817;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1542697754;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1542962614;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1544437584;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1544684920;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> private void truncateTranslogs(Path directory) throws Exception;1545236365;Randomly truncate some bytes in the translog files;private void truncateTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            try (FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)) {_                long prevSize = f.size()__                long newSize = prevSize - randomIntBetween(1, (int) prevSize / 2)__                logger.info("--> truncating {}, prev: {}, now: {}", file, prevSize, newSize)__                f.truncate(newSize)__            }_        }_    };randomly,truncate,some,bytes,in,the,translog,files;private,void,truncate,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,try,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,long,prev,size,f,size,long,new,size,prev,size,random,int,between,1,int,prev,size,2,logger,info,truncating,prev,now,file,prev,size,new,size,f,truncate,new,size
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1531910483;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1533295538;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1533641732;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1534848846;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1535046779;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1537806831;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1538067637;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1539615817;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1542697754;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1542962614;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1544437584;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1544684920;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testCloseSnapshotTwice() throws Exception;1545236365;Make sure that it's ok to close a translog snapshot multiple times;public void testCloseSnapshotTwice() throws Exception {_        int numOps = between(0, 10)__        for (int i = 0_ i < numOps_ i++) {_            Translog.Index op = new Translog.Index("doc", randomAlphaOfLength(10), i, primaryTerm.get(), new byte[]{1})__            translog.add(op)__            if (randomBoolean()) {_                translog.rollGeneration()__            }_        }_        for (int i = 0_ i < 5_ i++) {_            Translog.Snapshot snapshot = translog.newSnapshot()__            assertThat(snapshot, SnapshotMatchers.size(numOps))__            snapshot.close()__            snapshot.close()__        }_    };make,sure,that,it,s,ok,to,close,a,translog,snapshot,multiple,times;public,void,test,close,snapshot,twice,throws,exception,int,num,ops,between,0,10,for,int,i,0,i,num,ops,i,translog,index,op,new,translog,index,doc,random,alpha,of,length,10,i,primary,term,get,new,byte,1,translog,add,op,if,random,boolean,translog,roll,generation,for,int,i,0,i,5,i,translog,snapshot,snapshot,translog,new,snapshot,assert,that,snapshot,snapshot,matchers,size,num,ops,snapshot,close,snapshot,close
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1524684173;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1528706846;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1531910483;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1533295538;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1533641732;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1534848846;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1535046779;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1537806831;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1538067637;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1539615817;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1542697754;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy,_            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1542962614;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy,_            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1544437584;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy,_            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1544684920;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy,_            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> public void testRecoveryFromAFutureGenerationCleansUp() throws IOException;1545236365;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromAFutureGenerationCleansUp() throws IOException {_        int translogOperations = randomIntBetween(10, 100)__        for (int op = 0_ op < translogOperations / 2_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        translog.rollGeneration()__        long comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__        for (int op = translogOperations / 2_ op < translogOperations_ op++) {_            translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__            if (rarely()) {_                translog.rollGeneration()__            }_        }_        _        translog.close()__        TranslogConfig config = translog.getConfig()__        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        translog = new Translog(config, translog.getTranslogUUID(), deletionPolicy,_            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        assertThat(translog.getMinFileGeneration(), equalTo(1L))__        _        for (long gen = 1_ gen < translog.currentFileGeneration()_ gen++) {_            assertFileIsPresent(translog, gen)__        }_        translog.trimUnreferencedReaders()__        for (long gen = 1_ gen < comittedGeneration_ gen++) {_            assertFileDeleted(translog, gen)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,afuture,generation,cleans,up,throws,ioexception,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,long,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,close,translog,config,config,translog,get,config,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,translog,new,translog,config,translog,get,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,equal,to,1l,for,long,gen,1,gen,translog,current,file,generation,gen,assert,file,is,present,translog,gen,translog,trim,unreferenced,readers,for,long,gen,1,gen,comitted,generation,gen,assert,file,deleted,translog,gen
TranslogTests -> private void corruptTranslogs(Path directory) throws Exception;1524684173;Randomly overwrite some bytes in the translog files;private void corruptTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            logger.info("--> corrupting {}...", file)__            FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)__            int corruptions = scaledRandomIntBetween(10, 50)__            for (int i = 0_ i < corruptions_ i++) {_                _                long pos = randomIntBetween(0, (int) f.size())__                ByteBuffer junk = ByteBuffer.wrap(new byte[]{randomByte()})__                f.write(junk, pos)__            }_            f.close()__        }_    };randomly,overwrite,some,bytes,in,the,translog,files;private,void,corrupt,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,logger,info,corrupting,file,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,int,corruptions,scaled,random,int,between,10,50,for,int,i,0,i,corruptions,i,long,pos,random,int,between,0,int,f,size,byte,buffer,junk,byte,buffer,wrap,new,byte,random,byte,f,write,junk,pos,f,close
TranslogTests -> private void corruptTranslogs(Path directory) throws Exception;1528706846;Randomly overwrite some bytes in the translog files;private void corruptTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            logger.info("--> corrupting {}...", file)__            FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)__            int corruptions = scaledRandomIntBetween(10, 50)__            for (int i = 0_ i < corruptions_ i++) {_                _                long pos = randomIntBetween(0, (int) f.size())__                ByteBuffer junk = ByteBuffer.wrap(new byte[]{randomByte()})__                f.write(junk, pos)__            }_            f.close()__        }_    };randomly,overwrite,some,bytes,in,the,translog,files;private,void,corrupt,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,logger,info,corrupting,file,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,int,corruptions,scaled,random,int,between,10,50,for,int,i,0,i,corruptions,i,long,pos,random,int,between,0,int,f,size,byte,buffer,junk,byte,buffer,wrap,new,byte,random,byte,f,write,junk,pos,f,close
TranslogTests -> private void corruptTranslogs(Path directory) throws Exception;1531910483;Randomly overwrite some bytes in the translog files;private void corruptTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            logger.info("--> corrupting {}...", file)__            FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)__            int corruptions = scaledRandomIntBetween(10, 50)__            for (int i = 0_ i < corruptions_ i++) {_                _                long pos = randomIntBetween(0, (int) f.size())__                ByteBuffer junk = ByteBuffer.wrap(new byte[]{randomByte()})__                f.write(junk, pos)__            }_            f.close()__        }_    };randomly,overwrite,some,bytes,in,the,translog,files;private,void,corrupt,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,logger,info,corrupting,file,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,int,corruptions,scaled,random,int,between,10,50,for,int,i,0,i,corruptions,i,long,pos,random,int,between,0,int,f,size,byte,buffer,junk,byte,buffer,wrap,new,byte,random,byte,f,write,junk,pos,f,close
TranslogTests -> private void corruptTranslogs(Path directory) throws Exception;1533295538;Randomly overwrite some bytes in the translog files;private void corruptTranslogs(Path directory) throws Exception {_        Path[] files = FileSystemUtils.files(directory, "translog-*")__        for (Path file : files) {_            logger.info("--> corrupting {}...", file)__            FileChannel f = FileChannel.open(file, StandardOpenOption.READ, StandardOpenOption.WRITE)__            int corruptions = scaledRandomIntBetween(10, 50)__            for (int i = 0_ i < corruptions_ i++) {_                _                long pos = randomIntBetween(0, (int) f.size())__                ByteBuffer junk = ByteBuffer.wrap(new byte[]{randomByte()})__                f.write(junk, pos)__            }_            f.close()__        }_    };randomly,overwrite,some,bytes,in,the,translog,files;private,void,corrupt,translogs,path,directory,throws,exception,path,files,file,system,utils,files,directory,translog,for,path,file,files,logger,info,corrupting,file,file,channel,f,file,channel,open,file,standard,open,option,read,standard,open,option,write,int,corruptions,scaled,random,int,between,10,50,for,int,i,0,i,corruptions,i,long,pos,random,int,between,0,int,f,size,byte,buffer,junk,byte,buffer,wrap,new,byte,random,byte,f,write,junk,pos,f,close
TranslogTests -> public void testWithRandomException() throws IOException;1524684173;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(), doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            failableTLog.sync()_ _                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(minGenForRecovery)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,min,gen,for,recovery,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1528706846;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(), doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            failableTLog.sync()_ _                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(minGenForRecovery)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,min,gen,for,recovery,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1531910483;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(), doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            failableTLog.sync()_ _                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(minGenForRecovery)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,min,gen,for,recovery,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1533295538;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(), doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            failableTLog.sync()_ _                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(minGenForRecovery)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,min,gen,for,recovery,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1533641732;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(), doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            failableTLog.sync()_ _                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(minGenForRecovery)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,min,gen,for,recovery,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1534848846;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(), doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            failableTLog.sync()_ _                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                    assertEquals(failableTLog.getTragicException(), ex)__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(minGenForRecovery)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,assert,equals,failable,tlog,get,tragic,exception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,assert,equals,failable,tlog,get,tragic,exception,ex,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,assert,equals,failable,tlog,get,tragic,exception,ex,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,min,gen,for,recovery,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1535046779;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(), doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            failableTLog.sync()_ _                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                    assertEquals(failableTLog.getTragicException(), ex)__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(_                     new Translog.TranslogGeneration(generationUUID, minGenForRecovery), Long.MAX_VALUE)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,assert,equals,failable,tlog,get,tragic,exception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,assert,equals,failable,tlog,get,tragic,exception,ex,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,assert,equals,failable,tlog,get,tragic,exception,ex,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,new,translog,translog,generation,generation,uuid,min,gen,for,recovery,long,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1537806831;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(), doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            failableTLog.sync()_ _                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                    assertEquals(failableTLog.getTragicException(), ex)__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(_                     new Translog.TranslogGeneration(generationUUID, minGenForRecovery), Long.MAX_VALUE)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,assert,equals,failable,tlog,get,tragic,exception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,assert,equals,failable,tlog,get,tragic,exception,ex,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,assert,equals,failable,tlog,get,tragic,exception,ex,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,new,translog,translog,generation,generation,uuid,min,gen,for,recovery,long,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1538067637;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(), doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            failableTLog.sync()_ _                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                    assertEquals(failableTLog.getTragicException(), ex)__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(_                     new Translog.TranslogGeneration(generationUUID, minGenForRecovery), Long.MAX_VALUE)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,assert,equals,failable,tlog,get,tragic,exception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,assert,equals,failable,tlog,get,tragic,exception,ex,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,assert,equals,failable,tlog,get,tragic,exception,ex,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,new,translog,translog,generation,generation,uuid,min,gen,for,recovery,long,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1539615817;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(), doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            failableTLog.sync()_ _                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                    assertEquals(failableTLog.getTragicException(), ex)__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(), SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(_                     new Translog.TranslogGeneration(generationUUID, minGenForRecovery), Long.MAX_VALUE)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,assert,equals,failable,tlog,get,tragic,exception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,assert,equals,failable,tlog,get,tragic,exception,ex,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,assert,equals,failable,tlog,get,tragic,exception,ex,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,new,translog,translog,generation,generation,uuid,min,gen,for,recovery,long,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1542697754;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false,_                    generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(),_                            doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            _                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                    assertEquals(failableTLog.getTragicException(), ex)__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(),_                    SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy,_                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(_                     new Translog.TranslogGeneration(generationUUID, minGenForRecovery), Long.MAX_VALUE)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,assert,equals,failable,tlog,get,tragic,exception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,assert,equals,failable,tlog,get,tragic,exception,ex,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,assert,equals,failable,tlog,get,tragic,exception,ex,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,new,translog,translog,generation,generation,uuid,min,gen,for,recovery,long,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1542962614;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false,_                    generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(),_                            doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            _                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                    assertEquals(failableTLog.getTragicException(), ex)__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(),_                    SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy,_                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(_                     new Translog.TranslogGeneration(generationUUID, minGenForRecovery), Long.MAX_VALUE)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,assert,equals,failable,tlog,get,tragic,exception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,assert,equals,failable,tlog,get,tragic,exception,ex,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,assert,equals,failable,tlog,get,tragic,exception,ex,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,new,translog,translog,generation,generation,uuid,min,gen,for,recovery,long,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1544437584;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false,_                    generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(),_                            doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            _                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                    assertEquals(failableTLog.getTragicException(), ex)__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(),_                    SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy,_                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(_                     new Translog.TranslogGeneration(generationUUID, minGenForRecovery), Long.MAX_VALUE)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,assert,equals,failable,tlog,get,tragic,exception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,assert,equals,failable,tlog,get,tragic,exception,ex,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,assert,equals,failable,tlog,get,tragic,exception,ex,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,new,translog,translog,generation,generation,uuid,min,gen,for,recovery,long,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1544684920;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false,_                    generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(),_                            doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            _                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                    assertEquals(failableTLog.getTragicException(), ex)__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(),_                    SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy,_                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(_                     new Translog.TranslogGeneration(generationUUID, minGenForRecovery), Long.MAX_VALUE)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,assert,equals,failable,tlog,get,tragic,exception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,assert,equals,failable,tlog,get,tragic,exception,ex,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,assert,equals,failable,tlog,get,tragic,exception,ex,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,new,translog,translog,generation,generation,uuid,min,gen,for,recovery,long,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testWithRandomException() throws IOException;1545236365;This test adds operations to the translog which might randomly throw an IOException. The only thing this test verifies is_that we can, after we hit an exception, open and recover the translog successfully and retrieve all successfully synced operations_from the transaction log.;public void testWithRandomException() throws IOException {_        final int runs = randomIntBetween(5, 10)__        for (int run = 0_ run < runs_ run++) {_            Path tempDir = createTempDir()__            final FailSwitch fail = new FailSwitch()__            fail.failRandomly()__            TranslogConfig config = getTranslogConfig(tempDir)__            final int numOps = randomIntBetween(100, 200)__            long minGenForRecovery = 1__            List<String> syncedDocs = new ArrayList<>()__            List<String> unsynced = new ArrayList<>()__            if (randomBoolean()) {_                fail.onceFailedFailAlways()__            }_            String generationUUID = null__            try {_                boolean committing = false__                final Translog failableTLog = getFailableTranslog(fail, config, randomBoolean(), false,_                    generationUUID, createTranslogDeletionPolicy())__                try {_                    LineFileDocs lineFileDocs = new LineFileDocs(random())_ _                    for (int opsAdded = 0_ opsAdded < numOps_ opsAdded++) {_                        String doc = lineFileDocs.nextDoc().toString()__                        failableTLog.add(new Translog.Index("test", "" + opsAdded, opsAdded, primaryTerm.get(),_                            doc.getBytes(Charset.forName("UTF-8"))))__                        unsynced.add(doc)__                        if (randomBoolean()) {_                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                        }_                        if (randomFloat() < 0.1) {_                            _                            failableTLog.sync()__                            syncedDocs.addAll(unsynced)__                            unsynced.clear()__                            failableTLog.rollGeneration()__                            committing = true__                            failableTLog.getDeletionPolicy().setTranslogGenerationOfLastCommit(failableTLog.currentFileGeneration())__                            failableTLog.getDeletionPolicy().setMinTranslogGenerationForRecovery(failableTLog.currentFileGeneration())__                            failableTLog.trimUnreferencedReaders()__                            committing = false__                            syncedDocs.clear()__                        }_                    }_                    _                    _                    _                    failableTLog.close()__                    syncedDocs.addAll(unsynced)__                    unsynced.clear()__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                    assertEquals(failableTLog.getTragicException(), ex)__                } catch (RuntimeException ex) {_                    assertEquals(ex.getMessage(), "simulated")__                    assertEquals(failableTLog.getTragicException(), ex)__                } finally {_                    Checkpoint checkpoint = Translog.readCheckpoint(config.getTranslogPath())__                    if (checkpoint.numOps == unsynced.size() + syncedDocs.size()) {_                        syncedDocs.addAll(unsynced)_ _                        unsynced.clear()__                    }_                    if (committing && checkpoint.minTranslogGeneration == checkpoint.generation) {_                        _                        syncedDocs.clear()__                        assertThat(unsynced, empty())__                    }_                    generationUUID = failableTLog.getTranslogUUID()__                    minGenForRecovery = failableTLog.getDeletionPolicy().getMinTranslogGenerationForRecovery()__                    IOUtils.closeWhileHandlingException(failableTLog)__                }_            } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                _            } catch (IOException ex) {_                assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__            }_            _            if (randomBoolean()) {_                try {_                    TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__                    deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__                    deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__                    IOUtils.close(getFailableTranslog(fail, config, randomBoolean(), false, generationUUID, deletionPolicy))__                } catch (TranslogException | MockDirectoryWrapper.FakeIOException ex) {_                    _                } catch (IOException ex) {_                    assertEquals(ex.getMessage(), "__FAKE__ no space left on device")__                }_            }__            fail.failNever()_ _            TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy()__            deletionPolicy.setTranslogGenerationOfLastCommit(minGenForRecovery)__            deletionPolicy.setMinTranslogGenerationForRecovery(minGenForRecovery)__            if (generationUUID == null) {_                _                generationUUID = Translog.createEmptyTranslog(config.getTranslogPath(),_                    SequenceNumbers.NO_OPS_PERFORMED, shardId, primaryTerm.get())__            }_            try (Translog translog = new Translog(config, generationUUID, deletionPolicy,_                () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__                 Translog.Snapshot snapshot = translog.newSnapshotFromGen(_                     new Translog.TranslogGeneration(generationUUID, minGenForRecovery), Long.MAX_VALUE)) {_                assertEquals(syncedDocs.size(), snapshot.totalOperations())__                for (int i = 0_ i < syncedDocs.size()_ i++) {_                    Translog.Operation next = snapshot.next()__                    assertEquals(syncedDocs.get(i), next.getSource().source.utf8ToString())__                    assertNotNull("operation " + i + " must be non-null", next)__                }_            }_        }_    };this,test,adds,operations,to,the,translog,which,might,randomly,throw,an,ioexception,the,only,thing,this,test,verifies,is,that,we,can,after,we,hit,an,exception,open,and,recover,the,translog,successfully,and,retrieve,all,successfully,synced,operations,from,the,transaction,log;public,void,test,with,random,exception,throws,ioexception,final,int,runs,random,int,between,5,10,for,int,run,0,run,runs,run,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,randomly,translog,config,config,get,translog,config,temp,dir,final,int,num,ops,random,int,between,100,200,long,min,gen,for,recovery,1,list,string,synced,docs,new,array,list,list,string,unsynced,new,array,list,if,random,boolean,fail,once,failed,fail,always,string,generation,uuid,null,try,boolean,committing,false,final,translog,failable,tlog,get,failable,translog,fail,config,random,boolean,false,generation,uuid,create,translog,deletion,policy,try,line,file,docs,line,file,docs,new,line,file,docs,random,for,int,ops,added,0,ops,added,num,ops,ops,added,string,doc,line,file,docs,next,doc,to,string,failable,tlog,add,new,translog,index,test,ops,added,ops,added,primary,term,get,doc,get,bytes,charset,for,name,utf,8,unsynced,add,doc,if,random,boolean,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,if,random,float,0,1,failable,tlog,sync,synced,docs,add,all,unsynced,unsynced,clear,failable,tlog,roll,generation,committing,true,failable,tlog,get,deletion,policy,set,translog,generation,of,last,commit,failable,tlog,current,file,generation,failable,tlog,get,deletion,policy,set,min,translog,generation,for,recovery,failable,tlog,current,file,generation,failable,tlog,trim,unreferenced,readers,committing,false,synced,docs,clear,failable,tlog,close,synced,docs,add,all,unsynced,unsynced,clear,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,assert,equals,failable,tlog,get,tragic,exception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,assert,equals,failable,tlog,get,tragic,exception,ex,catch,runtime,exception,ex,assert,equals,ex,get,message,simulated,assert,equals,failable,tlog,get,tragic,exception,ex,finally,checkpoint,checkpoint,translog,read,checkpoint,config,get,translog,path,if,checkpoint,num,ops,unsynced,size,synced,docs,size,synced,docs,add,all,unsynced,unsynced,clear,if,committing,checkpoint,min,translog,generation,checkpoint,generation,synced,docs,clear,assert,that,unsynced,empty,generation,uuid,failable,tlog,get,translog,uuid,min,gen,for,recovery,failable,tlog,get,deletion,policy,get,min,translog,generation,for,recovery,ioutils,close,while,handling,exception,failable,tlog,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,if,random,boolean,try,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,ioutils,close,get,failable,translog,fail,config,random,boolean,false,generation,uuid,deletion,policy,catch,translog,exception,mock,directory,wrapper,fake,ioexception,ex,catch,ioexception,ex,assert,equals,ex,get,message,no,space,left,on,device,fail,fail,never,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,deletion,policy,set,translog,generation,of,last,commit,min,gen,for,recovery,deletion,policy,set,min,translog,generation,for,recovery,min,gen,for,recovery,if,generation,uuid,null,generation,uuid,translog,create,empty,translog,config,get,translog,path,sequence,numbers,shard,id,primary,term,get,try,translog,translog,new,translog,config,generation,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,snapshot,snapshot,translog,new,snapshot,from,gen,new,translog,translog,generation,generation,uuid,min,gen,for,recovery,long,assert,equals,synced,docs,size,snapshot,total,operations,for,int,i,0,i,synced,docs,size,i,translog,operation,next,snapshot,next,assert,equals,synced,docs,get,i,next,get,source,source,utf8to,string,assert,not,null,operation,i,must,be,non,null,next
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1524684173;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1528706846;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1531910483;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1533295538;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1533641732;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1534848846;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1535046779;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1537806831;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1538067637;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1539615817;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(), Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1542697754;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                    Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                    Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,_            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1542962614;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                    Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                    Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,_            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1544437584;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                    Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                    Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,_            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1544684920;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                    Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                    Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,_            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testRecoveryFromFailureOnTrimming() throws IOException;1545236365;Tests the situation where the node crashes after a translog gen was committed to lucene, but before the translog had the chance_to clean up its files.;public void testRecoveryFromFailureOnTrimming() throws IOException {_        Path tempDir = createTempDir()__        final FailSwitch fail = new FailSwitch()__        fail.failNever()__        final TranslogConfig config = getTranslogConfig(tempDir)__        final long comittedGeneration__        final String translogUUID__        try (Translog translog = getFailableTranslog(fail, config)) {_            final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__            _            deletionPolicy.setRetentionSizeInBytes(-1)__            deletionPolicy.setRetentionAgeInMillis(-1)__            translogUUID = translog.getTranslogUUID()__            int translogOperations = randomIntBetween(10, 100)__            for (int op = 0_ op < translogOperations / 2_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                    Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            translog.rollGeneration()__            comittedGeneration = randomLongBetween(2, translog.currentFileGeneration())__            for (int op = translogOperations / 2_ op < translogOperations_ op++) {_                translog.add(new Translog.Index("test", "" + op, op, primaryTerm.get(),_                    Integer.toString(op).getBytes(Charset.forName("UTF-8"))))__                if (rarely()) {_                    translog.rollGeneration()__                }_            }_            deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, translog.currentFileGeneration()))__            deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__            fail.failRandomly()__            try {_                translog.trimUnreferencedReaders()__            } catch (Exception e) {_                _            }_        }_        final TranslogDeletionPolicy deletionPolicy = new TranslogDeletionPolicy(-1, -1)__        deletionPolicy.setTranslogGenerationOfLastCommit(randomLongBetween(comittedGeneration, Long.MAX_VALUE))__        deletionPolicy.setMinTranslogGenerationForRecovery(comittedGeneration)__        try (Translog translog = new Translog(config, translogUUID, deletionPolicy,_            () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)) {_            _            assertThat(translog.getMinFileGeneration(), greaterThanOrEqualTo(1L))__            assertThat(translog.getMinFileGeneration(), lessThanOrEqualTo(comittedGeneration))__            assertFilePresences(translog)__            translog.trimUnreferencedReaders()__            assertThat(translog.getMinFileGeneration(), equalTo(comittedGeneration))__            assertFilePresences(translog)__        }_    };tests,the,situation,where,the,node,crashes,after,a,translog,gen,was,committed,to,lucene,but,before,the,translog,had,the,chance,to,clean,up,its,files;public,void,test,recovery,from,failure,on,trimming,throws,ioexception,path,temp,dir,create,temp,dir,final,fail,switch,fail,new,fail,switch,fail,fail,never,final,translog,config,config,get,translog,config,temp,dir,final,long,comitted,generation,final,string,translog,uuid,try,translog,translog,get,failable,translog,fail,config,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,deletion,policy,set,retention,size,in,bytes,1,deletion,policy,set,retention,age,in,millis,1,translog,uuid,translog,get,translog,uuid,int,translog,operations,random,int,between,10,100,for,int,op,0,op,translog,operations,2,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,translog,roll,generation,comitted,generation,random,long,between,2,translog,current,file,generation,for,int,op,translog,operations,2,op,translog,operations,op,translog,add,new,translog,index,test,op,op,primary,term,get,integer,to,string,op,get,bytes,charset,for,name,utf,8,if,rarely,translog,roll,generation,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,fail,fail,randomly,try,translog,trim,unreferenced,readers,catch,exception,e,final,translog,deletion,policy,deletion,policy,new,translog,deletion,policy,1,1,deletion,policy,set,translog,generation,of,last,commit,random,long,between,comitted,generation,long,deletion,policy,set,min,translog,generation,for,recovery,comitted,generation,try,translog,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,assert,that,translog,get,min,file,generation,greater,than,or,equal,to,1l,assert,that,translog,get,min,file,generation,less,than,or,equal,to,comitted,generation,assert,file,presences,translog,translog,trim,unreferenced,readers,assert,that,translog,get,min,file,generation,equal,to,comitted,generation,assert,file,presences,translog
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1524684173;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1528706846;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1531910483;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1533295538;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1533641732;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1534848846;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1535046779;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1537806831;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1538067637;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1539615817;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1542697754;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1542962614;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1544437584;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1544684920;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testConcurrentWriteViewsAndSnapshot() throws Throwable;1545236365;Tests that concurrent readers and writes maintain view and snapshot semantics;public void testConcurrentWriteViewsAndSnapshot() throws Throwable {_        final Thread[] writers = new Thread[randomIntBetween(1, 3)]__        final Thread[] readers = new Thread[randomIntBetween(1, 3)]__        final int flushEveryOps = randomIntBetween(5, 100)__        final int maxOps = randomIntBetween(200, 1000)__        final Object signalReaderSomeDataWasIndexed = new Object()__        final AtomicLong idGenerator = new AtomicLong()__        final CyclicBarrier barrier = new CyclicBarrier(writers.length + readers.length + 1)___        _        final Map<Translog.Operation, Translog.Location> writtenOps = ConcurrentCollections.newConcurrentMap()___        _        final AtomicBoolean run = new AtomicBoolean(true)___        final Object flushMutex = new Object()__        final AtomicLong lastCommittedLocalCheckpoint = new AtomicLong(SequenceNumbers.NO_OPS_PERFORMED)__        final LocalCheckpointTracker tracker = LocalCheckpointTrackerTests.createEmptyTracker()__        final TranslogDeletionPolicy deletionPolicy = translog.getDeletionPolicy()__        _        final List<Exception> errors = new CopyOnWriteArrayList<>()__        logger.info("using [{}] readers. [{}] writers. flushing every ~[{}] ops.", readers.length, writers.length, flushEveryOps)__        for (int i = 0_ i < writers.length_ i++) {_            final String threadName = "writer_" + i__            final int threadId = i__            writers[i] = new Thread(new AbstractRunnable() {_                @Override_                public void doRun() throws BrokenBarrierException, InterruptedException, IOException {_                    barrier.await()__                    int counter = 0__                    while (run.get() && idGenerator.get() < maxOps) {_                        long id = idGenerator.getAndIncrement()__                        final Translog.Operation op__                        final Translog.Operation.Type type =_                            Translog.Operation.Type.values()[((int) (id % Translog.Operation.Type.values().length))]__                        switch (type) {_                            case CREATE:_                            case INDEX:_                                op = new Translog.Index("type", "" + id, id, primaryTerm.get(), new byte[]{(byte) id})__                                break__                            case DELETE:_                                op = new Translog.Delete("test", Long.toString(id), id, primaryTerm.get(), newUid(Long.toString(id)))__                                break__                            case NO_OP:_                                op = new Translog.NoOp(id, 1, Long.toString(id))__                                break__                            default:_                                throw new AssertionError("unsupported operation type [" + type + "]")__                        }_                        Translog.Location location = translog.add(op)__                        tracker.markSeqNoAsCompleted(id)__                        Translog.Location existing = writtenOps.put(op, location)__                        if (existing != null) {_                            fail("duplicate op [" + op + "], old entry at " + location)__                        }_                        if (id % writers.length == threadId) {_                            translog.ensureSynced(location)__                        }_                        if (id % flushEveryOps == 0) {_                            synchronized (flushMutex) {_                                _                                _                                long localCheckpoint = tracker.getCheckpoint()__                                translog.rollGeneration()__                                _                                lastCommittedLocalCheckpoint.set(localCheckpoint)__                                deletionPolicy.setTranslogGenerationOfLastCommit(translog.currentFileGeneration())__                                deletionPolicy.setMinTranslogGenerationForRecovery(_                                    translog.getMinGenerationForSeqNo(localCheckpoint + 1).translogFileGeneration)__                                translog.trimUnreferencedReaders()__                            }_                        }_                        if (id % 7 == 0) {_                            synchronized (signalReaderSomeDataWasIndexed) {_                                signalReaderSomeDataWasIndexed.notifyAll()__                            }_                        }_                        counter++__                    }_                    logger.info("--> [{}] done. wrote [{}] ops.", threadName, counter)__                }__                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> writer [{}] had an error", threadName), e)__                    errors.add(e)__                }_            }, threadName)__            writers[i].start()__        }__        for (int i = 0_ i < readers.length_ i++) {_            final String threadId = "reader_" + i__            readers[i] = new Thread(new AbstractRunnable() {_                Closeable retentionLock = null__                long committedLocalCheckpointAtView___                @Override_                public void onFailure(Exception e) {_                    logger.error(() -> new ParameterizedMessage("--> reader [{}] had an error", threadId), e)__                    errors.add(e)__                    try {_                        closeRetentionLock()__                    } catch (IOException inner) {_                        inner.addSuppressed(e)__                        logger.error("unexpected error while closing view, after failure", inner)__                    }_                }__                void closeRetentionLock() throws IOException {_                    if (retentionLock != null) {_                        retentionLock.close()__                    }_                }__                void acquireRetentionLock() throws IOException {_                    closeRetentionLock()__                    retentionLock = translog.acquireRetentionLock()__                    _                    _                    committedLocalCheckpointAtView = lastCommittedLocalCheckpoint.get()__                    logger.info("--> [{}] min gen after acquiring lock [{}]", threadId, translog.getMinFileGeneration())__                }__                @Override_                protected void doRun() throws Exception {_                    barrier.await()__                    int iter = 0__                    while (idGenerator.get() < maxOps) {_                        if (iter++ % 10 == 0) {_                            acquireRetentionLock()__                        }__                        _                        _                        Set<Translog.Operation> expectedOps = new HashSet<>(writtenOps.keySet())__                        expectedOps.removeIf(op -> op.seqNo() <= committedLocalCheckpointAtView)__                        try (Translog.Snapshot snapshot = translog.newSnapshotFromMinSeqNo(committedLocalCheckpointAtView + 1L)) {_                            Translog.Operation op__                            while ((op = snapshot.next()) != null) {_                                expectedOps.remove(op)__                            }_                        }_                        if (expectedOps.isEmpty() == false) {_                            StringBuilder missed = new StringBuilder("missed ").append(expectedOps.size())_                                .append(" operations from [").append(committedLocalCheckpointAtView + 1L).append("]")__                            boolean failed = false__                            for (Translog.Operation expectedOp : expectedOps) {_                                final Translog.Location loc = writtenOps.get(expectedOp)__                                failed = true__                                missed.append("\n --> [").append(expectedOp).append("] written at ").append(loc)__                            }_                            if (failed) {_                                fail(missed.toString())__                            }_                        }_                        _                        synchronized (signalReaderSomeDataWasIndexed) {_                            if (idGenerator.get() < maxOps) {_                                signalReaderSomeDataWasIndexed.wait()__                            }_                        }_                    }_                    closeRetentionLock()__                    logger.info("--> [{}] done. tested [{}] snapshots", threadId, iter)__                }_            }, threadId)__            readers[i].start()__        }__        barrier.await()__        logger.debug("--> waiting for threads to stop")__        for (Thread thread : writers) {_            thread.join()__        }_        logger.debug("--> waiting for readers to stop")__        _        synchronized (signalReaderSomeDataWasIndexed) {_            idGenerator.set(Long.MAX_VALUE)__            signalReaderSomeDataWasIndexed.notifyAll()__        }_        for (Thread thread : readers) {_            thread.join()__        }_        if (errors.size() > 0) {_            Throwable e = errors.get(0)__            for (Throwable suppress : errors.subList(1, errors.size())) {_                e.addSuppressed(suppress)__            }_            throw e__        }_        logger.info("--> test done. total ops written [{}]", writtenOps.size())__    };tests,that,concurrent,readers,and,writes,maintain,view,and,snapshot,semantics;public,void,test,concurrent,write,views,and,snapshot,throws,throwable,final,thread,writers,new,thread,random,int,between,1,3,final,thread,readers,new,thread,random,int,between,1,3,final,int,flush,every,ops,random,int,between,5,100,final,int,max,ops,random,int,between,200,1000,final,object,signal,reader,some,data,was,indexed,new,object,final,atomic,long,id,generator,new,atomic,long,final,cyclic,barrier,barrier,new,cyclic,barrier,writers,length,readers,length,1,final,map,translog,operation,translog,location,written,ops,concurrent,collections,new,concurrent,map,final,atomic,boolean,run,new,atomic,boolean,true,final,object,flush,mutex,new,object,final,atomic,long,last,committed,local,checkpoint,new,atomic,long,sequence,numbers,final,local,checkpoint,tracker,tracker,local,checkpoint,tracker,tests,create,empty,tracker,final,translog,deletion,policy,deletion,policy,translog,get,deletion,policy,final,list,exception,errors,new,copy,on,write,array,list,logger,info,using,readers,writers,flushing,every,ops,readers,length,writers,length,flush,every,ops,for,int,i,0,i,writers,length,i,final,string,thread,name,i,final,int,thread,id,i,writers,i,new,thread,new,abstract,runnable,override,public,void,do,run,throws,broken,barrier,exception,interrupted,exception,ioexception,barrier,await,int,counter,0,while,run,get,id,generator,get,max,ops,long,id,id,generator,get,and,increment,final,translog,operation,op,final,translog,operation,type,type,translog,operation,type,values,int,id,translog,operation,type,values,length,switch,type,case,create,case,index,op,new,translog,index,type,id,id,primary,term,get,new,byte,byte,id,break,case,delete,op,new,translog,delete,test,long,to,string,id,id,primary,term,get,new,uid,long,to,string,id,break,case,op,new,translog,no,op,id,1,long,to,string,id,break,default,throw,new,assertion,error,unsupported,operation,type,type,translog,location,location,translog,add,op,tracker,mark,seq,no,as,completed,id,translog,location,existing,written,ops,put,op,location,if,existing,null,fail,duplicate,op,op,old,entry,at,location,if,id,writers,length,thread,id,translog,ensure,synced,location,if,id,flush,every,ops,0,synchronized,flush,mutex,long,local,checkpoint,tracker,get,checkpoint,translog,roll,generation,last,committed,local,checkpoint,set,local,checkpoint,deletion,policy,set,translog,generation,of,last,commit,translog,current,file,generation,deletion,policy,set,min,translog,generation,for,recovery,translog,get,min,generation,for,seq,no,local,checkpoint,1,translog,file,generation,translog,trim,unreferenced,readers,if,id,7,0,synchronized,signal,reader,some,data,was,indexed,signal,reader,some,data,was,indexed,notify,all,counter,logger,info,done,wrote,ops,thread,name,counter,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,writer,had,an,error,thread,name,e,errors,add,e,thread,name,writers,i,start,for,int,i,0,i,readers,length,i,final,string,thread,id,i,readers,i,new,thread,new,abstract,runnable,closeable,retention,lock,null,long,committed,local,checkpoint,at,view,override,public,void,on,failure,exception,e,logger,error,new,parameterized,message,reader,had,an,error,thread,id,e,errors,add,e,try,close,retention,lock,catch,ioexception,inner,inner,add,suppressed,e,logger,error,unexpected,error,while,closing,view,after,failure,inner,void,close,retention,lock,throws,ioexception,if,retention,lock,null,retention,lock,close,void,acquire,retention,lock,throws,ioexception,close,retention,lock,retention,lock,translog,acquire,retention,lock,committed,local,checkpoint,at,view,last,committed,local,checkpoint,get,logger,info,min,gen,after,acquiring,lock,thread,id,translog,get,min,file,generation,override,protected,void,do,run,throws,exception,barrier,await,int,iter,0,while,id,generator,get,max,ops,if,iter,10,0,acquire,retention,lock,set,translog,operation,expected,ops,new,hash,set,written,ops,key,set,expected,ops,remove,if,op,op,seq,no,committed,local,checkpoint,at,view,try,translog,snapshot,snapshot,translog,new,snapshot,from,min,seq,no,committed,local,checkpoint,at,view,1l,translog,operation,op,while,op,snapshot,next,null,expected,ops,remove,op,if,expected,ops,is,empty,false,string,builder,missed,new,string,builder,missed,append,expected,ops,size,append,operations,from,append,committed,local,checkpoint,at,view,1l,append,boolean,failed,false,for,translog,operation,expected,op,expected,ops,final,translog,location,loc,written,ops,get,expected,op,failed,true,missed,append,n,append,expected,op,append,written,at,append,loc,if,failed,fail,missed,to,string,synchronized,signal,reader,some,data,was,indexed,if,id,generator,get,max,ops,signal,reader,some,data,was,indexed,wait,close,retention,lock,logger,info,done,tested,snapshots,thread,id,iter,thread,id,readers,i,start,barrier,await,logger,debug,waiting,for,threads,to,stop,for,thread,thread,writers,thread,join,logger,debug,waiting,for,readers,to,stop,synchronized,signal,reader,some,data,was,indexed,id,generator,set,long,signal,reader,some,data,was,indexed,notify,all,for,thread,thread,readers,thread,join,if,errors,size,0,throwable,e,errors,get,0,for,throwable,suppress,errors,sub,list,1,errors,size,e,add,suppressed,suppress,throw,e,logger,info,test,done,total,ops,written,written,ops,size
TranslogTests -> public void testPendingDelete() throws IOException;1524684173;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1528706846;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1531910483;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1533295538;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1533641732;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1534848846;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1535046779;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1537806831;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1538067637;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1539615817;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1542697754;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1542962614;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1544437584;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1544684920;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
TranslogTests -> public void testPendingDelete() throws IOException;1545236365;Tests that closing views after the translog is fine and we can reopen the translog;public void testPendingDelete() throws IOException {_        translog.add(new Translog.Index("test", "1", 0, primaryTerm.get(), new byte[]{1}))__        translog.rollGeneration()__        TranslogConfig config = translog.getConfig()__        final String translogUUID = translog.getTranslogUUID()__        final TranslogDeletionPolicy deletionPolicy = createTranslogDeletionPolicy(config.getIndexSettings())__        translog.close()__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__        translog.add(new Translog.Index("test", "2", 1, primaryTerm.get(), new byte[]{2}))__        translog.rollGeneration()__        Closeable lock = translog.acquireRetentionLock()__        translog.add(new Translog.Index("test", "3", 2, primaryTerm.get(), new byte[]{3}))__        translog.close()__        IOUtils.close(lock)__        translog = new Translog(config, translogUUID, deletionPolicy, () -> SequenceNumbers.NO_OPS_PERFORMED, primaryTerm::get)__    };tests,that,closing,views,after,the,translog,is,fine,and,we,can,reopen,the,translog;public,void,test,pending,delete,throws,ioexception,translog,add,new,translog,index,test,1,0,primary,term,get,new,byte,1,translog,roll,generation,translog,config,config,translog,get,config,final,string,translog,uuid,translog,get,translog,uuid,final,translog,deletion,policy,deletion,policy,create,translog,deletion,policy,config,get,index,settings,translog,close,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get,translog,add,new,translog,index,test,2,1,primary,term,get,new,byte,2,translog,roll,generation,closeable,lock,translog,acquire,retention,lock,translog,add,new,translog,index,test,3,2,primary,term,get,new,byte,3,translog,close,ioutils,close,lock,translog,new,translog,config,translog,uuid,deletion,policy,sequence,numbers,primary,term,get
