commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;public void setUp() throws Exception {     super.setUp().     appender = new MockLogAppender().     Loggers.addAppender(LogManager.getLogger(TransportLogger.class), appender).     appender.start(). }
false;public;0;5;;public void tearDown() throws Exception {     Loggers.removeAppender(LogManager.getLogger(TransportLogger.class), appender).     appender.stop().     super.tearDown(). }
false;public;0;33;;public void testLoggingHandler() throws IOException {     TransportLogger transportLogger = new TransportLogger().     final String writePattern = ".*\\[length: \\d+" + ", request id: \\d+" + ", type: request" + ", version: .*" + ", action: cluster:monitor/stats]" + " WRITE: \\d+B".     final MockLogAppender.LoggingExpectation writeExpectation = new MockLogAppender.PatternSeenEventExcpectation("hot threads request", TransportLogger.class.getCanonicalName(), Level.TRACE, writePattern).     final String readPattern = ".*\\[length: \\d+" + ", request id: \\d+" + ", type: request" + ", version: .*" + ", action: cluster:monitor/stats]" + " READ: \\d+B".     final MockLogAppender.LoggingExpectation readExpectation = new MockLogAppender.PatternSeenEventExcpectation("cluster monitor request", TransportLogger.class.getCanonicalName(), Level.TRACE, readPattern).     appender.addExpectation(writeExpectation).     appender.addExpectation(readExpectation).     BytesReference bytesReference = buildRequest().     transportLogger.logInboundMessage(mock(TcpChannel.class), bytesReference.slice(6, bytesReference.length() - 6)).     transportLogger.logOutboundMessage(mock(TcpChannel.class), bytesReference).     appender.assertAllExpectationsMatched(). }
false;private;0;14;;private BytesReference buildRequest() throws IOException {     try (BytesStreamOutput messageOutput = new BytesStreamOutput()) {         messageOutput.setVersion(Version.CURRENT).         try (ThreadContext context = new ThreadContext(Settings.EMPTY)) {             context.writeTo(messageOutput).         }         messageOutput.writeStringArray(new String[0]).         messageOutput.writeString(ClusterStatsAction.NAME).         new ClusterStatsRequest().writeTo(messageOutput).         BytesReference messageBody = messageOutput.bytes().         final BytesReference header = buildHeader(randomInt(30), messageBody.length()).         return new CompositeBytesReference(header, messageBody).     } }
false;private;2;10;;private BytesReference buildHeader(long requestId, int length) throws IOException {     try (BytesStreamOutput headerOutput = new BytesStreamOutput(TcpHeader.HEADER_SIZE)) {         headerOutput.setVersion(Version.CURRENT).         TcpHeader.writeHeader(headerOutput, requestId, TransportStatus.setRequest((byte) 0), Version.CURRENT, length).         final BytesReference bytes = headerOutput.bytes().         assert bytes.length() == TcpHeader.HEADER_SIZE : "header size mismatch expected: " + TcpHeader.HEADER_SIZE + " but was: " + bytes.length().         return bytes.     } }
