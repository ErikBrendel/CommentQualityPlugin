# id;timestamp;commentText;codeText;commentWords;codeWords
IndicesClusterStateServiceRandomUpdatesTests -> public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID();1533063033;In rare cases it is possible that a nodes gets an instruction to replace a replica_shard that's in POST_RECOVERY with a new initializing primary with the same allocation id._This can happen by batching cluster states that include the starting of the replica, with_closing of the indices, opening it up again and allocating the primary shard to the node in_question. The node should then clean it's initializing replica and replace it with a new_initializing primary.;public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID() {_        disableRandomFailures()__        String index = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ClusterState state = ClusterStateCreationUtils.state(index, randomBoolean(),_            ShardRoutingState.STARTED, ShardRoutingState.INITIALIZING)___        _        ClusterState previousState = ClusterState.builder(state)_            .metaData(MetaData.builder(state.metaData()).remove(index))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        final ShardRouting shardRouting = state.routingTable().index(index).shard(0).replicaShards().get(0)__        final ShardId shardId = shardRouting.shardId()__        DiscoveryNode node = state.nodes().get(shardRouting.currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(state, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(previousState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))__        previousState = state___        _        state = cluster.applyStartedShards(state, state.routingTable().index(index).shard(0).replicaShards())___        _        CloseIndexRequest closeIndexRequest = new CloseIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.closeIndices(state, closeIndexRequest)__        OpenIndexRequest openIndexRequest = new OpenIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.openIndices(state, openIndexRequest)___        localState = adaptClusterStateToLocalNode(state, node)__        previousLocalState = adaptClusterStateToLocalNode(previousState, node)___        indicesCSSvc.applyClusterState(new ClusterChangedEvent("new cluster state", localState, previousLocalState))___        final MockIndexShard shardOrNull = ((RecordingIndicesService) indicesCSSvc.indicesService).getShardOrNull(shardId)__        assertThat(shardOrNull == null ? null : shardOrNull.routingEntry(),_            equalTo(state.getRoutingNodes().node(node.getId()).getByShardId(shardId)))___    };in,rare,cases,it,is,possible,that,a,nodes,gets,an,instruction,to,replace,a,replica,shard,that,s,in,with,a,new,initializing,primary,with,the,same,allocation,id,this,can,happen,by,batching,cluster,states,that,include,the,starting,of,the,replica,with,closing,of,the,indices,opening,it,up,again,and,allocating,the,primary,shard,to,the,node,in,question,the,node,should,then,clean,it,s,initializing,replica,and,replace,it,with,a,new,initializing,primary;public,void,test,initializing,primary,removes,initializing,replica,with,same,aid,disable,random,failures,string,index,random,alpha,of,length,8,to,lower,case,locale,root,cluster,state,state,cluster,state,creation,utils,state,index,random,boolean,shard,routing,state,started,shard,routing,state,initializing,cluster,state,previous,state,cluster,state,builder,state,meta,data,meta,data,builder,state,meta,data,remove,index,routing,table,routing,table,builder,build,build,final,shard,routing,shard,routing,state,routing,table,index,index,shard,0,replica,shards,get,0,final,shard,id,shard,id,shard,routing,shard,id,discovery,node,node,state,nodes,get,shard,routing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,previous,state,state,state,cluster,apply,started,shards,state,state,routing,table,index,index,shard,0,replica,shards,close,index,request,close,index,request,new,close,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,close,indices,state,close,index,request,open,index,request,open,index,request,new,open,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,open,indices,state,open,index,request,local,state,adapt,cluster,state,to,local,node,state,node,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,new,cluster,state,local,state,previous,local,state,final,mock,index,shard,shard,or,null,recording,indices,service,indices,cssvc,indices,service,get,shard,or,null,shard,id,assert,that,shard,or,null,null,null,shard,or,null,routing,entry,equal,to,state,get,routing,nodes,node,node,get,id,get,by,shard,id,shard,id
IndicesClusterStateServiceRandomUpdatesTests -> public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID();1541092382;In rare cases it is possible that a nodes gets an instruction to replace a replica_shard that's in POST_RECOVERY with a new initializing primary with the same allocation id._This can happen by batching cluster states that include the starting of the replica, with_closing of the indices, opening it up again and allocating the primary shard to the node in_question. The node should then clean it's initializing replica and replace it with a new_initializing primary.;public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID() {_        disableRandomFailures()__        String index = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ClusterState state = ClusterStateCreationUtils.state(index, randomBoolean(),_            ShardRoutingState.STARTED, ShardRoutingState.INITIALIZING)___        _        ClusterState previousState = ClusterState.builder(state)_            .metaData(MetaData.builder(state.metaData()).remove(index))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        final ShardRouting shardRouting = state.routingTable().index(index).shard(0).replicaShards().get(0)__        final ShardId shardId = shardRouting.shardId()__        DiscoveryNode node = state.nodes().get(shardRouting.currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(state, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(previousState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))__        previousState = state___        _        state = cluster.applyStartedShards(state, state.routingTable().index(index).shard(0).replicaShards())___        _        CloseIndexRequest closeIndexRequest = new CloseIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.closeIndices(state, closeIndexRequest)__        OpenIndexRequest openIndexRequest = new OpenIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.openIndices(state, openIndexRequest)___        localState = adaptClusterStateToLocalNode(state, node)__        previousLocalState = adaptClusterStateToLocalNode(previousState, node)___        indicesCSSvc.applyClusterState(new ClusterChangedEvent("new cluster state", localState, previousLocalState))___        final MockIndexShard shardOrNull = ((RecordingIndicesService) indicesCSSvc.indicesService).getShardOrNull(shardId)__        assertThat(shardOrNull == null ? null : shardOrNull.routingEntry(),_            equalTo(state.getRoutingNodes().node(node.getId()).getByShardId(shardId)))___    };in,rare,cases,it,is,possible,that,a,nodes,gets,an,instruction,to,replace,a,replica,shard,that,s,in,with,a,new,initializing,primary,with,the,same,allocation,id,this,can,happen,by,batching,cluster,states,that,include,the,starting,of,the,replica,with,closing,of,the,indices,opening,it,up,again,and,allocating,the,primary,shard,to,the,node,in,question,the,node,should,then,clean,it,s,initializing,replica,and,replace,it,with,a,new,initializing,primary;public,void,test,initializing,primary,removes,initializing,replica,with,same,aid,disable,random,failures,string,index,random,alpha,of,length,8,to,lower,case,locale,root,cluster,state,state,cluster,state,creation,utils,state,index,random,boolean,shard,routing,state,started,shard,routing,state,initializing,cluster,state,previous,state,cluster,state,builder,state,meta,data,meta,data,builder,state,meta,data,remove,index,routing,table,routing,table,builder,build,build,final,shard,routing,shard,routing,state,routing,table,index,index,shard,0,replica,shards,get,0,final,shard,id,shard,id,shard,routing,shard,id,discovery,node,node,state,nodes,get,shard,routing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,previous,state,state,state,cluster,apply,started,shards,state,state,routing,table,index,index,shard,0,replica,shards,close,index,request,close,index,request,new,close,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,close,indices,state,close,index,request,open,index,request,open,index,request,new,open,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,open,indices,state,open,index,request,local,state,adapt,cluster,state,to,local,node,state,node,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,new,cluster,state,local,state,previous,local,state,final,mock,index,shard,shard,or,null,recording,indices,service,indices,cssvc,indices,service,get,shard,or,null,shard,id,assert,that,shard,or,null,null,null,shard,or,null,routing,entry,equal,to,state,get,routing,nodes,node,node,get,id,get,by,shard,id,shard,id
IndicesClusterStateServiceRandomUpdatesTests -> public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID();1543959410;In rare cases it is possible that a nodes gets an instruction to replace a replica_shard that's in POST_RECOVERY with a new initializing primary with the same allocation id._This can happen by batching cluster states that include the starting of the replica, with_closing of the indices, opening it up again and allocating the primary shard to the node in_question. The node should then clean it's initializing replica and replace it with a new_initializing primary.;public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID() {_        disableRandomFailures()__        String index = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ClusterState state = ClusterStateCreationUtils.state(index, randomBoolean(),_            ShardRoutingState.STARTED, ShardRoutingState.INITIALIZING)___        _        ClusterState previousState = ClusterState.builder(state)_            .metaData(MetaData.builder(state.metaData()).remove(index))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        final ShardRouting shardRouting = state.routingTable().index(index).shard(0).replicaShards().get(0)__        final ShardId shardId = shardRouting.shardId()__        DiscoveryNode node = state.nodes().get(shardRouting.currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(state, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(previousState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))__        previousState = state___        _        state = cluster.applyStartedShards(state, state.routingTable().index(index).shard(0).replicaShards())___        _        CloseIndexRequest closeIndexRequest = new CloseIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.closeIndices(state, closeIndexRequest)__        OpenIndexRequest openIndexRequest = new OpenIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.openIndices(state, openIndexRequest)___        localState = adaptClusterStateToLocalNode(state, node)__        previousLocalState = adaptClusterStateToLocalNode(previousState, node)___        indicesCSSvc.applyClusterState(new ClusterChangedEvent("new cluster state", localState, previousLocalState))___        final MockIndexShard shardOrNull = ((RecordingIndicesService) indicesCSSvc.indicesService).getShardOrNull(shardId)__        assertThat(shardOrNull == null ? null : shardOrNull.routingEntry(),_            equalTo(state.getRoutingNodes().node(node.getId()).getByShardId(shardId)))___    };in,rare,cases,it,is,possible,that,a,nodes,gets,an,instruction,to,replace,a,replica,shard,that,s,in,with,a,new,initializing,primary,with,the,same,allocation,id,this,can,happen,by,batching,cluster,states,that,include,the,starting,of,the,replica,with,closing,of,the,indices,opening,it,up,again,and,allocating,the,primary,shard,to,the,node,in,question,the,node,should,then,clean,it,s,initializing,replica,and,replace,it,with,a,new,initializing,primary;public,void,test,initializing,primary,removes,initializing,replica,with,same,aid,disable,random,failures,string,index,random,alpha,of,length,8,to,lower,case,locale,root,cluster,state,state,cluster,state,creation,utils,state,index,random,boolean,shard,routing,state,started,shard,routing,state,initializing,cluster,state,previous,state,cluster,state,builder,state,meta,data,meta,data,builder,state,meta,data,remove,index,routing,table,routing,table,builder,build,build,final,shard,routing,shard,routing,state,routing,table,index,index,shard,0,replica,shards,get,0,final,shard,id,shard,id,shard,routing,shard,id,discovery,node,node,state,nodes,get,shard,routing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,previous,state,state,state,cluster,apply,started,shards,state,state,routing,table,index,index,shard,0,replica,shards,close,index,request,close,index,request,new,close,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,close,indices,state,close,index,request,open,index,request,open,index,request,new,open,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,open,indices,state,open,index,request,local,state,adapt,cluster,state,to,local,node,state,node,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,new,cluster,state,local,state,previous,local,state,final,mock,index,shard,shard,or,null,recording,indices,service,indices,cssvc,indices,service,get,shard,or,null,shard,id,assert,that,shard,or,null,null,null,shard,or,null,routing,entry,equal,to,state,get,routing,nodes,node,node,get,id,get,by,shard,id,shard,id
IndicesClusterStateServiceRandomUpdatesTests -> public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID();1546850547;In rare cases it is possible that a nodes gets an instruction to replace a replica_shard that's in POST_RECOVERY with a new initializing primary with the same allocation id._This can happen by batching cluster states that include the starting of the replica, with_closing of the indices, opening it up again and allocating the primary shard to the node in_question. The node should then clean it's initializing replica and replace it with a new_initializing primary.;public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID() {_        disableRandomFailures()__        String index = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ClusterState state = ClusterStateCreationUtils.state(index, randomBoolean(),_            ShardRoutingState.STARTED, ShardRoutingState.INITIALIZING)___        _        ClusterState previousState = ClusterState.builder(state)_            .metaData(MetaData.builder(state.metaData()).remove(index))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        final ShardRouting shardRouting = state.routingTable().index(index).shard(0).replicaShards().get(0)__        final ShardId shardId = shardRouting.shardId()__        DiscoveryNode node = state.nodes().get(shardRouting.currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(state, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(previousState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))__        previousState = state___        _        state = cluster.applyStartedShards(state, state.routingTable().index(index).shard(0).replicaShards())___        _        CloseIndexRequest closeIndexRequest = new CloseIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.closeIndices(state, closeIndexRequest)__        OpenIndexRequest openIndexRequest = new OpenIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.openIndices(state, openIndexRequest)___        localState = adaptClusterStateToLocalNode(state, node)__        previousLocalState = adaptClusterStateToLocalNode(previousState, node)___        indicesCSSvc.applyClusterState(new ClusterChangedEvent("new cluster state", localState, previousLocalState))___        final MockIndexShard shardOrNull = ((RecordingIndicesService) indicesCSSvc.indicesService).getShardOrNull(shardId)__        assertThat(shardOrNull == null ? null : shardOrNull.routingEntry(),_            equalTo(state.getRoutingNodes().node(node.getId()).getByShardId(shardId)))___    };in,rare,cases,it,is,possible,that,a,nodes,gets,an,instruction,to,replace,a,replica,shard,that,s,in,with,a,new,initializing,primary,with,the,same,allocation,id,this,can,happen,by,batching,cluster,states,that,include,the,starting,of,the,replica,with,closing,of,the,indices,opening,it,up,again,and,allocating,the,primary,shard,to,the,node,in,question,the,node,should,then,clean,it,s,initializing,replica,and,replace,it,with,a,new,initializing,primary;public,void,test,initializing,primary,removes,initializing,replica,with,same,aid,disable,random,failures,string,index,random,alpha,of,length,8,to,lower,case,locale,root,cluster,state,state,cluster,state,creation,utils,state,index,random,boolean,shard,routing,state,started,shard,routing,state,initializing,cluster,state,previous,state,cluster,state,builder,state,meta,data,meta,data,builder,state,meta,data,remove,index,routing,table,routing,table,builder,build,build,final,shard,routing,shard,routing,state,routing,table,index,index,shard,0,replica,shards,get,0,final,shard,id,shard,id,shard,routing,shard,id,discovery,node,node,state,nodes,get,shard,routing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,previous,state,state,state,cluster,apply,started,shards,state,state,routing,table,index,index,shard,0,replica,shards,close,index,request,close,index,request,new,close,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,close,indices,state,close,index,request,open,index,request,open,index,request,new,open,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,open,indices,state,open,index,request,local,state,adapt,cluster,state,to,local,node,state,node,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,new,cluster,state,local,state,previous,local,state,final,mock,index,shard,shard,or,null,recording,indices,service,indices,cssvc,indices,service,get,shard,or,null,shard,id,assert,that,shard,or,null,null,null,shard,or,null,routing,entry,equal,to,state,get,routing,nodes,node,node,get,id,get,by,shard,id,shard,id
IndicesClusterStateServiceRandomUpdatesTests -> public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID();1548593396;In rare cases it is possible that a nodes gets an instruction to replace a replica_shard that's in POST_RECOVERY with a new initializing primary with the same allocation id._This can happen by batching cluster states that include the starting of the replica, with_closing of the indices, opening it up again and allocating the primary shard to the node in_question. The node should then clean it's initializing replica and replace it with a new_initializing primary.;public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID() {_        disableRandomFailures()__        String index = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ClusterState state = ClusterStateCreationUtils.state(index, randomBoolean(),_            ShardRoutingState.STARTED, ShardRoutingState.INITIALIZING)___        _        ClusterState previousState = ClusterState.builder(state)_            .metaData(MetaData.builder(state.metaData()).remove(index))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        final ShardRouting shardRouting = state.routingTable().index(index).shard(0).replicaShards().get(0)__        final ShardId shardId = shardRouting.shardId()__        DiscoveryNode node = state.nodes().get(shardRouting.currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(state, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(previousState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))__        previousState = state___        _        state = cluster.applyStartedShards(state, state.routingTable().index(index).shard(0).replicaShards())___        _        CloseIndexRequest closeIndexRequest = new CloseIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.closeIndices(state, closeIndexRequest)__        OpenIndexRequest openIndexRequest = new OpenIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.openIndices(state, openIndexRequest)___        localState = adaptClusterStateToLocalNode(state, node)__        previousLocalState = adaptClusterStateToLocalNode(previousState, node)___        indicesCSSvc.applyClusterState(new ClusterChangedEvent("new cluster state", localState, previousLocalState))___        final MockIndexShard shardOrNull = ((RecordingIndicesService) indicesCSSvc.indicesService).getShardOrNull(shardId)__        assertThat(shardOrNull == null ? null : shardOrNull.routingEntry(),_            equalTo(state.getRoutingNodes().node(node.getId()).getByShardId(shardId)))___    };in,rare,cases,it,is,possible,that,a,nodes,gets,an,instruction,to,replace,a,replica,shard,that,s,in,with,a,new,initializing,primary,with,the,same,allocation,id,this,can,happen,by,batching,cluster,states,that,include,the,starting,of,the,replica,with,closing,of,the,indices,opening,it,up,again,and,allocating,the,primary,shard,to,the,node,in,question,the,node,should,then,clean,it,s,initializing,replica,and,replace,it,with,a,new,initializing,primary;public,void,test,initializing,primary,removes,initializing,replica,with,same,aid,disable,random,failures,string,index,random,alpha,of,length,8,to,lower,case,locale,root,cluster,state,state,cluster,state,creation,utils,state,index,random,boolean,shard,routing,state,started,shard,routing,state,initializing,cluster,state,previous,state,cluster,state,builder,state,meta,data,meta,data,builder,state,meta,data,remove,index,routing,table,routing,table,builder,build,build,final,shard,routing,shard,routing,state,routing,table,index,index,shard,0,replica,shards,get,0,final,shard,id,shard,id,shard,routing,shard,id,discovery,node,node,state,nodes,get,shard,routing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,previous,state,state,state,cluster,apply,started,shards,state,state,routing,table,index,index,shard,0,replica,shards,close,index,request,close,index,request,new,close,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,close,indices,state,close,index,request,open,index,request,open,index,request,new,open,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,open,indices,state,open,index,request,local,state,adapt,cluster,state,to,local,node,state,node,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,new,cluster,state,local,state,previous,local,state,final,mock,index,shard,shard,or,null,recording,indices,service,indices,cssvc,indices,service,get,shard,or,null,shard,id,assert,that,shard,or,null,null,null,shard,or,null,routing,entry,equal,to,state,get,routing,nodes,node,node,get,id,get,by,shard,id,shard,id
IndicesClusterStateServiceRandomUpdatesTests -> public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID();1548770980;In rare cases it is possible that a nodes gets an instruction to replace a replica_shard that's in POST_RECOVERY with a new initializing primary with the same allocation id._This can happen by batching cluster states that include the starting of the replica, with_closing of the indices, opening it up again and allocating the primary shard to the node in_question. The node should then clean it's initializing replica and replace it with a new_initializing primary.;public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID() {_        disableRandomFailures()__        String index = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ClusterState state = ClusterStateCreationUtils.state(index, randomBoolean(),_            ShardRoutingState.STARTED, ShardRoutingState.INITIALIZING)___        _        ClusterState previousState = ClusterState.builder(state)_            .metaData(MetaData.builder(state.metaData()).remove(index))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        final ShardRouting shardRouting = state.routingTable().index(index).shard(0).replicaShards().get(0)__        final ShardId shardId = shardRouting.shardId()__        DiscoveryNode node = state.nodes().get(shardRouting.currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(state, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(previousState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))__        previousState = state___        _        state = cluster.applyStartedShards(state, state.routingTable().index(index).shard(0).replicaShards())___        _        CloseIndexRequest closeIndexRequest = new CloseIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.closeIndices(state, closeIndexRequest)__        OpenIndexRequest openIndexRequest = new OpenIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.openIndices(state, openIndexRequest)___        localState = adaptClusterStateToLocalNode(state, node)__        previousLocalState = adaptClusterStateToLocalNode(previousState, node)___        indicesCSSvc.applyClusterState(new ClusterChangedEvent("new cluster state", localState, previousLocalState))___        final MockIndexShard shardOrNull = ((RecordingIndicesService) indicesCSSvc.indicesService).getShardOrNull(shardId)__        assertThat(shardOrNull == null ? null : shardOrNull.routingEntry(),_            equalTo(state.getRoutingNodes().node(node.getId()).getByShardId(shardId)))___    };in,rare,cases,it,is,possible,that,a,nodes,gets,an,instruction,to,replace,a,replica,shard,that,s,in,with,a,new,initializing,primary,with,the,same,allocation,id,this,can,happen,by,batching,cluster,states,that,include,the,starting,of,the,replica,with,closing,of,the,indices,opening,it,up,again,and,allocating,the,primary,shard,to,the,node,in,question,the,node,should,then,clean,it,s,initializing,replica,and,replace,it,with,a,new,initializing,primary;public,void,test,initializing,primary,removes,initializing,replica,with,same,aid,disable,random,failures,string,index,random,alpha,of,length,8,to,lower,case,locale,root,cluster,state,state,cluster,state,creation,utils,state,index,random,boolean,shard,routing,state,started,shard,routing,state,initializing,cluster,state,previous,state,cluster,state,builder,state,meta,data,meta,data,builder,state,meta,data,remove,index,routing,table,routing,table,builder,build,build,final,shard,routing,shard,routing,state,routing,table,index,index,shard,0,replica,shards,get,0,final,shard,id,shard,id,shard,routing,shard,id,discovery,node,node,state,nodes,get,shard,routing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,previous,state,state,state,cluster,apply,started,shards,state,state,routing,table,index,index,shard,0,replica,shards,close,index,request,close,index,request,new,close,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,close,indices,state,close,index,request,open,index,request,open,index,request,new,open,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,open,indices,state,open,index,request,local,state,adapt,cluster,state,to,local,node,state,node,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,new,cluster,state,local,state,previous,local,state,final,mock,index,shard,shard,or,null,recording,indices,service,indices,cssvc,indices,service,get,shard,or,null,shard,id,assert,that,shard,or,null,null,null,shard,or,null,routing,entry,equal,to,state,get,routing,nodes,node,node,get,id,get,by,shard,id,shard,id
IndicesClusterStateServiceRandomUpdatesTests -> public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID();1549294529;In rare cases it is possible that a nodes gets an instruction to replace a replica_shard that's in POST_RECOVERY with a new initializing primary with the same allocation id._This can happen by batching cluster states that include the starting of the replica, with_closing of the indices, opening it up again and allocating the primary shard to the node in_question. The node should then clean it's initializing replica and replace it with a new_initializing primary.;public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID() {_        disableRandomFailures()__        String index = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ClusterState state = ClusterStateCreationUtils.state(index, randomBoolean(),_            ShardRoutingState.STARTED, ShardRoutingState.INITIALIZING)___        _        ClusterState previousState = ClusterState.builder(state)_            .metaData(MetaData.builder(state.metaData()).remove(index))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        final ShardRouting shardRouting = state.routingTable().index(index).shard(0).replicaShards().get(0)__        final ShardId shardId = shardRouting.shardId()__        DiscoveryNode node = state.nodes().get(shardRouting.currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(state, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(previousState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))__        previousState = state___        _        state = cluster.applyStartedShards(state, state.routingTable().index(index).shard(0).replicaShards())___        _        CloseIndexRequest closeIndexRequest = new CloseIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.closeIndices(state, closeIndexRequest)__        OpenIndexRequest openIndexRequest = new OpenIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.openIndices(state, openIndexRequest)___        localState = adaptClusterStateToLocalNode(state, node)__        previousLocalState = adaptClusterStateToLocalNode(previousState, node)___        indicesCSSvc.applyClusterState(new ClusterChangedEvent("new cluster state", localState, previousLocalState))___        final MockIndexShard shardOrNull = ((RecordingIndicesService) indicesCSSvc.indicesService).getShardOrNull(shardId)__        assertThat(shardOrNull == null ? null : shardOrNull.routingEntry(),_            equalTo(state.getRoutingNodes().node(node.getId()).getByShardId(shardId)))___    };in,rare,cases,it,is,possible,that,a,nodes,gets,an,instruction,to,replace,a,replica,shard,that,s,in,with,a,new,initializing,primary,with,the,same,allocation,id,this,can,happen,by,batching,cluster,states,that,include,the,starting,of,the,replica,with,closing,of,the,indices,opening,it,up,again,and,allocating,the,primary,shard,to,the,node,in,question,the,node,should,then,clean,it,s,initializing,replica,and,replace,it,with,a,new,initializing,primary;public,void,test,initializing,primary,removes,initializing,replica,with,same,aid,disable,random,failures,string,index,random,alpha,of,length,8,to,lower,case,locale,root,cluster,state,state,cluster,state,creation,utils,state,index,random,boolean,shard,routing,state,started,shard,routing,state,initializing,cluster,state,previous,state,cluster,state,builder,state,meta,data,meta,data,builder,state,meta,data,remove,index,routing,table,routing,table,builder,build,build,final,shard,routing,shard,routing,state,routing,table,index,index,shard,0,replica,shards,get,0,final,shard,id,shard,id,shard,routing,shard,id,discovery,node,node,state,nodes,get,shard,routing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,previous,state,state,state,cluster,apply,started,shards,state,state,routing,table,index,index,shard,0,replica,shards,close,index,request,close,index,request,new,close,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,close,indices,state,close,index,request,open,index,request,open,index,request,new,open,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,open,indices,state,open,index,request,local,state,adapt,cluster,state,to,local,node,state,node,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,new,cluster,state,local,state,previous,local,state,final,mock,index,shard,shard,or,null,recording,indices,service,indices,cssvc,indices,service,get,shard,or,null,shard,id,assert,that,shard,or,null,null,null,shard,or,null,routing,entry,equal,to,state,get,routing,nodes,node,node,get,id,get,by,shard,id,shard,id
IndicesClusterStateServiceRandomUpdatesTests -> public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID();1549356476;In rare cases it is possible that a nodes gets an instruction to replace a replica_shard that's in POST_RECOVERY with a new initializing primary with the same allocation id._This can happen by batching cluster states that include the starting of the replica, with_closing of the indices, opening it up again and allocating the primary shard to the node in_question. The node should then clean it's initializing replica and replace it with a new_initializing primary.;public void testInitializingPrimaryRemovesInitializingReplicaWithSameAID() {_        disableRandomFailures()__        String index = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ClusterState state = ClusterStateCreationUtils.state(index, randomBoolean(),_            ShardRoutingState.STARTED, ShardRoutingState.INITIALIZING)___        _        ClusterState previousState = ClusterState.builder(state)_            .metaData(MetaData.builder(state.metaData()).remove(index))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        final ShardRouting shardRouting = state.routingTable().index(index).shard(0).replicaShards().get(0)__        final ShardId shardId = shardRouting.shardId()__        DiscoveryNode node = state.nodes().get(shardRouting.currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(state, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(previousState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))__        previousState = state___        _        state = cluster.applyStartedShards(state, state.routingTable().index(index).shard(0).replicaShards())___        _        CloseIndexRequest closeIndexRequest = new CloseIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.closeIndices(state, closeIndexRequest)__        OpenIndexRequest openIndexRequest = new OpenIndexRequest(state.metaData().index(index).getIndex().getName())__        state = cluster.openIndices(state, openIndexRequest)___        localState = adaptClusterStateToLocalNode(state, node)__        previousLocalState = adaptClusterStateToLocalNode(previousState, node)___        indicesCSSvc.applyClusterState(new ClusterChangedEvent("new cluster state", localState, previousLocalState))___        final MockIndexShard shardOrNull = ((RecordingIndicesService) indicesCSSvc.indicesService).getShardOrNull(shardId)__        assertThat(shardOrNull == null ? null : shardOrNull.routingEntry(),_            equalTo(state.getRoutingNodes().node(node.getId()).getByShardId(shardId)))___    };in,rare,cases,it,is,possible,that,a,nodes,gets,an,instruction,to,replace,a,replica,shard,that,s,in,with,a,new,initializing,primary,with,the,same,allocation,id,this,can,happen,by,batching,cluster,states,that,include,the,starting,of,the,replica,with,closing,of,the,indices,opening,it,up,again,and,allocating,the,primary,shard,to,the,node,in,question,the,node,should,then,clean,it,s,initializing,replica,and,replace,it,with,a,new,initializing,primary;public,void,test,initializing,primary,removes,initializing,replica,with,same,aid,disable,random,failures,string,index,random,alpha,of,length,8,to,lower,case,locale,root,cluster,state,state,cluster,state,creation,utils,state,index,random,boolean,shard,routing,state,started,shard,routing,state,initializing,cluster,state,previous,state,cluster,state,builder,state,meta,data,meta,data,builder,state,meta,data,remove,index,routing,table,routing,table,builder,build,build,final,shard,routing,shard,routing,state,routing,table,index,index,shard,0,replica,shards,get,0,final,shard,id,shard,id,shard,routing,shard,id,discovery,node,node,state,nodes,get,shard,routing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,previous,state,state,state,cluster,apply,started,shards,state,state,routing,table,index,index,shard,0,replica,shards,close,index,request,close,index,request,new,close,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,close,indices,state,close,index,request,open,index,request,open,index,request,new,open,index,request,state,meta,data,index,index,get,index,get,name,state,cluster,open,indices,state,open,index,request,local,state,adapt,cluster,state,to,local,node,state,node,previous,local,state,adapt,cluster,state,to,local,node,previous,state,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,new,cluster,state,local,state,previous,local,state,final,mock,index,shard,shard,or,null,recording,indices,service,indices,cssvc,indices,service,get,shard,or,null,shard,id,assert,that,shard,or,null,null,null,shard,or,null,routing,entry,equal,to,state,get,routing,nodes,node,node,get,id,get,by,shard,id,shard,id
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1524684173;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1525798022;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1531179852;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1531729807;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1532434432;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1533063033;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1541092382;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1543959410;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1546850547;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1548593396;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1548770980;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1549294529;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
IndicesClusterStateServiceRandomUpdatesTests -> public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures();1549356476;This test ensures that when a node joins a brand new cluster (different cluster UUID),_different from the cluster it was previously a part of, the in-memory index data structures_are all removed but the on disk contents of those indices remain so that they can later be_imported as dangling indices.  Normally, the first cluster state update that the node_receives from the new cluster would contain a cluster block that would cause all in-memory_structures to be removed (see {@link IndicesClusterStateService#applyClusterState(ClusterChangedEvent)}),_but in the case where the node joined and was a few cluster state updates behind, it would_not have received the cluster block, in which case we still need to remove the in-memory_structures while ensuring the data remains on disk.  This test executes this particular_scenario.;public void testJoiningNewClusterOnlyRemovesInMemoryIndexStructures() {_        _        String name = "index_" + randomAlphaOfLength(8).toLowerCase(Locale.ROOT)__        ShardRoutingState[] replicaStates = new ShardRoutingState[randomIntBetween(0, 3)]__        Arrays.fill(replicaStates, ShardRoutingState.INITIALIZING)__        ClusterState stateWithIndex = ClusterStateCreationUtils.state(name, randomBoolean(), ShardRoutingState.INITIALIZING, replicaStates)___        _        ClusterState initialState = ClusterState.builder(stateWithIndex)_            .metaData(MetaData.builder(stateWithIndex.metaData()).remove(name))_            .routingTable(RoutingTable.builder().build())_            .build()___        _        DiscoveryNode node = stateWithIndex.nodes().get(_            randomFrom(stateWithIndex.routingTable().index(name).shardsWithState(INITIALIZING)).currentNodeId())___        _        ClusterState localState = adaptClusterStateToLocalNode(stateWithIndex, node)__        ClusterState previousLocalState = adaptClusterStateToLocalNode(initialState, node)__        IndicesClusterStateService indicesCSSvc = createIndicesClusterStateService(node, RecordingIndicesService::new)__        indicesCSSvc.start()__        indicesCSSvc.applyClusterState(new ClusterChangedEvent("cluster state change that adds the index", localState, previousLocalState))___        _        ClusterState newClusterState = ClusterState.builder(initialState)_            .metaData(MetaData.builder(initialState.metaData()).clusterUUID(UUIDs.randomBase64UUID()))_            .build()___        _        localState = adaptClusterStateToLocalNode(newClusterState, node)__        previousLocalState = adaptClusterStateToLocalNode(stateWithIndex, node)__        indicesCSSvc.applyClusterState(new ClusterChangedEvent(_            "cluster state change with a new cluster UUID (and doesn't contain the index)", localState, previousLocalState))___        _        _        RecordingIndicesService indicesService = (RecordingIndicesService) indicesCSSvc.indicesService__        for (IndexMetaData indexMetaData : stateWithIndex.metaData()) {_            Index index = indexMetaData.getIndex()__            assertNull(indicesService.indexService(index))__            assertFalse(indicesService.isDeleted(index))__        }_    };this,test,ensures,that,when,a,node,joins,a,brand,new,cluster,different,cluster,uuid,different,from,the,cluster,it,was,previously,a,part,of,the,in,memory,index,data,structures,are,all,removed,but,the,on,disk,contents,of,those,indices,remain,so,that,they,can,later,be,imported,as,dangling,indices,normally,the,first,cluster,state,update,that,the,node,receives,from,the,new,cluster,would,contain,a,cluster,block,that,would,cause,all,in,memory,structures,to,be,removed,see,link,indices,cluster,state,service,apply,cluster,state,cluster,changed,event,but,in,the,case,where,the,node,joined,and,was,a,few,cluster,state,updates,behind,it,would,not,have,received,the,cluster,block,in,which,case,we,still,need,to,remove,the,in,memory,structures,while,ensuring,the,data,remains,on,disk,this,test,executes,this,particular,scenario;public,void,test,joining,new,cluster,only,removes,in,memory,index,structures,string,name,random,alpha,of,length,8,to,lower,case,locale,root,shard,routing,state,replica,states,new,shard,routing,state,random,int,between,0,3,arrays,fill,replica,states,shard,routing,state,initializing,cluster,state,state,with,index,cluster,state,creation,utils,state,name,random,boolean,shard,routing,state,initializing,replica,states,cluster,state,initial,state,cluster,state,builder,state,with,index,meta,data,meta,data,builder,state,with,index,meta,data,remove,name,routing,table,routing,table,builder,build,build,discovery,node,node,state,with,index,nodes,get,random,from,state,with,index,routing,table,index,name,shards,with,state,initializing,current,node,id,cluster,state,local,state,adapt,cluster,state,to,local,node,state,with,index,node,cluster,state,previous,local,state,adapt,cluster,state,to,local,node,initial,state,node,indices,cluster,state,service,indices,cssvc,create,indices,cluster,state,service,node,recording,indices,service,new,indices,cssvc,start,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,that,adds,the,index,local,state,previous,local,state,cluster,state,new,cluster,state,cluster,state,builder,initial,state,meta,data,meta,data,builder,initial,state,meta,data,cluster,uuid,uuids,random,base64uuid,build,local,state,adapt,cluster,state,to,local,node,new,cluster,state,node,previous,local,state,adapt,cluster,state,to,local,node,state,with,index,node,indices,cssvc,apply,cluster,state,new,cluster,changed,event,cluster,state,change,with,a,new,cluster,uuid,and,doesn,t,contain,the,index,local,state,previous,local,state,recording,indices,service,indices,service,recording,indices,service,indices,cssvc,indices,service,for,index,meta,data,index,meta,data,state,with,index,meta,data,index,index,index,meta,data,get,index,assert,null,indices,service,index,service,index,assert,false,indices,service,is,deleted,index
