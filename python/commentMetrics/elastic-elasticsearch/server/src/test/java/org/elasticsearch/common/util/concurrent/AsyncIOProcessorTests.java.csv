commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;13;;@Override protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {     if (blockInternal) {         synchronized (this) {             // TODO: check why we need a loop, can't we just use received.addAndGet(candidates.size())             for (int i = 0. i < candidates.size(). i++) {                 received.incrementAndGet().             }         }     } else {         received.addAndGet(candidates.size()).     } }
false;public;0;13;;@Override public void run() {     try {         latch.countDown().         latch.await().         for (int i = 0. i < count. i++) {             semaphore.acquire().             processor.put(new Object(), (ex) -> semaphore.release()).         }     } catch (Exception ex) {         throw new RuntimeException(ex).     } }
false;public;0;47;;public void testPut() throws InterruptedException {     boolean blockInternal = randomBoolean().     AtomicInteger received = new AtomicInteger(0).     AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {          @Override         protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {             if (blockInternal) {                 synchronized (this) {                     // TODO: check why we need a loop, can't we just use received.addAndGet(candidates.size())                     for (int i = 0. i < candidates.size(). i++) {                         received.incrementAndGet().                     }                 }             } else {                 received.addAndGet(candidates.size()).             }         }     }.     Semaphore semaphore = new Semaphore(Integer.MAX_VALUE).     final int count = randomIntBetween(1000, 20000).     Thread[] thread = new Thread[randomIntBetween(3, 10)].     CountDownLatch latch = new CountDownLatch(thread.length).     for (int i = 0. i < thread.length. i++) {         thread[i] = new Thread() {              @Override             public void run() {                 try {                     latch.countDown().                     latch.await().                     for (int i = 0. i < count. i++) {                         semaphore.acquire().                         processor.put(new Object(), (ex) -> semaphore.release()).                     }                 } catch (Exception ex) {                     throw new RuntimeException(ex).                 }             }         }.         thread[i].start().     }     for (int i = 0. i < thread.length. i++) {         thread[i].join().     }     assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS)).     assertEquals(count * thread.length, received.get()). }
false;protected;1;12;;@Override protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {     received.addAndGet(candidates.size()).     if (randomBoolean()) {         failed.addAndGet(candidates.size()).         if (randomBoolean()) {             throw new IOException().         } else {             throw new RuntimeException().         }     } }
false;public;0;18;;@Override public void run() {     try {         latch.countDown().         latch.await().         for (int i = 0. i < count. i++) {             semaphore.acquire().             processor.put(new Object(), (ex) -> {                 if (ex != null) {                     actualFailed.incrementAndGet().                 }                 semaphore.release().             }).         }     } catch (Exception ex) {         throw new RuntimeException(ex).     } }
false;public;0;53;;public void testRandomFail() throws InterruptedException {     AtomicInteger received = new AtomicInteger(0).     AtomicInteger failed = new AtomicInteger(0).     AtomicInteger actualFailed = new AtomicInteger(0).     AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {          @Override         protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {             received.addAndGet(candidates.size()).             if (randomBoolean()) {                 failed.addAndGet(candidates.size()).                 if (randomBoolean()) {                     throw new IOException().                 } else {                     throw new RuntimeException().                 }             }         }     }.     Semaphore semaphore = new Semaphore(Integer.MAX_VALUE).     final int count = randomIntBetween(1000, 20000).     Thread[] thread = new Thread[randomIntBetween(3, 10)].     CountDownLatch latch = new CountDownLatch(thread.length).     for (int i = 0. i < thread.length. i++) {         thread[i] = new Thread() {              @Override             public void run() {                 try {                     latch.countDown().                     latch.await().                     for (int i = 0. i < count. i++) {                         semaphore.acquire().                         processor.put(new Object(), (ex) -> {                             if (ex != null) {                                 actualFailed.incrementAndGet().                             }                             semaphore.release().                         }).                     }                 } catch (Exception ex) {                     throw new RuntimeException(ex).                 }             }         }.         thread[i].start().     }     for (int i = 0. i < thread.length. i++) {         thread[i].join().     }     assertTrue(semaphore.tryAcquire(Integer.MAX_VALUE, 10, TimeUnit.SECONDS)).     assertEquals(count * thread.length, received.get()).     assertEquals(actualFailed.get(), failed.get()). }
false;protected;1;4;;@Override protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {     received.addAndGet(candidates.size()). }
false;public;0;21;;public void testConsumerCanThrowExceptions() {     AtomicInteger received = new AtomicInteger(0).     AtomicInteger notified = new AtomicInteger(0).     AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {          @Override         protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {             received.addAndGet(candidates.size()).         }     }.     processor.put(new Object(), (e) -> {         notified.incrementAndGet().         throw new RuntimeException().     }).     processor.put(new Object(), (e) -> {         notified.incrementAndGet().         throw new RuntimeException().     }).     assertEquals(2, notified.get()).     assertEquals(2, received.get()). }
false;protected;1;3;;@Override protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException { }
false;public;0;10;;public void testNullArguments() {     AsyncIOProcessor<Object> processor = new AsyncIOProcessor<Object>(logger, scaledRandomIntBetween(1, 2024)) {          @Override         protected void write(List<Tuple<Object, Consumer<Exception>>> candidates) throws IOException {         }     }.     expectThrows(NullPointerException.class, () -> processor.put(null, (e) -> {     })).     expectThrows(NullPointerException.class, () -> processor.put(new Object(), null)). }
