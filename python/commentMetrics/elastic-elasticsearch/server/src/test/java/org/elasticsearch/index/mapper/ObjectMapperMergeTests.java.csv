commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;6;;@AfterClass public static void cleanupReferences() {     barFieldMapper = null.     bazFieldMapper = null.     rootObjectMapper = null. }
false;public;0;17;;public void testMerge() {     // GIVEN an enriched mapping with "baz" new field     ObjectMapper mergeWith = createRootObjectMapper("type1", true, ImmutableMap.of("disabled", createObjectMapper("disabled", false, emptyMap()), "foo", createObjectMapper("foo", true, ImmutableMap.of("bar", barFieldMapper, "baz", bazFieldMapper)))).     // WHEN merging mappings     final ObjectMapper merged = rootObjectMapper.merge(mergeWith).     // THEN "baz" new field is added to merged mapping     final ObjectMapper mergedFoo = (ObjectMapper) merged.getMapper("foo").     assertThat(mergedFoo.getMapper("bar"), notNullValue()).     assertThat(mergedFoo.getMapper("baz"), notNullValue()). }
false;public;0;12;;public void testMergeWhenDisablingField() {     // GIVEN a mapping with "foo" field disabled     ObjectMapper mergeWith = createRootObjectMapper("type1", true, ImmutableMap.of("disabled", createObjectMapper("disabled", false, emptyMap()), "foo", createObjectMapper("foo", false, emptyMap()))).     // WHEN merging mappings     // THEN a MapperException is thrown with an excepted message     MapperException e = expectThrows(MapperException.class, () -> rootObjectMapper.merge(mergeWith)).     assertEquals("Can't update attribute for type [type1.foo.enabled] in index mapping", e.getMessage()). }
false;public;0;13;;public void testMergeWhenEnablingField() {     // GIVEN a mapping with "disabled" field enabled     ObjectMapper mergeWith = createRootObjectMapper("type1", true, ImmutableMap.of("disabled", createObjectMapper("disabled", true, emptyMap()), "foo", createObjectMapper("foo", true, ImmutableMap.of("bar", barFieldMapper)))).     // WHEN merging mappings     // THEN a MapperException is thrown with an excepted message     MapperException e = expectThrows(MapperException.class, () -> rootObjectMapper.merge(mergeWith)).     assertEquals("Can't update attribute for type [type1.disabled.enabled] in index mapping", e.getMessage()). }
false;private,static;3;9;;private static RootObjectMapper createRootObjectMapper(String name, boolean enabled, Map<String, Mapper> mappers) {     final Settings indexSettings = Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).build().     final Mapper.BuilderContext context = new Mapper.BuilderContext(indexSettings, new ContentPath()).     final RootObjectMapper rootObjectMapper = new RootObjectMapper.Builder(name).enabled(enabled).build(context).     mappers.values().forEach(rootObjectMapper::putMapper).     return rootObjectMapper. }
false;private,static;3;9;;private static ObjectMapper createObjectMapper(String name, boolean enabled, Map<String, Mapper> mappers) {     final Settings indexSettings = Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).build().     final Mapper.BuilderContext context = new Mapper.BuilderContext(indexSettings, new ContentPath()).     final ObjectMapper mapper = new ObjectMapper.Builder(name).enabled(enabled).build(context).     mappers.values().forEach(mapper::putMapper).     return mapper. }
false;private,static;1;6;;private static TextFieldMapper createTextFieldMapper(String name) {     final TextFieldType fieldType = new TextFieldType().     final Settings indexSettings = Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).build().     return new TextFieldMapper(name, fieldType, fieldType, -1, null, indexSettings, MultiFields.empty(), CopyTo.empty()). }
