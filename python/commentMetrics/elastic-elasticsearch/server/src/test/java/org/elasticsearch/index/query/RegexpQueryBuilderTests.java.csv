commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;19;;@Override protected RegexpQueryBuilder doCreateTestQueryBuilder() {     RegexpQueryBuilder query = randomRegexpQuery().     if (randomBoolean()) {         List<RegexpFlag> flags = new ArrayList<>().         int iter = randomInt(5).         for (int i = 0. i < iter. i++) {             flags.add(randomFrom(RegexpFlag.values())).         }         query.flags(flags.toArray(new RegexpFlag[flags.size()])).     }     if (randomBoolean()) {         query.maxDeterminizedStates(randomInt(50000)).     }     if (randomBoolean()) {         query.rewrite(randomFrom(getRandomRewriteMethod())).     }     return query. }
false;protected;0;12;;@Override protected Map<String, RegexpQueryBuilder> getAlternateVersions() {     Map<String, RegexpQueryBuilder> alternateVersions = new HashMap<>().     RegexpQueryBuilder regexpQuery = randomRegexpQuery().     String contentString = "{\n" + "    \"regexp\" : {\n" + "        \"" + regexpQuery.fieldName() + "\" : \"" + regexpQuery.value() + "\"\n" + "    }\n" + "}".     alternateVersions.put(contentString, regexpQuery).     return alternateVersions. }
false;private,static;0;6;;private static RegexpQueryBuilder randomRegexpQuery() {     // mapped or unmapped fields     String fieldName = randomFrom(STRING_FIELD_NAME, STRING_ALIAS_FIELD_NAME, randomAlphaOfLengthBetween(1, 10)).     String value = randomAlphaOfLengthBetween(1, 10).     return new RegexpQueryBuilder(fieldName, value). }
false;protected;3;8;;@Override protected void doAssertLuceneQuery(RegexpQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     assertThat(query, instanceOf(RegexpQuery.class)).     RegexpQuery regexpQuery = (RegexpQuery) query.     String expectedFieldName = expectedFieldName(queryBuilder.fieldName()).     assertThat(regexpQuery.getField(), equalTo(expectedFieldName)). }
false;public;0;9;;public void testIllegalArguments() {     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> new RegexpQueryBuilder(null, "text")).     assertEquals("field name is null or empty", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new RegexpQueryBuilder("", "text")).     assertEquals("field name is null or empty", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new RegexpQueryBuilder("field", null)).     assertEquals("value cannot be null", e.getMessage()). }
false;public;0;19;;public void testFromJson() throws IOException {     String json = "{\n" + "  \"regexp\" : {\n" + "    \"name.first\" : {\n" + "      \"value\" : \"s.*y\",\n" + "      \"flags_value\" : 7,\n" + "      \"max_determinized_states\" : 20000,\n" + "      \"boost\" : 1.0\n" + "    }\n" + "  }\n" + "}".     RegexpQueryBuilder parsed = (RegexpQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     assertEquals(json, "s.*y", parsed.value()).     assertEquals(json, 20000, parsed.maxDeterminizedStates()). }
false;public;0;7;;public void testNumeric() throws Exception {     RegexpQueryBuilder query = new RegexpQueryBuilder(INT_FIELD_NAME, "12").     QueryShardContext context = createShardContext().     QueryShardException e = expectThrows(QueryShardException.class, () -> query.toQuery(context)).     assertEquals("Can only use regexp queries on keyword and text fields - not on [mapped_int] which is of type [integer]", e.getMessage()). }
false;public;0;25;;public void testParseFailsWithMultipleFields() throws IOException {     String json = "{\n" + "    \"regexp\": {\n" + "      \"user1\": {\n" + "        \"value\": \"k.*y\"\n" + "      },\n" + "      \"user2\": {\n" + "        \"value\": \"k.*y\"\n" + "      }\n" + "    }\n" + "}".     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(json)).     assertEquals("[regexp] query doesn't support multiple fields, found [user1] and [user2]", e.getMessage()).     String shortJson = "{\n" + "    \"regexp\": {\n" + "      \"user1\": \"k.*y\",\n" + "      \"user2\": \"k.*y\"\n" + "    }\n" + "}".     e = expectThrows(ParsingException.class, () -> parseQuery(shortJson)).     assertEquals("[regexp] query doesn't support multiple fields, found [user1] and [user2]", e.getMessage()). }
