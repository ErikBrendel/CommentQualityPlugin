commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return Arrays.asList(MockTransportService.TestPlugin.class). }
false;protected;1;11;;@Override protected Settings nodeSettings(int nodeOrdinal) {     return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_INCOMING_RECOVERIES_SETTING.getKey(), 5).put(ThrottlingAllocationDecider.CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_OUTGOING_RECOVERIES_SETTING.getKey(), 5).put(ConcurrentRebalanceAllocationDecider.CLUSTER_ROUTING_ALLOCATION_CLUSTER_CONCURRENT_REBALANCE_SETTING.getKey(), 10).build(). }
false;protected;0;4;;@Override protected int minimumNumberOfShards() {     return cluster().numDataNodes(). }
false;protected;0;4;;@Override protected int numberOfReplicas() {     return 0. }
false;private;0;8;;private void removePublishTimeout() {     // to test that the acknowledgement mechanism is working we better disable the wait for publish     // otherwise the operation is most likely acknowledged even if it doesn't support ack     assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().put(DiscoverySettings.PUBLISH_TIMEOUT_SETTING.getKey(), "0").put(DiscoverySettings.COMMIT_TIMEOUT_SETTING.getKey(), "30s"))). }
false;public;0;42;;public void testClusterUpdateSettingsAcknowledgement() {     createIndex("test").     ensureGreen().     // now that the cluster is stable, remove timeout     removePublishTimeout().     NodesInfoResponse nodesInfo = client().admin().cluster().prepareNodesInfo().get().     String excludedNodeId = null.     for (NodeInfo nodeInfo : nodesInfo.getNodes()) {         if (nodeInfo.getNode().isDataNode()) {             excludedNodeId = nodeInfo.getNode().getId().             break.         }     }     assertNotNull(excludedNodeId).     ClusterUpdateSettingsResponse clusterUpdateSettingsResponse = client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().put("cluster.routing.allocation.exclude._id", excludedNodeId)).get().     assertAcked(clusterUpdateSettingsResponse).     assertThat(clusterUpdateSettingsResponse.getTransientSettings().get("cluster.routing.allocation.exclude._id"), equalTo(excludedNodeId)).     for (Client client : clients()) {         ClusterState clusterState = getLocalClusterState(client).         assertThat(clusterState.metaData().transientSettings().get("cluster.routing.allocation.exclude._id"), equalTo(excludedNodeId)).         for (IndexRoutingTable indexRoutingTable : clusterState.routingTable()) {             for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {                 for (ShardRouting shardRouting : indexShardRoutingTable) {                     assert clusterState.nodes() != null.                     if (shardRouting.unassigned() == false && clusterState.nodes().get(shardRouting.currentNodeId()).getId().equals(excludedNodeId)) {                         // if the shard is still there it must be relocating and all nodes need to know,                         // since the request was acknowledged reroute happens as part of the update settings                         // and we made sure no throttling comes into the picture via settings                         assertThat(shardRouting.relocating(), equalTo(true)).                     }                 }             }         }     } }
false;public;0;26;;public void testClusterUpdateSettingsNoAcknowledgement() {     client().admin().indices().prepareCreate("test").setSettings(Settings.builder().put("number_of_shards", between(cluster().numDataNodes(), DEFAULT_MAX_NUM_SHARDS)).put("number_of_replicas", 0)).get().     ensureGreen().     // now that the cluster is stable, remove timeout     removePublishTimeout().     NodesInfoResponse nodesInfo = client().admin().cluster().prepareNodesInfo().get().     String excludedNodeId = null.     for (NodeInfo nodeInfo : nodesInfo.getNodes()) {         if (nodeInfo.getNode().isDataNode()) {             excludedNodeId = nodeInfo.getNode().getId().             break.         }     }     assertNotNull(excludedNodeId).     ClusterUpdateSettingsResponse clusterUpdateSettingsResponse = client().admin().cluster().prepareUpdateSettings().setTimeout("0s").setTransientSettings(Settings.builder().put("cluster.routing.allocation.exclude._id", excludedNodeId)).get().     assertThat(clusterUpdateSettingsResponse.isAcknowledged(), equalTo(false)).     assertThat(clusterUpdateSettingsResponse.getTransientSettings().get("cluster.routing.allocation.exclude._id"), equalTo(excludedNodeId)). }
false;private,static;1;3;;private static ClusterState getLocalClusterState(Client client) {     return client.admin().cluster().prepareState().setLocal(true).get().getState(). }
false;public;0;11;;public void testOpenIndexNoAcknowledgement() {     createIndex("test").     ensureGreen().     removePublishTimeout().     AcknowledgedResponse closeIndexResponse = client().admin().indices().prepareClose("test").execute().actionGet().     assertThat(closeIndexResponse.isAcknowledged(), equalTo(true)).     OpenIndexResponse openIndexResponse = client().admin().indices().prepareOpen("test").setTimeout("0s").get().     assertThat(openIndexResponse.isAcknowledged(), equalTo(false)).     // make sure that recovery from disk has completed, so that check index doesn't fail.     ensureGreen("test"). }
false;public;0;27;;public void testAckingFailsIfNotPublishedToAllNodes() {     String masterNode = internalCluster().getMasterName().     String nonMasterNode = Stream.of(internalCluster().getNodeNames()).filter(node -> node.equals(masterNode) == false).findFirst().get().     MockTransportService masterTransportService = (MockTransportService) internalCluster().getInstance(TransportService.class, masterNode).     MockTransportService nonMasterTransportService = (MockTransportService) internalCluster().getInstance(TransportService.class, nonMasterNode).     logger.info("blocking cluster state publishing from master [{}] to non master [{}]", masterNode, nonMasterNode).     if (randomBoolean() && internalCluster().numMasterNodes() != 2) {         masterTransportService.addFailToSendNoConnectRule(nonMasterTransportService, PublishClusterStateAction.SEND_ACTION_NAME).     } else {         masterTransportService.addFailToSendNoConnectRule(nonMasterTransportService, PublishClusterStateAction.COMMIT_ACTION_NAME).     }     CreateIndexResponse response = client().admin().indices().prepareCreate("test").get().     assertFalse(response.isAcknowledged()).     logger.info("waiting for cluster to reform").     masterTransportService.clearRule(nonMasterTransportService).     ensureStableCluster(internalCluster().size()).     assertAcked(client().admin().indices().prepareDelete("test")). }
