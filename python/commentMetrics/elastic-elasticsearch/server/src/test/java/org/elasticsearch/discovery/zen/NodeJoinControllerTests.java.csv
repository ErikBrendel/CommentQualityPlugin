# id;timestamp;commentText;codeText;commentWords;codeWords
NodeJoinControllerTests -> public void testElectionBasedOnConflictingNodes() throws InterruptedException, ExecutionException;1524684173;Tests tha node can become a master, even though the last cluster state it knows contains_nodes that conflict with the joins it got and needs to become a master;public void testElectionBasedOnConflictingNodes() throws InterruptedException, ExecutionException {_        ClusterState initialState = initialState(true)__        final DiscoveryNode masterNode = initialState.nodes().getLocalNode()__        final DiscoveryNode otherNode = new DiscoveryNode("other_node", buildNewFakeTransportAddress(), emptyMap(),_            EnumSet.allOf(DiscoveryNode.Role.class), Version.CURRENT)__        _        _        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder(initialState.nodes())__        discoBuilder.masterNodeId(null)__        discoBuilder.add(otherNode)__        ClusterState.Builder stateBuilder = ClusterState.builder(initialState).nodes(discoBuilder)__        if (randomBoolean()) {_            IndexMetaData indexMetaData = IndexMetaData.builder("test").settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, 1).put(SETTING_NUMBER_OF_REPLICAS, 1)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()__            IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(indexMetaData.getIndex())__            RoutingTable.Builder routing = new RoutingTable.Builder()__            routing.addAsNew(indexMetaData)__            final ShardId shardId = new ShardId("test", "_na_", 0)__            IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)___            final DiscoveryNode primaryNode = randomBoolean() ? masterNode : otherNode__            final DiscoveryNode replicaNode = primaryNode.equals(masterNode) ? otherNode : masterNode__            final boolean primaryStarted = randomBoolean()__            indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting("test", 0, primaryNode.getId(), null, true,_                primaryStarted ? ShardRoutingState.STARTED : ShardRoutingState.INITIALIZING,_                primaryStarted ? null : new UnassignedInfo(UnassignedInfo.Reason.INDEX_REOPENED, "getting there")))__            if (primaryStarted) {_                boolean replicaStared = randomBoolean()__                indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting("test", 0, replicaNode.getId(), null, false,_                    replicaStared ? ShardRoutingState.STARTED : ShardRoutingState.INITIALIZING,_                    replicaStared ? null : new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "getting there")))__            } else {_                indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting("test", 0, null, null, false,_                    ShardRoutingState.UNASSIGNED, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "life sucks")))__            }_            indexRoutingTableBuilder.addIndexShard(indexShardRoutingBuilder.build())__            IndexRoutingTable indexRoutingTable = indexRoutingTableBuilder.build()__            IndexMetaData updatedIndexMetaData = updateActiveAllocations(indexRoutingTable, indexMetaData)__            stateBuilder.metaData(MetaData.builder().put(updatedIndexMetaData, false).generateClusterUuidIfNeeded())_                        .routingTable(RoutingTable.builder().add(indexRoutingTable).build())__        }__        setupMasterServiceAndNodeJoinController(stateBuilder.build())___        _        final DiscoveryNode conflictingNode = randomBoolean() ?_            new DiscoveryNode(otherNode.getId(), randomBoolean() ? otherNode.getAddress() : buildNewFakeTransportAddress(),_                otherNode.getAttributes(), otherNode.getRoles(), Version.CURRENT) :_            new DiscoveryNode("conflicting_address_node", otherNode.getAddress(), otherNode.getAttributes(), otherNode.getRoles(),_                Version.CURRENT)___        nodeJoinController.startElectionContext()__        final SimpleFuture joinFuture = joinNodeAsync(conflictingNode)__        final CountDownLatch elected = new CountDownLatch(1)__        nodeJoinController.waitToBeElectedAsMaster(1, TimeValue.timeValueHours(5), new NodeJoinController.ElectionCallback() {_            @Override_            public void onElectedAsMaster(ClusterState state) {_                elected.countDown()__            }__            @Override_            public void onFailure(Throwable t) {_                logger.error("failed to be elected as master", t)__                throw new AssertionError("failed to be elected as master", t)__            }_        })___        elected.await()___        joinFuture.get()_ __        final ClusterState finalState = discoveryState(masterService)__        final DiscoveryNodes finalNodes = finalState.nodes()__        assertTrue(finalNodes.isLocalNodeElectedMaster())__        assertThat(finalNodes.getLocalNode(), equalTo(masterNode))__        assertThat(finalNodes.getSize(), equalTo(2))__        assertThat(finalNodes.get(conflictingNode.getId()), equalTo(conflictingNode))__        List<ShardRouting> activeShardsOnRestartedNode =_            StreamSupport.stream(finalState.getRoutingNodes().node(conflictingNode.getId()).spliterator(), false)_                .filter(ShardRouting::active).collect(Collectors.toList())__        assertThat(activeShardsOnRestartedNode, empty())__    };tests,tha,node,can,become,a,master,even,though,the,last,cluster,state,it,knows,contains,nodes,that,conflict,with,the,joins,it,got,and,needs,to,become,a,master;public,void,test,election,based,on,conflicting,nodes,throws,interrupted,exception,execution,exception,cluster,state,initial,state,initial,state,true,final,discovery,node,master,node,initial,state,nodes,get,local,node,final,discovery,node,other,node,new,discovery,node,build,new,fake,transport,address,empty,map,enum,set,all,of,discovery,node,role,class,version,current,discovery,nodes,builder,disco,builder,discovery,nodes,builder,initial,state,nodes,disco,builder,master,node,id,null,disco,builder,add,other,node,cluster,state,builder,state,builder,cluster,state,builder,initial,state,nodes,disco,builder,if,random,boolean,index,meta,data,index,meta,data,index,meta,data,builder,test,settings,settings,builder,put,version,current,put,1,put,1,put,system,current,time,millis,build,index,routing,table,builder,index,routing,table,builder,index,routing,table,builder,index,meta,data,get,index,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,final,shard,id,shard,id,new,shard,id,test,0,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,final,discovery,node,primary,node,random,boolean,master,node,other,node,final,discovery,node,replica,node,primary,node,equals,master,node,other,node,master,node,final,boolean,primary,started,random,boolean,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,test,0,primary,node,get,id,null,true,primary,started,shard,routing,state,started,shard,routing,state,initializing,primary,started,null,new,unassigned,info,unassigned,info,reason,getting,there,if,primary,started,boolean,replica,stared,random,boolean,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,test,0,replica,node,get,id,null,false,replica,stared,shard,routing,state,started,shard,routing,state,initializing,replica,stared,null,new,unassigned,info,unassigned,info,reason,getting,there,else,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,test,0,null,null,false,shard,routing,state,unassigned,new,unassigned,info,unassigned,info,reason,life,sucks,index,routing,table,builder,add,index,shard,index,shard,routing,builder,build,index,routing,table,index,routing,table,index,routing,table,builder,build,index,meta,data,updated,index,meta,data,update,active,allocations,index,routing,table,index,meta,data,state,builder,meta,data,meta,data,builder,put,updated,index,meta,data,false,generate,cluster,uuid,if,needed,routing,table,routing,table,builder,add,index,routing,table,build,setup,master,service,and,node,join,controller,state,builder,build,final,discovery,node,conflicting,node,random,boolean,new,discovery,node,other,node,get,id,random,boolean,other,node,get,address,build,new,fake,transport,address,other,node,get,attributes,other,node,get,roles,version,current,new,discovery,node,other,node,get,address,other,node,get,attributes,other,node,get,roles,version,current,node,join,controller,start,election,context,final,simple,future,join,future,join,node,async,conflicting,node,final,count,down,latch,elected,new,count,down,latch,1,node,join,controller,wait,to,be,elected,as,master,1,time,value,time,value,hours,5,new,node,join,controller,election,callback,override,public,void,on,elected,as,master,cluster,state,state,elected,count,down,override,public,void,on,failure,throwable,t,logger,error,failed,to,be,elected,as,master,t,throw,new,assertion,error,failed,to,be,elected,as,master,t,elected,await,join,future,get,final,cluster,state,final,state,discovery,state,master,service,final,discovery,nodes,final,nodes,final,state,nodes,assert,true,final,nodes,is,local,node,elected,master,assert,that,final,nodes,get,local,node,equal,to,master,node,assert,that,final,nodes,get,size,equal,to,2,assert,that,final,nodes,get,conflicting,node,get,id,equal,to,conflicting,node,list,shard,routing,active,shards,on,restarted,node,stream,support,stream,final,state,get,routing,nodes,node,conflicting,node,get,id,spliterator,false,filter,shard,routing,active,collect,collectors,to,list,assert,that,active,shards,on,restarted,node,empty
NodeJoinControllerTests -> public void testElectionBasedOnConflictingNodes() throws InterruptedException, ExecutionException;1541092382;Tests tha node can become a master, even though the last cluster state it knows contains_nodes that conflict with the joins it got and needs to become a master;public void testElectionBasedOnConflictingNodes() throws InterruptedException, ExecutionException {_        ClusterState initialState = initialState(true)__        final DiscoveryNode masterNode = initialState.nodes().getLocalNode()__        final DiscoveryNode otherNode = new DiscoveryNode("other_node", buildNewFakeTransportAddress(), emptyMap(),_            EnumSet.allOf(DiscoveryNode.Role.class), Version.CURRENT)__        _        _        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder(initialState.nodes())__        discoBuilder.masterNodeId(null)__        discoBuilder.add(otherNode)__        ClusterState.Builder stateBuilder = ClusterState.builder(initialState).nodes(discoBuilder)__        if (randomBoolean()) {_            IndexMetaData indexMetaData = IndexMetaData.builder("test").settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, 1).put(SETTING_NUMBER_OF_REPLICAS, 1)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()__            IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(indexMetaData.getIndex())__            RoutingTable.Builder routing = new RoutingTable.Builder()__            routing.addAsNew(indexMetaData)__            final ShardId shardId = new ShardId("test", "_na_", 0)__            IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)___            final DiscoveryNode primaryNode = randomBoolean() ? masterNode : otherNode__            final DiscoveryNode replicaNode = primaryNode.equals(masterNode) ? otherNode : masterNode__            final boolean primaryStarted = randomBoolean()__            indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting("test", 0, primaryNode.getId(), null, true,_                primaryStarted ? ShardRoutingState.STARTED : ShardRoutingState.INITIALIZING,_                primaryStarted ? null : new UnassignedInfo(UnassignedInfo.Reason.INDEX_REOPENED, "getting there")))__            if (primaryStarted) {_                boolean replicaStared = randomBoolean()__                indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting("test", 0, replicaNode.getId(), null, false,_                    replicaStared ? ShardRoutingState.STARTED : ShardRoutingState.INITIALIZING,_                    replicaStared ? null : new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "getting there")))__            } else {_                indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting("test", 0, null, null, false,_                    ShardRoutingState.UNASSIGNED, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "life sucks")))__            }_            indexRoutingTableBuilder.addIndexShard(indexShardRoutingBuilder.build())__            IndexRoutingTable indexRoutingTable = indexRoutingTableBuilder.build()__            IndexMetaData updatedIndexMetaData = updateActiveAllocations(indexRoutingTable, indexMetaData)__            stateBuilder.metaData(MetaData.builder().put(updatedIndexMetaData, false).generateClusterUuidIfNeeded())_                        .routingTable(RoutingTable.builder().add(indexRoutingTable).build())__        }__        setupMasterServiceAndNodeJoinController(stateBuilder.build())___        _        final DiscoveryNode conflictingNode = randomBoolean() ?_            new DiscoveryNode(otherNode.getId(), randomBoolean() ? otherNode.getAddress() : buildNewFakeTransportAddress(),_                otherNode.getAttributes(), otherNode.getRoles(), Version.CURRENT) :_            new DiscoveryNode("conflicting_address_node", otherNode.getAddress(), otherNode.getAttributes(), otherNode.getRoles(),_                Version.CURRENT)___        nodeJoinController.startElectionContext()__        final SimpleFuture joinFuture = joinNodeAsync(conflictingNode)__        final CountDownLatch elected = new CountDownLatch(1)__        nodeJoinController.waitToBeElectedAsMaster(1, TimeValue.timeValueHours(5), new NodeJoinController.ElectionCallback() {_            @Override_            public void onElectedAsMaster(ClusterState state) {_                elected.countDown()__            }__            @Override_            public void onFailure(Throwable t) {_                logger.error("failed to be elected as master", t)__                throw new AssertionError("failed to be elected as master", t)__            }_        })___        elected.await()___        joinFuture.get()_ __        final ClusterState finalState = discoveryState(masterService)__        final DiscoveryNodes finalNodes = finalState.nodes()__        assertTrue(finalNodes.isLocalNodeElectedMaster())__        assertThat(finalNodes.getLocalNode(), equalTo(masterNode))__        assertThat(finalNodes.getSize(), equalTo(2))__        assertThat(finalNodes.get(conflictingNode.getId()), equalTo(conflictingNode))__        List<ShardRouting> activeShardsOnRestartedNode =_            StreamSupport.stream(finalState.getRoutingNodes().node(conflictingNode.getId()).spliterator(), false)_                .filter(ShardRouting::active).collect(Collectors.toList())__        assertThat(activeShardsOnRestartedNode, empty())__    };tests,tha,node,can,become,a,master,even,though,the,last,cluster,state,it,knows,contains,nodes,that,conflict,with,the,joins,it,got,and,needs,to,become,a,master;public,void,test,election,based,on,conflicting,nodes,throws,interrupted,exception,execution,exception,cluster,state,initial,state,initial,state,true,final,discovery,node,master,node,initial,state,nodes,get,local,node,final,discovery,node,other,node,new,discovery,node,build,new,fake,transport,address,empty,map,enum,set,all,of,discovery,node,role,class,version,current,discovery,nodes,builder,disco,builder,discovery,nodes,builder,initial,state,nodes,disco,builder,master,node,id,null,disco,builder,add,other,node,cluster,state,builder,state,builder,cluster,state,builder,initial,state,nodes,disco,builder,if,random,boolean,index,meta,data,index,meta,data,index,meta,data,builder,test,settings,settings,builder,put,version,current,put,1,put,1,put,system,current,time,millis,build,index,routing,table,builder,index,routing,table,builder,index,routing,table,builder,index,meta,data,get,index,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,final,shard,id,shard,id,new,shard,id,test,0,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,final,discovery,node,primary,node,random,boolean,master,node,other,node,final,discovery,node,replica,node,primary,node,equals,master,node,other,node,master,node,final,boolean,primary,started,random,boolean,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,test,0,primary,node,get,id,null,true,primary,started,shard,routing,state,started,shard,routing,state,initializing,primary,started,null,new,unassigned,info,unassigned,info,reason,getting,there,if,primary,started,boolean,replica,stared,random,boolean,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,test,0,replica,node,get,id,null,false,replica,stared,shard,routing,state,started,shard,routing,state,initializing,replica,stared,null,new,unassigned,info,unassigned,info,reason,getting,there,else,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,test,0,null,null,false,shard,routing,state,unassigned,new,unassigned,info,unassigned,info,reason,life,sucks,index,routing,table,builder,add,index,shard,index,shard,routing,builder,build,index,routing,table,index,routing,table,index,routing,table,builder,build,index,meta,data,updated,index,meta,data,update,active,allocations,index,routing,table,index,meta,data,state,builder,meta,data,meta,data,builder,put,updated,index,meta,data,false,generate,cluster,uuid,if,needed,routing,table,routing,table,builder,add,index,routing,table,build,setup,master,service,and,node,join,controller,state,builder,build,final,discovery,node,conflicting,node,random,boolean,new,discovery,node,other,node,get,id,random,boolean,other,node,get,address,build,new,fake,transport,address,other,node,get,attributes,other,node,get,roles,version,current,new,discovery,node,other,node,get,address,other,node,get,attributes,other,node,get,roles,version,current,node,join,controller,start,election,context,final,simple,future,join,future,join,node,async,conflicting,node,final,count,down,latch,elected,new,count,down,latch,1,node,join,controller,wait,to,be,elected,as,master,1,time,value,time,value,hours,5,new,node,join,controller,election,callback,override,public,void,on,elected,as,master,cluster,state,state,elected,count,down,override,public,void,on,failure,throwable,t,logger,error,failed,to,be,elected,as,master,t,throw,new,assertion,error,failed,to,be,elected,as,master,t,elected,await,join,future,get,final,cluster,state,final,state,discovery,state,master,service,final,discovery,nodes,final,nodes,final,state,nodes,assert,true,final,nodes,is,local,node,elected,master,assert,that,final,nodes,get,local,node,equal,to,master,node,assert,that,final,nodes,get,size,equal,to,2,assert,that,final,nodes,get,conflicting,node,get,id,equal,to,conflicting,node,list,shard,routing,active,shards,on,restarted,node,stream,support,stream,final,state,get,routing,nodes,node,conflicting,node,get,id,spliterator,false,filter,shard,routing,active,collect,collectors,to,list,assert,that,active,shards,on,restarted,node,empty
NodeJoinControllerTests -> public void testElectionBasedOnConflictingNodes() throws InterruptedException, ExecutionException;1548320260;Tests tha node can become a master, even though the last cluster state it knows contains_nodes that conflict with the joins it got and needs to become a master;public void testElectionBasedOnConflictingNodes() throws InterruptedException, ExecutionException {_        ClusterState initialState = initialState(true)__        final DiscoveryNode masterNode = initialState.nodes().getLocalNode()__        final DiscoveryNode otherNode = new DiscoveryNode("other_node", buildNewFakeTransportAddress(), emptyMap(),_            EnumSet.allOf(DiscoveryNode.Role.class), Version.CURRENT)__        _        _        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder(initialState.nodes())__        discoBuilder.masterNodeId(null)__        discoBuilder.add(otherNode)__        ClusterState.Builder stateBuilder = ClusterState.builder(initialState).nodes(discoBuilder)__        if (randomBoolean()) {_            IndexMetaData indexMetaData = IndexMetaData.builder("test").settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, 1).put(SETTING_NUMBER_OF_REPLICAS, 1)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()__            IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(indexMetaData.getIndex())__            RoutingTable.Builder routing = new RoutingTable.Builder()__            routing.addAsNew(indexMetaData)__            final ShardId shardId = new ShardId("test", "_na_", 0)__            IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)___            final DiscoveryNode primaryNode = randomBoolean() ? masterNode : otherNode__            final DiscoveryNode replicaNode = primaryNode.equals(masterNode) ? otherNode : masterNode__            final boolean primaryStarted = randomBoolean()__            indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting("test", 0, primaryNode.getId(), null, true,_                primaryStarted ? ShardRoutingState.STARTED : ShardRoutingState.INITIALIZING,_                primaryStarted ? null : new UnassignedInfo(UnassignedInfo.Reason.INDEX_REOPENED, "getting there")))__            if (primaryStarted) {_                boolean replicaStared = randomBoolean()__                indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting("test", 0, replicaNode.getId(), null, false,_                    replicaStared ? ShardRoutingState.STARTED : ShardRoutingState.INITIALIZING,_                    replicaStared ? null : new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "getting there")))__            } else {_                indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting("test", 0, null, null, false,_                    ShardRoutingState.UNASSIGNED, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, "life sucks")))__            }_            indexRoutingTableBuilder.addIndexShard(indexShardRoutingBuilder.build())__            IndexRoutingTable indexRoutingTable = indexRoutingTableBuilder.build()__            IndexMetaData updatedIndexMetaData = updateActiveAllocations(indexRoutingTable, indexMetaData)__            stateBuilder.metaData(MetaData.builder().put(updatedIndexMetaData, false).generateClusterUuidIfNeeded())_                        .routingTable(RoutingTable.builder().add(indexRoutingTable).build())__        }__        setupMasterServiceAndNodeJoinController(stateBuilder.build())___        _        final DiscoveryNode conflictingNode = randomBoolean() ?_            new DiscoveryNode(otherNode.getId(), randomBoolean() ? otherNode.getAddress() : buildNewFakeTransportAddress(),_                otherNode.getAttributes(), otherNode.getRoles(), Version.CURRENT) :_            new DiscoveryNode("conflicting_address_node", otherNode.getAddress(), otherNode.getAttributes(), otherNode.getRoles(),_                Version.CURRENT)___        nodeJoinController.startElectionContext()__        final SimpleFuture joinFuture = joinNodeAsync(conflictingNode)__        final CountDownLatch elected = new CountDownLatch(1)__        nodeJoinController.waitToBeElectedAsMaster(1, TimeValue.timeValueHours(5), new NodeJoinController.ElectionCallback() {_            @Override_            public void onElectedAsMaster(ClusterState state) {_                elected.countDown()__            }__            @Override_            public void onFailure(Throwable t) {_                logger.error("failed to be elected as master", t)__                throw new AssertionError("failed to be elected as master", t)__            }_        })___        elected.await()___        joinFuture.get()_ __        final ClusterState finalState = discoveryState(masterService)__        final DiscoveryNodes finalNodes = finalState.nodes()__        assertTrue(finalNodes.isLocalNodeElectedMaster())__        assertThat(finalNodes.getLocalNode(), equalTo(masterNode))__        assertThat(finalNodes.getSize(), equalTo(2))__        assertThat(finalNodes.get(conflictingNode.getId()), equalTo(conflictingNode))__        List<ShardRouting> activeShardsOnRestartedNode =_            StreamSupport.stream(finalState.getRoutingNodes().node(conflictingNode.getId()).spliterator(), false)_                .filter(ShardRouting::active).collect(Collectors.toList())__        assertThat(activeShardsOnRestartedNode, empty())__    };tests,tha,node,can,become,a,master,even,though,the,last,cluster,state,it,knows,contains,nodes,that,conflict,with,the,joins,it,got,and,needs,to,become,a,master;public,void,test,election,based,on,conflicting,nodes,throws,interrupted,exception,execution,exception,cluster,state,initial,state,initial,state,true,final,discovery,node,master,node,initial,state,nodes,get,local,node,final,discovery,node,other,node,new,discovery,node,build,new,fake,transport,address,empty,map,enum,set,all,of,discovery,node,role,class,version,current,discovery,nodes,builder,disco,builder,discovery,nodes,builder,initial,state,nodes,disco,builder,master,node,id,null,disco,builder,add,other,node,cluster,state,builder,state,builder,cluster,state,builder,initial,state,nodes,disco,builder,if,random,boolean,index,meta,data,index,meta,data,index,meta,data,builder,test,settings,settings,builder,put,version,current,put,1,put,1,put,system,current,time,millis,build,index,routing,table,builder,index,routing,table,builder,index,routing,table,builder,index,meta,data,get,index,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,final,shard,id,shard,id,new,shard,id,test,0,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,final,discovery,node,primary,node,random,boolean,master,node,other,node,final,discovery,node,replica,node,primary,node,equals,master,node,other,node,master,node,final,boolean,primary,started,random,boolean,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,test,0,primary,node,get,id,null,true,primary,started,shard,routing,state,started,shard,routing,state,initializing,primary,started,null,new,unassigned,info,unassigned,info,reason,getting,there,if,primary,started,boolean,replica,stared,random,boolean,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,test,0,replica,node,get,id,null,false,replica,stared,shard,routing,state,started,shard,routing,state,initializing,replica,stared,null,new,unassigned,info,unassigned,info,reason,getting,there,else,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,test,0,null,null,false,shard,routing,state,unassigned,new,unassigned,info,unassigned,info,reason,life,sucks,index,routing,table,builder,add,index,shard,index,shard,routing,builder,build,index,routing,table,index,routing,table,index,routing,table,builder,build,index,meta,data,updated,index,meta,data,update,active,allocations,index,routing,table,index,meta,data,state,builder,meta,data,meta,data,builder,put,updated,index,meta,data,false,generate,cluster,uuid,if,needed,routing,table,routing,table,builder,add,index,routing,table,build,setup,master,service,and,node,join,controller,state,builder,build,final,discovery,node,conflicting,node,random,boolean,new,discovery,node,other,node,get,id,random,boolean,other,node,get,address,build,new,fake,transport,address,other,node,get,attributes,other,node,get,roles,version,current,new,discovery,node,other,node,get,address,other,node,get,attributes,other,node,get,roles,version,current,node,join,controller,start,election,context,final,simple,future,join,future,join,node,async,conflicting,node,final,count,down,latch,elected,new,count,down,latch,1,node,join,controller,wait,to,be,elected,as,master,1,time,value,time,value,hours,5,new,node,join,controller,election,callback,override,public,void,on,elected,as,master,cluster,state,state,elected,count,down,override,public,void,on,failure,throwable,t,logger,error,failed,to,be,elected,as,master,t,throw,new,assertion,error,failed,to,be,elected,as,master,t,elected,await,join,future,get,final,cluster,state,final,state,discovery,state,master,service,final,discovery,nodes,final,nodes,final,state,nodes,assert,true,final,nodes,is,local,node,elected,master,assert,that,final,nodes,get,local,node,equal,to,master,node,assert,that,final,nodes,get,size,equal,to,2,assert,that,final,nodes,get,conflicting,node,get,id,equal,to,conflicting,node,list,shard,routing,active,shards,on,restarted,node,stream,support,stream,final,state,get,routing,nodes,node,conflicting,node,get,id,spliterator,false,filter,shard,routing,active,collect,collectors,to,list,assert,that,active,shards,on,restarted,node,empty
NodeJoinControllerTests -> private DiscoveryNode cloneNode(DiscoveryNode node);1524684173;creates an object clone of node, so it will be a different object instance;private DiscoveryNode cloneNode(DiscoveryNode node) {_        return new DiscoveryNode(node.getName(), node.getId(), node.getEphemeralId(), node.getHostName(), node.getHostAddress(),_            node.getAddress(), node.getAttributes(), node.getRoles(), node.getVersion())__    };creates,an,object,clone,of,node,so,it,will,be,a,different,object,instance;private,discovery,node,clone,node,discovery,node,node,return,new,discovery,node,node,get,name,node,get,id,node,get,ephemeral,id,node,get,host,name,node,get,host,address,node,get,address,node,get,attributes,node,get,roles,node,get,version
NodeJoinControllerTests -> private DiscoveryNode cloneNode(DiscoveryNode node);1541092382;creates an object clone of node, so it will be a different object instance;private DiscoveryNode cloneNode(DiscoveryNode node) {_        return new DiscoveryNode(node.getName(), node.getId(), node.getEphemeralId(), node.getHostName(), node.getHostAddress(),_            node.getAddress(), node.getAttributes(), node.getRoles(), node.getVersion())__    };creates,an,object,clone,of,node,so,it,will,be,a,different,object,instance;private,discovery,node,clone,node,discovery,node,node,return,new,discovery,node,node,get,name,node,get,id,node,get,ephemeral,id,node,get,host,name,node,get,host,address,node,get,address,node,get,attributes,node,get,roles,node,get,version
NodeJoinControllerTests -> private DiscoveryNode cloneNode(DiscoveryNode node);1548320260;creates an object clone of node, so it will be a different object instance;private DiscoveryNode cloneNode(DiscoveryNode node) {_        return new DiscoveryNode(node.getName(), node.getId(), node.getEphemeralId(), node.getHostName(), node.getHostAddress(),_            node.getAddress(), node.getAttributes(), node.getRoles(), node.getVersion())__    };creates,an,object,clone,of,node,so,it,will,be,a,different,object,instance;private,discovery,node,clone,node,discovery,node,node,return,new,discovery,node,node,get,name,node,get,id,node,get,ephemeral,id,node,get,host,name,node,get,host,address,node,get,address,node,get,attributes,node,get,roles,node,get,version
