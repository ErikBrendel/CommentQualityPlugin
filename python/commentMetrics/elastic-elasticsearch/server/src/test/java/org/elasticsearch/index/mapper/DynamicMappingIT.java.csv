commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return Collections.singleton(InternalSettingsPlugin.class). }
false;public;0;19;;public void testConflictingDynamicMappings() {     // we don't use indexRandom because the order of requests is important here     createIndex("index").     client().prepareIndex("index", "type", "1").setSource("foo", 3).get().     try {         client().prepareIndex("index", "type", "2").setSource("foo", "bar").get().         fail("Indexing request should have failed!").     } catch (MapperParsingException e) {         // general case, the parsing code complains that it can't parse "bar" as a "long"         assertThat(e.getMessage(), Matchers.containsString("failed to parse field [foo] of type [long]")).     } catch (IllegalArgumentException e) {         // rare case: the node that processes the index request doesn't have the mappings         // yet and sends a mapping update to the master node to map "bar" as "text". This         // fails as it had been already mapped as a long by the previous index request.         assertThat(e.getMessage(), Matchers.containsString("mapper [foo] of different type, current_type [long], merged_type [text]")).     } }
false;public;0;9;;public void testConflictingDynamicMappingsBulk() {     // we don't use indexRandom because the order of requests is important here     createIndex("index").     client().prepareIndex("index", "type", "1").setSource("foo", 3).get().     BulkResponse bulkResponse = client().prepareBulk().add(client().prepareIndex("index", "type", "1").setSource("foo", 3)).get().     assertFalse(bulkResponse.hasFailures()).     bulkResponse = client().prepareBulk().add(client().prepareIndex("index", "type", "2").setSource("foo", "bar")).get().     assertTrue(bulkResponse.hasFailures()). }
false;private,static;4;9;;private static void assertMappingsHaveField(GetMappingsResponse mappings, String index, String type, String field) throws IOException {     ImmutableOpenMap<String, MappingMetaData> indexMappings = mappings.getMappings().get("index").     assertNotNull(indexMappings).     MappingMetaData typeMappings = indexMappings.get(type).     assertNotNull(typeMappings).     Map<String, Object> typeMappingsMap = typeMappings.getSourceAsMap().     Map<String, Object> properties = (Map<String, Object>) typeMappingsMap.get("properties").     assertTrue("Could not find [" + field + "] in " + typeMappingsMap.toString(), properties.containsKey(field)). }
false;public;0;10;;@Override public void run() {     try {         startLatch.await().         assertEquals(DocWriteResponse.Result.CREATED, client().prepareIndex("index", "type", id).setSource("field" + id, "bar").get().getResult()).     } catch (Exception e) {         error.compareAndSet(null, e).     } }
false;public;0;37;;public void testConcurrentDynamicUpdates() throws Throwable {     createIndex("index").     final Thread[] indexThreads = new Thread[32].     final CountDownLatch startLatch = new CountDownLatch(1).     final AtomicReference<Throwable> error = new AtomicReference<>().     for (int i = 0. i < indexThreads.length. ++i) {         final String id = Integer.toString(i).         indexThreads[i] = new Thread(new Runnable() {              @Override             public void run() {                 try {                     startLatch.await().                     assertEquals(DocWriteResponse.Result.CREATED, client().prepareIndex("index", "type", id).setSource("field" + id, "bar").get().getResult()).                 } catch (Exception e) {                     error.compareAndSet(null, e).                 }             }         }).         indexThreads[i].start().     }     startLatch.countDown().     for (Thread thread : indexThreads) {         thread.join().     }     if (error.get() != null) {         throw error.get().     }     Thread.sleep(2000).     GetMappingsResponse mappings = client().admin().indices().prepareGetMappings("index").setTypes("type").get().     for (int i = 0. i < indexThreads.length. ++i) {         assertMappingsHaveField(mappings, "index", "type", "field" + i).     }     for (int i = 0. i < indexThreads.length. ++i) {         assertTrue(client().prepareGet("index", "type", Integer.toString(i)).get().isExists()).     } }
