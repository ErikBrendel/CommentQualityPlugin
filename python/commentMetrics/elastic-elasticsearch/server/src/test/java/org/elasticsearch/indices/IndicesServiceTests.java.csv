# id;timestamp;commentText;codeText;commentWords;codeWords
IndicesServiceTests -> public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception;1524684173;This test checks an edge case where, if a node had an index (lets call it A with UUID 1), then_deleted it (so a tombstone entry for A will exist in the cluster state), then created_a new index A with UUID 2, then shutdown, when the node comes back online, it will look at the_tombstones for deletions, and it should proceed with trying to delete A with UUID 1 and not_throw any errors that the index still exists in the cluster state.  This is a case of ensuring_that tombstones that have the same name as current valid indices don't cause confusion by_trying to delete an index that exists._See https://github.com/elastic/elasticsearch/issues/18054;public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_                                         .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_                                         .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_                                                .settings(idxSettings)_                                                .numberOfShards(1)_                                                .numberOfReplicas(0)_                                                .build()__        final Index tombstonedIndex = new Index(indexName, UUIDs.randomBase64UUID())__        final IndexGraveyard graveyard = IndexGraveyard.builder().addTombstone(tombstonedIndex).build()__        final MetaData metaData = MetaData.builder().put(indexMetaData, true).indexGraveyard(graveyard).build()__        final ClusterState clusterState = new ClusterState.Builder(new ClusterName("testCluster")).metaData(metaData).build()__        _        indicesService.verifyIndexIsDeleted(tombstonedIndex, clusterState)__    };this,test,checks,an,edge,case,where,if,a,node,had,an,index,lets,call,it,a,with,uuid,1,then,deleted,it,so,a,tombstone,entry,for,a,will,exist,in,the,cluster,state,then,created,a,new,index,a,with,uuid,2,then,shutdown,when,the,node,comes,back,online,it,will,look,at,the,tombstones,for,deletions,and,it,should,proceed,with,trying,to,delete,a,with,uuid,1,and,not,throw,any,errors,that,the,index,still,exists,in,the,cluster,state,this,is,a,case,of,ensuring,that,tombstones,that,have,the,same,name,as,current,valid,indices,don,t,cause,confusion,by,trying,to,delete,an,index,that,exists,see,https,github,com,elastic,elasticsearch,issues,18054;public,void,test,index,and,tombstone,with,same,name,on,startup,throws,exception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,final,index,tombstoned,index,new,index,index,name,uuids,random,base64uuid,final,index,graveyard,graveyard,index,graveyard,builder,add,tombstone,tombstoned,index,build,final,meta,data,meta,data,meta,data,builder,put,index,meta,data,true,index,graveyard,graveyard,build,final,cluster,state,cluster,state,new,cluster,state,builder,new,cluster,name,test,cluster,meta,data,meta,data,build,indices,service,verify,index,is,deleted,tombstoned,index,cluster,state
IndicesServiceTests -> public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception;1528706846;This test checks an edge case where, if a node had an index (lets call it A with UUID 1), then_deleted it (so a tombstone entry for A will exist in the cluster state), then created_a new index A with UUID 2, then shutdown, when the node comes back online, it will look at the_tombstones for deletions, and it should proceed with trying to delete A with UUID 1 and not_throw any errors that the index still exists in the cluster state.  This is a case of ensuring_that tombstones that have the same name as current valid indices don't cause confusion by_trying to delete an index that exists._See https://github.com/elastic/elasticsearch/issues/18054;public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_                                         .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_                                         .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_                                                .settings(idxSettings)_                                                .numberOfShards(1)_                                                .numberOfReplicas(0)_                                                .build()__        final Index tombstonedIndex = new Index(indexName, UUIDs.randomBase64UUID())__        final IndexGraveyard graveyard = IndexGraveyard.builder().addTombstone(tombstonedIndex).build()__        final MetaData metaData = MetaData.builder().put(indexMetaData, true).indexGraveyard(graveyard).build()__        final ClusterState clusterState = new ClusterState.Builder(new ClusterName("testCluster")).metaData(metaData).build()__        _        indicesService.verifyIndexIsDeleted(tombstonedIndex, clusterState)__    };this,test,checks,an,edge,case,where,if,a,node,had,an,index,lets,call,it,a,with,uuid,1,then,deleted,it,so,a,tombstone,entry,for,a,will,exist,in,the,cluster,state,then,created,a,new,index,a,with,uuid,2,then,shutdown,when,the,node,comes,back,online,it,will,look,at,the,tombstones,for,deletions,and,it,should,proceed,with,trying,to,delete,a,with,uuid,1,and,not,throw,any,errors,that,the,index,still,exists,in,the,cluster,state,this,is,a,case,of,ensuring,that,tombstones,that,have,the,same,name,as,current,valid,indices,don,t,cause,confusion,by,trying,to,delete,an,index,that,exists,see,https,github,com,elastic,elasticsearch,issues,18054;public,void,test,index,and,tombstone,with,same,name,on,startup,throws,exception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,final,index,tombstoned,index,new,index,index,name,uuids,random,base64uuid,final,index,graveyard,graveyard,index,graveyard,builder,add,tombstone,tombstoned,index,build,final,meta,data,meta,data,meta,data,builder,put,index,meta,data,true,index,graveyard,graveyard,build,final,cluster,state,cluster,state,new,cluster,state,builder,new,cluster,name,test,cluster,meta,data,meta,data,build,indices,service,verify,index,is,deleted,tombstoned,index,cluster,state
IndicesServiceTests -> public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception;1537371806;This test checks an edge case where, if a node had an index (lets call it A with UUID 1), then_deleted it (so a tombstone entry for A will exist in the cluster state), then created_a new index A with UUID 2, then shutdown, when the node comes back online, it will look at the_tombstones for deletions, and it should proceed with trying to delete A with UUID 1 and not_throw any errors that the index still exists in the cluster state.  This is a case of ensuring_that tombstones that have the same name as current valid indices don't cause confusion by_trying to delete an index that exists._See https://github.com/elastic/elasticsearch/issues/18054;public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_                                         .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_                                         .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_                                                .settings(idxSettings)_                                                .numberOfShards(1)_                                                .numberOfReplicas(0)_                                                .build()__        final Index tombstonedIndex = new Index(indexName, UUIDs.randomBase64UUID())__        final IndexGraveyard graveyard = IndexGraveyard.builder().addTombstone(tombstonedIndex).build()__        final MetaData metaData = MetaData.builder().put(indexMetaData, true).indexGraveyard(graveyard).build()__        final ClusterState clusterState = new ClusterState.Builder(new ClusterName("testCluster")).metaData(metaData).build()__        _        indicesService.verifyIndexIsDeleted(tombstonedIndex, clusterState)__    };this,test,checks,an,edge,case,where,if,a,node,had,an,index,lets,call,it,a,with,uuid,1,then,deleted,it,so,a,tombstone,entry,for,a,will,exist,in,the,cluster,state,then,created,a,new,index,a,with,uuid,2,then,shutdown,when,the,node,comes,back,online,it,will,look,at,the,tombstones,for,deletions,and,it,should,proceed,with,trying,to,delete,a,with,uuid,1,and,not,throw,any,errors,that,the,index,still,exists,in,the,cluster,state,this,is,a,case,of,ensuring,that,tombstones,that,have,the,same,name,as,current,valid,indices,don,t,cause,confusion,by,trying,to,delete,an,index,that,exists,see,https,github,com,elastic,elasticsearch,issues,18054;public,void,test,index,and,tombstone,with,same,name,on,startup,throws,exception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,final,index,tombstoned,index,new,index,index,name,uuids,random,base64uuid,final,index,graveyard,graveyard,index,graveyard,builder,add,tombstone,tombstoned,index,build,final,meta,data,meta,data,meta,data,builder,put,index,meta,data,true,index,graveyard,graveyard,build,final,cluster,state,cluster,state,new,cluster,state,builder,new,cluster,name,test,cluster,meta,data,meta,data,build,indices,service,verify,index,is,deleted,tombstoned,index,cluster,state
IndicesServiceTests -> public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception;1540486836;This test checks an edge case where, if a node had an index (lets call it A with UUID 1), then_deleted it (so a tombstone entry for A will exist in the cluster state), then created_a new index A with UUID 2, then shutdown, when the node comes back online, it will look at the_tombstones for deletions, and it should proceed with trying to delete A with UUID 1 and not_throw any errors that the index still exists in the cluster state.  This is a case of ensuring_that tombstones that have the same name as current valid indices don't cause confusion by_trying to delete an index that exists._See https://github.com/elastic/elasticsearch/issues/18054;public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_                                         .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_                                         .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_                                                .settings(idxSettings)_                                                .numberOfShards(1)_                                                .numberOfReplicas(0)_                                                .build()__        final Index tombstonedIndex = new Index(indexName, UUIDs.randomBase64UUID())__        final IndexGraveyard graveyard = IndexGraveyard.builder().addTombstone(tombstonedIndex).build()__        final MetaData metaData = MetaData.builder().put(indexMetaData, true).indexGraveyard(graveyard).build()__        final ClusterState clusterState = new ClusterState.Builder(new ClusterName("testCluster")).metaData(metaData).build()__        _        indicesService.verifyIndexIsDeleted(tombstonedIndex, clusterState)__    };this,test,checks,an,edge,case,where,if,a,node,had,an,index,lets,call,it,a,with,uuid,1,then,deleted,it,so,a,tombstone,entry,for,a,will,exist,in,the,cluster,state,then,created,a,new,index,a,with,uuid,2,then,shutdown,when,the,node,comes,back,online,it,will,look,at,the,tombstones,for,deletions,and,it,should,proceed,with,trying,to,delete,a,with,uuid,1,and,not,throw,any,errors,that,the,index,still,exists,in,the,cluster,state,this,is,a,case,of,ensuring,that,tombstones,that,have,the,same,name,as,current,valid,indices,don,t,cause,confusion,by,trying,to,delete,an,index,that,exists,see,https,github,com,elastic,elasticsearch,issues,18054;public,void,test,index,and,tombstone,with,same,name,on,startup,throws,exception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,final,index,tombstoned,index,new,index,index,name,uuids,random,base64uuid,final,index,graveyard,graveyard,index,graveyard,builder,add,tombstone,tombstoned,index,build,final,meta,data,meta,data,meta,data,builder,put,index,meta,data,true,index,graveyard,graveyard,build,final,cluster,state,cluster,state,new,cluster,state,builder,new,cluster,name,test,cluster,meta,data,meta,data,build,indices,service,verify,index,is,deleted,tombstoned,index,cluster,state
IndicesServiceTests -> public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception;1543277112;This test checks an edge case where, if a node had an index (lets call it A with UUID 1), then_deleted it (so a tombstone entry for A will exist in the cluster state), then created_a new index A with UUID 2, then shutdown, when the node comes back online, it will look at the_tombstones for deletions, and it should proceed with trying to delete A with UUID 1 and not_throw any errors that the index still exists in the cluster state.  This is a case of ensuring_that tombstones that have the same name as current valid indices don't cause confusion by_trying to delete an index that exists._See https://github.com/elastic/elasticsearch/issues/18054;public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_                                         .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_                                         .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_                                                .settings(idxSettings)_                                                .numberOfShards(1)_                                                .numberOfReplicas(0)_                                                .build()__        final Index tombstonedIndex = new Index(indexName, UUIDs.randomBase64UUID())__        final IndexGraveyard graveyard = IndexGraveyard.builder().addTombstone(tombstonedIndex).build()__        final MetaData metaData = MetaData.builder().put(indexMetaData, true).indexGraveyard(graveyard).build()__        final ClusterState clusterState = new ClusterState.Builder(new ClusterName("testCluster")).metaData(metaData).build()__        _        indicesService.verifyIndexIsDeleted(tombstonedIndex, clusterState)__    };this,test,checks,an,edge,case,where,if,a,node,had,an,index,lets,call,it,a,with,uuid,1,then,deleted,it,so,a,tombstone,entry,for,a,will,exist,in,the,cluster,state,then,created,a,new,index,a,with,uuid,2,then,shutdown,when,the,node,comes,back,online,it,will,look,at,the,tombstones,for,deletions,and,it,should,proceed,with,trying,to,delete,a,with,uuid,1,and,not,throw,any,errors,that,the,index,still,exists,in,the,cluster,state,this,is,a,case,of,ensuring,that,tombstones,that,have,the,same,name,as,current,valid,indices,don,t,cause,confusion,by,trying,to,delete,an,index,that,exists,see,https,github,com,elastic,elasticsearch,issues,18054;public,void,test,index,and,tombstone,with,same,name,on,startup,throws,exception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,final,index,tombstoned,index,new,index,index,name,uuids,random,base64uuid,final,index,graveyard,graveyard,index,graveyard,builder,add,tombstone,tombstoned,index,build,final,meta,data,meta,data,meta,data,builder,put,index,meta,data,true,index,graveyard,graveyard,build,final,cluster,state,cluster,state,new,cluster,state,builder,new,cluster,name,test,cluster,meta,data,meta,data,build,indices,service,verify,index,is,deleted,tombstoned,index,cluster,state
IndicesServiceTests -> public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception;1544081506;This test checks an edge case where, if a node had an index (lets call it A with UUID 1), then_deleted it (so a tombstone entry for A will exist in the cluster state), then created_a new index A with UUID 2, then shutdown, when the node comes back online, it will look at the_tombstones for deletions, and it should proceed with trying to delete A with UUID 1 and not_throw any errors that the index still exists in the cluster state.  This is a case of ensuring_that tombstones that have the same name as current valid indices don't cause confusion by_trying to delete an index that exists._See https://github.com/elastic/elasticsearch/issues/18054;public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_                                         .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_                                         .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_                                                .settings(idxSettings)_                                                .numberOfShards(1)_                                                .numberOfReplicas(0)_                                                .build()__        final Index tombstonedIndex = new Index(indexName, UUIDs.randomBase64UUID())__        final IndexGraveyard graveyard = IndexGraveyard.builder().addTombstone(tombstonedIndex).build()__        final MetaData metaData = MetaData.builder().put(indexMetaData, true).indexGraveyard(graveyard).build()__        final ClusterState clusterState = new ClusterState.Builder(new ClusterName("testCluster")).metaData(metaData).build()__        _        indicesService.verifyIndexIsDeleted(tombstonedIndex, clusterState)__    };this,test,checks,an,edge,case,where,if,a,node,had,an,index,lets,call,it,a,with,uuid,1,then,deleted,it,so,a,tombstone,entry,for,a,will,exist,in,the,cluster,state,then,created,a,new,index,a,with,uuid,2,then,shutdown,when,the,node,comes,back,online,it,will,look,at,the,tombstones,for,deletions,and,it,should,proceed,with,trying,to,delete,a,with,uuid,1,and,not,throw,any,errors,that,the,index,still,exists,in,the,cluster,state,this,is,a,case,of,ensuring,that,tombstones,that,have,the,same,name,as,current,valid,indices,don,t,cause,confusion,by,trying,to,delete,an,index,that,exists,see,https,github,com,elastic,elasticsearch,issues,18054;public,void,test,index,and,tombstone,with,same,name,on,startup,throws,exception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,final,index,tombstoned,index,new,index,index,name,uuids,random,base64uuid,final,index,graveyard,graveyard,index,graveyard,builder,add,tombstone,tombstoned,index,build,final,meta,data,meta,data,meta,data,builder,put,index,meta,data,true,index,graveyard,graveyard,build,final,cluster,state,cluster,state,new,cluster,state,builder,new,cluster,name,test,cluster,meta,data,meta,data,build,indices,service,verify,index,is,deleted,tombstoned,index,cluster,state
IndicesServiceTests -> public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception;1548834350;This test checks an edge case where, if a node had an index (lets call it A with UUID 1), then_deleted it (so a tombstone entry for A will exist in the cluster state), then created_a new index A with UUID 2, then shutdown, when the node comes back online, it will look at the_tombstones for deletions, and it should proceed with trying to delete A with UUID 1 and not_throw any errors that the index still exists in the cluster state.  This is a case of ensuring_that tombstones that have the same name as current valid indices don't cause confusion by_trying to delete an index that exists._See https://github.com/elastic/elasticsearch/issues/18054;public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_                                         .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_                                         .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_                                                .settings(idxSettings)_                                                .numberOfShards(1)_                                                .numberOfReplicas(0)_                                                .build()__        final Index tombstonedIndex = new Index(indexName, UUIDs.randomBase64UUID())__        final IndexGraveyard graveyard = IndexGraveyard.builder().addTombstone(tombstonedIndex).build()__        final MetaData metaData = MetaData.builder().put(indexMetaData, true).indexGraveyard(graveyard).build()__        final ClusterState clusterState = new ClusterState.Builder(new ClusterName("testCluster")).metaData(metaData).build()__        _        indicesService.verifyIndexIsDeleted(tombstonedIndex, clusterState)__    };this,test,checks,an,edge,case,where,if,a,node,had,an,index,lets,call,it,a,with,uuid,1,then,deleted,it,so,a,tombstone,entry,for,a,will,exist,in,the,cluster,state,then,created,a,new,index,a,with,uuid,2,then,shutdown,when,the,node,comes,back,online,it,will,look,at,the,tombstones,for,deletions,and,it,should,proceed,with,trying,to,delete,a,with,uuid,1,and,not,throw,any,errors,that,the,index,still,exists,in,the,cluster,state,this,is,a,case,of,ensuring,that,tombstones,that,have,the,same,name,as,current,valid,indices,don,t,cause,confusion,by,trying,to,delete,an,index,that,exists,see,https,github,com,elastic,elasticsearch,issues,18054;public,void,test,index,and,tombstone,with,same,name,on,startup,throws,exception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,final,index,tombstoned,index,new,index,index,name,uuids,random,base64uuid,final,index,graveyard,graveyard,index,graveyard,builder,add,tombstone,tombstoned,index,build,final,meta,data,meta,data,meta,data,builder,put,index,meta,data,true,index,graveyard,graveyard,build,final,cluster,state,cluster,state,new,cluster,state,builder,new,cluster,name,test,cluster,meta,data,meta,data,build,indices,service,verify,index,is,deleted,tombstoned,index,cluster,state
IndicesServiceTests -> public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception;1549822589;This test checks an edge case where, if a node had an index (lets call it A with UUID 1), then_deleted it (so a tombstone entry for A will exist in the cluster state), then created_a new index A with UUID 2, then shutdown, when the node comes back online, it will look at the_tombstones for deletions, and it should proceed with trying to delete A with UUID 1 and not_throw any errors that the index still exists in the cluster state.  This is a case of ensuring_that tombstones that have the same name as current valid indices don't cause confusion by_trying to delete an index that exists._See https://github.com/elastic/elasticsearch/issues/18054;public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_                                         .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_                                         .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_                                                .settings(idxSettings)_                                                .numberOfShards(1)_                                                .numberOfReplicas(0)_                                                .build()__        final Index tombstonedIndex = new Index(indexName, UUIDs.randomBase64UUID())__        final IndexGraveyard graveyard = IndexGraveyard.builder().addTombstone(tombstonedIndex).build()__        final MetaData metaData = MetaData.builder().put(indexMetaData, true).indexGraveyard(graveyard).build()__        final ClusterState clusterState = new ClusterState.Builder(new ClusterName("testCluster")).metaData(metaData).build()__        _        indicesService.verifyIndexIsDeleted(tombstonedIndex, clusterState)__    };this,test,checks,an,edge,case,where,if,a,node,had,an,index,lets,call,it,a,with,uuid,1,then,deleted,it,so,a,tombstone,entry,for,a,will,exist,in,the,cluster,state,then,created,a,new,index,a,with,uuid,2,then,shutdown,when,the,node,comes,back,online,it,will,look,at,the,tombstones,for,deletions,and,it,should,proceed,with,trying,to,delete,a,with,uuid,1,and,not,throw,any,errors,that,the,index,still,exists,in,the,cluster,state,this,is,a,case,of,ensuring,that,tombstones,that,have,the,same,name,as,current,valid,indices,don,t,cause,confusion,by,trying,to,delete,an,index,that,exists,see,https,github,com,elastic,elasticsearch,issues,18054;public,void,test,index,and,tombstone,with,same,name,on,startup,throws,exception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,final,index,tombstoned,index,new,index,index,name,uuids,random,base64uuid,final,index,graveyard,graveyard,index,graveyard,builder,add,tombstone,tombstoned,index,build,final,meta,data,meta,data,meta,data,builder,put,index,meta,data,true,index,graveyard,graveyard,build,final,cluster,state,cluster,state,new,cluster,state,builder,new,cluster,name,test,cluster,meta,data,meta,data,build,indices,service,verify,index,is,deleted,tombstoned,index,cluster,state
IndicesServiceTests -> public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception;1550342051;This test checks an edge case where, if a node had an index (lets call it A with UUID 1), then_deleted it (so a tombstone entry for A will exist in the cluster state), then created_a new index A with UUID 2, then shutdown, when the node comes back online, it will look at the_tombstones for deletions, and it should proceed with trying to delete A with UUID 1 and not_throw any errors that the index still exists in the cluster state.  This is a case of ensuring_that tombstones that have the same name as current valid indices don't cause confusion by_trying to delete an index that exists._See https://github.com/elastic/elasticsearch/issues/18054;public void testIndexAndTombstoneWithSameNameOnStartup() throws Exception {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_                                         .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_                                         .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_                                                .settings(idxSettings)_                                                .numberOfShards(1)_                                                .numberOfReplicas(0)_                                                .build()__        final Index tombstonedIndex = new Index(indexName, UUIDs.randomBase64UUID())__        final IndexGraveyard graveyard = IndexGraveyard.builder().addTombstone(tombstonedIndex).build()__        final MetaData metaData = MetaData.builder().put(indexMetaData, true).indexGraveyard(graveyard).build()__        final ClusterState clusterState = new ClusterState.Builder(new ClusterName("testCluster")).metaData(metaData).build()__        _        indicesService.verifyIndexIsDeleted(tombstonedIndex, clusterState)__    };this,test,checks,an,edge,case,where,if,a,node,had,an,index,lets,call,it,a,with,uuid,1,then,deleted,it,so,a,tombstone,entry,for,a,will,exist,in,the,cluster,state,then,created,a,new,index,a,with,uuid,2,then,shutdown,when,the,node,comes,back,online,it,will,look,at,the,tombstones,for,deletions,and,it,should,proceed,with,trying,to,delete,a,with,uuid,1,and,not,throw,any,errors,that,the,index,still,exists,in,the,cluster,state,this,is,a,case,of,ensuring,that,tombstones,that,have,the,same,name,as,current,valid,indices,don,t,cause,confusion,by,trying,to,delete,an,index,that,exists,see,https,github,com,elastic,elasticsearch,issues,18054;public,void,test,index,and,tombstone,with,same,name,on,startup,throws,exception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,final,index,tombstoned,index,new,index,index,name,uuids,random,base64uuid,final,index,graveyard,graveyard,index,graveyard,builder,add,tombstone,tombstoned,index,build,final,meta,data,meta,data,meta,data,builder,put,index,meta,data,true,index,graveyard,graveyard,build,final,cluster,state,cluster,state,new,cluster,state,builder,new,cluster,name,test,cluster,meta,data,meta,data,build,indices,service,verify,index,is,deleted,tombstoned,index,cluster,state
IndicesServiceTests -> public void testStandAloneMapperServiceWithPlugins() throws IOException;1524684173;Tests that teh {@link MapperService} created by {@link IndicesService#createIndexMapperService(IndexMetaData)} contains_custom types and similarities registered by plugins;public void testStandAloneMapperServiceWithPlugins() throws IOException {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_            .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_            .put(IndexModule.SIMILARITY_SETTINGS_PREFIX + ".test.type", "fake-similarity")_            .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_            .settings(idxSettings)_            .numberOfShards(1)_            .numberOfReplicas(0)_            .build()__        MapperService mapperService = indicesService.createIndexMapperService(indexMetaData)__        assertNotNull(mapperService.documentMapperParser().parserContext("type").typeParser("fake-mapper"))__        assertThat(mapperService.documentMapperParser().parserContext("type").getSimilarity("test").get(),_            instanceOf(BM25Similarity.class))__    };tests,that,teh,link,mapper,service,created,by,link,indices,service,create,index,mapper,service,index,meta,data,contains,custom,types,and,similarities,registered,by,plugins;public,void,test,stand,alone,mapper,service,with,plugins,throws,ioexception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,put,index,module,test,type,fake,similarity,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,mapper,service,mapper,service,indices,service,create,index,mapper,service,index,meta,data,assert,not,null,mapper,service,document,mapper,parser,parser,context,type,type,parser,fake,mapper,assert,that,mapper,service,document,mapper,parser,parser,context,type,get,similarity,test,get,instance,of,bm25similarity,class
IndicesServiceTests -> public void testStandAloneMapperServiceWithPlugins() throws IOException;1528706846;Tests that teh {@link MapperService} created by {@link IndicesService#createIndexMapperService(IndexMetaData)} contains_custom types and similarities registered by plugins;public void testStandAloneMapperServiceWithPlugins() throws IOException {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_            .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_            .put(IndexModule.SIMILARITY_SETTINGS_PREFIX + ".test.type", "fake-similarity")_            .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_            .settings(idxSettings)_            .numberOfShards(1)_            .numberOfReplicas(0)_            .build()__        MapperService mapperService = indicesService.createIndexMapperService(indexMetaData)__        assertNotNull(mapperService.documentMapperParser().parserContext("type").typeParser("fake-mapper"))__        assertThat(mapperService.documentMapperParser().parserContext("type").getSimilarity("test").get(),_            instanceOf(BM25Similarity.class))__    };tests,that,teh,link,mapper,service,created,by,link,indices,service,create,index,mapper,service,index,meta,data,contains,custom,types,and,similarities,registered,by,plugins;public,void,test,stand,alone,mapper,service,with,plugins,throws,ioexception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,put,index,module,test,type,fake,similarity,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,mapper,service,mapper,service,indices,service,create,index,mapper,service,index,meta,data,assert,not,null,mapper,service,document,mapper,parser,parser,context,type,type,parser,fake,mapper,assert,that,mapper,service,document,mapper,parser,parser,context,type,get,similarity,test,get,instance,of,bm25similarity,class
IndicesServiceTests -> public void testStandAloneMapperServiceWithPlugins() throws IOException;1537371806;Tests that teh {@link MapperService} created by {@link IndicesService#createIndexMapperService(IndexMetaData)} contains_custom types and similarities registered by plugins;public void testStandAloneMapperServiceWithPlugins() throws IOException {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_            .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_            .put(IndexModule.SIMILARITY_SETTINGS_PREFIX + ".test.type", "fake-similarity")_            .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_            .settings(idxSettings)_            .numberOfShards(1)_            .numberOfReplicas(0)_            .build()__        MapperService mapperService = indicesService.createIndexMapperService(indexMetaData)__        assertNotNull(mapperService.documentMapperParser().parserContext("type").typeParser("fake-mapper"))__        Similarity sim = mapperService.documentMapperParser().parserContext("type").getSimilarity("test").get()__        assertThat(sim, instanceOf(NonNegativeScoresSimilarity.class))__        sim = ((NonNegativeScoresSimilarity) sim).getDelegate()__        assertThat(sim, instanceOf(BM25Similarity.class))__    };tests,that,teh,link,mapper,service,created,by,link,indices,service,create,index,mapper,service,index,meta,data,contains,custom,types,and,similarities,registered,by,plugins;public,void,test,stand,alone,mapper,service,with,plugins,throws,ioexception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,put,index,module,test,type,fake,similarity,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,mapper,service,mapper,service,indices,service,create,index,mapper,service,index,meta,data,assert,not,null,mapper,service,document,mapper,parser,parser,context,type,type,parser,fake,mapper,similarity,sim,mapper,service,document,mapper,parser,parser,context,type,get,similarity,test,get,assert,that,sim,instance,of,non,negative,scores,similarity,class,sim,non,negative,scores,similarity,sim,get,delegate,assert,that,sim,instance,of,bm25similarity,class
IndicesServiceTests -> public void testStandAloneMapperServiceWithPlugins() throws IOException;1540486836;Tests that teh {@link MapperService} created by {@link IndicesService#createIndexMapperService(IndexMetaData)} contains_custom types and similarities registered by plugins;public void testStandAloneMapperServiceWithPlugins() throws IOException {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_            .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_            .put(IndexModule.SIMILARITY_SETTINGS_PREFIX + ".test.type", "fake-similarity")_            .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_            .settings(idxSettings)_            .numberOfShards(1)_            .numberOfReplicas(0)_            .build()__        MapperService mapperService = indicesService.createIndexMapperService(indexMetaData)__        assertNotNull(mapperService.documentMapperParser().parserContext("type").typeParser("fake-mapper"))__        Similarity sim = mapperService.documentMapperParser().parserContext("type").getSimilarity("test").get()__        assertThat(sim, instanceOf(NonNegativeScoresSimilarity.class))__        sim = ((NonNegativeScoresSimilarity) sim).getDelegate()__        assertThat(sim, instanceOf(BM25Similarity.class))__    };tests,that,teh,link,mapper,service,created,by,link,indices,service,create,index,mapper,service,index,meta,data,contains,custom,types,and,similarities,registered,by,plugins;public,void,test,stand,alone,mapper,service,with,plugins,throws,ioexception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,put,index,module,test,type,fake,similarity,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,mapper,service,mapper,service,indices,service,create,index,mapper,service,index,meta,data,assert,not,null,mapper,service,document,mapper,parser,parser,context,type,type,parser,fake,mapper,similarity,sim,mapper,service,document,mapper,parser,parser,context,type,get,similarity,test,get,assert,that,sim,instance,of,non,negative,scores,similarity,class,sim,non,negative,scores,similarity,sim,get,delegate,assert,that,sim,instance,of,bm25similarity,class
IndicesServiceTests -> public void testStandAloneMapperServiceWithPlugins() throws IOException;1543277112;Tests that teh {@link MapperService} created by {@link IndicesService#createIndexMapperService(IndexMetaData)} contains_custom types and similarities registered by plugins;public void testStandAloneMapperServiceWithPlugins() throws IOException {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_            .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_            .put(IndexModule.SIMILARITY_SETTINGS_PREFIX + ".test.type", "fake-similarity")_            .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_            .settings(idxSettings)_            .numberOfShards(1)_            .numberOfReplicas(0)_            .build()__        MapperService mapperService = indicesService.createIndexMapperService(indexMetaData)__        assertNotNull(mapperService.documentMapperParser().parserContext("type").typeParser("fake-mapper"))__        Similarity sim = mapperService.documentMapperParser().parserContext("type").getSimilarity("test").get()__        assertThat(sim, instanceOf(NonNegativeScoresSimilarity.class))__        sim = ((NonNegativeScoresSimilarity) sim).getDelegate()__        assertThat(sim, instanceOf(BM25Similarity.class))__    };tests,that,teh,link,mapper,service,created,by,link,indices,service,create,index,mapper,service,index,meta,data,contains,custom,types,and,similarities,registered,by,plugins;public,void,test,stand,alone,mapper,service,with,plugins,throws,ioexception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,put,index,module,test,type,fake,similarity,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,mapper,service,mapper,service,indices,service,create,index,mapper,service,index,meta,data,assert,not,null,mapper,service,document,mapper,parser,parser,context,type,type,parser,fake,mapper,similarity,sim,mapper,service,document,mapper,parser,parser,context,type,get,similarity,test,get,assert,that,sim,instance,of,non,negative,scores,similarity,class,sim,non,negative,scores,similarity,sim,get,delegate,assert,that,sim,instance,of,bm25similarity,class
IndicesServiceTests -> public void testStandAloneMapperServiceWithPlugins() throws IOException;1544081506;Tests that teh {@link MapperService} created by {@link IndicesService#createIndexMapperService(IndexMetaData)} contains_custom types and similarities registered by plugins;public void testStandAloneMapperServiceWithPlugins() throws IOException {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_            .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_            .put(IndexModule.SIMILARITY_SETTINGS_PREFIX + ".test.type", "fake-similarity")_            .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_            .settings(idxSettings)_            .numberOfShards(1)_            .numberOfReplicas(0)_            .build()__        MapperService mapperService = indicesService.createIndexMapperService(indexMetaData)__        assertNotNull(mapperService.documentMapperParser().parserContext("type").typeParser("fake-mapper"))__        Similarity sim = mapperService.documentMapperParser().parserContext("type").getSimilarity("test").get()__        assertThat(sim, instanceOf(NonNegativeScoresSimilarity.class))__        sim = ((NonNegativeScoresSimilarity) sim).getDelegate()__        assertThat(sim, instanceOf(BM25Similarity.class))__    };tests,that,teh,link,mapper,service,created,by,link,indices,service,create,index,mapper,service,index,meta,data,contains,custom,types,and,similarities,registered,by,plugins;public,void,test,stand,alone,mapper,service,with,plugins,throws,ioexception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,put,index,module,test,type,fake,similarity,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,mapper,service,mapper,service,indices,service,create,index,mapper,service,index,meta,data,assert,not,null,mapper,service,document,mapper,parser,parser,context,type,type,parser,fake,mapper,similarity,sim,mapper,service,document,mapper,parser,parser,context,type,get,similarity,test,get,assert,that,sim,instance,of,non,negative,scores,similarity,class,sim,non,negative,scores,similarity,sim,get,delegate,assert,that,sim,instance,of,bm25similarity,class
IndicesServiceTests -> public void testStandAloneMapperServiceWithPlugins() throws IOException;1548834350;Tests that teh {@link MapperService} created by {@link IndicesService#createIndexMapperService(IndexMetaData)} contains_custom types and similarities registered by plugins;public void testStandAloneMapperServiceWithPlugins() throws IOException {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_            .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_            .put(IndexModule.SIMILARITY_SETTINGS_PREFIX + ".test.type", "fake-similarity")_            .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_            .settings(idxSettings)_            .numberOfShards(1)_            .numberOfReplicas(0)_            .build()__        MapperService mapperService = indicesService.createIndexMapperService(indexMetaData)__        assertNotNull(mapperService.documentMapperParser().parserContext("type").typeParser("fake-mapper"))__        Similarity sim = mapperService.documentMapperParser().parserContext("type").getSimilarity("test").get()__        assertThat(sim, instanceOf(NonNegativeScoresSimilarity.class))__        sim = ((NonNegativeScoresSimilarity) sim).getDelegate()__        assertThat(sim, instanceOf(BM25Similarity.class))__    };tests,that,teh,link,mapper,service,created,by,link,indices,service,create,index,mapper,service,index,meta,data,contains,custom,types,and,similarities,registered,by,plugins;public,void,test,stand,alone,mapper,service,with,plugins,throws,ioexception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,put,index,module,test,type,fake,similarity,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,mapper,service,mapper,service,indices,service,create,index,mapper,service,index,meta,data,assert,not,null,mapper,service,document,mapper,parser,parser,context,type,type,parser,fake,mapper,similarity,sim,mapper,service,document,mapper,parser,parser,context,type,get,similarity,test,get,assert,that,sim,instance,of,non,negative,scores,similarity,class,sim,non,negative,scores,similarity,sim,get,delegate,assert,that,sim,instance,of,bm25similarity,class
IndicesServiceTests -> public void testStandAloneMapperServiceWithPlugins() throws IOException;1549822589;Tests that teh {@link MapperService} created by {@link IndicesService#createIndexMapperService(IndexMetaData)} contains_custom types and similarities registered by plugins;public void testStandAloneMapperServiceWithPlugins() throws IOException {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_            .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_            .put(IndexModule.SIMILARITY_SETTINGS_PREFIX + ".test.type", "fake-similarity")_            .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_            .settings(idxSettings)_            .numberOfShards(1)_            .numberOfReplicas(0)_            .build()__        MapperService mapperService = indicesService.createIndexMapperService(indexMetaData)__        assertNotNull(mapperService.documentMapperParser().parserContext("type").typeParser("fake-mapper"))__        Similarity sim = mapperService.documentMapperParser().parserContext("type").getSimilarity("test").get()__        assertThat(sim, instanceOf(NonNegativeScoresSimilarity.class))__        sim = ((NonNegativeScoresSimilarity) sim).getDelegate()__        assertThat(sim, instanceOf(BM25Similarity.class))__    };tests,that,teh,link,mapper,service,created,by,link,indices,service,create,index,mapper,service,index,meta,data,contains,custom,types,and,similarities,registered,by,plugins;public,void,test,stand,alone,mapper,service,with,plugins,throws,ioexception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,put,index,module,test,type,fake,similarity,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,mapper,service,mapper,service,indices,service,create,index,mapper,service,index,meta,data,assert,not,null,mapper,service,document,mapper,parser,parser,context,type,type,parser,fake,mapper,similarity,sim,mapper,service,document,mapper,parser,parser,context,type,get,similarity,test,get,assert,that,sim,instance,of,non,negative,scores,similarity,class,sim,non,negative,scores,similarity,sim,get,delegate,assert,that,sim,instance,of,bm25similarity,class
IndicesServiceTests -> public void testStandAloneMapperServiceWithPlugins() throws IOException;1550342051;Tests that teh {@link MapperService} created by {@link IndicesService#createIndexMapperService(IndexMetaData)} contains_custom types and similarities registered by plugins;public void testStandAloneMapperServiceWithPlugins() throws IOException {_        final String indexName = "test"__        final Index index = new Index(indexName, UUIDs.randomBase64UUID())__        final IndicesService indicesService = getIndicesService()__        final Settings idxSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT)_            .put(IndexMetaData.SETTING_INDEX_UUID, index.getUUID())_            .put(IndexModule.SIMILARITY_SETTINGS_PREFIX + ".test.type", "fake-similarity")_            .build()__        final IndexMetaData indexMetaData = new IndexMetaData.Builder(index.getName())_            .settings(idxSettings)_            .numberOfShards(1)_            .numberOfReplicas(0)_            .build()__        MapperService mapperService = indicesService.createIndexMapperService(indexMetaData)__        assertNotNull(mapperService.documentMapperParser().parserContext("type").typeParser("fake-mapper"))__        Similarity sim = mapperService.documentMapperParser().parserContext("type").getSimilarity("test").get()__        assertThat(sim, instanceOf(NonNegativeScoresSimilarity.class))__        sim = ((NonNegativeScoresSimilarity) sim).getDelegate()__        assertThat(sim, instanceOf(BM25Similarity.class))__    };tests,that,teh,link,mapper,service,created,by,link,indices,service,create,index,mapper,service,index,meta,data,contains,custom,types,and,similarities,registered,by,plugins;public,void,test,stand,alone,mapper,service,with,plugins,throws,ioexception,final,string,index,name,test,final,index,index,new,index,index,name,uuids,random,base64uuid,final,indices,service,indices,service,get,indices,service,final,settings,idx,settings,settings,builder,put,index,meta,data,version,current,put,index,meta,data,index,get,uuid,put,index,module,test,type,fake,similarity,build,final,index,meta,data,index,meta,data,new,index,meta,data,builder,index,get,name,settings,idx,settings,number,of,shards,1,number,of,replicas,0,build,mapper,service,mapper,service,indices,service,create,index,mapper,service,index,meta,data,assert,not,null,mapper,service,document,mapper,parser,parser,context,type,type,parser,fake,mapper,similarity,sim,mapper,service,document,mapper,parser,parser,context,type,get,similarity,test,get,assert,that,sim,instance,of,non,negative,scores,similarity,class,sim,non,negative,scores,similarity,sim,get,delegate,assert,that,sim,instance,of,bm25similarity,class
