commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;12;;@BeforeClass public static void createThreadPoolAndClusterService() {     threadPool = new TestThreadPool("test", Settings.EMPTY).     localNode = makeDiscoveryNode("local").     localNodeExclusion = new VotingConfigExclusion(localNode).     otherNode1 = makeDiscoveryNode("other1").     otherNode1Exclusion = new VotingConfigExclusion(otherNode1).     otherNode2 = makeDiscoveryNode("other2").     otherNode2Exclusion = new VotingConfigExclusion(otherNode2).     otherDataNode = new DiscoveryNode("data", "data", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT).     clusterService = createClusterService(threadPool, localNode). }
false;private,static;1;3;;private static DiscoveryNode makeDiscoveryNode(String name) {     return new DiscoveryNode(name, name, buildNewFakeTransportAddress(), emptyMap(), singleton(Role.MASTER), Version.CURRENT). }
false;public,static;0;5;;@AfterClass public static void shutdownThreadPoolAndClusterService() {     clusterService.stop().     threadPool.shutdown(). }
false;public;0;23;;@Before public void setupForTest() {     final MockTransport transport = new MockTransport().     transportService = transport.createTransportService(Settings.EMPTY, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, boundTransportAddress -> localNode, null, emptySet()).     new TransportAddVotingConfigExclusionsAction(transportService, clusterService, threadPool, new ActionFilters(emptySet()), // registers action     new IndexNameExpressionResolver()).     transportService.start().     transportService.acceptIncomingRequests().     final VotingConfiguration allNodesConfig = VotingConfiguration.of(localNode, otherNode1, otherNode2).     setState(clusterService, builder(new ClusterName("cluster")).nodes(new Builder().add(localNode).add(otherNode1).add(otherNode2).add(otherDataNode).localNodeId(localNode.getId()).masterNodeId(localNode.getId())).metaData(MetaData.builder().coordinationMetaData(CoordinationMetaData.builder().lastAcceptedConfiguration(allNodesConfig).lastCommittedConfiguration(allNodesConfig).build()))).     clusterStateObserver = new ClusterStateObserver(clusterService, null, logger, threadPool.getThreadContext()). }
false;public;0;15;;public void testWithdrawsVoteFromANode() throws InterruptedException {     final CountDownLatch countDownLatch = new CountDownLatch(1).     clusterStateObserver.waitForNextChange(new AdjustConfigurationForExclusions()).     transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME, new AddVotingConfigExclusionsRequest(new String[] { "other1" }), expectSuccess(r -> {         assertNotNull(r).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(), contains(otherNode1Exclusion)). }
false;public;0;16;;public void testWithdrawsVotesFromMultipleNodes() throws InterruptedException {     final CountDownLatch countDownLatch = new CountDownLatch(1).     clusterStateObserver.waitForNextChange(new AdjustConfigurationForExclusions()).     transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME, new AddVotingConfigExclusionsRequest(new String[] { "other1", "other2" }), expectSuccess(r -> {         assertNotNull(r).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(), containsInAnyOrder(otherNode1Exclusion, otherNode2Exclusion)). }
false;public;0;16;;public void testWithdrawsVotesFromNodesMatchingWildcard() throws InterruptedException {     final CountDownLatch countDownLatch = new CountDownLatch(1).     clusterStateObserver.waitForNextChange(new AdjustConfigurationForExclusions()).     transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME, new AddVotingConfigExclusionsRequest(new String[] { "other*" }), expectSuccess(r -> {         assertNotNull(r).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(), containsInAnyOrder(otherNode1Exclusion, otherNode2Exclusion)). }
false;public;0;16;;public void testWithdrawsVotesFromAllMasterEligibleNodes() throws InterruptedException {     final CountDownLatch countDownLatch = new CountDownLatch(1).     clusterStateObserver.waitForNextChange(new AdjustConfigurationForExclusions()).     transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME, new AddVotingConfigExclusionsRequest(new String[] { "_all" }), expectSuccess(r -> {         assertNotNull(r).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(), containsInAnyOrder(localNodeExclusion, otherNode1Exclusion, otherNode2Exclusion)). }
false;public;0;16;;public void testWithdrawsVoteFromLocalNode() throws InterruptedException {     final CountDownLatch countDownLatch = new CountDownLatch(1).     clusterStateObserver.waitForNextChange(new AdjustConfigurationForExclusions()).     transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME, new AddVotingConfigExclusionsRequest(new String[] { "_local" }), expectSuccess(r -> {         assertNotNull(r).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(), contains(localNodeExclusion)). }
false;public;0;24;;public void testReturnsImmediatelyIfVoteAlreadyWithdrawn() throws InterruptedException {     final ClusterState state = clusterService.state().     setState(clusterService, builder(state).metaData(MetaData.builder(state.metaData()).coordinationMetaData(CoordinationMetaData.builder(state.coordinationMetaData()).lastCommittedConfiguration(VotingConfiguration.of(localNode, otherNode2)).lastAcceptedConfiguration(VotingConfiguration.of(localNode, otherNode2)).build()))).     final CountDownLatch countDownLatch = new CountDownLatch(1).     // no observer to reconfigure     transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME, new AddVotingConfigExclusionsRequest(new String[] { "other1" }, TimeValue.ZERO), expectSuccess(r -> {         assertNotNull(r).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(), contains(otherNode1Exclusion)). }
false;public;0;18;;public void testReturnsErrorIfNoMatchingNodes() throws InterruptedException {     final CountDownLatch countDownLatch = new CountDownLatch(1).     final SetOnce<TransportException> exceptionHolder = new SetOnce<>().     transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME, new AddVotingConfigExclusionsRequest(new String[] { "not-a-node" }), expectError(e -> {         exceptionHolder.set(e).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     final Throwable rootCause = exceptionHolder.get().getRootCause().     assertThat(rootCause, instanceOf(IllegalArgumentException.class)).     assertThat(rootCause.getMessage(), equalTo("add voting config exclusions request for [not-a-node] matched no master-eligible nodes")). }
false;public;0;18;;public void testOnlyMatchesMasterEligibleNodes() throws InterruptedException {     final CountDownLatch countDownLatch = new CountDownLatch(1).     final SetOnce<TransportException> exceptionHolder = new SetOnce<>().     transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME, new AddVotingConfigExclusionsRequest(new String[] { "_all", "master:false" }), expectError(e -> {         exceptionHolder.set(e).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     final Throwable rootCause = exceptionHolder.get().getRootCause().     assertThat(rootCause, instanceOf(IllegalArgumentException.class)).     assertThat(rootCause.getMessage(), equalTo("add voting config exclusions request for [_all, master:false] matched no master-eligible nodes")). }
false;public;0;24;;public void testSucceedsEvenIfAllExclusionsAlreadyAdded() throws InterruptedException {     final ClusterState state = clusterService.state().     final ClusterState.Builder builder = builder(state).     builder.metaData(MetaData.builder(state.metaData()).coordinationMetaData(CoordinationMetaData.builder(state.coordinationMetaData()).addVotingConfigExclusion(otherNode1Exclusion).build())).     setState(clusterService, builder).     final CountDownLatch countDownLatch = new CountDownLatch(1).     transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME, new AddVotingConfigExclusionsRequest(new String[] { "other1" }), expectSuccess(r -> {         assertNotNull(r).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(), contains(otherNode1Exclusion)). }
false;public;0;41;;public void testReturnsErrorIfMaximumExclusionCountExceeded() throws InterruptedException {     final MetaData.Builder metaDataBuilder = MetaData.builder(clusterService.state().metaData()).persistentSettings(Settings.builder().put(clusterService.state().metaData().persistentSettings()).put(MAXIMUM_VOTING_CONFIG_EXCLUSIONS_SETTING.getKey(), 2).build()).     CoordinationMetaData.Builder coordinationMetaDataBuilder = CoordinationMetaData.builder(clusterService.state().coordinationMetaData()).addVotingConfigExclusion(localNodeExclusion).     final int existingCount, newCount.     if (randomBoolean()) {         coordinationMetaDataBuilder.addVotingConfigExclusion(otherNode1Exclusion).         existingCount = 2.         newCount = 1.     } else {         existingCount = 1.         newCount = 2.     }     metaDataBuilder.coordinationMetaData(coordinationMetaDataBuilder.build()).     final ClusterState.Builder builder = builder(clusterService.state()).metaData(metaDataBuilder).     setState(clusterService, builder).     final CountDownLatch countDownLatch = new CountDownLatch(1).     final SetOnce<TransportException> exceptionHolder = new SetOnce<>().     transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME, new AddVotingConfigExclusionsRequest(new String[] { "other*" }), expectError(e -> {         exceptionHolder.set(e).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     final Throwable rootCause = exceptionHolder.get().getRootCause().     assertThat(rootCause, instanceOf(IllegalArgumentException.class)).     assertThat(rootCause.getMessage(), equalTo("add voting config exclusions request for [other*] would add [" + newCount + "] exclusions to the existing [" + existingCount + "] which would exceed the maximum of [2] set by [cluster.max_voting_config_exclusions]")). }
false;public;0;17;;public void testTimesOut() throws InterruptedException {     final CountDownLatch countDownLatch = new CountDownLatch(1).     final SetOnce<TransportException> exceptionHolder = new SetOnce<>().     transportService.sendRequest(localNode, AddVotingConfigExclusionsAction.NAME, new AddVotingConfigExclusionsRequest(new String[] { "other1" }, TimeValue.timeValueMillis(100)), expectError(e -> {         exceptionHolder.set(e).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     final Throwable rootCause = exceptionHolder.get().getRootCause().     assertThat(rootCause, instanceOf(ElasticsearchTimeoutException.class)).     assertThat(rootCause.getMessage(), startsWith("timed out waiting for voting config exclusions [{other1}")). }
false;private;1;6;;private TransportResponseHandler<AddVotingConfigExclusionsResponse> expectSuccess(Consumer<AddVotingConfigExclusionsResponse> onResponse) {     return responseHandler(onResponse, e -> {         throw new AssertionError("unexpected", e).     }). }
false;private;1;5;;private TransportResponseHandler<AddVotingConfigExclusionsResponse> expectError(Consumer<TransportException> onException) {     return responseHandler(r -> {         assert false : r.     }, onException). }
false;public;1;4;;@Override public void handleResponse(AddVotingConfigExclusionsResponse response) {     onResponse.accept(response). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     onException.accept(exp). }
false;public;0;4;;@Override public String executor() {     return Names.SAME. }
false;public;1;4;;@Override public AddVotingConfigExclusionsResponse read(StreamInput in) throws IOException {     return new AddVotingConfigExclusionsResponse(in). }
false;private;2;24;;private TransportResponseHandler<AddVotingConfigExclusionsResponse> responseHandler(Consumer<AddVotingConfigExclusionsResponse> onResponse, Consumer<TransportException> onException) {     return new TransportResponseHandler<AddVotingConfigExclusionsResponse>() {          @Override         public void handleResponse(AddVotingConfigExclusionsResponse response) {             onResponse.accept(response).         }          @Override         public void handleException(TransportException exp) {             onException.accept(exp).         }          @Override         public String executor() {             return Names.SAME.         }          @Override         public AddVotingConfigExclusionsResponse read(StreamInput in) throws IOException {             return new AddVotingConfigExclusionsResponse(in).         }     }. }
false;public;1;15;;@Override public ClusterState execute(ClusterState currentState) {     assertThat(currentState, sameInstance(state)).     final Set<String> votingNodeIds = new HashSet<>().     currentState.nodes().forEach(n -> votingNodeIds.add(n.getId())).     currentState.getVotingConfigExclusions().forEach(t -> votingNodeIds.remove(t.getNodeId())).     final VotingConfiguration votingConfiguration = new VotingConfiguration(votingNodeIds).     return builder(currentState).metaData(MetaData.builder(currentState.metaData()).coordinationMetaData(CoordinationMetaData.builder(currentState.coordinationMetaData()).lastAcceptedConfiguration(votingConfiguration).lastCommittedConfiguration(votingConfiguration).build())).build(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     throw new AssertionError("unexpected failure", e). }
false;public;1;25;;@Override public void onNewClusterState(ClusterState state) {     clusterService.getMasterService().submitStateUpdateTask("reconfiguration", new ClusterStateUpdateTask() {          @Override         public ClusterState execute(ClusterState currentState) {             assertThat(currentState, sameInstance(state)).             final Set<String> votingNodeIds = new HashSet<>().             currentState.nodes().forEach(n -> votingNodeIds.add(n.getId())).             currentState.getVotingConfigExclusions().forEach(t -> votingNodeIds.remove(t.getNodeId())).             final VotingConfiguration votingConfiguration = new VotingConfiguration(votingNodeIds).             return builder(currentState).metaData(MetaData.builder(currentState.metaData()).coordinationMetaData(CoordinationMetaData.builder(currentState.coordinationMetaData()).lastAcceptedConfiguration(votingConfiguration).lastCommittedConfiguration(votingConfiguration).build())).build().         }          @Override         public void onFailure(String source, Exception e) {             throw new AssertionError("unexpected failure", e).         }     }). }
false;public;0;4;;@Override public void onClusterServiceClose() {     throw new AssertionError("unexpected close"). }
false;public;1;4;;@Override public void onTimeout(TimeValue timeout) {     throw new AssertionError("unexpected timeout"). }
