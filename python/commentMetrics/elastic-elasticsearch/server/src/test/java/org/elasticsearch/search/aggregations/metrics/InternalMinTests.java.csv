commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;6;;@Override protected InternalMin createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) {     double value = frequently() ? randomDouble() : randomFrom(new Double[] { Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY }).     DocValueFormat formatter = randomNumericDocValueFormat().     return new InternalMin(name, value, formatter, pipelineAggregators, metaData). }
false;protected;0;4;;@Override protected Reader<InternalMin> instanceReader() {     return InternalMin::new. }
false;protected;2;4;;@Override protected void assertReduced(InternalMin reduced, List<InternalMin> inputs) {     assertEquals(inputs.stream().mapToDouble(InternalMin::value).min().getAsDouble(), reduced.value(), 0). }
false;protected;2;12;;@Override protected void assertFromXContent(InternalMin min, ParsedAggregation parsedAggregation) {     ParsedMin parsed = ((ParsedMin) parsedAggregation).     if (Double.isInfinite(min.getValue()) == false) {         assertEquals(min.getValue(), parsed.getValue(), Double.MIN_VALUE).         assertEquals(min.getValueAsString(), parsed.getValueAsString()).     } else {         // we write Double.NEGATIVE_INFINITY and Double.POSITIVE_INFINITY to xContent as 'null', so we         // cannot differentiate between them. Also we cannot recreate the exact String representation         assertEquals(parsed.getValue(), Double.POSITIVE_INFINITY, 0).     } }
false;protected;1;31;;@Override protected InternalMin mutateInstance(InternalMin instance) {     String name = instance.getName().     double value = instance.getValue().     DocValueFormat formatter = instance.format.     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 2)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             if (Double.isFinite(value)) {                 value += between(1, 100).             } else {                 value = between(1, 100).             }             break.         case 2:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new InternalMin(name, value, formatter, pipelineAggregators, metaData). }
