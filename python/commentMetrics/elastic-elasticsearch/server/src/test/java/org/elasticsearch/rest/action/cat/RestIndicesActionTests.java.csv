commented;modifiers;parameterAmount;loc;comment;code
false;private;1;16;;private IndexMetaData[] buildRandomIndicesMetaData(int numIndices) {     // build a (semi-)random table     final IndexMetaData[] indicesMetaData = new IndexMetaData[numIndices].     for (int i = 0. i < numIndices. i++) {         indicesMetaData[i] = IndexMetaData.builder(randomAlphaOfLength(5) + i).settings(Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).put(IndexMetaData.SETTING_INDEX_UUID, UUIDs.randomBase64UUID())).creationDate(System.currentTimeMillis()).numberOfShards(1).numberOfReplicas(1).state(IndexMetaData.State.OPEN).build().     }     return indicesMetaData. }
false;private;1;11;;private ClusterState buildClusterState(IndexMetaData[] indicesMetaData) {     final MetaData.Builder metaDataBuilder = MetaData.builder().     for (IndexMetaData indexMetaData : indicesMetaData) {         metaDataBuilder.put(indexMetaData, false).     }     final MetaData metaData = metaDataBuilder.build().     final ClusterState clusterState = ClusterState.builder(ClusterName.CLUSTER_NAME_SETTING.getDefault(Settings.EMPTY)).metaData(metaData).build().     return clusterState. }
false;private;2;10;;private ClusterHealthResponse buildClusterHealthResponse(ClusterState clusterState, IndexMetaData[] indicesMetaData) {     final String[] indicesStr = new String[indicesMetaData.length].     for (int i = 0. i < indicesMetaData.length. i++) {         indicesStr[i] = indicesMetaData[i].getIndex().getName().     }     final ClusterHealthResponse clusterHealthResponse = new ClusterHealthResponse(clusterState.getClusterName().value(), indicesStr, clusterState, 0, 0, 0, TimeValue.timeValueMillis(1000L)).     return clusterHealthResponse. }
false;public;0;36;;public void testBuildTable() {     final Settings settings = Settings.EMPTY.     UsageService usageService = new UsageService().     final RestController restController = new RestController(Collections.emptySet(), null, null, null, usageService).     final RestIndicesAction action = new RestIndicesAction(settings, restController, new IndexNameExpressionResolver()).     final IndexMetaData[] generatedIndicesMetaData = buildRandomIndicesMetaData(randomIntBetween(1, 5)).     final ClusterState clusterState = buildClusterState(generatedIndicesMetaData).     final ClusterHealthResponse clusterHealthResponse = buildClusterHealthResponse(clusterState, generatedIndicesMetaData).     final IndexMetaData[] sortedIndicesMetaData = action.getOrderedIndexMetaData(new String[0], clusterState, IndicesOptions.strictExpand()).     final IndexMetaData[] smallerSortedIndicesMetaData = removeRandomElement(sortedIndicesMetaData).     final Table table = action.buildTable(new FakeRestRequest(), sortedIndicesMetaData, clusterHealthResponse, randomIndicesStatsResponse(smallerSortedIndicesMetaData)).     // now, verify the table is correct     int count = 0.     List<Table.Cell> headers = table.getHeaders().     assertThat(headers.get(count++).value, equalTo("health")).     assertThat(headers.get(count++).value, equalTo("status")).     assertThat(headers.get(count++).value, equalTo("index")).     assertThat(headers.get(count++).value, equalTo("uuid")).     List<List<Table.Cell>> rows = table.getRows().     assertThat(rows.size(), equalTo(smallerSortedIndicesMetaData.length)).     // TODO: more to verify (e.g. randomize cluster health, num primaries, num replicas, etc)     for (int i = 0. i < rows.size(). i++) {         count = 0.         final List<Table.Cell> row = rows.get(i).         // all are red because cluster state doesn't have routing entries         assertThat(row.get(count++).value, equalTo("red*")).         // all are OPEN for now         assertThat(row.get(count++).value, equalTo("open")).         assertThat(row.get(count++).value, equalTo(smallerSortedIndicesMetaData[i].getIndex().getName())).         assertThat(row.get(count++).value, equalTo(smallerSortedIndicesMetaData[i].getIndexUUID())).     } }
false;private;1;37;;private IndicesStatsResponse randomIndicesStatsResponse(final IndexMetaData[] indices) {     List<ShardStats> shardStats = new ArrayList<>().     for (final IndexMetaData index : indices) {         int numShards = randomIntBetween(1, 3).         // -1 means there is no primary shard.         int primaryIdx = randomIntBetween(-1, numShards - 1).         for (int i = 0. i < numShards. i++) {             ShardId shardId = new ShardId(index.getIndex(), i).             boolean primary = (i == primaryIdx).             Path path = createTempDir().resolve("indices").resolve(index.getIndexUUID()).resolve(String.valueOf(i)).             ShardRouting shardRouting = ShardRouting.newUnassigned(shardId, primary, primary ? RecoverySource.EmptyStoreRecoverySource.INSTANCE : PeerRecoverySource.INSTANCE, new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null)).             shardRouting = shardRouting.initialize("node-0", null, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE).             shardRouting = shardRouting.moveToStarted().             CommonStats stats = new CommonStats().             stats.fieldData = new FieldDataStats().             stats.queryCache = new QueryCacheStats().             stats.docs = new DocsStats().             stats.store = new StoreStats().             stats.indexing = new IndexingStats().             stats.search = new SearchStats().             stats.segments = new SegmentsStats().             stats.merge = new MergeStats().             stats.refresh = new RefreshStats().             stats.completion = new CompletionStats().             stats.requestCache = new RequestCacheStats().             stats.get = new GetStats().             stats.flush = new FlushStats().             stats.warmer = new WarmerStats().             shardStats.add(new ShardStats(shardRouting, new ShardPath(false, path, path, shardId), stats, null, null, null)).         }     }     return IndicesStatsTests.newIndicesStatsResponse(shardStats.toArray(new ShardStats[shardStats.size()]), shardStats.size(), shardStats.size(), 0, emptyList()). }
false;private;1;9;;private IndexMetaData[] removeRandomElement(IndexMetaData[] array) {     assert array != null.     assert array.length > 0.     final List<IndexMetaData> collectionLessAnItem = new ArrayList<>().     collectionLessAnItem.addAll(Arrays.asList(array)).     final int toRemoveIndex = randomIntBetween(0, array.length - 1).     collectionLessAnItem.remove(toRemoveIndex).     return collectionLessAnItem.toArray(new IndexMetaData[0]). }
