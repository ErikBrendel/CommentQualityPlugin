commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;3;;protected String[] getCurrentTypes() {     return currentTypes. }
false;protected,abstract;0;1;;protected abstract AF createTestAggregatorFactory().
true;public;0;21;/**  * Setup for the whole base test class.  */ ;/**  * Setup for the whole base test class.  */ @Override public void setUp() throws Exception {     super.setUp().     Settings settings = Settings.builder().put("node.name", AbstractQueryTestCase.class.toString()).put(Environment.PATH_HOME_SETTING.getKey(), createTempDir()).build().     IndicesModule indicesModule = new IndicesModule(Collections.emptyList()).     SearchModule searchModule = new SearchModule(settings, false, emptyList()).     List<NamedWriteableRegistry.Entry> entries = new ArrayList<>().     entries.addAll(indicesModule.getNamedWriteables()).     entries.addAll(searchModule.getNamedWriteables()).     namedWriteableRegistry = new NamedWriteableRegistry(entries).     xContentRegistry = new NamedXContentRegistry(searchModule.getNamedXContents()).     // create some random type with some default field, those types will stick around for all of the subclasses     currentTypes = new String[randomIntBetween(0, 5)].     for (int i = 0. i < currentTypes.length. i++) {         String type = randomAlphaOfLengthBetween(1, 10).         currentTypes[i] = type.     } }
true;public;0;19;/**  * Generic test that creates new AggregatorFactory from the test  * AggregatorFactory and checks both for equality and asserts equality on  * the two queries.  */ ;/**  * Generic test that creates new AggregatorFactory from the test  * AggregatorFactory and checks both for equality and asserts equality on  * the two queries.  */ public void testFromXContent() throws IOException {     AF testAgg = createTestAggregatorFactory().     AggregatorFactories.Builder factoriesBuilder = AggregatorFactories.builder().skipResolveOrder().addPipelineAggregator(testAgg).     logger.info("Content string: {}", factoriesBuilder).     XContentBuilder builder = XContentFactory.contentBuilder(randomFrom(XContentType.values())).     if (randomBoolean()) {         builder.prettyPrint().     }     factoriesBuilder.toXContent(builder, ToXContent.EMPTY_PARAMS).     XContentBuilder shuffled = shuffleXContent(builder).     try (XContentParser parser = createParser(shuffled)) {         String contentString = factoriesBuilder.toString().         logger.info("Content string: {}", contentString).         PipelineAggregationBuilder newAgg = parse(parser).         assertNotSame(newAgg, testAgg).         assertEquals(testAgg, newAgg).         assertEquals(testAgg.hashCode(), newAgg.hashCode()).     } }
false;protected;1;10;;protected PipelineAggregationBuilder parse(XContentParser parser) throws IOException {     assertSame(XContentParser.Token.START_OBJECT, parser.nextToken()).     AggregatorFactories.Builder parsed = AggregatorFactories.parseAggregators(parser).     assertThat(parsed.getAggregatorFactories(), hasSize(0)).     assertThat(parsed.getPipelineAggregatorFactories(), hasSize(1)).     PipelineAggregationBuilder newAgg = parsed.getPipelineAggregatorFactories().iterator().next().     assertNull(parser.nextToken()).     assertNotNull(newAgg).     return newAgg. }
true;public;0;12;/**  * Test serialization and deserialization of the test AggregatorFactory.  */ ;/**  * Test serialization and deserialization of the test AggregatorFactory.  */ public void testSerialization() throws IOException {     AF testAgg = createTestAggregatorFactory().     try (BytesStreamOutput output = new BytesStreamOutput()) {         output.writeNamedWriteable(testAgg).         try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry)) {             PipelineAggregationBuilder deserializedQuery = in.readNamedWriteable(PipelineAggregationBuilder.class).             assertEquals(deserializedQuery, testAgg).             assertEquals(deserializedQuery.hashCode(), testAgg.hashCode()).             assertNotSame(deserializedQuery, testAgg).         }     } }
false;public;0;5;;public void testEqualsAndHashcode() throws IOException {     // TODO we only change name and boost, we should extend by any sub-test supplying a "mutate" method that randomly changes one     // aspect of the object under test     checkEqualsAndHashCode(createTestAggregatorFactory(), this::copyAggregation). }
true;private;1;10;// argument ;// we use the streaming infra to create a copy of the query provided as // argument private AF copyAggregation(AF agg) throws IOException {     try (BytesStreamOutput output = new BytesStreamOutput()) {         output.writeNamedWriteable(agg).         try (StreamInput in = new NamedWriteableAwareStreamInput(output.bytes().streamInput(), namedWriteableRegistry)) {             @SuppressWarnings("unchecked")             AF secondAgg = (AF) in.readNamedWriteable(PipelineAggregationBuilder.class).             return secondAgg.         }     } }
false;protected;0;17;;protected String[] getRandomTypes() {     String[] types.     if (currentTypes.length > 0 && randomBoolean()) {         int numberOfQueryTypes = randomIntBetween(1, currentTypes.length).         types = new String[numberOfQueryTypes].         for (int i = 0. i < numberOfQueryTypes. i++) {             types[i] = randomFrom(currentTypes).         }     } else {         if (randomBoolean()) {             types = new String[] { MetaData.ALL }.         } else {             types = new String[0].         }     }     return types. }
false;public;0;12;;public String randomNumericField() {     int randomInt = randomInt(3).     switch(randomInt) {         case 0:             return DATE_FIELD_NAME.         case 1:             return DOUBLE_FIELD_NAME.         case 2:         default:             return INT_FIELD_NAME.     } }
false;protected;0;4;;@Override protected NamedXContentRegistry xContentRegistry() {     return xContentRegistry. }
