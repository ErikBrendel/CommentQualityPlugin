commented;modifiers;parameterAmount;loc;comment;code
false;public;0;33;;@Override public void setUp() throws Exception {     super.setUp().     format = randomNumericDocValueFormat().     Function<DateTime, DateTime> interval = randomFrom(dateTime -> dateTime.plusSeconds(1), dateTime -> dateTime.plusMinutes(1), dateTime -> dateTime.plusHours(1), dateTime -> dateTime.plusDays(1), dateTime -> dateTime.plusMonths(1), dateTime -> dateTime.plusYears(1)).     final int numRanges = randomNumberOfBuckets().     final List<Tuple<Double, Double>> listOfRanges = new ArrayList<>(numRanges).     DateTime date = new DateTime(DateTimeZone.UTC).     double start = date.getMillis().     double end = 0.     for (int i = 0. i < numRanges. i++) {         double from = date.getMillis().         date = interval.apply(date).         double to = date.getMillis().         if (to > end) {             end = to.         }         if (randomBoolean()) {             listOfRanges.add(Tuple.tuple(from, to)).         } else {             // Add some overlapping range             listOfRanges.add(Tuple.tuple(start, randomDoubleBetween(start, end, false))).         }     }     Collections.shuffle(listOfRanges, random()).     dateRanges = Collections.unmodifiableList(listOfRanges). }
false;protected;5;16;;@Override protected InternalDateRange createTestInstance(String name, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData, InternalAggregations aggregations, boolean keyed) {     final List<InternalDateRange.Bucket> buckets = new ArrayList<>().     for (int i = 0. i < dateRanges.size(). ++i) {         Tuple<Double, Double> range = dateRanges.get(i).         int docCount = randomIntBetween(0, 1000).         double from = range.v1().         double to = range.v2().         buckets.add(new InternalDateRange.Bucket("range_" + i, from, to, docCount, aggregations, keyed, format)).     }     return new InternalDateRange(name, buckets, format, keyed, pipelineAggregators, metaData). }
false;protected;0;4;;@Override protected Writeable.Reader<InternalDateRange> instanceReader() {     return InternalDateRange::new. }
false;protected;0;4;;@Override protected Class<? extends ParsedMultiBucketAggregation> implementationClass() {     return ParsedDateRange.class. }
false;protected;0;4;;@Override protected Class<? extends InternalMultiBucketAggregation.InternalBucket> internalRangeBucketClass() {     return InternalDateRange.Bucket.class. }
false;protected;0;4;;@Override protected Class<? extends ParsedMultiBucketAggregation.ParsedBucket> parsedRangeBucketClass() {     return ParsedDateRange.ParsedBucket.class. }
false;protected;1;34;;@Override protected InternalDateRange mutateInstance(InternalDateRange instance) {     String name = instance.getName().     DocValueFormat format = instance.format.     boolean keyed = instance.keyed.     List<InternalDateRange.Bucket> buckets = instance.getBuckets().     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 3)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             keyed = keyed == false.             break.         case 2:             buckets = new ArrayList<>(buckets).             double from = randomDouble().             buckets.add(new InternalDateRange.Bucket("range_a", from, from + randomDouble(), randomNonNegativeLong(), InternalAggregations.EMPTY, false, format)).             break.         case 3:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new InternalDateRange(name, buckets, format, keyed, pipelineAggregators, metaData). }
