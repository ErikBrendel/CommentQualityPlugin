commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void injectRandomFailures() {     enableRandomFailures = randomBoolean(). }
false;protected;0;3;;protected void disableRandomFailures() {     enableRandomFailures = false. }
false;protected;0;5;;protected void failRandomly() {     if (enableRandomFailures && rarely()) {         throw new RuntimeException("dummy test failure").     } }
true;public;2;95;/**  * Checks if cluster state matches internal state of IndicesClusterStateService instance  *  * @param state cluster state used for matching  */ ;/**  * Checks if cluster state matches internal state of IndicesClusterStateService instance  *  * @param state cluster state used for matching  */ public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService) {     MockIndicesService indicesService = (MockIndicesService) indicesClusterStateService.indicesService.     ConcurrentMap<ShardId, ShardRouting> failedShardsCache = indicesClusterStateService.failedShardsCache.     RoutingNode localRoutingNode = state.getRoutingNodes().node(state.getNodes().getLocalNodeId()).     if (localRoutingNode != null) {         if (enableRandomFailures == false) {             // active shards can be failed if state persistence was disabled in an earlier CS update             if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {                 fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values()).             }         }         // check that all shards in local routing nodes have been allocated         for (ShardRouting shardRouting : localRoutingNode) {             Index index = shardRouting.index().             IndexMetaData indexMetaData = state.metaData().getIndexSafe(index).             MockIndexShard shard = indicesService.getShardOrNull(shardRouting.shardId()).             ShardRouting failedShard = failedShardsCache.get(shardRouting.shardId()).             if (state.blocks().disableStatePersistence()) {                 if (shard != null) {                     fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence").                 }             } else {                 if (failedShard != null && failedShard.isSameAllocation(shardRouting) == false) {                     fail("Shard cache has not been properly cleaned for " + failedShard).                 }                 if (shard == null && failedShard == null) {                     // shard must either be there or there must be a failure                     fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache").                 }                 if (enableRandomFailures == false) {                     if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {                         // initializing a shard should succeed when enableRandomFailures is disabled                         fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard).                     }                 }                 if (shard != null) {                     AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index).                     assertTrue("Index " + index + " expected but missing in indicesService", indexService != null).                     // index metadata has been updated                     assertThat(indexService.getIndexSettings().getIndexMetaData(), equalTo(indexMetaData)).                     // shard has been created                     if (enableRandomFailures == false || failedShard == null) {                         assertTrue("Shard with id " + shardRouting + " expected but missing in indexService", shard != null).                         // shard has latest shard routing                         assertThat(shard.routingEntry(), equalTo(shardRouting)).                     }                     if (shard.routingEntry().primary() && shard.routingEntry().active()) {                         IndexShardRoutingTable shardRoutingTable = state.routingTable().shardRoutingTable(shard.shardId()).                         Set<String> inSyncIds = state.metaData().index(shard.shardId().getIndex()).inSyncAllocationIds(shard.shardId().id()).                         assertThat(shard.routingEntry() + " isn't updated with in-sync aIDs", shard.inSyncAllocationIds, equalTo(inSyncIds)).                         assertThat(shard.routingEntry() + " isn't updated with routing table", shard.routingTable, equalTo(shardRoutingTable)).                     }                 }             }         }     }     // all other shards / indices have been cleaned up     for (AllocatedIndex<? extends Shard> indexService : indicesService) {         if (state.blocks().disableStatePersistence()) {             fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence").         }         assertTrue(state.metaData().getIndexSafe(indexService.index()) != null).         boolean shardsFound = false.         for (Shard shard : indexService) {             shardsFound = true.             ShardRouting persistedShardRouting = shard.routingEntry().             ShardRouting shardRouting = localRoutingNode.getByShardId(persistedShardRouting.shardId()).             if (shardRouting == null) {                 fail("Shard with id " + persistedShardRouting + " locally exists but missing in routing table").             }             if (shardRouting.equals(persistedShardRouting) == false) {                 fail("Local shard " + persistedShardRouting + " has stale routing" + shardRouting).             }         }         if (shardsFound == false) {             // check if we have shards of that index in failedShardsCache             // if yes, we might not have cleaned the index as failedShardsCache can be populated by another thread             assertFalse(failedShardsCache.keySet().stream().noneMatch(shardId -> shardId.getIndex().equals(indexService.index()))).         }     } }
false;public,synchronized;2;8;;@Override public synchronized MockIndexService createIndex(IndexMetaData indexMetaData, List<IndexEventListener> buildInIndexListener) throws IOException {     MockIndexService indexService = new MockIndexService(new IndexSettings(indexMetaData, Settings.EMPTY)).     indices = newMapBuilder(indices).put(indexMetaData.getIndexUUID(), indexService).immutableMap().     return indexService. }
false;public;2;4;;@Override public IndexMetaData verifyIndexIsDeleted(Index index, ClusterState state) {     return null. }
false;public;3;4;;@Override public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) { }
false;public,synchronized;3;8;;@Override public synchronized void removeIndex(Index index, IndexRemovalReason reason, String extraInfo) {     if (hasIndex(index)) {         Map<String, MockIndexService> newIndices = new HashMap<>(indices).         newIndices.remove(index.getUUID()).         indices = unmodifiableMap(newIndices).     } }
false;public;1;5;;@Override @Nullable public MockIndexService indexService(Index index) {     return indices.get(index.getUUID()). }
false;public;8;16;;@Override public MockIndexShard createShard(final ShardRouting shardRouting, final RecoveryState recoveryState, final PeerRecoveryTargetService recoveryTargetService, final PeerRecoveryTargetService.RecoveryListener recoveryListener, final RepositoriesService repositoriesService, final Consumer<IndexShard.ShardFailure> onShardFailure, final Consumer<ShardId> globalCheckpointSyncer, final RetentionLeaseSyncer retentionLeaseSyncer) throws IOException {     failRandomly().     MockIndexService indexService = indexService(recoveryState.getShardId().getIndex()).     MockIndexShard indexShard = indexService.createShard(shardRouting).     indexShard.recoveryState = recoveryState.     return indexShard. }
false;public;3;5;;@Override public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeValue) throws IOException, InterruptedException { }
false;private;1;3;;private boolean hasIndex(Index index) {     return indices.containsKey(index.getUUID()). }
false;public;0;4;;@Override public Iterator<MockIndexService> iterator() {     return indices.values().iterator(). }
false;public;0;4;;@Override public IndexSettings getIndexSettings() {     return indexSettings. }
false;public;2;5;;@Override public boolean updateMapping(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) throws IOException {     failRandomly().     return false. }
false;public;2;7;;@Override public void updateMetaData(final IndexMetaData currentIndexMetaData, final IndexMetaData newIndexMetaData) {     indexSettings.updateIndexMetaData(newIndexMetaData).     for (MockIndexShard shard : shards.values()) {         shard.updateTerm(newIndexMetaData.primaryTerm(shard.shardId().id())).     } }
false;public;1;4;;@Override public MockIndexShard getShardOrNull(int shardId) {     return shards.get(shardId). }
false;public,synchronized;1;6;;public synchronized MockIndexShard createShard(ShardRouting routing) throws IOException {     failRandomly().     MockIndexShard shard = new MockIndexShard(routing, indexSettings.getIndexMetaData().primaryTerm(routing.shardId().id())).     shards = newMapBuilder(shards).put(routing.id(), shard).immutableMap().     return shard. }
false;public,synchronized;2;10;;@Override public synchronized void removeShard(int shardId, String reason) {     if (shards.containsKey(shardId) == false) {         return.     }     HashMap<Integer, MockIndexShard> newShards = new HashMap<>(shards).     MockIndexShard indexShard = newShards.remove(shardId).     assert indexShard != null.     shards = unmodifiableMap(newShards). }
false;public;0;4;;@Override public Iterator<MockIndexShard> iterator() {     return shards.values().iterator(). }
false;public;0;4;;@Override public Index index() {     return indexSettings.getIndex(). }
false;public;0;4;;@Override public ShardId shardId() {     return shardRouting.shardId(). }
false;public;0;4;;@Override public RecoveryState recoveryState() {     return recoveryState. }
false;public;7;33;;@Override public void updateShardState(ShardRouting shardRouting, long newPrimaryTerm, BiConsumer<IndexShard, ActionListener<ResyncTask>> primaryReplicaSyncer, long applyingClusterStateVersion, Set<String> inSyncAllocationIds, IndexShardRoutingTable routingTable, Set<String> pre60AllocationIds) throws IOException {     failRandomly().     assertThat(this.shardId(), equalTo(shardRouting.shardId())).     assertTrue("current: " + this.shardRouting + ", got: " + shardRouting, this.shardRouting.isSameAllocation(shardRouting)).     if (this.shardRouting.active()) {         assertTrue("an active shard must stay active, current: " + this.shardRouting + ", got: " + shardRouting, shardRouting.active()).     }     if (this.shardRouting.primary()) {         assertTrue("a primary shard can't be demoted", shardRouting.primary()).         if (this.shardRouting.initializing()) {             assertEquals("primary term can not be updated on an initializing primary shard: " + shardRouting, term, newPrimaryTerm).         }     } else if (shardRouting.primary()) {         // note: it's ok for a replica in post recovery to be started and promoted at once         // this can happen when the primary failed after we sent the start shard message         assertTrue("a replica can only be promoted when active. current: " + this.shardRouting + " new: " + shardRouting, shardRouting.active()).     }     this.shardRouting = shardRouting.     if (shardRouting.primary()) {         term = newPrimaryTerm.         this.inSyncAllocationIds = inSyncAllocationIds.         this.routingTable = routingTable.     } }
false;public;0;4;;@Override public ShardRouting routingEntry() {     return shardRouting. }
false;public;0;4;;@Override public IndexShardState state() {     return null. }
false;public;0;3;;public long term() {     return term. }
false;public;1;7;;public void updateTerm(long newTerm) {     assertThat("term can only be incremented: " + shardRouting, newTerm, greaterThanOrEqualTo(term)).     if (shardRouting.primary() && shardRouting.active()) {         assertThat("term can not be changed on an active primary shard: " + shardRouting, newTerm, equalTo(term)).     }     this.term = newTerm. }
