# id;timestamp;commentText;codeText;commentWords;codeWords
AbstractIndicesClusterStateServiceTestCase -> public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService);1524684173;Checks if cluster state matches internal state of IndicesClusterStateService instance__@param state cluster state used for matching;public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService) {_        MockIndicesService indicesService = (MockIndicesService) indicesClusterStateService.indicesService__        ConcurrentMap<ShardId, ShardRouting> failedShardsCache = indicesClusterStateService.failedShardsCache__        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.getNodes().getLocalNodeId())__        if (localRoutingNode != null) {_            if (enableRandomFailures == false) {_                _                _                if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {_                    fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values())__                }_            }_            _            for (ShardRouting shardRouting : localRoutingNode) {_                Index index = shardRouting.index()__                IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)___                MockIndexShard shard = indicesService.getShardOrNull(shardRouting.shardId())__                ShardRouting failedShard = failedShardsCache.get(shardRouting.shardId())___                if (state.blocks().disableStatePersistence()) {_                    if (shard != null) {_                        fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence")__                    }_                } else {_                    if (failedShard != null && failedShard.isSameAllocation(shardRouting) == false) {_                        fail("Shard cache has not been properly cleaned for " + failedShard)__                    }_                    if (shard == null && failedShard == null) {_                        _                        fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache")__                    }_                    if (enableRandomFailures == false) {_                        if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {_                            _                            fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard)__                        }_                    }__                    if (shard != null) {_                        AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__                        assertTrue("Index " + index + " expected but missing in indicesService", indexService != null)___                        _                        assertThat(indexService.getIndexSettings().getIndexMetaData(), equalTo(indexMetaData))__                        _                        if (enableRandomFailures == false || failedShard == null) {_                            assertTrue("Shard with id " + shardRouting + " expected but missing in indexService", shard != null)__                            _                            assertThat(shard.routingEntry(), equalTo(shardRouting))__                        }__                        if (shard.routingEntry().primary() && shard.routingEntry().active()) {_                            IndexShardRoutingTable shardRoutingTable = state.routingTable().shardRoutingTable(shard.shardId())__                            Set<String> inSyncIds = state.metaData().index(shard.shardId().getIndex())_                                .inSyncAllocationIds(shard.shardId().id())__                            assertThat(shard.routingEntry() + " isn't updated with in-sync aIDs", shard.inSyncAllocationIds,_                                equalTo(inSyncIds))__                            assertThat(shard.routingEntry() + " isn't updated with routing table", shard.routingTable,_                                equalTo(shardRoutingTable))__                        }_                    }_                }_            }_        }__        _        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            if (state.blocks().disableStatePersistence()) {_                fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence")__            }__            assertTrue(state.metaData().getIndexSafe(indexService.index()) != null)___            boolean shardsFound = false__            for (Shard shard : indexService) {_                shardsFound = true__                ShardRouting persistedShardRouting = shard.routingEntry()__                ShardRouting shardRouting = localRoutingNode.getByShardId(persistedShardRouting.shardId())__                if (shardRouting == null) {_                    fail("Shard with id " + persistedShardRouting + " locally exists but missing in routing table")__                }_                if (shardRouting.equals(persistedShardRouting) == false) {_                    fail("Local shard " + persistedShardRouting + " has stale routing" + shardRouting)__                }_            }__            if (shardsFound == false) {_                _                _                assertFalse(failedShardsCache.keySet().stream().noneMatch(shardId -> shardId.getIndex().equals(indexService.index())))__            }__        }_    };checks,if,cluster,state,matches,internal,state,of,indices,cluster,state,service,instance,param,state,cluster,state,used,for,matching;public,void,assert,cluster,state,matches,node,state,cluster,state,state,indices,cluster,state,service,indices,cluster,state,service,mock,indices,service,indices,service,mock,indices,service,indices,cluster,state,service,indices,service,concurrent,map,shard,id,shard,routing,failed,shards,cache,indices,cluster,state,service,failed,shards,cache,routing,node,local,routing,node,state,get,routing,nodes,node,state,get,nodes,get,local,node,id,if,local,routing,node,null,if,enable,random,failures,false,if,failed,shards,cache,values,stream,any,match,shard,routing,initializing,fail,failed,shard,cache,should,not,contain,initializing,shard,routing,failed,shards,cache,values,for,shard,routing,shard,routing,local,routing,node,index,index,shard,routing,index,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,mock,index,shard,shard,indices,service,get,shard,or,null,shard,routing,shard,id,shard,routing,failed,shard,failed,shards,cache,get,shard,routing,shard,id,if,state,blocks,disable,state,persistence,if,shard,null,fail,shard,with,id,shard,routing,should,be,removed,from,indices,service,due,to,disabled,state,persistence,else,if,failed,shard,null,failed,shard,is,same,allocation,shard,routing,false,fail,shard,cache,has,not,been,properly,cleaned,for,failed,shard,if,shard,null,failed,shard,null,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,and,failed,shards,cache,if,enable,random,failures,false,if,shard,null,shard,routing,initializing,failed,shard,shard,routing,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,failed,shard,if,shard,null,allocated,index,extends,shard,index,service,indices,service,index,service,index,assert,true,index,index,expected,but,missing,in,indices,service,index,service,null,assert,that,index,service,get,index,settings,get,index,meta,data,equal,to,index,meta,data,if,enable,random,failures,false,failed,shard,null,assert,true,shard,with,id,shard,routing,expected,but,missing,in,index,service,shard,null,assert,that,shard,routing,entry,equal,to,shard,routing,if,shard,routing,entry,primary,shard,routing,entry,active,index,shard,routing,table,shard,routing,table,state,routing,table,shard,routing,table,shard,shard,id,set,string,in,sync,ids,state,meta,data,index,shard,shard,id,get,index,in,sync,allocation,ids,shard,shard,id,id,assert,that,shard,routing,entry,isn,t,updated,with,in,sync,a,ids,shard,in,sync,allocation,ids,equal,to,in,sync,ids,assert,that,shard,routing,entry,isn,t,updated,with,routing,table,shard,routing,table,equal,to,shard,routing,table,for,allocated,index,extends,shard,index,service,indices,service,if,state,blocks,disable,state,persistence,fail,index,service,index,service,index,should,be,removed,from,indices,service,due,to,disabled,state,persistence,assert,true,state,meta,data,get,index,safe,index,service,index,null,boolean,shards,found,false,for,shard,shard,index,service,shards,found,true,shard,routing,persisted,shard,routing,shard,routing,entry,shard,routing,shard,routing,local,routing,node,get,by,shard,id,persisted,shard,routing,shard,id,if,shard,routing,null,fail,shard,with,id,persisted,shard,routing,locally,exists,but,missing,in,routing,table,if,shard,routing,equals,persisted,shard,routing,false,fail,local,shard,persisted,shard,routing,has,stale,routing,shard,routing,if,shards,found,false,assert,false,failed,shards,cache,key,set,stream,none,match,shard,id,shard,id,get,index,equals,index,service,index
AbstractIndicesClusterStateServiceTestCase -> public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService);1531910483;Checks if cluster state matches internal state of IndicesClusterStateService instance__@param state cluster state used for matching;public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService) {_        MockIndicesService indicesService = (MockIndicesService) indicesClusterStateService.indicesService__        ConcurrentMap<ShardId, ShardRouting> failedShardsCache = indicesClusterStateService.failedShardsCache__        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.getNodes().getLocalNodeId())__        if (localRoutingNode != null) {_            if (enableRandomFailures == false) {_                _                _                if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {_                    fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values())__                }_            }_            _            for (ShardRouting shardRouting : localRoutingNode) {_                Index index = shardRouting.index()__                IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)___                MockIndexShard shard = indicesService.getShardOrNull(shardRouting.shardId())__                ShardRouting failedShard = failedShardsCache.get(shardRouting.shardId())___                if (state.blocks().disableStatePersistence()) {_                    if (shard != null) {_                        fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence")__                    }_                } else {_                    if (failedShard != null && failedShard.isSameAllocation(shardRouting) == false) {_                        fail("Shard cache has not been properly cleaned for " + failedShard)__                    }_                    if (shard == null && failedShard == null) {_                        _                        fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache")__                    }_                    if (enableRandomFailures == false) {_                        if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {_                            _                            fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard)__                        }_                    }__                    if (shard != null) {_                        AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__                        assertTrue("Index " + index + " expected but missing in indicesService", indexService != null)___                        _                        assertThat(indexService.getIndexSettings().getIndexMetaData(), equalTo(indexMetaData))__                        _                        if (enableRandomFailures == false || failedShard == null) {_                            assertTrue("Shard with id " + shardRouting + " expected but missing in indexService", shard != null)__                            _                            assertThat(shard.routingEntry(), equalTo(shardRouting))__                        }__                        if (shard.routingEntry().primary() && shard.routingEntry().active()) {_                            IndexShardRoutingTable shardRoutingTable = state.routingTable().shardRoutingTable(shard.shardId())__                            Set<String> inSyncIds = state.metaData().index(shard.shardId().getIndex())_                                .inSyncAllocationIds(shard.shardId().id())__                            assertThat(shard.routingEntry() + " isn't updated with in-sync aIDs", shard.inSyncAllocationIds,_                                equalTo(inSyncIds))__                            assertThat(shard.routingEntry() + " isn't updated with routing table", shard.routingTable,_                                equalTo(shardRoutingTable))__                        }_                    }_                }_            }_        }__        _        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            if (state.blocks().disableStatePersistence()) {_                fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence")__            }__            assertTrue(state.metaData().getIndexSafe(indexService.index()) != null)___            boolean shardsFound = false__            for (Shard shard : indexService) {_                shardsFound = true__                ShardRouting persistedShardRouting = shard.routingEntry()__                ShardRouting shardRouting = localRoutingNode.getByShardId(persistedShardRouting.shardId())__                if (shardRouting == null) {_                    fail("Shard with id " + persistedShardRouting + " locally exists but missing in routing table")__                }_                if (shardRouting.equals(persistedShardRouting) == false) {_                    fail("Local shard " + persistedShardRouting + " has stale routing" + shardRouting)__                }_            }__            if (shardsFound == false) {_                _                _                assertFalse(failedShardsCache.keySet().stream().noneMatch(shardId -> shardId.getIndex().equals(indexService.index())))__            }__        }_    };checks,if,cluster,state,matches,internal,state,of,indices,cluster,state,service,instance,param,state,cluster,state,used,for,matching;public,void,assert,cluster,state,matches,node,state,cluster,state,state,indices,cluster,state,service,indices,cluster,state,service,mock,indices,service,indices,service,mock,indices,service,indices,cluster,state,service,indices,service,concurrent,map,shard,id,shard,routing,failed,shards,cache,indices,cluster,state,service,failed,shards,cache,routing,node,local,routing,node,state,get,routing,nodes,node,state,get,nodes,get,local,node,id,if,local,routing,node,null,if,enable,random,failures,false,if,failed,shards,cache,values,stream,any,match,shard,routing,initializing,fail,failed,shard,cache,should,not,contain,initializing,shard,routing,failed,shards,cache,values,for,shard,routing,shard,routing,local,routing,node,index,index,shard,routing,index,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,mock,index,shard,shard,indices,service,get,shard,or,null,shard,routing,shard,id,shard,routing,failed,shard,failed,shards,cache,get,shard,routing,shard,id,if,state,blocks,disable,state,persistence,if,shard,null,fail,shard,with,id,shard,routing,should,be,removed,from,indices,service,due,to,disabled,state,persistence,else,if,failed,shard,null,failed,shard,is,same,allocation,shard,routing,false,fail,shard,cache,has,not,been,properly,cleaned,for,failed,shard,if,shard,null,failed,shard,null,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,and,failed,shards,cache,if,enable,random,failures,false,if,shard,null,shard,routing,initializing,failed,shard,shard,routing,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,failed,shard,if,shard,null,allocated,index,extends,shard,index,service,indices,service,index,service,index,assert,true,index,index,expected,but,missing,in,indices,service,index,service,null,assert,that,index,service,get,index,settings,get,index,meta,data,equal,to,index,meta,data,if,enable,random,failures,false,failed,shard,null,assert,true,shard,with,id,shard,routing,expected,but,missing,in,index,service,shard,null,assert,that,shard,routing,entry,equal,to,shard,routing,if,shard,routing,entry,primary,shard,routing,entry,active,index,shard,routing,table,shard,routing,table,state,routing,table,shard,routing,table,shard,shard,id,set,string,in,sync,ids,state,meta,data,index,shard,shard,id,get,index,in,sync,allocation,ids,shard,shard,id,id,assert,that,shard,routing,entry,isn,t,updated,with,in,sync,a,ids,shard,in,sync,allocation,ids,equal,to,in,sync,ids,assert,that,shard,routing,entry,isn,t,updated,with,routing,table,shard,routing,table,equal,to,shard,routing,table,for,allocated,index,extends,shard,index,service,indices,service,if,state,blocks,disable,state,persistence,fail,index,service,index,service,index,should,be,removed,from,indices,service,due,to,disabled,state,persistence,assert,true,state,meta,data,get,index,safe,index,service,index,null,boolean,shards,found,false,for,shard,shard,index,service,shards,found,true,shard,routing,persisted,shard,routing,shard,routing,entry,shard,routing,shard,routing,local,routing,node,get,by,shard,id,persisted,shard,routing,shard,id,if,shard,routing,null,fail,shard,with,id,persisted,shard,routing,locally,exists,but,missing,in,routing,table,if,shard,routing,equals,persisted,shard,routing,false,fail,local,shard,persisted,shard,routing,has,stale,routing,shard,routing,if,shards,found,false,assert,false,failed,shards,cache,key,set,stream,none,match,shard,id,shard,id,get,index,equals,index,service,index
AbstractIndicesClusterStateServiceTestCase -> public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService);1533063033;Checks if cluster state matches internal state of IndicesClusterStateService instance__@param state cluster state used for matching;public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService) {_        MockIndicesService indicesService = (MockIndicesService) indicesClusterStateService.indicesService__        ConcurrentMap<ShardId, ShardRouting> failedShardsCache = indicesClusterStateService.failedShardsCache__        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.getNodes().getLocalNodeId())__        if (localRoutingNode != null) {_            if (enableRandomFailures == false) {_                _                _                if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {_                    fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values())__                }_            }_            _            for (ShardRouting shardRouting : localRoutingNode) {_                Index index = shardRouting.index()__                IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)___                MockIndexShard shard = indicesService.getShardOrNull(shardRouting.shardId())__                ShardRouting failedShard = failedShardsCache.get(shardRouting.shardId())___                if (state.blocks().disableStatePersistence()) {_                    if (shard != null) {_                        fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence")__                    }_                } else {_                    if (failedShard != null && failedShard.isSameAllocation(shardRouting) == false) {_                        fail("Shard cache has not been properly cleaned for " + failedShard)__                    }_                    if (shard == null && failedShard == null) {_                        _                        fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache")__                    }_                    if (enableRandomFailures == false) {_                        if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {_                            _                            fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard)__                        }_                    }__                    if (shard != null) {_                        AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__                        assertTrue("Index " + index + " expected but missing in indicesService", indexService != null)___                        _                        assertThat(indexService.getIndexSettings().getIndexMetaData(), equalTo(indexMetaData))__                        _                        if (enableRandomFailures == false || failedShard == null) {_                            assertTrue("Shard with id " + shardRouting + " expected but missing in indexService", shard != null)__                            _                            assertThat(shard.routingEntry(), equalTo(shardRouting))__                        }__                        if (shard.routingEntry().primary() && shard.routingEntry().active()) {_                            IndexShardRoutingTable shardRoutingTable = state.routingTable().shardRoutingTable(shard.shardId())__                            Set<String> inSyncIds = state.metaData().index(shard.shardId().getIndex())_                                .inSyncAllocationIds(shard.shardId().id())__                            assertThat(shard.routingEntry() + " isn't updated with in-sync aIDs", shard.inSyncAllocationIds,_                                equalTo(inSyncIds))__                            assertThat(shard.routingEntry() + " isn't updated with routing table", shard.routingTable,_                                equalTo(shardRoutingTable))__                        }_                    }_                }_            }_        }__        _        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            if (state.blocks().disableStatePersistence()) {_                fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence")__            }__            assertTrue(state.metaData().getIndexSafe(indexService.index()) != null)___            boolean shardsFound = false__            for (Shard shard : indexService) {_                shardsFound = true__                ShardRouting persistedShardRouting = shard.routingEntry()__                ShardRouting shardRouting = localRoutingNode.getByShardId(persistedShardRouting.shardId())__                if (shardRouting == null) {_                    fail("Shard with id " + persistedShardRouting + " locally exists but missing in routing table")__                }_                if (shardRouting.equals(persistedShardRouting) == false) {_                    fail("Local shard " + persistedShardRouting + " has stale routing" + shardRouting)__                }_            }__            if (shardsFound == false) {_                _                _                assertFalse(failedShardsCache.keySet().stream().noneMatch(shardId -> shardId.getIndex().equals(indexService.index())))__            }__        }_    };checks,if,cluster,state,matches,internal,state,of,indices,cluster,state,service,instance,param,state,cluster,state,used,for,matching;public,void,assert,cluster,state,matches,node,state,cluster,state,state,indices,cluster,state,service,indices,cluster,state,service,mock,indices,service,indices,service,mock,indices,service,indices,cluster,state,service,indices,service,concurrent,map,shard,id,shard,routing,failed,shards,cache,indices,cluster,state,service,failed,shards,cache,routing,node,local,routing,node,state,get,routing,nodes,node,state,get,nodes,get,local,node,id,if,local,routing,node,null,if,enable,random,failures,false,if,failed,shards,cache,values,stream,any,match,shard,routing,initializing,fail,failed,shard,cache,should,not,contain,initializing,shard,routing,failed,shards,cache,values,for,shard,routing,shard,routing,local,routing,node,index,index,shard,routing,index,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,mock,index,shard,shard,indices,service,get,shard,or,null,shard,routing,shard,id,shard,routing,failed,shard,failed,shards,cache,get,shard,routing,shard,id,if,state,blocks,disable,state,persistence,if,shard,null,fail,shard,with,id,shard,routing,should,be,removed,from,indices,service,due,to,disabled,state,persistence,else,if,failed,shard,null,failed,shard,is,same,allocation,shard,routing,false,fail,shard,cache,has,not,been,properly,cleaned,for,failed,shard,if,shard,null,failed,shard,null,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,and,failed,shards,cache,if,enable,random,failures,false,if,shard,null,shard,routing,initializing,failed,shard,shard,routing,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,failed,shard,if,shard,null,allocated,index,extends,shard,index,service,indices,service,index,service,index,assert,true,index,index,expected,but,missing,in,indices,service,index,service,null,assert,that,index,service,get,index,settings,get,index,meta,data,equal,to,index,meta,data,if,enable,random,failures,false,failed,shard,null,assert,true,shard,with,id,shard,routing,expected,but,missing,in,index,service,shard,null,assert,that,shard,routing,entry,equal,to,shard,routing,if,shard,routing,entry,primary,shard,routing,entry,active,index,shard,routing,table,shard,routing,table,state,routing,table,shard,routing,table,shard,shard,id,set,string,in,sync,ids,state,meta,data,index,shard,shard,id,get,index,in,sync,allocation,ids,shard,shard,id,id,assert,that,shard,routing,entry,isn,t,updated,with,in,sync,a,ids,shard,in,sync,allocation,ids,equal,to,in,sync,ids,assert,that,shard,routing,entry,isn,t,updated,with,routing,table,shard,routing,table,equal,to,shard,routing,table,for,allocated,index,extends,shard,index,service,indices,service,if,state,blocks,disable,state,persistence,fail,index,service,index,service,index,should,be,removed,from,indices,service,due,to,disabled,state,persistence,assert,true,state,meta,data,get,index,safe,index,service,index,null,boolean,shards,found,false,for,shard,shard,index,service,shards,found,true,shard,routing,persisted,shard,routing,shard,routing,entry,shard,routing,shard,routing,local,routing,node,get,by,shard,id,persisted,shard,routing,shard,id,if,shard,routing,null,fail,shard,with,id,persisted,shard,routing,locally,exists,but,missing,in,routing,table,if,shard,routing,equals,persisted,shard,routing,false,fail,local,shard,persisted,shard,routing,has,stale,routing,shard,routing,if,shards,found,false,assert,false,failed,shards,cache,key,set,stream,none,match,shard,id,shard,id,get,index,equals,index,service,index
AbstractIndicesClusterStateServiceTestCase -> public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService);1535405719;Checks if cluster state matches internal state of IndicesClusterStateService instance__@param state cluster state used for matching;public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService) {_        MockIndicesService indicesService = (MockIndicesService) indicesClusterStateService.indicesService__        ConcurrentMap<ShardId, ShardRouting> failedShardsCache = indicesClusterStateService.failedShardsCache__        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.getNodes().getLocalNodeId())__        if (localRoutingNode != null) {_            if (enableRandomFailures == false) {_                _                _                if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {_                    fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values())__                }_            }_            _            for (ShardRouting shardRouting : localRoutingNode) {_                Index index = shardRouting.index()__                IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)___                MockIndexShard shard = indicesService.getShardOrNull(shardRouting.shardId())__                ShardRouting failedShard = failedShardsCache.get(shardRouting.shardId())___                if (state.blocks().disableStatePersistence()) {_                    if (shard != null) {_                        fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence")__                    }_                } else {_                    if (failedShard != null && failedShard.isSameAllocation(shardRouting) == false) {_                        fail("Shard cache has not been properly cleaned for " + failedShard)__                    }_                    if (shard == null && failedShard == null) {_                        _                        fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache")__                    }_                    if (enableRandomFailures == false) {_                        if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {_                            _                            fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard)__                        }_                    }__                    if (shard != null) {_                        AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__                        assertTrue("Index " + index + " expected but missing in indicesService", indexService != null)___                        _                        assertThat(indexService.getIndexSettings().getIndexMetaData(), equalTo(indexMetaData))__                        _                        if (enableRandomFailures == false || failedShard == null) {_                            assertTrue("Shard with id " + shardRouting + " expected but missing in indexService", shard != null)__                            _                            assertThat(shard.routingEntry(), equalTo(shardRouting))__                        }__                        if (shard.routingEntry().primary() && shard.routingEntry().active()) {_                            IndexShardRoutingTable shardRoutingTable = state.routingTable().shardRoutingTable(shard.shardId())__                            Set<String> inSyncIds = state.metaData().index(shard.shardId().getIndex())_                                .inSyncAllocationIds(shard.shardId().id())__                            assertThat(shard.routingEntry() + " isn't updated with in-sync aIDs", shard.inSyncAllocationIds,_                                equalTo(inSyncIds))__                            assertThat(shard.routingEntry() + " isn't updated with routing table", shard.routingTable,_                                equalTo(shardRoutingTable))__                        }_                    }_                }_            }_        }__        _        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            if (state.blocks().disableStatePersistence()) {_                fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence")__            }__            assertTrue(state.metaData().getIndexSafe(indexService.index()) != null)___            boolean shardsFound = false__            for (Shard shard : indexService) {_                shardsFound = true__                ShardRouting persistedShardRouting = shard.routingEntry()__                ShardRouting shardRouting = localRoutingNode.getByShardId(persistedShardRouting.shardId())__                if (shardRouting == null) {_                    fail("Shard with id " + persistedShardRouting + " locally exists but missing in routing table")__                }_                if (shardRouting.equals(persistedShardRouting) == false) {_                    fail("Local shard " + persistedShardRouting + " has stale routing" + shardRouting)__                }_            }__            if (shardsFound == false) {_                _                _                assertFalse(failedShardsCache.keySet().stream().noneMatch(shardId -> shardId.getIndex().equals(indexService.index())))__            }__        }_    };checks,if,cluster,state,matches,internal,state,of,indices,cluster,state,service,instance,param,state,cluster,state,used,for,matching;public,void,assert,cluster,state,matches,node,state,cluster,state,state,indices,cluster,state,service,indices,cluster,state,service,mock,indices,service,indices,service,mock,indices,service,indices,cluster,state,service,indices,service,concurrent,map,shard,id,shard,routing,failed,shards,cache,indices,cluster,state,service,failed,shards,cache,routing,node,local,routing,node,state,get,routing,nodes,node,state,get,nodes,get,local,node,id,if,local,routing,node,null,if,enable,random,failures,false,if,failed,shards,cache,values,stream,any,match,shard,routing,initializing,fail,failed,shard,cache,should,not,contain,initializing,shard,routing,failed,shards,cache,values,for,shard,routing,shard,routing,local,routing,node,index,index,shard,routing,index,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,mock,index,shard,shard,indices,service,get,shard,or,null,shard,routing,shard,id,shard,routing,failed,shard,failed,shards,cache,get,shard,routing,shard,id,if,state,blocks,disable,state,persistence,if,shard,null,fail,shard,with,id,shard,routing,should,be,removed,from,indices,service,due,to,disabled,state,persistence,else,if,failed,shard,null,failed,shard,is,same,allocation,shard,routing,false,fail,shard,cache,has,not,been,properly,cleaned,for,failed,shard,if,shard,null,failed,shard,null,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,and,failed,shards,cache,if,enable,random,failures,false,if,shard,null,shard,routing,initializing,failed,shard,shard,routing,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,failed,shard,if,shard,null,allocated,index,extends,shard,index,service,indices,service,index,service,index,assert,true,index,index,expected,but,missing,in,indices,service,index,service,null,assert,that,index,service,get,index,settings,get,index,meta,data,equal,to,index,meta,data,if,enable,random,failures,false,failed,shard,null,assert,true,shard,with,id,shard,routing,expected,but,missing,in,index,service,shard,null,assert,that,shard,routing,entry,equal,to,shard,routing,if,shard,routing,entry,primary,shard,routing,entry,active,index,shard,routing,table,shard,routing,table,state,routing,table,shard,routing,table,shard,shard,id,set,string,in,sync,ids,state,meta,data,index,shard,shard,id,get,index,in,sync,allocation,ids,shard,shard,id,id,assert,that,shard,routing,entry,isn,t,updated,with,in,sync,a,ids,shard,in,sync,allocation,ids,equal,to,in,sync,ids,assert,that,shard,routing,entry,isn,t,updated,with,routing,table,shard,routing,table,equal,to,shard,routing,table,for,allocated,index,extends,shard,index,service,indices,service,if,state,blocks,disable,state,persistence,fail,index,service,index,service,index,should,be,removed,from,indices,service,due,to,disabled,state,persistence,assert,true,state,meta,data,get,index,safe,index,service,index,null,boolean,shards,found,false,for,shard,shard,index,service,shards,found,true,shard,routing,persisted,shard,routing,shard,routing,entry,shard,routing,shard,routing,local,routing,node,get,by,shard,id,persisted,shard,routing,shard,id,if,shard,routing,null,fail,shard,with,id,persisted,shard,routing,locally,exists,but,missing,in,routing,table,if,shard,routing,equals,persisted,shard,routing,false,fail,local,shard,persisted,shard,routing,has,stale,routing,shard,routing,if,shards,found,false,assert,false,failed,shards,cache,key,set,stream,none,match,shard,id,shard,id,get,index,equals,index,service,index
AbstractIndicesClusterStateServiceTestCase -> public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService);1538067637;Checks if cluster state matches internal state of IndicesClusterStateService instance__@param state cluster state used for matching;public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService) {_        MockIndicesService indicesService = (MockIndicesService) indicesClusterStateService.indicesService__        ConcurrentMap<ShardId, ShardRouting> failedShardsCache = indicesClusterStateService.failedShardsCache__        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.getNodes().getLocalNodeId())__        if (localRoutingNode != null) {_            if (enableRandomFailures == false) {_                _                _                if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {_                    fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values())__                }_            }_            _            for (ShardRouting shardRouting : localRoutingNode) {_                Index index = shardRouting.index()__                IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)___                MockIndexShard shard = indicesService.getShardOrNull(shardRouting.shardId())__                ShardRouting failedShard = failedShardsCache.get(shardRouting.shardId())___                if (state.blocks().disableStatePersistence()) {_                    if (shard != null) {_                        fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence")__                    }_                } else {_                    if (failedShard != null && failedShard.isSameAllocation(shardRouting) == false) {_                        fail("Shard cache has not been properly cleaned for " + failedShard)__                    }_                    if (shard == null && failedShard == null) {_                        _                        fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache")__                    }_                    if (enableRandomFailures == false) {_                        if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {_                            _                            fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard)__                        }_                    }__                    if (shard != null) {_                        AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__                        assertTrue("Index " + index + " expected but missing in indicesService", indexService != null)___                        _                        assertThat(indexService.getIndexSettings().getIndexMetaData(), equalTo(indexMetaData))__                        _                        if (enableRandomFailures == false || failedShard == null) {_                            assertTrue("Shard with id " + shardRouting + " expected but missing in indexService", shard != null)__                            _                            assertThat(shard.routingEntry(), equalTo(shardRouting))__                        }__                        if (shard.routingEntry().primary() && shard.routingEntry().active()) {_                            IndexShardRoutingTable shardRoutingTable = state.routingTable().shardRoutingTable(shard.shardId())__                            Set<String> inSyncIds = state.metaData().index(shard.shardId().getIndex())_                                .inSyncAllocationIds(shard.shardId().id())__                            assertThat(shard.routingEntry() + " isn't updated with in-sync aIDs", shard.inSyncAllocationIds,_                                equalTo(inSyncIds))__                            assertThat(shard.routingEntry() + " isn't updated with routing table", shard.routingTable,_                                equalTo(shardRoutingTable))__                        }_                    }_                }_            }_        }__        _        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            if (state.blocks().disableStatePersistence()) {_                fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence")__            }__            assertTrue(state.metaData().getIndexSafe(indexService.index()) != null)___            boolean shardsFound = false__            for (Shard shard : indexService) {_                shardsFound = true__                ShardRouting persistedShardRouting = shard.routingEntry()__                ShardRouting shardRouting = localRoutingNode.getByShardId(persistedShardRouting.shardId())__                if (shardRouting == null) {_                    fail("Shard with id " + persistedShardRouting + " locally exists but missing in routing table")__                }_                if (shardRouting.equals(persistedShardRouting) == false) {_                    fail("Local shard " + persistedShardRouting + " has stale routing" + shardRouting)__                }_            }__            if (shardsFound == false) {_                _                _                assertFalse(failedShardsCache.keySet().stream().noneMatch(shardId -> shardId.getIndex().equals(indexService.index())))__            }__        }_    };checks,if,cluster,state,matches,internal,state,of,indices,cluster,state,service,instance,param,state,cluster,state,used,for,matching;public,void,assert,cluster,state,matches,node,state,cluster,state,state,indices,cluster,state,service,indices,cluster,state,service,mock,indices,service,indices,service,mock,indices,service,indices,cluster,state,service,indices,service,concurrent,map,shard,id,shard,routing,failed,shards,cache,indices,cluster,state,service,failed,shards,cache,routing,node,local,routing,node,state,get,routing,nodes,node,state,get,nodes,get,local,node,id,if,local,routing,node,null,if,enable,random,failures,false,if,failed,shards,cache,values,stream,any,match,shard,routing,initializing,fail,failed,shard,cache,should,not,contain,initializing,shard,routing,failed,shards,cache,values,for,shard,routing,shard,routing,local,routing,node,index,index,shard,routing,index,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,mock,index,shard,shard,indices,service,get,shard,or,null,shard,routing,shard,id,shard,routing,failed,shard,failed,shards,cache,get,shard,routing,shard,id,if,state,blocks,disable,state,persistence,if,shard,null,fail,shard,with,id,shard,routing,should,be,removed,from,indices,service,due,to,disabled,state,persistence,else,if,failed,shard,null,failed,shard,is,same,allocation,shard,routing,false,fail,shard,cache,has,not,been,properly,cleaned,for,failed,shard,if,shard,null,failed,shard,null,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,and,failed,shards,cache,if,enable,random,failures,false,if,shard,null,shard,routing,initializing,failed,shard,shard,routing,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,failed,shard,if,shard,null,allocated,index,extends,shard,index,service,indices,service,index,service,index,assert,true,index,index,expected,but,missing,in,indices,service,index,service,null,assert,that,index,service,get,index,settings,get,index,meta,data,equal,to,index,meta,data,if,enable,random,failures,false,failed,shard,null,assert,true,shard,with,id,shard,routing,expected,but,missing,in,index,service,shard,null,assert,that,shard,routing,entry,equal,to,shard,routing,if,shard,routing,entry,primary,shard,routing,entry,active,index,shard,routing,table,shard,routing,table,state,routing,table,shard,routing,table,shard,shard,id,set,string,in,sync,ids,state,meta,data,index,shard,shard,id,get,index,in,sync,allocation,ids,shard,shard,id,id,assert,that,shard,routing,entry,isn,t,updated,with,in,sync,a,ids,shard,in,sync,allocation,ids,equal,to,in,sync,ids,assert,that,shard,routing,entry,isn,t,updated,with,routing,table,shard,routing,table,equal,to,shard,routing,table,for,allocated,index,extends,shard,index,service,indices,service,if,state,blocks,disable,state,persistence,fail,index,service,index,service,index,should,be,removed,from,indices,service,due,to,disabled,state,persistence,assert,true,state,meta,data,get,index,safe,index,service,index,null,boolean,shards,found,false,for,shard,shard,index,service,shards,found,true,shard,routing,persisted,shard,routing,shard,routing,entry,shard,routing,shard,routing,local,routing,node,get,by,shard,id,persisted,shard,routing,shard,id,if,shard,routing,null,fail,shard,with,id,persisted,shard,routing,locally,exists,but,missing,in,routing,table,if,shard,routing,equals,persisted,shard,routing,false,fail,local,shard,persisted,shard,routing,has,stale,routing,shard,routing,if,shards,found,false,assert,false,failed,shards,cache,key,set,stream,none,match,shard,id,shard,id,get,index,equals,index,service,index
AbstractIndicesClusterStateServiceTestCase -> public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService);1539723533;Checks if cluster state matches internal state of IndicesClusterStateService instance__@param state cluster state used for matching;public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService) {_        MockIndicesService indicesService = (MockIndicesService) indicesClusterStateService.indicesService__        ConcurrentMap<ShardId, ShardRouting> failedShardsCache = indicesClusterStateService.failedShardsCache__        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.getNodes().getLocalNodeId())__        if (localRoutingNode != null) {_            if (enableRandomFailures == false) {_                _                _                if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {_                    fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values())__                }_            }_            _            for (ShardRouting shardRouting : localRoutingNode) {_                Index index = shardRouting.index()__                IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)___                MockIndexShard shard = indicesService.getShardOrNull(shardRouting.shardId())__                ShardRouting failedShard = failedShardsCache.get(shardRouting.shardId())___                if (state.blocks().disableStatePersistence()) {_                    if (shard != null) {_                        fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence")__                    }_                } else {_                    if (failedShard != null && failedShard.isSameAllocation(shardRouting) == false) {_                        fail("Shard cache has not been properly cleaned for " + failedShard)__                    }_                    if (shard == null && failedShard == null) {_                        _                        fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache")__                    }_                    if (enableRandomFailures == false) {_                        if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {_                            _                            fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard)__                        }_                    }__                    if (shard != null) {_                        AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__                        assertTrue("Index " + index + " expected but missing in indicesService", indexService != null)___                        _                        assertThat(indexService.getIndexSettings().getIndexMetaData(), equalTo(indexMetaData))__                        _                        if (enableRandomFailures == false || failedShard == null) {_                            assertTrue("Shard with id " + shardRouting + " expected but missing in indexService", shard != null)__                            _                            assertThat(shard.routingEntry(), equalTo(shardRouting))__                        }__                        if (shard.routingEntry().primary() && shard.routingEntry().active()) {_                            IndexShardRoutingTable shardRoutingTable = state.routingTable().shardRoutingTable(shard.shardId())__                            Set<String> inSyncIds = state.metaData().index(shard.shardId().getIndex())_                                .inSyncAllocationIds(shard.shardId().id())__                            assertThat(shard.routingEntry() + " isn't updated with in-sync aIDs", shard.inSyncAllocationIds,_                                equalTo(inSyncIds))__                            assertThat(shard.routingEntry() + " isn't updated with routing table", shard.routingTable,_                                equalTo(shardRoutingTable))__                        }_                    }_                }_            }_        }__        _        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            if (state.blocks().disableStatePersistence()) {_                fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence")__            }__            assertTrue(state.metaData().getIndexSafe(indexService.index()) != null)___            boolean shardsFound = false__            for (Shard shard : indexService) {_                shardsFound = true__                ShardRouting persistedShardRouting = shard.routingEntry()__                ShardRouting shardRouting = localRoutingNode.getByShardId(persistedShardRouting.shardId())__                if (shardRouting == null) {_                    fail("Shard with id " + persistedShardRouting + " locally exists but missing in routing table")__                }_                if (shardRouting.equals(persistedShardRouting) == false) {_                    fail("Local shard " + persistedShardRouting + " has stale routing" + shardRouting)__                }_            }__            if (shardsFound == false) {_                _                _                assertFalse(failedShardsCache.keySet().stream().noneMatch(shardId -> shardId.getIndex().equals(indexService.index())))__            }__        }_    };checks,if,cluster,state,matches,internal,state,of,indices,cluster,state,service,instance,param,state,cluster,state,used,for,matching;public,void,assert,cluster,state,matches,node,state,cluster,state,state,indices,cluster,state,service,indices,cluster,state,service,mock,indices,service,indices,service,mock,indices,service,indices,cluster,state,service,indices,service,concurrent,map,shard,id,shard,routing,failed,shards,cache,indices,cluster,state,service,failed,shards,cache,routing,node,local,routing,node,state,get,routing,nodes,node,state,get,nodes,get,local,node,id,if,local,routing,node,null,if,enable,random,failures,false,if,failed,shards,cache,values,stream,any,match,shard,routing,initializing,fail,failed,shard,cache,should,not,contain,initializing,shard,routing,failed,shards,cache,values,for,shard,routing,shard,routing,local,routing,node,index,index,shard,routing,index,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,mock,index,shard,shard,indices,service,get,shard,or,null,shard,routing,shard,id,shard,routing,failed,shard,failed,shards,cache,get,shard,routing,shard,id,if,state,blocks,disable,state,persistence,if,shard,null,fail,shard,with,id,shard,routing,should,be,removed,from,indices,service,due,to,disabled,state,persistence,else,if,failed,shard,null,failed,shard,is,same,allocation,shard,routing,false,fail,shard,cache,has,not,been,properly,cleaned,for,failed,shard,if,shard,null,failed,shard,null,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,and,failed,shards,cache,if,enable,random,failures,false,if,shard,null,shard,routing,initializing,failed,shard,shard,routing,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,failed,shard,if,shard,null,allocated,index,extends,shard,index,service,indices,service,index,service,index,assert,true,index,index,expected,but,missing,in,indices,service,index,service,null,assert,that,index,service,get,index,settings,get,index,meta,data,equal,to,index,meta,data,if,enable,random,failures,false,failed,shard,null,assert,true,shard,with,id,shard,routing,expected,but,missing,in,index,service,shard,null,assert,that,shard,routing,entry,equal,to,shard,routing,if,shard,routing,entry,primary,shard,routing,entry,active,index,shard,routing,table,shard,routing,table,state,routing,table,shard,routing,table,shard,shard,id,set,string,in,sync,ids,state,meta,data,index,shard,shard,id,get,index,in,sync,allocation,ids,shard,shard,id,id,assert,that,shard,routing,entry,isn,t,updated,with,in,sync,a,ids,shard,in,sync,allocation,ids,equal,to,in,sync,ids,assert,that,shard,routing,entry,isn,t,updated,with,routing,table,shard,routing,table,equal,to,shard,routing,table,for,allocated,index,extends,shard,index,service,indices,service,if,state,blocks,disable,state,persistence,fail,index,service,index,service,index,should,be,removed,from,indices,service,due,to,disabled,state,persistence,assert,true,state,meta,data,get,index,safe,index,service,index,null,boolean,shards,found,false,for,shard,shard,index,service,shards,found,true,shard,routing,persisted,shard,routing,shard,routing,entry,shard,routing,shard,routing,local,routing,node,get,by,shard,id,persisted,shard,routing,shard,id,if,shard,routing,null,fail,shard,with,id,persisted,shard,routing,locally,exists,but,missing,in,routing,table,if,shard,routing,equals,persisted,shard,routing,false,fail,local,shard,persisted,shard,routing,has,stale,routing,shard,routing,if,shards,found,false,assert,false,failed,shards,cache,key,set,stream,none,match,shard,id,shard,id,get,index,equals,index,service,index
AbstractIndicesClusterStateServiceTestCase -> public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService);1547520324;Checks if cluster state matches internal state of IndicesClusterStateService instance__@param state cluster state used for matching;public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService) {_        MockIndicesService indicesService = (MockIndicesService) indicesClusterStateService.indicesService__        ConcurrentMap<ShardId, ShardRouting> failedShardsCache = indicesClusterStateService.failedShardsCache__        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.getNodes().getLocalNodeId())__        if (localRoutingNode != null) {_            if (enableRandomFailures == false) {_                _                _                if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {_                    fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values())__                }_            }_            _            for (ShardRouting shardRouting : localRoutingNode) {_                Index index = shardRouting.index()__                IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)___                MockIndexShard shard = indicesService.getShardOrNull(shardRouting.shardId())__                ShardRouting failedShard = failedShardsCache.get(shardRouting.shardId())___                if (state.blocks().disableStatePersistence()) {_                    if (shard != null) {_                        fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence")__                    }_                } else {_                    if (failedShard != null && failedShard.isSameAllocation(shardRouting) == false) {_                        fail("Shard cache has not been properly cleaned for " + failedShard)__                    }_                    if (shard == null && failedShard == null) {_                        _                        fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache")__                    }_                    if (enableRandomFailures == false) {_                        if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {_                            _                            fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard)__                        }_                    }__                    if (shard != null) {_                        AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__                        assertTrue("Index " + index + " expected but missing in indicesService", indexService != null)___                        _                        assertThat(indexService.getIndexSettings().getIndexMetaData(), equalTo(indexMetaData))__                        _                        if (enableRandomFailures == false || failedShard == null) {_                            assertTrue("Shard with id " + shardRouting + " expected but missing in indexService", shard != null)__                            _                            assertThat(shard.routingEntry(), equalTo(shardRouting))__                        }__                        if (shard.routingEntry().primary() && shard.routingEntry().active()) {_                            IndexShardRoutingTable shardRoutingTable = state.routingTable().shardRoutingTable(shard.shardId())__                            Set<String> inSyncIds = state.metaData().index(shard.shardId().getIndex())_                                .inSyncAllocationIds(shard.shardId().id())__                            assertThat(shard.routingEntry() + " isn't updated with in-sync aIDs", shard.inSyncAllocationIds,_                                equalTo(inSyncIds))__                            assertThat(shard.routingEntry() + " isn't updated with routing table", shard.routingTable,_                                equalTo(shardRoutingTable))__                        }_                    }_                }_            }_        }__        _        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            if (state.blocks().disableStatePersistence()) {_                fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence")__            }__            assertTrue(state.metaData().getIndexSafe(indexService.index()) != null)___            boolean shardsFound = false__            for (Shard shard : indexService) {_                shardsFound = true__                ShardRouting persistedShardRouting = shard.routingEntry()__                ShardRouting shardRouting = localRoutingNode.getByShardId(persistedShardRouting.shardId())__                if (shardRouting == null) {_                    fail("Shard with id " + persistedShardRouting + " locally exists but missing in routing table")__                }_                if (shardRouting.equals(persistedShardRouting) == false) {_                    fail("Local shard " + persistedShardRouting + " has stale routing" + shardRouting)__                }_            }__            if (shardsFound == false) {_                _                _                assertFalse(failedShardsCache.keySet().stream().noneMatch(shardId -> shardId.getIndex().equals(indexService.index())))__            }__        }_    };checks,if,cluster,state,matches,internal,state,of,indices,cluster,state,service,instance,param,state,cluster,state,used,for,matching;public,void,assert,cluster,state,matches,node,state,cluster,state,state,indices,cluster,state,service,indices,cluster,state,service,mock,indices,service,indices,service,mock,indices,service,indices,cluster,state,service,indices,service,concurrent,map,shard,id,shard,routing,failed,shards,cache,indices,cluster,state,service,failed,shards,cache,routing,node,local,routing,node,state,get,routing,nodes,node,state,get,nodes,get,local,node,id,if,local,routing,node,null,if,enable,random,failures,false,if,failed,shards,cache,values,stream,any,match,shard,routing,initializing,fail,failed,shard,cache,should,not,contain,initializing,shard,routing,failed,shards,cache,values,for,shard,routing,shard,routing,local,routing,node,index,index,shard,routing,index,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,mock,index,shard,shard,indices,service,get,shard,or,null,shard,routing,shard,id,shard,routing,failed,shard,failed,shards,cache,get,shard,routing,shard,id,if,state,blocks,disable,state,persistence,if,shard,null,fail,shard,with,id,shard,routing,should,be,removed,from,indices,service,due,to,disabled,state,persistence,else,if,failed,shard,null,failed,shard,is,same,allocation,shard,routing,false,fail,shard,cache,has,not,been,properly,cleaned,for,failed,shard,if,shard,null,failed,shard,null,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,and,failed,shards,cache,if,enable,random,failures,false,if,shard,null,shard,routing,initializing,failed,shard,shard,routing,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,failed,shard,if,shard,null,allocated,index,extends,shard,index,service,indices,service,index,service,index,assert,true,index,index,expected,but,missing,in,indices,service,index,service,null,assert,that,index,service,get,index,settings,get,index,meta,data,equal,to,index,meta,data,if,enable,random,failures,false,failed,shard,null,assert,true,shard,with,id,shard,routing,expected,but,missing,in,index,service,shard,null,assert,that,shard,routing,entry,equal,to,shard,routing,if,shard,routing,entry,primary,shard,routing,entry,active,index,shard,routing,table,shard,routing,table,state,routing,table,shard,routing,table,shard,shard,id,set,string,in,sync,ids,state,meta,data,index,shard,shard,id,get,index,in,sync,allocation,ids,shard,shard,id,id,assert,that,shard,routing,entry,isn,t,updated,with,in,sync,a,ids,shard,in,sync,allocation,ids,equal,to,in,sync,ids,assert,that,shard,routing,entry,isn,t,updated,with,routing,table,shard,routing,table,equal,to,shard,routing,table,for,allocated,index,extends,shard,index,service,indices,service,if,state,blocks,disable,state,persistence,fail,index,service,index,service,index,should,be,removed,from,indices,service,due,to,disabled,state,persistence,assert,true,state,meta,data,get,index,safe,index,service,index,null,boolean,shards,found,false,for,shard,shard,index,service,shards,found,true,shard,routing,persisted,shard,routing,shard,routing,entry,shard,routing,shard,routing,local,routing,node,get,by,shard,id,persisted,shard,routing,shard,id,if,shard,routing,null,fail,shard,with,id,persisted,shard,routing,locally,exists,but,missing,in,routing,table,if,shard,routing,equals,persisted,shard,routing,false,fail,local,shard,persisted,shard,routing,has,stale,routing,shard,routing,if,shards,found,false,assert,false,failed,shards,cache,key,set,stream,none,match,shard,id,shard,id,get,index,equals,index,service,index
AbstractIndicesClusterStateServiceTestCase -> public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService);1548593396;Checks if cluster state matches internal state of IndicesClusterStateService instance__@param state cluster state used for matching;public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService) {_        MockIndicesService indicesService = (MockIndicesService) indicesClusterStateService.indicesService__        ConcurrentMap<ShardId, ShardRouting> failedShardsCache = indicesClusterStateService.failedShardsCache__        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.getNodes().getLocalNodeId())__        if (localRoutingNode != null) {_            if (enableRandomFailures == false) {_                _                _                if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {_                    fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values())__                }_            }_            _            for (ShardRouting shardRouting : localRoutingNode) {_                Index index = shardRouting.index()__                IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)___                MockIndexShard shard = indicesService.getShardOrNull(shardRouting.shardId())__                ShardRouting failedShard = failedShardsCache.get(shardRouting.shardId())___                if (state.blocks().disableStatePersistence()) {_                    if (shard != null) {_                        fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence")__                    }_                } else {_                    if (failedShard != null && failedShard.isSameAllocation(shardRouting) == false) {_                        fail("Shard cache has not been properly cleaned for " + failedShard)__                    }_                    if (shard == null && failedShard == null) {_                        _                        fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache")__                    }_                    if (enableRandomFailures == false) {_                        if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {_                            _                            fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard)__                        }_                    }__                    if (shard != null) {_                        AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__                        assertTrue("Index " + index + " expected but missing in indicesService", indexService != null)___                        _                        assertThat(indexService.getIndexSettings().getIndexMetaData(), equalTo(indexMetaData))__                        _                        if (enableRandomFailures == false || failedShard == null) {_                            assertTrue("Shard with id " + shardRouting + " expected but missing in indexService", shard != null)__                            _                            assertThat(shard.routingEntry(), equalTo(shardRouting))__                        }__                        if (shard.routingEntry().primary() && shard.routingEntry().active()) {_                            IndexShardRoutingTable shardRoutingTable = state.routingTable().shardRoutingTable(shard.shardId())__                            Set<String> inSyncIds = state.metaData().index(shard.shardId().getIndex())_                                .inSyncAllocationIds(shard.shardId().id())__                            assertThat(shard.routingEntry() + " isn't updated with in-sync aIDs", shard.inSyncAllocationIds,_                                equalTo(inSyncIds))__                            assertThat(shard.routingEntry() + " isn't updated with routing table", shard.routingTable,_                                equalTo(shardRoutingTable))__                        }_                    }_                }_            }_        }__        _        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            if (state.blocks().disableStatePersistence()) {_                fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence")__            }__            assertTrue(state.metaData().getIndexSafe(indexService.index()) != null)___            boolean shardsFound = false__            for (Shard shard : indexService) {_                shardsFound = true__                ShardRouting persistedShardRouting = shard.routingEntry()__                ShardRouting shardRouting = localRoutingNode.getByShardId(persistedShardRouting.shardId())__                if (shardRouting == null) {_                    fail("Shard with id " + persistedShardRouting + " locally exists but missing in routing table")__                }_                if (shardRouting.equals(persistedShardRouting) == false) {_                    fail("Local shard " + persistedShardRouting + " has stale routing" + shardRouting)__                }_            }__            if (shardsFound == false) {_                _                _                assertFalse(failedShardsCache.keySet().stream().noneMatch(shardId -> shardId.getIndex().equals(indexService.index())))__            }__        }_    };checks,if,cluster,state,matches,internal,state,of,indices,cluster,state,service,instance,param,state,cluster,state,used,for,matching;public,void,assert,cluster,state,matches,node,state,cluster,state,state,indices,cluster,state,service,indices,cluster,state,service,mock,indices,service,indices,service,mock,indices,service,indices,cluster,state,service,indices,service,concurrent,map,shard,id,shard,routing,failed,shards,cache,indices,cluster,state,service,failed,shards,cache,routing,node,local,routing,node,state,get,routing,nodes,node,state,get,nodes,get,local,node,id,if,local,routing,node,null,if,enable,random,failures,false,if,failed,shards,cache,values,stream,any,match,shard,routing,initializing,fail,failed,shard,cache,should,not,contain,initializing,shard,routing,failed,shards,cache,values,for,shard,routing,shard,routing,local,routing,node,index,index,shard,routing,index,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,mock,index,shard,shard,indices,service,get,shard,or,null,shard,routing,shard,id,shard,routing,failed,shard,failed,shards,cache,get,shard,routing,shard,id,if,state,blocks,disable,state,persistence,if,shard,null,fail,shard,with,id,shard,routing,should,be,removed,from,indices,service,due,to,disabled,state,persistence,else,if,failed,shard,null,failed,shard,is,same,allocation,shard,routing,false,fail,shard,cache,has,not,been,properly,cleaned,for,failed,shard,if,shard,null,failed,shard,null,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,and,failed,shards,cache,if,enable,random,failures,false,if,shard,null,shard,routing,initializing,failed,shard,shard,routing,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,failed,shard,if,shard,null,allocated,index,extends,shard,index,service,indices,service,index,service,index,assert,true,index,index,expected,but,missing,in,indices,service,index,service,null,assert,that,index,service,get,index,settings,get,index,meta,data,equal,to,index,meta,data,if,enable,random,failures,false,failed,shard,null,assert,true,shard,with,id,shard,routing,expected,but,missing,in,index,service,shard,null,assert,that,shard,routing,entry,equal,to,shard,routing,if,shard,routing,entry,primary,shard,routing,entry,active,index,shard,routing,table,shard,routing,table,state,routing,table,shard,routing,table,shard,shard,id,set,string,in,sync,ids,state,meta,data,index,shard,shard,id,get,index,in,sync,allocation,ids,shard,shard,id,id,assert,that,shard,routing,entry,isn,t,updated,with,in,sync,a,ids,shard,in,sync,allocation,ids,equal,to,in,sync,ids,assert,that,shard,routing,entry,isn,t,updated,with,routing,table,shard,routing,table,equal,to,shard,routing,table,for,allocated,index,extends,shard,index,service,indices,service,if,state,blocks,disable,state,persistence,fail,index,service,index,service,index,should,be,removed,from,indices,service,due,to,disabled,state,persistence,assert,true,state,meta,data,get,index,safe,index,service,index,null,boolean,shards,found,false,for,shard,shard,index,service,shards,found,true,shard,routing,persisted,shard,routing,shard,routing,entry,shard,routing,shard,routing,local,routing,node,get,by,shard,id,persisted,shard,routing,shard,id,if,shard,routing,null,fail,shard,with,id,persisted,shard,routing,locally,exists,but,missing,in,routing,table,if,shard,routing,equals,persisted,shard,routing,false,fail,local,shard,persisted,shard,routing,has,stale,routing,shard,routing,if,shards,found,false,assert,false,failed,shards,cache,key,set,stream,none,match,shard,id,shard,id,get,index,equals,index,service,index
AbstractIndicesClusterStateServiceTestCase -> public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService);1548770980;Checks if cluster state matches internal state of IndicesClusterStateService instance__@param state cluster state used for matching;public void assertClusterStateMatchesNodeState(ClusterState state, IndicesClusterStateService indicesClusterStateService) {_        MockIndicesService indicesService = (MockIndicesService) indicesClusterStateService.indicesService__        ConcurrentMap<ShardId, ShardRouting> failedShardsCache = indicesClusterStateService.failedShardsCache__        RoutingNode localRoutingNode = state.getRoutingNodes().node(state.getNodes().getLocalNodeId())__        if (localRoutingNode != null) {_            if (enableRandomFailures == false) {_                _                _                if (failedShardsCache.values().stream().anyMatch(ShardRouting::initializing)) {_                    fail("failed shard cache should not contain initializing shard routing: " + failedShardsCache.values())__                }_            }_            _            for (ShardRouting shardRouting : localRoutingNode) {_                Index index = shardRouting.index()__                IndexMetaData indexMetaData = state.metaData().getIndexSafe(index)___                MockIndexShard shard = indicesService.getShardOrNull(shardRouting.shardId())__                ShardRouting failedShard = failedShardsCache.get(shardRouting.shardId())___                if (state.blocks().disableStatePersistence()) {_                    if (shard != null) {_                        fail("Shard with id " + shardRouting + " should be removed from indicesService due to disabled state persistence")__                    }_                } else {_                    if (failedShard != null && failedShard.isSameAllocation(shardRouting) == false) {_                        fail("Shard cache has not been properly cleaned for " + failedShard)__                    }_                    if (shard == null && failedShard == null) {_                        _                        fail("Shard with id " + shardRouting + " expected but missing in indicesService and failedShardsCache")__                    }_                    if (enableRandomFailures == false) {_                        if (shard == null && shardRouting.initializing() && failedShard == shardRouting) {_                            _                            fail("Shard with id " + shardRouting + " expected but missing in indicesService " + failedShard)__                        }_                    }__                    if (shard != null) {_                        AllocatedIndex<? extends Shard> indexService = indicesService.indexService(index)__                        assertTrue("Index " + index + " expected but missing in indicesService", indexService != null)___                        _                        assertThat(indexService.getIndexSettings().getIndexMetaData(), equalTo(indexMetaData))__                        _                        if (enableRandomFailures == false || failedShard == null) {_                            assertTrue("Shard with id " + shardRouting + " expected but missing in indexService", shard != null)__                            _                            assertThat(shard.routingEntry(), equalTo(shardRouting))__                        }__                        if (shard.routingEntry().primary() && shard.routingEntry().active()) {_                            IndexShardRoutingTable shardRoutingTable = state.routingTable().shardRoutingTable(shard.shardId())__                            Set<String> inSyncIds = state.metaData().index(shard.shardId().getIndex())_                                .inSyncAllocationIds(shard.shardId().id())__                            assertThat(shard.routingEntry() + " isn't updated with in-sync aIDs", shard.inSyncAllocationIds,_                                equalTo(inSyncIds))__                            assertThat(shard.routingEntry() + " isn't updated with routing table", shard.routingTable,_                                equalTo(shardRoutingTable))__                        }_                    }_                }_            }_        }__        _        for (AllocatedIndex<? extends Shard> indexService : indicesService) {_            if (state.blocks().disableStatePersistence()) {_                fail("Index service " + indexService.index() + " should be removed from indicesService due to disabled state persistence")__            }__            assertTrue(state.metaData().getIndexSafe(indexService.index()) != null)___            boolean shardsFound = false__            for (Shard shard : indexService) {_                shardsFound = true__                ShardRouting persistedShardRouting = shard.routingEntry()__                ShardRouting shardRouting = localRoutingNode.getByShardId(persistedShardRouting.shardId())__                if (shardRouting == null) {_                    fail("Shard with id " + persistedShardRouting + " locally exists but missing in routing table")__                }_                if (shardRouting.equals(persistedShardRouting) == false) {_                    fail("Local shard " + persistedShardRouting + " has stale routing" + shardRouting)__                }_            }__            if (shardsFound == false) {_                _                _                assertFalse(failedShardsCache.keySet().stream().noneMatch(shardId -> shardId.getIndex().equals(indexService.index())))__            }__        }_    };checks,if,cluster,state,matches,internal,state,of,indices,cluster,state,service,instance,param,state,cluster,state,used,for,matching;public,void,assert,cluster,state,matches,node,state,cluster,state,state,indices,cluster,state,service,indices,cluster,state,service,mock,indices,service,indices,service,mock,indices,service,indices,cluster,state,service,indices,service,concurrent,map,shard,id,shard,routing,failed,shards,cache,indices,cluster,state,service,failed,shards,cache,routing,node,local,routing,node,state,get,routing,nodes,node,state,get,nodes,get,local,node,id,if,local,routing,node,null,if,enable,random,failures,false,if,failed,shards,cache,values,stream,any,match,shard,routing,initializing,fail,failed,shard,cache,should,not,contain,initializing,shard,routing,failed,shards,cache,values,for,shard,routing,shard,routing,local,routing,node,index,index,shard,routing,index,index,meta,data,index,meta,data,state,meta,data,get,index,safe,index,mock,index,shard,shard,indices,service,get,shard,or,null,shard,routing,shard,id,shard,routing,failed,shard,failed,shards,cache,get,shard,routing,shard,id,if,state,blocks,disable,state,persistence,if,shard,null,fail,shard,with,id,shard,routing,should,be,removed,from,indices,service,due,to,disabled,state,persistence,else,if,failed,shard,null,failed,shard,is,same,allocation,shard,routing,false,fail,shard,cache,has,not,been,properly,cleaned,for,failed,shard,if,shard,null,failed,shard,null,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,and,failed,shards,cache,if,enable,random,failures,false,if,shard,null,shard,routing,initializing,failed,shard,shard,routing,fail,shard,with,id,shard,routing,expected,but,missing,in,indices,service,failed,shard,if,shard,null,allocated,index,extends,shard,index,service,indices,service,index,service,index,assert,true,index,index,expected,but,missing,in,indices,service,index,service,null,assert,that,index,service,get,index,settings,get,index,meta,data,equal,to,index,meta,data,if,enable,random,failures,false,failed,shard,null,assert,true,shard,with,id,shard,routing,expected,but,missing,in,index,service,shard,null,assert,that,shard,routing,entry,equal,to,shard,routing,if,shard,routing,entry,primary,shard,routing,entry,active,index,shard,routing,table,shard,routing,table,state,routing,table,shard,routing,table,shard,shard,id,set,string,in,sync,ids,state,meta,data,index,shard,shard,id,get,index,in,sync,allocation,ids,shard,shard,id,id,assert,that,shard,routing,entry,isn,t,updated,with,in,sync,a,ids,shard,in,sync,allocation,ids,equal,to,in,sync,ids,assert,that,shard,routing,entry,isn,t,updated,with,routing,table,shard,routing,table,equal,to,shard,routing,table,for,allocated,index,extends,shard,index,service,indices,service,if,state,blocks,disable,state,persistence,fail,index,service,index,service,index,should,be,removed,from,indices,service,due,to,disabled,state,persistence,assert,true,state,meta,data,get,index,safe,index,service,index,null,boolean,shards,found,false,for,shard,shard,index,service,shards,found,true,shard,routing,persisted,shard,routing,shard,routing,entry,shard,routing,shard,routing,local,routing,node,get,by,shard,id,persisted,shard,routing,shard,id,if,shard,routing,null,fail,shard,with,id,persisted,shard,routing,locally,exists,but,missing,in,routing,table,if,shard,routing,equals,persisted,shard,routing,false,fail,local,shard,persisted,shard,routing,has,stale,routing,shard,routing,if,shards,found,false,assert,false,failed,shards,cache,key,set,stream,none,match,shard,id,shard,id,get,index,equals,index,service,index
