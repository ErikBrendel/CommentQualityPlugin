commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return pluginList(InternalSettingsPlugin.class). }
false;protected;0;5;;@Override protected void setTypeList() {     TYPES = new HashSet<>(Arrays.asList("date_range", "ip_range", "float_range", "double_range", "integer_range", "long_range")).     WHOLE_TYPES = new HashSet<>(Arrays.asList("integer_range", "long_range")). }
false;private;1;8;;private Object getFrom(String type) {     if (type.equals("date_range")) {         return FROM_DATE.     } else if (type.equals("ip_range")) {         return FROM_IP.     }     return random().nextBoolean() ? FROM : FROM_STR. }
false;private;0;3;;private String getFromField() {     return random().nextBoolean() ? GT_FIELD.getPreferredName() : GTE_FIELD.getPreferredName(). }
false;private;0;3;;private String getToField() {     return random().nextBoolean() ? LT_FIELD.getPreferredName() : LTE_FIELD.getPreferredName(). }
false;private;1;8;;private Object getTo(String type) {     if (type.equals("date_range")) {         return TO_DATE.     } else if (type.equals("ip_range")) {         return TO_IP.     }     return random().nextBoolean() ? TO : TO_STR. }
false;private;1;12;;private Object getMax(String type) {     if (type.equals("date_range") || type.equals("long_range")) {         return Long.MAX_VALUE.     } else if (type.equals("ip_range")) {         return InetAddressPoint.MAX_VALUE.     } else if (type.equals("integer_range")) {         return Integer.MAX_VALUE.     } else if (type.equals("float_range")) {         return Float.POSITIVE_INFINITY.     }     return Double.POSITIVE_INFINITY. }
false;public;1;30;;@Override public void doTestDefaults(String type) throws Exception {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", type).     if (type.equals("date_range")) {         mapping = mapping.field("format", DATE_FORMAT).     }     mapping = mapping.endObject().endObject().endObject().endObject().     DocumentMapper mapper = parser.parse("type", new CompressedXContent(Strings.toString(mapping))).     assertEquals(Strings.toString(mapping), mapper.mappingSource().toString()).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("field").field(getFromField(), getFrom(type)).field(getToField(), getTo(type)).endObject().endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(2, fields.length).     IndexableField dvField = fields[0].     assertEquals(DocValuesType.BINARY, dvField.fieldType().docValuesType()).     IndexableField pointField = fields[1].     assertEquals(2, pointField.fieldType().pointIndexDimensionCount()).     assertFalse(pointField.fieldType().stored()). }
false;protected;1;24;;@Override protected void doTestNotIndexed(String type) throws Exception {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", type).field("index", false).     if (type.equals("date_range")) {         mapping = mapping.field("format", DATE_FORMAT).     }     mapping = mapping.endObject().endObject().endObject().endObject().     DocumentMapper mapper = parser.parse("type", new CompressedXContent(Strings.toString(mapping))).     assertEquals(Strings.toString(mapping), mapper.mappingSource().toString()).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("field").field(getFromField(), getFrom(type)).field(getToField(), getTo(type)).endObject().endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(1, fields.length). }
false;protected;1;25;;@Override protected void doTestNoDocValues(String type) throws Exception {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", type).field("doc_values", false).     if (type.equals("date_range")) {         mapping = mapping.field("format", DATE_FORMAT).     }     mapping = mapping.endObject().endObject().endObject().endObject().     DocumentMapper mapper = parser.parse("type", new CompressedXContent(Strings.toString(mapping))).     assertEquals(Strings.toString(mapping), mapper.mappingSource().toString()).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("field").field(getFromField(), getFrom(type)).field(getToField(), getTo(type)).endObject().endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(1, fields.length).     IndexableField pointField = fields[0].     assertEquals(2, pointField.fieldType().pointIndexDimensionCount()). }
false;protected;1;37;;@Override protected void doTestStore(String type) throws Exception {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", type).field("store", true).     if (type.equals("date_range")) {         mapping = mapping.field("format", DATE_FORMAT).     }     mapping = mapping.endObject().endObject().endObject().endObject().     DocumentMapper mapper = parser.parse("type", new CompressedXContent(Strings.toString(mapping))).     assertEquals(Strings.toString(mapping), mapper.mappingSource().toString()).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("field").field(getFromField(), getFrom(type)).field(getToField(), getTo(type)).endObject().endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(3, fields.length).     IndexableField dvField = fields[0].     assertEquals(DocValuesType.BINARY, dvField.fieldType().docValuesType()).     IndexableField pointField = fields[1].     assertEquals(2, pointField.fieldType().pointIndexDimensionCount()).     IndexableField storedField = fields[2].     assertTrue(storedField.fieldType().stored()).     String strVal = "5".     if (type.equals("date_range")) {         strVal = "1477872000000".     } else if (type.equals("ip_range")) {         strVal = InetAddresses.toAddrString(InetAddresses.forString("192.168.1.7")) + " : " + InetAddresses.toAddrString(InetAddresses.forString("2001:db8:0:0:0:0:0:0")).     }     assertThat(storedField.stringValue(), containsString(strVal)). }
false;public;1;47;;@Override public void doTestCoerce(String type) throws IOException {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", type).     if (type.equals("date_range")) {         mapping = mapping.field("format", DATE_FORMAT).     }     mapping = mapping.endObject().endObject().endObject().endObject().     DocumentMapper mapper = parser.parse("type", new CompressedXContent(Strings.toString(mapping))).     assertEquals(Strings.toString(mapping), mapper.mappingSource().toString()).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("field").field(getFromField(), getFrom(type)).field(getToField(), getTo(type)).endObject().endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(2, fields.length).     IndexableField dvField = fields[0].     assertEquals(DocValuesType.BINARY, dvField.fieldType().docValuesType()).     IndexableField pointField = fields[1].     assertEquals(2, pointField.fieldType().pointIndexDimensionCount()).     // date_range ignores the coerce parameter and epoch_millis date format truncates floats (see issue: #14641)     if (type.equals("date_range") == false) {         mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", type).field("coerce", false).endObject().endObject().endObject().endObject().         DocumentMapper mapper2 = parser.parse("type", new CompressedXContent(Strings.toString(mapping))).         assertEquals(Strings.toString(mapping), mapper2.mappingSource().toString()).         ThrowingRunnable runnable = () -> mapper2.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("field").field(getFromField(), "5.2").field(getToField(), "10").endObject().endObject()), XContentType.JSON)).         MapperParsingException e = expectThrows(MapperParsingException.class, runnable).         assertThat(e.getCause().getMessage(), anyOf(containsString("passed as String"), containsString("failed to parse date"), containsString("is not an IP string literal"))).     } }
false;protected;1;33;;@Override protected void doTestDecimalCoerce(String type) throws IOException {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", type).     mapping = mapping.endObject().endObject().endObject().endObject().     DocumentMapper mapper = parser.parse("type", new CompressedXContent(Strings.toString(mapping))).     assertEquals(Strings.toString(mapping), mapper.mappingSource().toString()).     ParsedDocument doc1 = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("field").field(GT_FIELD.getPreferredName(), "2.34").field(LT_FIELD.getPreferredName(), "5.67").endObject().endObject()), XContentType.JSON)).     ParsedDocument doc2 = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("field").field(GT_FIELD.getPreferredName(), "2").field(LT_FIELD.getPreferredName(), "5").endObject().endObject()), XContentType.JSON)).     IndexableField[] fields1 = doc1.rootDoc().getFields("field").     IndexableField[] fields2 = doc2.rootDoc().getFields("field").     assertEquals(fields1[1].binaryValue(), fields2[1].binaryValue()). }
false;protected;1;64;;@Override protected void doTestNullValue(String type) throws IOException {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", type).field("store", true).     if (type.equals("date_range")) {         mapping = mapping.field("format", DATE_FORMAT).     }     mapping = mapping.endObject().endObject().endObject().endObject().     DocumentMapper mapper = parser.parse("type", new CompressedXContent(Strings.toString(mapping))).     assertEquals(Strings.toString(mapping), mapper.mappingSource().toString()).     // test null value for min and max     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("field").nullField(getFromField()).nullField(getToField()).endObject().endObject()), XContentType.JSON)).     assertEquals(3, doc.rootDoc().getFields("field").length).     IndexableField[] fields = doc.rootDoc().getFields("field").     IndexableField storedField = fields[2].     String expected = type.equals("ip_range") ? InetAddresses.toAddrString((InetAddress) getMax(type)) : getMax(type) + "".     assertThat(storedField.stringValue(), containsString(expected)).     // test null max value     doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("field").field(getFromField(), getFrom(type)).nullField(getToField()).endObject().endObject()), XContentType.JSON)).     fields = doc.rootDoc().getFields("field").     assertEquals(3, fields.length).     IndexableField dvField = fields[0].     assertEquals(DocValuesType.BINARY, dvField.fieldType().docValuesType()).     IndexableField pointField = fields[1].     assertEquals(2, pointField.fieldType().pointIndexDimensionCount()).     assertFalse(pointField.fieldType().stored()).     storedField = fields[2].     assertTrue(storedField.fieldType().stored()).     String strVal = "5".     if (type.equals("date_range")) {         strVal = "1477872000000".     } else if (type.equals("ip_range")) {         strVal = InetAddresses.toAddrString(InetAddresses.forString("192.168.1.7")) + " : " + InetAddresses.toAddrString(InetAddresses.forString("ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff")).     }     assertThat(storedField.stringValue(), containsString(strVal)).     // test null range     doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().nullField("field").endObject()), XContentType.JSON)).     assertNull(doc.rootDoc().get("field")). }
false;public;0;5;;public void testNoBounds() throws Exception {     for (String type : TYPES) {         doTestNoBounds(type).     } }
false;public;1;31;;public void doTestNoBounds(String type) throws IOException {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", type).field("store", true).     if (type.equals("date_range")) {         mapping = mapping.field("format", DATE_FORMAT).     }     mapping = mapping.endObject().endObject().endObject().endObject().     DocumentMapper mapper = parser.parse("type", new CompressedXContent(Strings.toString(mapping))).     assertEquals(Strings.toString(mapping), mapper.mappingSource().toString()).     // test no bounds specified     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().startObject("field").endObject().endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(3, fields.length).     IndexableField dvField = fields[0].     assertEquals(DocValuesType.BINARY, dvField.fieldType().docValuesType()).     IndexableField pointField = fields[1].     assertEquals(2, pointField.fieldType().pointIndexDimensionCount()).     assertFalse(pointField.fieldType().stored()).     IndexableField storedField = fields[2].     assertTrue(storedField.fieldType().stored()).     String expected = type.equals("ip_range") ? InetAddresses.toAddrString((InetAddress) getMax(type)) : getMax(type) + "".     assertThat(storedField.stringValue(), containsString(expected)). }
false;public;0;9;;public void testIllegalArguments() throws Exception {     XContentBuilder mapping = XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", RangeFieldMapper.RangeType.INTEGER.name).field("format", DATE_FORMAT).endObject().endObject().endObject().endObject().     ThrowingRunnable runnable = () -> parser.parse("type", new CompressedXContent(Strings.toString(mapping))).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, runnable).     assertThat(e.getMessage(), containsString("should not define a dateTimeFormatter")). }
false;public;0;18;;public void testSerializeDefaults() throws Exception {     for (String type : TYPES) {         String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", type).endObject().endObject().endObject().endObject()).         DocumentMapper docMapper = parser.parse("type", new CompressedXContent(mapping)).         RangeFieldMapper mapper = (RangeFieldMapper) docMapper.root().getMapper("field").         XContentBuilder builder = XContentFactory.jsonBuilder().startObject().         mapper.doXContentBody(builder, true, ToXContent.EMPTY_PARAMS).         String got = Strings.toString(builder.endObject()).         // if type is date_range we check that the mapper contains the default format and locale         // otherwise it should not contain a locale or format         assertTrue(got, got.contains("\"format\":\"strict_date_optional_time||epoch_millis\"") == type.equals("date_range")).         assertTrue(got, got.contains("\"locale\":" + "\"" + Locale.ROOT + "\"") == type.equals("date_range")).     } }
false;public;0;17;;public void testIllegalFormatField() throws Exception {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date_range").array("format", "test_format").endObject().endObject().endObject().endObject()).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> parser.parse("type", new CompressedXContent(mapping))).     assertEquals("Invalid format: [[test_format]]: Unknown pattern letter: t", e.getMessage()). }
