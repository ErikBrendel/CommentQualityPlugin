commented;modifiers;parameterAmount;loc;comment;code
false;public;0;16;;public void setUp() throws Exception {     super.setUp().     threadPool = new TestThreadPool(getClass().getName()).     transport = new CapturingTransport().     clusterService = createClusterService(threadPool).     transportService = transport.createTransportService(clusterService.getSettings(), threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, boundAddress -> clusterService.localNode(), null, Collections.emptySet()).     transportService.start().     transportService.acceptIncomingRequests().     shardStateAction = new ShardStateAction(clusterService, transportService, null, null, threadPool). }
false;public;0;8;;public void tearDown() throws Exception {     try {         IOUtils.close(transportService, clusterService, transport).     } finally {         terminate(threadPool).     }     super.tearDown(). }
false;public;0;35;;public void testRetentionLeaseSyncActionOnPrimary() throws WriteStateException {     final IndicesService indicesService = mock(IndicesService.class).     final Index index = new Index("index", "uuid").     final IndexService indexService = mock(IndexService.class).     when(indicesService.indexServiceSafe(index)).thenReturn(indexService).     final int id = randomIntBetween(0, 4).     final IndexShard indexShard = mock(IndexShard.class).     when(indexService.getShard(id)).thenReturn(indexShard).     final ShardId shardId = new ShardId(index, id).     when(indexShard.shardId()).thenReturn(shardId).     final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(Settings.EMPTY, transportService, clusterService, indicesService, threadPool, shardStateAction, new ActionFilters(Collections.emptySet()), new IndexNameExpressionResolver()).     final RetentionLeases retentionLeases = mock(RetentionLeases.class).     final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases).     final TransportWriteAction.WritePrimaryResult<RetentionLeaseSyncAction.Request, RetentionLeaseSyncAction.Response> result = action.shardOperationOnPrimary(request, indexShard).     // the retention leases on the shard should be persisted     verify(indexShard).persistRetentionLeases().     // we should forward the request containing the current retention leases to the replica     assertThat(result.replicaRequest(), sameInstance(request)).     // we should start with an empty replication response     assertNull(result.finalResponseIfSuccessful.getShardInfo()). }
false;public;0;37;;public void testRetentionLeaseSyncActionOnReplica() throws WriteStateException {     final IndicesService indicesService = mock(IndicesService.class).     final Index index = new Index("index", "uuid").     final IndexService indexService = mock(IndexService.class).     when(indicesService.indexServiceSafe(index)).thenReturn(indexService).     final int id = randomIntBetween(0, 4).     final IndexShard indexShard = mock(IndexShard.class).     when(indexService.getShard(id)).thenReturn(indexShard).     final ShardId shardId = new ShardId(index, id).     when(indexShard.shardId()).thenReturn(shardId).     final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(Settings.EMPTY, transportService, clusterService, indicesService, threadPool, shardStateAction, new ActionFilters(Collections.emptySet()), new IndexNameExpressionResolver()).     final RetentionLeases retentionLeases = mock(RetentionLeases.class).     final RetentionLeaseSyncAction.Request request = new RetentionLeaseSyncAction.Request(indexShard.shardId(), retentionLeases).     final TransportWriteAction.WriteReplicaResult<RetentionLeaseSyncAction.Request> result = action.shardOperationOnReplica(request, indexShard).     // the retention leases on the shard should be updated     verify(indexShard).updateRetentionLeasesOnReplica(retentionLeases).     // the retention leases on the shard should be persisteed     verify(indexShard).persistRetentionLeases().     // the result should indicate success     final AtomicBoolean success = new AtomicBoolean().     result.respond(ActionListener.wrap(r -> success.set(true), e -> fail(e.toString()))).     assertTrue(success.get()). }
false;protected;3;24;;@Override protected void doExecute(Task task, Request request, ActionListener<Response> listener) {     assertTrue(threadPool.getThreadContext().isSystemContext()).     assertThat(request.shardId(), sameInstance(indexShard.shardId())).     assertThat(request.getRetentionLeases(), sameInstance(retentionLeases)).     if (randomBoolean()) {         listener.onResponse(new Response()).     } else {         final Exception e = randomFrom(new AlreadyClosedException("closed"), new IndexShardClosedException(indexShard.shardId()), new RuntimeException("failed")).         listener.onFailure(e).         if (e instanceof AlreadyClosedException == false && e instanceof IndexShardClosedException == false) {             final ArgumentCaptor<ParameterizedMessage> captor = ArgumentCaptor.forClass(ParameterizedMessage.class).             verify(retentionLeaseSyncActionLogger).warn(captor.capture(), same(e)).             final ParameterizedMessage message = captor.getValue().             assertThat(message.getFormat(), equalTo("{} retention lease sync failed")).             assertThat(message.getParameters(), arrayContaining(indexShard.shardId())).         }         verifyNoMoreInteractions(retentionLeaseSyncActionLogger).     }     invoked.set(true). }
false;protected;0;4;;@Override protected Logger getLogger() {     return retentionLeaseSyncActionLogger. }
false;public;0;63;;public void testRetentionLeaseSyncExecution() {     final IndicesService indicesService = mock(IndicesService.class).     final Index index = new Index("index", "uuid").     final IndexService indexService = mock(IndexService.class).     when(indicesService.indexServiceSafe(index)).thenReturn(indexService).     final int id = randomIntBetween(0, 4).     final IndexShard indexShard = mock(IndexShard.class).     when(indexService.getShard(id)).thenReturn(indexShard).     final ShardId shardId = new ShardId(index, id).     when(indexShard.shardId()).thenReturn(shardId).     final Logger retentionLeaseSyncActionLogger = mock(Logger.class).     final RetentionLeases retentionLeases = mock(RetentionLeases.class).     final AtomicBoolean invoked = new AtomicBoolean().     final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(Settings.EMPTY, transportService, clusterService, indicesService, threadPool, shardStateAction, new ActionFilters(Collections.emptySet()), new IndexNameExpressionResolver()) {          @Override         protected void doExecute(Task task, Request request, ActionListener<Response> listener) {             assertTrue(threadPool.getThreadContext().isSystemContext()).             assertThat(request.shardId(), sameInstance(indexShard.shardId())).             assertThat(request.getRetentionLeases(), sameInstance(retentionLeases)).             if (randomBoolean()) {                 listener.onResponse(new Response()).             } else {                 final Exception e = randomFrom(new AlreadyClosedException("closed"), new IndexShardClosedException(indexShard.shardId()), new RuntimeException("failed")).                 listener.onFailure(e).                 if (e instanceof AlreadyClosedException == false && e instanceof IndexShardClosedException == false) {                     final ArgumentCaptor<ParameterizedMessage> captor = ArgumentCaptor.forClass(ParameterizedMessage.class).                     verify(retentionLeaseSyncActionLogger).warn(captor.capture(), same(e)).                     final ParameterizedMessage message = captor.getValue().                     assertThat(message.getFormat(), equalTo("{} retention lease sync failed")).                     assertThat(message.getParameters(), arrayContaining(indexShard.shardId())).                 }                 verifyNoMoreInteractions(retentionLeaseSyncActionLogger).             }             invoked.set(true).         }          @Override         protected Logger getLogger() {             return retentionLeaseSyncActionLogger.         }     }.     // execution happens on the test thread, so no need to register an actual listener to callback     action.sync(indexShard.shardId(), retentionLeases, ActionListener.wrap(() -> {     })).     assertTrue(invoked.get()). }
false;public;0;26;;public void testBlocks() {     final IndicesService indicesService = mock(IndicesService.class).     final Index index = new Index("index", "uuid").     final IndexService indexService = mock(IndexService.class).     when(indicesService.indexServiceSafe(index)).thenReturn(indexService).     final int id = randomIntBetween(0, 4).     final IndexShard indexShard = mock(IndexShard.class).     when(indexService.getShard(id)).thenReturn(indexShard).     final ShardId shardId = new ShardId(index, id).     when(indexShard.shardId()).thenReturn(shardId).     final RetentionLeaseSyncAction action = new RetentionLeaseSyncAction(Settings.EMPTY, transportService, clusterService, indicesService, threadPool, shardStateAction, new ActionFilters(Collections.emptySet()), new IndexNameExpressionResolver()).     assertNull(action.indexBlockLevel()). }
