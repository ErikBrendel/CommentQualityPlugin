commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String fieldName() {     return "ip_range_dv_field". }
false;protected;0;4;;@Override protected RangeFieldMapper.RangeType rangeType() {     return RangeFieldMapper.RangeType.IP. }
false;protected;1;11;;@Override protected Range nextRange(int dimensions) throws Exception {     InetAddress min = nextInetaddress().     byte[] bMin = InetAddressPoint.encode(min).     InetAddress max = nextInetaddress().     byte[] bMax = InetAddressPoint.encode(max).     if (FutureArrays.compareUnsigned(bMin, 0, bMin.length, bMax, 0, bMin.length) > 0) {         return new IpRange(max, min).     }     return new IpRange(min, max). }
false;private;0;16;;private InetAddress nextInetaddress() throws UnknownHostException {     byte[] b = random().nextBoolean() ? new byte[4] : new byte[16].     switch(random().nextInt(5)) {         case 0:             return InetAddress.getByAddress(b).         case 1:             Arrays.fill(b, (byte) 0xff).             return InetAddress.getByAddress(b).         case 2:             Arrays.fill(b, (byte) 42).             return InetAddress.getByAddress(b).         default:             random().nextBytes(b).             return InetAddress.getByAddress(b).     } }
false;public;0;4;;@Override public InetAddress getMin() {     return minAddress. }
false;protected;2;14;;@Override protected void setMin(int dim, Object val) {     assert dim == 0.     InetAddress v = (InetAddress) val.     byte[] e = InetAddressPoint.encode(v).     if (FutureArrays.compareUnsigned(min, 0, e.length, e, 0, e.length) < 0) {         max = e.         maxAddress = v.     } else {         min = e.         minAddress = v.     } }
false;public;0;4;;@Override public InetAddress getMax() {     return maxAddress. }
false;protected;2;14;;@Override protected void setMax(int dim, Object val) {     assert dim == 0.     InetAddress v = (InetAddress) val.     byte[] e = InetAddressPoint.encode(v).     if (FutureArrays.compareUnsigned(max, 0, e.length, e, 0, e.length) > 0) {         min = e.         minAddress = v.     } else {         max = e.         maxAddress = v.     } }
false;protected;1;6;;@Override protected boolean isDisjoint(Range o) {     IpRange other = (IpRange) o.     return FutureArrays.compareUnsigned(min, 0, min.length, other.max, 0, min.length) > 0 || FutureArrays.compareUnsigned(max, 0, max.length, other.min, 0, max.length) < 0. }
false;protected;1;6;;@Override protected boolean isWithin(Range o) {     IpRange other = (IpRange) o.     return FutureArrays.compareUnsigned(min, 0, min.length, other.min, 0, min.length) >= 0 && FutureArrays.compareUnsigned(max, 0, max.length, other.max, 0, max.length) <= 0. }
false;protected;1;6;;@Override protected boolean contains(Range o) {     IpRange other = (IpRange) o.     return FutureArrays.compareUnsigned(min, 0, min.length, other.min, 0, min.length) <= 0 && FutureArrays.compareUnsigned(max, 0, max.length, other.max, 0, max.length) >= 0. }
