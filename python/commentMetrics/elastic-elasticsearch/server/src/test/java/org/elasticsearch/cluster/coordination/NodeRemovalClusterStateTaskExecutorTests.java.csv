commented;modifiers;parameterAmount;loc;comment;code
false;public;0;24;;public void testRemovingNonExistentNodes() throws Exception {     final NodeRemovalClusterStateTaskExecutor executor = new NodeRemovalClusterStateTaskExecutor(null, logger).     final DiscoveryNodes.Builder builder = DiscoveryNodes.builder().     final int nodes = randomIntBetween(2, 16).     for (int i = 0. i < nodes. i++) {         builder.add(node(i)).     }     final ClusterState clusterState = ClusterState.builder(new ClusterName("test")).nodes(builder).build().     final DiscoveryNodes.Builder removeBuilder = DiscoveryNodes.builder().     for (int i = nodes. i < nodes + randomIntBetween(1, 16). i++) {         removeBuilder.add(node(i)).     }     final List<NodeRemovalClusterStateTaskExecutor.Task> tasks = StreamSupport.stream(removeBuilder.build().spliterator(), false).map(node -> new NodeRemovalClusterStateTaskExecutor.Task(node, randomBoolean() ? "left" : "failed")).collect(Collectors.toList()).     final ClusterStateTaskExecutor.ClusterTasksResult<NodeRemovalClusterStateTaskExecutor.Task> result = executor.execute(clusterState, tasks).     assertThat(result.resultingState, equalTo(clusterState)). }
false;protected;2;6;;@Override protected ClusterState remainingNodesClusterState(ClusterState currentState, DiscoveryNodes.Builder remainingNodesBuilder) {     remainingNodesClusterState.set(super.remainingNodesClusterState(currentState, remainingNodesBuilder)).     return remainingNodesClusterState.get(). }
false;public;0;40;;public void testRerouteAfterRemovingNodes() throws Exception {     final AllocationService allocationService = mock(AllocationService.class).     when(allocationService.disassociateDeadNodes(any(ClusterState.class), eq(true), any(String.class))).thenAnswer(im -> im.getArguments()[0]).     final AtomicReference<ClusterState> remainingNodesClusterState = new AtomicReference<>().     final NodeRemovalClusterStateTaskExecutor executor = new NodeRemovalClusterStateTaskExecutor(allocationService, logger) {          @Override         protected ClusterState remainingNodesClusterState(ClusterState currentState, DiscoveryNodes.Builder remainingNodesBuilder) {             remainingNodesClusterState.set(super.remainingNodesClusterState(currentState, remainingNodesBuilder)).             return remainingNodesClusterState.get().         }     }.     final DiscoveryNodes.Builder builder = DiscoveryNodes.builder().     final int nodes = randomIntBetween(2, 16).     final List<NodeRemovalClusterStateTaskExecutor.Task> tasks = new ArrayList<>().     // to ensure that there is at least one removal     boolean first = true.     for (int i = 0. i < nodes. i++) {         final DiscoveryNode node = node(i).         builder.add(node).         if (first || randomBoolean()) {             tasks.add(new NodeRemovalClusterStateTaskExecutor.Task(node, randomBoolean() ? "left" : "failed")).         }         first = false.     }     final ClusterState clusterState = ClusterState.builder(new ClusterName("test")).nodes(builder).build().     final ClusterStateTaskExecutor.ClusterTasksResult<NodeRemovalClusterStateTaskExecutor.Task> result = executor.execute(clusterState, tasks).     verify(allocationService).disassociateDeadNodes(eq(remainingNodesClusterState.get()), eq(true), any(String.class)).     for (final NodeRemovalClusterStateTaskExecutor.Task task : tasks) {         assertNull(result.resultingState.nodes().get(task.node().getId())).     } }
false;private;1;3;;private DiscoveryNode node(final int id) {     return new DiscoveryNode(Integer.toString(id), buildNewFakeTransportAddress(), Version.CURRENT). }
