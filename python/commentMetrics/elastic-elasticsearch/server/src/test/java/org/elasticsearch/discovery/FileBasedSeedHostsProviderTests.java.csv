commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Before public void setUp() throws Exception {     super.setUp().     threadPool = new TestThreadPool(FileBasedSeedHostsProviderTests.class.getName()).     executorService = Executors.newSingleThreadExecutor().     createTransportSvc(). }
false;public;0;12;;@After public void tearDown() throws Exception {     try {         terminate(executorService).     } finally {         try {             terminate(threadPool).         } finally {             super.tearDown().         }     } }
false;public;0;7;;@Override public BoundTransportAddress boundAddress() {     return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(InetAddress.getLoopbackAddress(), 9300) }, new TransportAddress(InetAddress.getLoopbackAddress(), 9300)). }
false;private;0;17;;private void createTransportSvc() {     final MockNioTransport transport = new MockNioTransport(Settings.EMPTY, Version.CURRENT, threadPool, new NetworkService(Collections.emptyList()), PageCacheRecycler.NON_RECYCLING_INSTANCE, new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService()) {          @Override         public BoundTransportAddress boundAddress() {             return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(InetAddress.getLoopbackAddress(), 9300) }, new TransportAddress(InetAddress.getLoopbackAddress(), 9300)).         }     }.     transportService = new MockTransportService(Settings.EMPTY, transport, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, null). }
false;public;0;11;;public void testBuildDynamicNodes() throws Exception {     final List<String> hostEntries = Arrays.asList("#comment, should be ignored", "192.168.0.1", "192.168.0.2:9305", "255.255.23.15").     final List<TransportAddress> nodes = setupAndRunHostProvider(hostEntries).     // minus 1 because we are ignoring the first line that's a comment     assertEquals(hostEntries.size() - 1, nodes.size()).     assertEquals("192.168.0.1", nodes.get(0).getAddress()).     assertEquals(9300, nodes.get(0).getPort()).     assertEquals("192.168.0.2", nodes.get(1).getAddress()).     assertEquals(9305, nodes.get(1).getPort()).     assertEquals("255.255.23.15", nodes.get(2).getAddress()).     assertEquals(9300, nodes.get(2).getPort()). }
false;public;0;5;;public void testEmptyUnicastHostsFile() throws Exception {     final List<String> hostEntries = Collections.emptyList().     final List<TransportAddress> addresses = setupAndRunHostProvider(hostEntries).     assertEquals(0, addresses.size()). }
false;public;0;7;;public void testUnicastHostsDoesNotExist() {     final FileBasedSeedHostsProvider provider = new FileBasedSeedHostsProvider(createTempDir().toAbsolutePath()).     final List<TransportAddress> addresses = provider.getSeedAddresses((hosts, limitPortCounts) -> UnicastZenPing.resolveHostsLists(executorService, logger, hosts, limitPortCounts, transportService, TimeValue.timeValueSeconds(10))).     assertEquals(0, addresses.size()). }
false;public;0;5;;public void testInvalidHostEntries() throws Exception {     final List<String> hostEntries = Collections.singletonList("192.168.0.1:9300:9300").     final List<TransportAddress> addresses = setupAndRunHostProvider(hostEntries).     assertEquals(0, addresses.size()). }
false;public;0;7;;public void testSomeInvalidHostEntries() throws Exception {     final List<String> hostEntries = Arrays.asList("192.168.0.1:9300:9300", "192.168.0.1:9301").     final List<TransportAddress> addresses = setupAndRunHostProvider(hostEntries).     // only one of the two is valid and will be used     assertEquals(1, addresses.size()).     assertEquals("192.168.0.1", addresses.get(0).getAddress()).     assertEquals(9301, addresses.get(0).getPort()). }
true;private;1;12;// and then runs the file-based unicast host provider to get the list of discovery nodes ;// sets up the config dir, writes to the unicast hosts file in the config dir, // and then runs the file-based unicast host provider to get the list of discovery nodes private List<TransportAddress> setupAndRunHostProvider(final List<String> hostEntries) throws IOException {     final Path homeDir = createTempDir().     final Path configPath = randomBoolean() ? homeDir.resolve("config") : createTempDir().     Files.createDirectories(configPath).     try (BufferedWriter writer = Files.newBufferedWriter(configPath.resolve(UNICAST_HOSTS_FILE))) {         writer.write(String.join("\n", hostEntries)).     }     return new FileBasedSeedHostsProvider(configPath).getSeedAddresses((hosts, limitPortCounts) -> UnicastZenPing.resolveHostsLists(executorService, logger, hosts, limitPortCounts, transportService, TimeValue.timeValueSeconds(10))). }
