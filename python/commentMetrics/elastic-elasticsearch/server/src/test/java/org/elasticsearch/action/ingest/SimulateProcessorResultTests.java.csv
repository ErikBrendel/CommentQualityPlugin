commented;modifiers;parameterAmount;loc;comment;code
false;public;0;26;;public void testSerialization() throws IOException {     boolean isSuccessful = randomBoolean().     boolean isIgnoredException = randomBoolean().     SimulateProcessorResult simulateProcessorResult = createTestInstance(isSuccessful, isIgnoredException).     BytesStreamOutput out = new BytesStreamOutput().     simulateProcessorResult.writeTo(out).     StreamInput streamInput = out.bytes().streamInput().     SimulateProcessorResult otherSimulateProcessorResult = new SimulateProcessorResult(streamInput).     assertThat(otherSimulateProcessorResult.getProcessorTag(), equalTo(simulateProcessorResult.getProcessorTag())).     if (isSuccessful) {         assertIngestDocument(otherSimulateProcessorResult.getIngestDocument(), simulateProcessorResult.getIngestDocument()).         if (isIgnoredException) {             assertThat(otherSimulateProcessorResult.getFailure(), instanceOf(IllegalArgumentException.class)).             IllegalArgumentException e = (IllegalArgumentException) otherSimulateProcessorResult.getFailure().             assertThat(e.getMessage(), equalTo("test")).         } else {             assertThat(otherSimulateProcessorResult.getFailure(), nullValue()).         }     } else {         assertThat(otherSimulateProcessorResult.getIngestDocument(), is(nullValue())).         assertThat(otherSimulateProcessorResult.getFailure(), instanceOf(IllegalArgumentException.class)).         IllegalArgumentException e = (IllegalArgumentException) otherSimulateProcessorResult.getFailure().         assertThat(e.getMessage(), equalTo("test")).     } }
false;static;2;16;;static SimulateProcessorResult createTestInstance(boolean isSuccessful, boolean isIgnoredException) {     String processorTag = randomAlphaOfLengthBetween(1, 10).     SimulateProcessorResult simulateProcessorResult.     if (isSuccessful) {         IngestDocument ingestDocument = createRandomIngestDoc().         if (isIgnoredException) {             simulateProcessorResult = new SimulateProcessorResult(processorTag, ingestDocument, new IllegalArgumentException("test")).         } else {             simulateProcessorResult = new SimulateProcessorResult(processorTag, ingestDocument).         }     } else {         simulateProcessorResult = new SimulateProcessorResult(processorTag, new IllegalArgumentException("test")).     }     return simulateProcessorResult. }
false;private,static;0;5;;private static SimulateProcessorResult createTestInstanceWithFailures() {     boolean isSuccessful = randomBoolean().     boolean isIgnoredException = randomBoolean().     return createTestInstance(isSuccessful, isIgnoredException). }
false;protected;0;5;;@Override protected SimulateProcessorResult createTestInstance() {     // we test failures separately since comparing XContent is not possible with failures     return createTestInstance(true, false). }
false;protected;1;4;;@Override protected SimulateProcessorResult doParseInstance(XContentParser parser) {     return SimulateProcessorResult.fromXContent(parser). }
false;protected;0;4;;@Override protected boolean supportsUnknownFields() {     return true. }
false;protected;0;15;;@Override protected Predicate<String> getRandomFieldsExcludeFilter() {     // We cannot have random fields in the _source field and _ingest field     return field -> field.startsWith(new StringJoiner(".").add(WriteableIngestDocument.DOC_FIELD).add(WriteableIngestDocument.SOURCE_FIELD).toString()) || field.startsWith(new StringJoiner(".").add(WriteableIngestDocument.DOC_FIELD).add(WriteableIngestDocument.INGEST_FIELD).toString()). }
false;static;2;14;;static void assertEqualProcessorResults(SimulateProcessorResult response, SimulateProcessorResult parsedResponse) {     assertEquals(response.getProcessorTag(), parsedResponse.getProcessorTag()).     assertEquals(response.getIngestDocument(), parsedResponse.getIngestDocument()).     if (response.getFailure() != null) {         assertNotNull(parsedResponse.getFailure()).         assertThat(parsedResponse.getFailure().getMessage(), containsString(response.getFailure().getMessage())).     } else {         assertNull(parsedResponse.getFailure()).     } }
false;protected;2;4;;@Override protected void assertEqualInstances(SimulateProcessorResult response, SimulateProcessorResult parsedResponse) {     assertEqualProcessorResults(response, parsedResponse). }
true;public;0;11;/**  * Test parsing {@link SimulateProcessorResult} with inner failures as they don't support asserting on xcontent equivalence, given that  * exceptions are not parsed back as the same original class. We run the usual {@link AbstractXContentTestCase#testFromXContent()}  * without failures, and this other test with failures where we disable asserting on xcontent equivalence at the end.  */ ;/**  * Test parsing {@link SimulateProcessorResult} with inner failures as they don't support asserting on xcontent equivalence, given that  * exceptions are not parsed back as the same original class. We run the usual {@link AbstractXContentTestCase#testFromXContent()}  * without failures, and this other test with failures where we disable asserting on xcontent equivalence at the end.  */ public void testFromXContentWithFailures() throws IOException {     Supplier<SimulateProcessorResult> instanceSupplier = SimulateProcessorResultTests::createTestInstanceWithFailures.     // with random fields insertion in the inner exceptions, some random stuff may be parsed back as metadata,     // but that does not bother our assertions, as we only want to test that we don't break.     boolean supportsUnknownFields = true.     // exceptions are not of the same type whenever parsed back     boolean assertToXContentEquivalence = false.     AbstractXContentTestCase.testFromXContent(NUMBER_OF_TEST_RUNS, instanceSupplier, supportsUnknownFields, getShuffleFieldsExceptions(), getRandomFieldsExcludeFilter(), this::createParser, this::doParseInstance, this::assertEqualInstances, assertToXContentEquivalence, getToXContentParams()). }
