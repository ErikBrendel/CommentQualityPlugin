commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;6;/**  * setup for the whole base test class  */ ;/**  * setup for the whole base test class  */ @BeforeClass public static void init() {     SearchModule searchModule = new SearchModule(Settings.EMPTY, false, emptyList()).     namedWriteableRegistry = new NamedWriteableRegistry(searchModule.getNamedWriteables()).     xContentRegistry = new NamedXContentRegistry(searchModule.getNamedXContents()). }
false;public,static;0;5;;@AfterClass public static void afterClass() throws Exception {     namedWriteableRegistry = null.     xContentRegistry = null. }
true;public;0;9;/**  * Test serialization and deserialization of the suggestion builder  */ ;/**  * Test serialization and deserialization of the suggestion builder  */ public void testSerialization() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         SB original = randomTestBuilder().         SB deserialized = copy(original).         assertEquals(deserialized, original).         assertEquals(deserialized.hashCode(), original.hashCode()).         assertNotSame(deserialized, original).     } }
true;protected;0;4;/**  * returns a random suggestion builder, setting the common options randomly  */ ;/**  * returns a random suggestion builder, setting the common options randomly  */ protected SB randomTestBuilder() {     SB randomSuggestion = randomSuggestionBuilder().     return randomSuggestion. }
false;public,static;1;8;;public static void setCommonPropertiesOnRandomBuilder(SuggestionBuilder<?> randomSuggestion) {     // have to set the text because we don't know if the global text was set     randomSuggestion.text(randomAlphaOfLengthBetween(2, 20)).     maybeSet(randomSuggestion::prefix, randomAlphaOfLengthBetween(2, 20)).     maybeSet(randomSuggestion::regex, randomAlphaOfLengthBetween(2, 20)).     maybeSet(randomSuggestion::analyzer, randomAlphaOfLengthBetween(2, 20)).     maybeSet(randomSuggestion::size, randomIntBetween(1, 20)).     maybeSet(randomSuggestion::shardSize, randomIntBetween(1, 20)). }
true;protected,abstract;0;1;/**  * create a randomized {@link SuggestBuilder} that is used in further tests  */ ;/**  * create a randomized {@link SuggestBuilder} that is used in further tests  */ protected abstract SB randomSuggestionBuilder().
true;public;0;5;/**  * Test equality and hashCode properties  */ ;/**  * Test equality and hashCode properties  */ public void testEqualsAndHashcode() {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         checkEqualsAndHashCode(randomTestBuilder(), this::copy, this::mutate).     } }
true;public;0;23;/**  * creates random suggestion builder, renders it to xContent and back to new  * instance that should be equal to original  */ ;/**  * creates random suggestion builder, renders it to xContent and back to new  * instance that should be equal to original  */ public void testFromXContent() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         SB suggestionBuilder = randomTestBuilder().         XContentBuilder xContentBuilder = XContentFactory.contentBuilder(randomFrom(XContentType.values())).         if (randomBoolean()) {             xContentBuilder.prettyPrint().         }         xContentBuilder.startObject().         suggestionBuilder.toXContent(xContentBuilder, ToXContent.EMPTY_PARAMS).         xContentBuilder.endObject().         XContentBuilder shuffled = shuffleXContent(xContentBuilder, shuffleProtectedFields()).         try (XContentParser parser = createParser(shuffled)) {             // we need to skip the start object and the name, those will be parsed by outer SuggestBuilder             parser.nextToken().             SuggestionBuilder<?> secondSuggestionBuilder = SuggestionBuilder.fromXContent(parser).             assertNotSame(suggestionBuilder, secondSuggestionBuilder).             assertEquals(suggestionBuilder, secondSuggestionBuilder).             assertEquals(suggestionBuilder.hashCode(), secondSuggestionBuilder.hashCode()).         }     } }
false;public;0;53;;public void testBuild() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         SB suggestionBuilder = randomTestBuilder().         Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build().         IndexSettings idxSettings = IndexSettingsModule.newIndexSettings(new Index(randomAlphaOfLengthBetween(1, 10), "_na_"), indexSettings).         MapperService mapperService = mock(MapperService.class).         ScriptService scriptService = mock(ScriptService.class).         MappedFieldType fieldType = mockFieldType(suggestionBuilder.field()).         boolean fieldTypeSearchAnalyzerSet = randomBoolean().         if (fieldTypeSearchAnalyzerSet) {             NamedAnalyzer searchAnalyzer = new NamedAnalyzer("fieldSearchAnalyzer", AnalyzerScope.INDEX, new SimpleAnalyzer()).             if (Mockito.mockingDetails(fieldType).isMock()) {                 when(fieldType.searchAnalyzer()).thenReturn(searchAnalyzer).             } else {                 fieldType.setSearchAnalyzer(searchAnalyzer).             }         } else {             when(mapperService.searchAnalyzer()).thenReturn(new NamedAnalyzer("mapperServiceSearchAnalyzer", AnalyzerScope.INDEX, new SimpleAnalyzer())).         }         when(mapperService.fullName(any(String.class))).thenReturn(fieldType).         when(mapperService.getNamedAnalyzer(any(String.class))).then(invocation -> new NamedAnalyzer((String) invocation.getArguments()[0], AnalyzerScope.INDEX, new SimpleAnalyzer())).         when(scriptService.compile(any(Script.class), any())).then(invocation -> new TestTemplateService.MockTemplateScript.Factory(((Script) invocation.getArguments()[0]).getIdOrCode())).         QueryShardContext mockShardContext = new QueryShardContext(0, idxSettings, null, null, mapperService, null, scriptService, xContentRegistry(), namedWriteableRegistry, null, null, System::currentTimeMillis, null).         SuggestionContext suggestionContext = suggestionBuilder.build(mockShardContext).         assertEquals(toBytesRef(suggestionBuilder.text()), suggestionContext.getText()).         if (suggestionBuilder.text() != null && suggestionBuilder.prefix() == null) {             assertEquals(toBytesRef(suggestionBuilder.text()), suggestionContext.getPrefix()).         } else {             assertEquals(toBytesRef(suggestionBuilder.prefix()), suggestionContext.getPrefix()).         }         assertEquals(toBytesRef(suggestionBuilder.regex()), suggestionContext.getRegex()).         assertEquals(suggestionBuilder.field(), suggestionContext.getField()).         int expectedSize = suggestionBuilder.size() != null ? suggestionBuilder.size : 5.         assertEquals(expectedSize, suggestionContext.getSize()).         Integer expectedShardSize = suggestionBuilder.shardSize != null ? suggestionBuilder.shardSize : Math.max(expectedSize, 5).         assertEquals(expectedShardSize, suggestionContext.getShardSize()).         assertSame(mockShardContext, suggestionContext.getShardContext()).         if (suggestionBuilder.analyzer() != null) {             assertEquals(suggestionBuilder.analyzer(), ((NamedAnalyzer) suggestionContext.getAnalyzer()).name()).         } else if (fieldTypeSearchAnalyzerSet) {             assertEquals("fieldSearchAnalyzer", ((NamedAnalyzer) suggestionContext.getAnalyzer()).name()).         } else {             assertEquals("mapperServiceSearchAnalyzer", ((NamedAnalyzer) suggestionContext.getAnalyzer()).name()).         }         assertSuggestionContext(suggestionBuilder, suggestionContext).     } }
true;protected,abstract;2;1;/**  * put implementation dependent assertions in the sub-type test  */ ;/**  * put implementation dependent assertions in the sub-type test  */ protected abstract void assertSuggestionContext(SB builder, SuggestionContext context) throws IOException.
false;protected;1;5;;protected MappedFieldType mockFieldType(String fieldName) {     MappedFieldType fieldType = mock(MappedFieldType.class).     when(fieldType.name()).thenReturn(fieldName).     return fieldType. }
true;protected;0;3;/**  * Subclasses can override this method and return a set of fields which should be protected from  * recursive random shuffling in the {@link #testFromXContent()} test case  */ ;/**  * Subclasses can override this method and return a set of fields which should be protected from  * recursive random shuffling in the {@link #testFromXContent()} test case  */ protected String[] shuffleProtectedFields() {     return new String[0]. }
false;private;1;30;;private SB mutate(SB firstBuilder) throws IOException {     SB mutation = copy(firstBuilder).     assertNotSame(mutation, firstBuilder).     // change ither one of the shared SuggestionBuilder parameters, or delegate to the specific tests mutate method     if (randomBoolean()) {         switch(randomIntBetween(0, 5)) {             case 0:                 mutation.text(randomValueOtherThan(mutation.text(), () -> randomAlphaOfLengthBetween(2, 20))).                 break.             case 1:                 mutation.prefix(randomValueOtherThan(mutation.prefix(), () -> randomAlphaOfLengthBetween(2, 20))).                 break.             case 2:                 mutation.regex(randomValueOtherThan(mutation.regex(), () -> randomAlphaOfLengthBetween(2, 20))).                 break.             case 3:                 mutation.analyzer(randomValueOtherThan(mutation.analyzer(), () -> randomAlphaOfLengthBetween(2, 20))).                 break.             case 4:                 mutation.size(randomValueOtherThan(mutation.size(), () -> randomIntBetween(1, 20))).                 break.             case 5:                 mutation.shardSize(randomValueOtherThan(mutation.shardSize(), () -> randomIntBetween(1, 20))).                 break.         }     } else {         mutateSpecificParameters(firstBuilder).     }     return mutation. }
true;protected,abstract;1;1;/**  * take and input {@link SuggestBuilder} and return another one that is  * different in one aspect (to test non-equality)  */ ;/**  * take and input {@link SuggestBuilder} and return another one that is  * different in one aspect (to test non-equality)  */ protected abstract void mutateSpecificParameters(SB firstBuilder) throws IOException.
false;protected;1;5;;@SuppressWarnings("unchecked") protected SB copy(SB original) throws IOException {     return copyWriteable(original, namedWriteableRegistry, (Writeable.Reader<SB>) namedWriteableRegistry.getReader(SuggestionBuilder.class, original.getWriteableName())). }
false;protected;0;4;;@Override protected NamedXContentRegistry xContentRegistry() {     return xContentRegistry. }
