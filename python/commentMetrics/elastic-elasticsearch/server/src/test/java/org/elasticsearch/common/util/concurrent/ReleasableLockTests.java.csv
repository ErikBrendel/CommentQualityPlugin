commented;modifiers;parameterAmount;loc;comment;code
true;public;0;39;/**  * Test that accounting on whether or not a thread holds a releasable lock is correct. Previously we had a bug where on a re-entrant  * lock that if a thread entered the lock twice we would declare that it does not hold the lock after it exits its first entrance but  * not its second entrance.  *  * @throws BrokenBarrierException if awaiting on the synchronization barrier breaks  * @throws InterruptedException   if awaiting on the synchronization barrier is interrupted  */ ;/**  * Test that accounting on whether or not a thread holds a releasable lock is correct. Previously we had a bug where on a re-entrant  * lock that if a thread entered the lock twice we would declare that it does not hold the lock after it exits its first entrance but  * not its second entrance.  *  * @throws BrokenBarrierException if awaiting on the synchronization barrier breaks  * @throws InterruptedException   if awaiting on the synchronization barrier is interrupted  */ public void testIsHeldByCurrentThread() throws BrokenBarrierException, InterruptedException {     final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock().     final ReleasableLock readLock = new ReleasableLock(readWriteLock.readLock()).     final ReleasableLock writeLock = new ReleasableLock(readWriteLock.writeLock()).     final int numberOfThreads = scaledRandomIntBetween(1, 32).     final int iterations = scaledRandomIntBetween(1, 32).     final CyclicBarrier barrier = new CyclicBarrier(1 + numberOfThreads).     final List<Thread> threads = new ArrayList<>().     for (int i = 0. i < numberOfThreads. i++) {         final Thread thread = new Thread(() -> {             try {                 barrier.await().             } catch (final BrokenBarrierException | InterruptedException e) {                 throw new RuntimeException(e).             }             for (int j = 0. j < iterations. j++) {                 if (randomBoolean()) {                     acquire(readLock, writeLock).                 } else {                     acquire(writeLock, readLock).                 }             }             try {                 barrier.await().             } catch (final BrokenBarrierException | InterruptedException e) {                 throw new RuntimeException(e).             }         }).         threads.add(thread).         thread.start().     }     barrier.await().     barrier.await().     for (final Thread thread : threads) {         thread.join().     } }
false;private;2;15;;private void acquire(final ReleasableLock lockToAcquire, final ReleasableLock otherLock) {     try (@SuppressWarnings("unused") Releasable outer = lockToAcquire.acquire()) {         assertTrue(lockToAcquire.isHeldByCurrentThread()).         assertFalse(otherLock.isHeldByCurrentThread()).         try (@SuppressWarnings("unused") Releasable inner = lockToAcquire.acquire()) {             assertTrue(lockToAcquire.isHeldByCurrentThread()).             assertFalse(otherLock.isHeldByCurrentThread()).         }         // previously there was a bug here and this would return false         assertTrue(lockToAcquire.isHeldByCurrentThread()).         assertFalse(otherLock.isHeldByCurrentThread()).     }     assertFalse(lockToAcquire.isHeldByCurrentThread()).     assertFalse(otherLock.isHeldByCurrentThread()). }
