commented;modifiers;parameterAmount;loc;comment;code
false;public,static;3;6;;public static void corruptRandomTranslogFile(Logger logger, Random random, Collection<Path> translogDirs) throws IOException {     for (Path translogDir : translogDirs) {         final long minTranslogGen = minTranslogGenUsedInRecovery(translogDir).         corruptRandomTranslogFile(logger, random, translogDir, minTranslogGen).     } }
true;public,static;4;19;/**  * Corrupts random translog file (translog-N.tlog) from the given translog directory.  *  * @return a translog file which has been corrupted.  */ ;/**  * Corrupts random translog file (translog-N.tlog) from the given translog directory.  *  * @return a translog file which has been corrupted.  */ public static Path corruptRandomTranslogFile(Logger logger, Random random, Path translogDir, long minGeneration) throws IOException {     // TreeSet makes sure iteration order is deterministic     Set<Path> candidates = new TreeSet<>().     logger.info("--> Translog dir [{}], minUsedTranslogGen [{}]", translogDir, minGeneration).     try (DirectoryStream<Path> stream = Files.newDirectoryStream(translogDir)) {         for (Path item : stream) {             if (Files.isRegularFile(item)) {                 final Matcher matcher = TRANSLOG_FILE_PATTERN.matcher(item.getFileName().toString()).                 if (matcher.matches() && Long.parseLong(matcher.group(1)) >= minGeneration) {                     candidates.add(item).                 }             }         }     }     assertThat(candidates, is(not(empty()))).     Path corruptedFile = RandomPicks.randomFrom(random, candidates).     corruptFile(logger, random, corruptedFile).     return corruptedFile. }
false;static;3;22;;static void corruptFile(Logger logger, Random random, Path fileToCorrupt) throws IOException {     try (FileChannel raf = FileChannel.open(fileToCorrupt, StandardOpenOption.READ, StandardOpenOption.WRITE)) {         // read         raf.position(RandomNumbers.randomLongBetween(random, 0, raf.size() - 1)).         long filePointer = raf.position().         ByteBuffer bb = ByteBuffer.wrap(new byte[1]).         raf.read(bb).         bb.flip().         // corrupt         byte oldValue = bb.get(0).         byte newValue = (byte) (oldValue + 1).         bb.put(0, newValue).         // rewrite         raf.position(filePointer).         raf.write(bb).         logger.info("--> corrupting file {} --  flipping at position {} from {} to {} file: {}", fileToCorrupt, filePointer, Integer.toHexString(oldValue), Integer.toHexString(newValue), fileToCorrupt).     } }
true;public,static;1;9;/**  * Lists all existing commits in a given index path, then read the minimum translog generation that will be used in recoverFromTranslog.  */ ;/**  * Lists all existing commits in a given index path, then read the minimum translog generation that will be used in recoverFromTranslog.  */ public static long minTranslogGenUsedInRecovery(Path translogPath) throws IOException {     try (NIOFSDirectory directory = new NIOFSDirectory(translogPath.getParent().resolve("index"))) {         List<IndexCommit> commits = DirectoryReader.listCommits(directory).         final String translogUUID = commits.get(commits.size() - 1).getUserData().get(Translog.TRANSLOG_UUID_KEY).         long globalCheckpoint = Translog.readGlobalCheckpoint(translogPath, translogUUID).         IndexCommit recoveringCommit = CombinedDeletionPolicy.findSafeCommitPoint(commits, globalCheckpoint).         return Long.parseLong(recoveringCommit.getUserData().get(Translog.TRANSLOG_GENERATION_KEY)).     } }
true;public,static;1;3;/**  * Returns the primary term associated with the current translog writer of the given translog.  */ ;/**  * Returns the primary term associated with the current translog writer of the given translog.  */ public static long getCurrentTerm(Translog translog) {     return translog.getCurrent().getPrimaryTerm(). }
false;public,static;2;11;;public static List<Translog.Operation> drainSnapshot(Translog.Snapshot snapshot, boolean sortBySeqNo) throws IOException {     final List<Translog.Operation> ops = new ArrayList<>(snapshot.totalOperations()).     Translog.Operation op.     while ((op = snapshot.next()) != null) {         ops.add(op).     }     if (sortBySeqNo) {         ops.sort(Comparator.comparing(Translog.Operation::seqNo)).     }     return ops. }
