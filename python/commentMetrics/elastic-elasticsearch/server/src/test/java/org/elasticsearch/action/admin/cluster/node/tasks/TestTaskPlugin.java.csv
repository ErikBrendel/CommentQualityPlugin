commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Override public List<ActionHandler<? extends ActionRequest, ? extends ActionResponse>> getActions() {     return Arrays.asList(new ActionHandler<>(TestTaskAction.INSTANCE, TransportTestTaskAction.class), new ActionHandler<>(UnblockTestTasksAction.INSTANCE, TransportUnblockTestTasksAction.class)). }
false;public;0;4;;@Override public Collection<String> getTaskHeaders() {     return Collections.singleton("Custom-Task-Header"). }
true;public;2;4;/**  * Intercept transport requests to verify that all of the ones that should  * have the origin set <strong>do</strong> have the origin set and the ones  * that should not have the origin set <strong>do not</strong> have it set.  */ ;/**  * Intercept transport requests to verify that all of the ones that should  * have the origin set <strong>do</strong> have the origin set and the ones  * that should not have the origin set <strong>do not</strong> have it set.  */ @Override public List<TransportInterceptor> getTransportInterceptors(NamedWriteableRegistry namedWriteableRegistry, ThreadContext threadContext) {     return Collections.singletonList(new OriginAssertingInterceptor(threadContext)). }
false;public;0;4;;@Override public boolean shouldCancelChildrenOnCancellation() {     return false. }
false;public;0;3;;public boolean isBlocked() {     return blocked. }
false;public;0;3;;public void unblock() {     blocked = false. }
false;protected;1;4;;@Override protected List<NodeResponse> readNodesFrom(StreamInput in) throws IOException {     return in.readStreamableList(NodeResponse::new). }
false;protected;2;4;;@Override protected void writeNodesTo(StreamOutput out, List<NodeResponse> nodes) throws IOException {     out.writeStreamableList(nodes). }
false;public;0;3;;public int getFailureCount() {     return failures().size(). }
false;public;2;5;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field("failure_count", getFailureCount()).     return builder. }
false;public;1;7;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     requestName = in.readString().     nodeId = in.readString().     shouldBlock = in.readBoolean(). }
false;public;1;7;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(requestName).     out.writeString(nodeId).     out.writeBoolean(shouldBlock). }
false;public;0;4;;@Override public String getDescription() {     return "NodeRequest[" + requestName + ", " + nodeId + "]". }
false;public;5;4;;@Override public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {     return new TestTask(id, type, action, this.getDescription(), parentTaskId, headers). }
false;public;1;3;;public void setShouldStoreResult(boolean shouldStoreResult) {     this.shouldStoreResult = shouldStoreResult. }
false;public;0;4;;@Override public boolean getShouldStoreResult() {     return shouldStoreResult. }
false;public;1;3;;public void setShouldBlock(boolean shouldBlock) {     this.shouldBlock = shouldBlock. }
false;public;0;3;;public boolean getShouldBlock() {     return shouldBlock. }
false;public;1;3;;public void setShouldFail(boolean shouldFail) {     this.shouldFail = shouldFail. }
false;public;0;3;;public boolean getShouldFail() {     return shouldFail. }
false;public;1;8;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     requestName = in.readString().     shouldStoreResult = in.readBoolean().     shouldBlock = in.readBoolean().     shouldFail = in.readBoolean(). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeString(requestName).     out.writeBoolean(shouldStoreResult).     out.writeBoolean(shouldBlock).     out.writeBoolean(shouldFail). }
false;public;0;4;;@Override public String getDescription() {     return "NodesRequest[" + requestName + "]". }
false;public;0;4;;@Override public boolean shouldCancelChildrenOnCancellation() {     return true. }
false;public;5;9;;@Override public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {     return new CancellableTask(id, type, action, getDescription(), parentTaskId, headers) {          @Override         public boolean shouldCancelChildrenOnCancellation() {             return true.         }     }. }
false;protected;3;7;;@Override protected NodesResponse newResponse(NodesRequest request, List<NodeResponse> responses, List<FailedNodeException> failures) {     if (request.getShouldFail()) {         throw new IllegalStateException("Simulating operation failure").     }     return new NodesResponse(clusterService.getClusterName(), responses, failures). }
false;protected;2;4;;@Override protected NodeRequest newNodeRequest(String nodeId, NodesRequest request) {     return new NodeRequest(request, nodeId, request.getShouldBlock()). }
false;protected;0;4;;@Override protected NodeResponse newNodeResponse() {     return new NodeResponse(). }
false;protected;3;4;;@Override protected void doExecute(Task task, NodesRequest request, ActionListener<NodesResponse> listener) {     super.doExecute(task, request, listener). }
false;protected;2;18;;@Override protected NodeResponse nodeOperation(NodeRequest request, Task task) {     logger.info("Test task started on the node {}", clusterService.localNode()).     if (request.shouldBlock) {         try {             awaitBusy(() -> {                 if (((CancellableTask) task).isCancelled()) {                     throw new RuntimeException("Cancelled!").                 }                 return ((TestTask) task).isBlocked() == false.             }).         } catch (InterruptedException ex) {             Thread.currentThread().interrupt().         }     }     logger.info("Test task finished on the node {}", clusterService.localNode()).     return new NodeResponse(clusterService.localNode()). }
false;protected;1;4;;@Override protected NodeResponse nodeOperation(NodeRequest request) {     throw new UnsupportedOperationException("the task parameter is required"). }
false;public;0;4;;@Override public NodesResponse newResponse() {     return new NodesResponse(). }
false;public;1;4;;public NodesRequestBuilder setShouldStoreResult(boolean shouldStoreResult) {     request().setShouldStoreResult(shouldStoreResult).     return this. }
false;public;1;4;;public NodesRequestBuilder setShouldBlock(boolean shouldBlock) {     request().setShouldBlock(shouldBlock).     return this. }
false;public;1;4;;public NodesRequestBuilder setShouldFail(boolean shouldFail) {     request().setShouldFail(shouldFail).     return this. }
false;public;1;3;;@Override public void writeTo(StreamOutput out) throws IOException { }
false;public;1;4;;@Override public boolean match(Task task) {     return task instanceof TestTask && super.match(task). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVInt(tasks.size()).     for (UnblockTestTaskResponse task : tasks) {         task.writeTo(out).     } }
false;protected;4;6;;@Override protected UnblockTestTasksResponse newResponse(UnblockTestTasksRequest request, List<UnblockTestTaskResponse> tasks, List<TaskOperationFailure> taskOperationFailures, List<FailedNodeException> failedNodeExceptions) {     return new UnblockTestTasksResponse(tasks, taskOperationFailures, failedNodeExceptions). }
false;protected;3;5;;@Override protected void taskOperation(UnblockTestTasksRequest request, Task task, ActionListener<UnblockTestTaskResponse> listener) {     ((TestTask) task).unblock().     listener.onResponse(new UnblockTestTaskResponse()). }
false;public;0;4;;@Override public UnblockTestTasksResponse newResponse() {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;public;0;4;;@Override public Writeable.Reader<UnblockTestTasksResponse> getResponseReader() {     return UnblockTestTasksResponse::new. }
false;public;5;27;;@Override public <T extends TransportResponse> void sendRequest(Transport.Connection connection, String action, TransportRequest request, TransportRequestOptions options, TransportResponseHandler<T> handler) {     if (action.startsWith("indices:data/write/bulk[s]")) {         /*                          * We can't reason about these requests because                          * *sometimes* they should have the origin, if they are                          * running on the node that stores the task. But                          * sometimes they won't be and in that case they don't                          * need the origin. Either way, the interesting work is                          * done by checking that the main bulk request                          * (without the [s] part) has the origin.                          */         sender.sendRequest(connection, action, request, options, handler).         return.     }     String expectedOrigin = shouldHaveOrigin(action, request) ? TASKS_ORIGIN : null.     String actualOrigin = threadContext.getTransient(ThreadContext.ACTION_ORIGIN_TRANSIENT_NAME).     if (Objects.equals(expectedOrigin, actualOrigin)) {         sender.sendRequest(connection, action, request, options, handler).         return.     }     handler.handleException(new TransportException("should have origin of [" + expectedOrigin + "] but was [" + actualOrigin + "] action was [" + action + "][" + request + "]")). }
false;public;1;32;;@Override public AsyncSender interceptSender(AsyncSender sender) {     return new AsyncSender() {          @Override         public <T extends TransportResponse> void sendRequest(Transport.Connection connection, String action, TransportRequest request, TransportRequestOptions options, TransportResponseHandler<T> handler) {             if (action.startsWith("indices:data/write/bulk[s]")) {                 /*                          * We can't reason about these requests because                          * *sometimes* they should have the origin, if they are                          * running on the node that stores the task. But                          * sometimes they won't be and in that case they don't                          * need the origin. Either way, the interesting work is                          * done by checking that the main bulk request                          * (without the [s] part) has the origin.                          */                 sender.sendRequest(connection, action, request, options, handler).                 return.             }             String expectedOrigin = shouldHaveOrigin(action, request) ? TASKS_ORIGIN : null.             String actualOrigin = threadContext.getTransient(ThreadContext.ACTION_ORIGIN_TRANSIENT_NAME).             if (Objects.equals(expectedOrigin, actualOrigin)) {                 sender.sendRequest(connection, action, request, options, handler).                 return.             }             handler.handleException(new TransportException("should have origin of [" + expectedOrigin + "] but was [" + actualOrigin + "] action was [" + action + "][" + request + "]")).         }     }. }
false;private;2;25;;private boolean shouldHaveOrigin(String action, TransportRequest request) {     if (false == action.startsWith("indices:")) {         /*                  * The Tasks API never uses origin with non-indices actions.                  */         return false.     }     if (action.startsWith("indices:admin/refresh") || action.startsWith("indices:data/read/search")) {         /*                  * The test refreshes and searches to count the number of tasks                  * in the index and the Tasks API never does either.                  */         return false.     }     if (false == (request instanceof IndicesRequest)) {         return false.     }     IndicesRequest ir = (IndicesRequest) request.     /*              * When the API Tasks API makes an indices request it only every              * targets the .tasks index. Other requests come from the tests.              */     return Arrays.equals(new String[] { ".tasks" }, ir.indices()). }
