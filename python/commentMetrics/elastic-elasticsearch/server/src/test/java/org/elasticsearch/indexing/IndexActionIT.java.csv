commented;modifiers;parameterAmount;loc;comment;code
false;public;0;55;;/**  * This test tries to simulate load while creating an index and indexing documents  * while the index is being created.  */ @TestLogging("_root:DEBUG,org.elasticsearch.index.shard.IndexShard:TRACE,org.elasticsearch.action.search:TRACE") public void testAutoGenerateIdNoDuplicates() throws Exception {     int numberOfIterations = scaledRandomIntBetween(10, 50).     for (int i = 0. i < numberOfIterations. i++) {         Exception firstError = null.         createIndex("test").         int numOfDocs = randomIntBetween(10, 100).         logger.info("indexing [{}] docs", numOfDocs).         List<IndexRequestBuilder> builders = new ArrayList<>(numOfDocs).         for (int j = 0. j < numOfDocs. j++) {             builders.add(client().prepareIndex("test", "type").setSource("field", "value_" + j)).         }         indexRandom(true, builders).         logger.info("verifying indexed content").         int numOfChecks = randomIntBetween(8, 12).         for (int j = 0. j < numOfChecks. j++) {             try {                 logger.debug("running search with all types").                 SearchResponse response = client().prepareSearch("test").get().                 if (response.getHits().getTotalHits().value != numOfDocs) {                     final String message = "Count is " + response.getHits().getTotalHits().value + " but " + numOfDocs + " was expected. " + ElasticsearchAssertions.formatShardStatus(response).                     logger.error("{}. search response: \n{}", message, response).                     fail(message).                 }             } catch (Exception e) {                 logger.error("search for all docs types failed", e).                 if (firstError == null) {                     firstError = e.                 }             }             try {                 logger.debug("running search with a specific type").                 SearchResponse response = client().prepareSearch("test").setTypes("type").get().                 if (response.getHits().getTotalHits().value != numOfDocs) {                     final String message = "Count is " + response.getHits().getTotalHits().value + " but " + numOfDocs + " was expected. " + ElasticsearchAssertions.formatShardStatus(response).                     logger.error("{}. search response: \n{}", message, response).                     fail(message).                 }             } catch (Exception e) {                 logger.error("search for all docs of a specific type failed", e).                 if (firstError == null) {                     firstError = e.                 }             }         }         if (firstError != null) {             fail(firstError.getMessage()).         }         internalCluster().wipeIndices("test").     } }
false;public;0;16;;public void testCreatedFlag() throws Exception {     createIndex("test").     ensureGreen().     IndexResponse indexResponse = client().prepareIndex("test", "type", "1").setSource("field1", "value1_1").execute().actionGet().     assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult()).     indexResponse = client().prepareIndex("test", "type", "1").setSource("field1", "value1_2").execute().actionGet().     assertEquals(DocWriteResponse.Result.UPDATED, indexResponse.getResult()).     client().prepareDelete("test", "type", "1").execute().actionGet().     indexResponse = client().prepareIndex("test", "type", "1").setSource("field1", "value1_2").execute().actionGet().     assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult()). }
false;public;0;14;;public void testCreatedFlagWithFlush() throws Exception {     createIndex("test").     ensureGreen().     IndexResponse indexResponse = client().prepareIndex("test", "type", "1").setSource("field1", "value1_1").execute().actionGet().     assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult()).     client().prepareDelete("test", "type", "1").execute().actionGet().     flush().     indexResponse = client().prepareIndex("test", "type", "1").setSource("field1", "value1_2").execute().actionGet().     assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult()). }
false;public;0;9;;@Override public Void call() throws Exception {     int docId = random.nextInt(docCount).     IndexResponse indexResponse = index("test", "type", Integer.toString(docId), "field1", "value").     if (indexResponse.getResult() == DocWriteResponse.Result.CREATED) {         createdCounts.incrementAndGet(docId).     }     return null. }
false;public;0;33;;public void testCreatedFlagParallelExecution() throws Exception {     createIndex("test").     ensureGreen().     int threadCount = 20.     final int docCount = 300.     int taskCount = docCount * threadCount.     final AtomicIntegerArray createdCounts = new AtomicIntegerArray(docCount).     ExecutorService threadPool = Executors.newFixedThreadPool(threadCount).     List<Callable<Void>> tasks = new ArrayList<>(taskCount).     final Random random = random().     for (int i = 0. i < taskCount. i++) {         tasks.add(new Callable<Void>() {              @Override             public Void call() throws Exception {                 int docId = random.nextInt(docCount).                 IndexResponse indexResponse = index("test", "type", Integer.toString(docId), "field1", "value").                 if (indexResponse.getResult() == DocWriteResponse.Result.CREATED) {                     createdCounts.incrementAndGet(docId).                 }                 return null.             }         }).     }     threadPool.invokeAll(tasks).     for (int i = 0. i < docCount. i++) {         assertThat(createdCounts.get(i), lessThanOrEqualTo(1)).     }     terminate(threadPool). }
false;public;0;8;;public void testCreatedFlagWithExternalVersioning() throws Exception {     createIndex("test").     ensureGreen().     IndexResponse indexResponse = client().prepareIndex("test", "type", "1").setSource("field1", "value1_1").setVersion(123).setVersionType(VersionType.EXTERNAL).execute().actionGet().     assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult()). }
false;public;0;11;;public void testCreateFlagWithBulk() {     createIndex("test").     ensureGreen().     BulkResponse bulkResponse = client().prepareBulk().add(client().prepareIndex("test", "type", "1").setSource("field1", "value1_1")).execute().actionGet().     assertThat(bulkResponse.hasFailures(), equalTo(false)).     assertThat(bulkResponse.getItems().length, equalTo(1)).     IndexResponse indexResponse = bulkResponse.getItems()[0].getResponse().     assertEquals(DocWriteResponse.Result.CREATED, indexResponse.getResult()). }
false;public;0;33;;public void testCreateIndexWithLongName() {     int min = MetaDataCreateIndexService.MAX_INDEX_NAME_BYTES + 1.     int max = MetaDataCreateIndexService.MAX_INDEX_NAME_BYTES * 2.     try {         createIndex(randomAlphaOfLengthBetween(min, max).toLowerCase(Locale.ROOT)).         fail("exception should have been thrown on too-long index name").     } catch (InvalidIndexNameException e) {         assertThat("exception contains message about index name too long: " + e.getMessage(), e.getMessage().contains("index name is too long,"), equalTo(true)).     }     try {         client().prepareIndex(randomAlphaOfLengthBetween(min, max).toLowerCase(Locale.ROOT), "mytype").setSource("foo", "bar").get().         fail("exception should have been thrown on too-long index name").     } catch (InvalidIndexNameException e) {         assertThat("exception contains message about index name too long: " + e.getMessage(), e.getMessage().contains("index name is too long,"), equalTo(true)).     }     try {         // Catch chars that are more than a single byte         client().prepareIndex(randomAlphaOfLength(MetaDataCreateIndexService.MAX_INDEX_NAME_BYTES - 1).toLowerCase(Locale.ROOT) + "Ïž".toLowerCase(Locale.ROOT), "mytype").setSource("foo", "bar").get().         fail("exception should have been thrown on too-long index name").     } catch (InvalidIndexNameException e) {         assertThat("exception contains message about index name too long: " + e.getMessage(), e.getMessage().contains("index name is too long,"), equalTo(true)).     }     // we can create an index of max length     createIndex(randomAlphaOfLength(MetaDataCreateIndexService.MAX_INDEX_NAME_BYTES).toLowerCase(Locale.ROOT)). }
false;public;0;17;;public void testInvalidIndexName() {     try {         createIndex(".").         fail("exception should have been thrown on dot index name").     } catch (InvalidIndexNameException e) {         assertThat("exception contains message about index name is dot " + e.getMessage(), e.getMessage().contains("Invalid index name [.], must not be \'.\' or '..'"), equalTo(true)).     }     try {         createIndex("..").         fail("exception should have been thrown on dot index name").     } catch (InvalidIndexNameException e) {         assertThat("exception contains message about index name is dot " + e.getMessage(), e.getMessage().contains("Invalid index name [..], must not be \'.\' or '..'"), equalTo(true)).     } }
false;public;0;9;;public void testDocumentWithBlankFieldName() {     MapperParsingException e = expectThrows(MapperParsingException.class, () -> {         client().prepareIndex("test", "type", "1").setSource("", "value1_2").execute().actionGet().     }).     assertThat(e.getMessage(), containsString("failed to parse")).     assertThat(e.getRootCause().getMessage(), containsString("field name cannot be an empty string")). }
