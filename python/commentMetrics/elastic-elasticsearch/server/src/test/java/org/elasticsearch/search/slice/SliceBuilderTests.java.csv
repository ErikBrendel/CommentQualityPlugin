commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String[] indices() {     return indices. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return null. }
false;public;0;4;;@Override public ShardId shardId() {     return new ShardId(new Index(indices[0], indices[0]), shardId). }
false;public;0;4;;@Override public String[] types() {     return new String[0]. }
false;public;0;4;;@Override public SearchSourceBuilder source() {     return null. }
false;public;0;4;;@Override public AliasFilter getAliasFilter() {     return null. }
false;public;1;4;;@Override public void setAliasFilter(AliasFilter filter) { }
false;public;1;4;;@Override public void source(SearchSourceBuilder source) { }
false;public;0;4;;@Override public int numberOfShards() {     return 0. }
false;public;0;4;;@Override public SearchType searchType() {     return null. }
false;public;0;4;;@Override public float indexBoost() {     return 0. }
false;public;0;4;;@Override public long nowInMillis() {     return 0. }
false;public;0;4;;@Override public Boolean requestCache() {     return null. }
false;public;0;4;;@Override public boolean allowPartialSearchResults() {     return true. }
false;public;0;4;;@Override public Scroll scroll() {     return null. }
false;public;0;4;;@Override public String[] indexRoutings() {     return indexRoutings. }
false;public;0;4;;@Override public String preference() {     return preference. }
false;public;0;4;;@Override public BytesReference cacheKey() {     return null. }
false;public;0;4;;@Override public String getClusterAlias() {     return null. }
false;public;0;4;;@Override public Rewriteable<Rewriteable> getRewriteable() {     return null. }
false;private,static;0;6;;private static SliceBuilder randomSliceBuilder() {     int max = randomIntBetween(2, MAX_SLICE).     int id = randomIntBetween(1, max - 1).     String field = randomAlphaOfLengthBetween(5, 20).     return new SliceBuilder(field, id, max). }
false;private,static;1;3;;private static SliceBuilder serializedCopy(SliceBuilder original) throws IOException {     return copyWriteable(original, new NamedWriteableRegistry(Collections.emptyList()), SliceBuilder::new). }
false;private,static;1;8;;private static SliceBuilder mutate(SliceBuilder original) {     switch(randomIntBetween(0, 2)) {         case 0:             return new SliceBuilder(original.getField() + "_xyz", original.getId(), original.getMax()).         case 1:             return new SliceBuilder(original.getField(), original.getId() - 1, original.getMax()).         case 2:         default:             return new SliceBuilder(original.getField(), original.getId(), original.getMax() + 1).     } }
false;private;2;9;;private IndexSettings createIndexSettings(Version indexVersionCreated, int numShards) {     Settings settings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, indexVersionCreated).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, numShards).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 0).build().     IndexMetaData indexState = IndexMetaData.builder("index").settings(settings).build().     return new IndexSettings(indexState, Settings.EMPTY). }
false;private;1;3;;private ShardSearchRequest createRequest(int shardId) {     return createRequest(shardId, Strings.EMPTY_ARRAY, null). }
false;private;3;3;;private ShardSearchRequest createRequest(int shardId, String[] routings, String preference) {     return new ShardSearchRequestTest("index", shardId, routings, preference). }
false;public;0;4;;@Override public MappedFieldType clone() {     return null. }
false;public;0;4;;@Override public String typeName() {     return null. }
false;public;2;4;;@Override public Query termQuery(Object value, @Nullable QueryShardContext context) {     return null. }
false;public;1;3;;public Query existsQuery(QueryShardContext context) {     return null. }
false;private;6;38;;private QueryShardContext createShardContext(Version indexVersionCreated, IndexReader reader, String fieldName, DocValuesType dvType, int numShards, int shardId) {     MappedFieldType fieldType = new MappedFieldType() {          @Override         public MappedFieldType clone() {             return null.         }          @Override         public String typeName() {             return null.         }          @Override         public Query termQuery(Object value, @Nullable QueryShardContext context) {             return null.         }          public Query existsQuery(QueryShardContext context) {             return null.         }     }.     fieldType.setName(fieldName).     QueryShardContext context = mock(QueryShardContext.class).     when(context.fieldMapper(fieldName)).thenReturn(fieldType).     when(context.getIndexReader()).thenReturn(reader).     when(context.getShardId()).thenReturn(shardId).     IndexSettings indexSettings = createIndexSettings(indexVersionCreated, numShards).     when(context.getIndexSettings()).thenReturn(indexSettings).     if (dvType != null) {         fieldType.setHasDocValues(true).         fieldType.setDocValuesType(dvType).         IndexNumericFieldData fd = mock(IndexNumericFieldData.class).         when(context.getForField(fieldType)).thenReturn(fd).     }     return context. }
false;public;0;7;;public void testSerialization() throws Exception {     SliceBuilder original = randomSliceBuilder().     SliceBuilder deserialized = serializedCopy(original).     assertEquals(deserialized, original).     assertEquals(deserialized.hashCode(), original.hashCode()).     assertNotSame(deserialized, original). }
false;public;0;3;;public void testEqualsAndHashcode() throws Exception {     checkEqualsAndHashCode(randomSliceBuilder(), SliceBuilderTests::serializedCopy, SliceBuilderTests::mutate). }
false;public;0;16;;public void testFromXContent() throws Exception {     SliceBuilder sliceBuilder = randomSliceBuilder().     XContentBuilder builder = XContentFactory.contentBuilder(randomFrom(XContentType.values())).     if (randomBoolean()) {         builder.prettyPrint().     }     builder.startObject().     sliceBuilder.innerToXContent(builder).     builder.endObject().     try (XContentParser parser = createParser(shuffleXContent(builder))) {         SliceBuilder secondSliceBuilder = SliceBuilder.fromXContent(parser).         assertNotSame(sliceBuilder, secondSliceBuilder).         assertEquals(sliceBuilder, secondSliceBuilder).         assertEquals(sliceBuilder.hashCode(), secondSliceBuilder.hashCode()).     } }
false;public;0;18;;public void testInvalidArguments() throws Exception {     Exception e = expectThrows(IllegalArgumentException.class, () -> new SliceBuilder("field", -1, 10)).     assertEquals("id must be greater than or equal to 0", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new SliceBuilder("field", 10, -1)).     assertEquals("max must be greater than 1", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new SliceBuilder("field", 10, 0)).     assertEquals("max must be greater than 1", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new SliceBuilder("field", 10, 5)).     assertEquals("max must be greater than id", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new SliceBuilder("field", 1000, 1000)).     assertEquals("max must be greater than id", e.getMessage()).     e = expectThrows(IllegalArgumentException.class, () -> new SliceBuilder("field", 1001, 1000)).     assertEquals("max must be greater than id", e.getMessage()). }
false;public;0;19;;public void testToFilterSimple() throws IOException {     Directory dir = new RAMDirectory().     try (IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())))) {         writer.commit().     }     try (IndexReader reader = DirectoryReader.open(dir)) {         QueryShardContext context = createShardContext(Version.CURRENT, reader, "_id", DocValuesType.SORTED_NUMERIC, 1, 0).         SliceBuilder builder = new SliceBuilder(5, 10).         Query query = builder.toFilter(null, createRequest(0), context, Version.CURRENT).         assertThat(query, instanceOf(TermsSliceQuery.class)).         assertThat(builder.toFilter(null, createRequest(0), context, Version.CURRENT), equalTo(query)).         try (IndexReader newReader = DirectoryReader.open(dir)) {             when(context.getIndexReader()).thenReturn(newReader).             assertThat(builder.toFilter(null, createRequest(0), context, Version.CURRENT), equalTo(query)).         }     } }
false;public;0;82;;public void testToFilterRandom() throws IOException {     Directory dir = new RAMDirectory().     try (IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())))) {         writer.commit().     }     try (IndexReader reader = DirectoryReader.open(dir)) {         QueryShardContext context = createShardContext(Version.CURRENT, reader, "field", DocValuesType.SORTED_NUMERIC, 1, 0).         SliceBuilder builder = new SliceBuilder("field", 5, 10).         Query query = builder.toFilter(null, createRequest(0), context, Version.CURRENT).         assertThat(query, instanceOf(DocValuesSliceQuery.class)).         assertThat(builder.toFilter(null, createRequest(0), context, Version.CURRENT), equalTo(query)).         try (IndexReader newReader = DirectoryReader.open(dir)) {             when(context.getIndexReader()).thenReturn(newReader).             assertThat(builder.toFilter(null, createRequest(0), context, Version.CURRENT), equalTo(query)).         }         // numSlices > numShards         int numSlices = randomIntBetween(10, 100).         int numShards = randomIntBetween(1, 9).         Map<Integer, AtomicInteger> numSliceMap = new HashMap<>().         for (int i = 0. i < numSlices. i++) {             for (int j = 0. j < numShards. j++) {                 SliceBuilder slice = new SliceBuilder("_id", i, numSlices).                 context = createShardContext(Version.CURRENT, reader, "_id", DocValuesType.SORTED, numShards, j).                 Query q = slice.toFilter(null, createRequest(j), context, Version.CURRENT).                 if (q instanceof TermsSliceQuery || q instanceof MatchAllDocsQuery) {                     AtomicInteger count = numSliceMap.get(j).                     if (count == null) {                         count = new AtomicInteger(0).                         numSliceMap.put(j, count).                     }                     count.incrementAndGet().                     if (q instanceof MatchAllDocsQuery) {                         assertThat(count.get(), equalTo(1)).                     }                 } else {                     assertThat(q, instanceOf(MatchNoDocsQuery.class)).                 }             }         }         int total = 0.         for (Map.Entry<Integer, AtomicInteger> e : numSliceMap.entrySet()) {             total += e.getValue().get().         }         assertThat(total, equalTo(numSlices)).         // numShards > numSlices         numShards = randomIntBetween(4, 100).         numSlices = randomIntBetween(2, numShards - 1).         List<Integer> targetShards = new ArrayList<>().         for (int i = 0. i < numSlices. i++) {             for (int j = 0. j < numShards. j++) {                 SliceBuilder slice = new SliceBuilder("_id", i, numSlices).                 context = createShardContext(Version.CURRENT, reader, "_id", DocValuesType.SORTED, numShards, j).                 Query q = slice.toFilter(null, createRequest(j), context, Version.CURRENT).                 if (q instanceof MatchNoDocsQuery == false) {                     assertThat(q, instanceOf(MatchAllDocsQuery.class)).                     targetShards.add(j).                 }             }         }         assertThat(targetShards.size(), equalTo(numShards)).         assertThat(new HashSet<>(targetShards).size(), equalTo(numShards)).         // numShards == numSlices         numShards = randomIntBetween(2, 10).         numSlices = numShards.         for (int i = 0. i < numSlices. i++) {             for (int j = 0. j < numShards. j++) {                 SliceBuilder slice = new SliceBuilder("_id", i, numSlices).                 context = createShardContext(Version.CURRENT, reader, "_id", DocValuesType.SORTED, numShards, j).                 Query q = slice.toFilter(null, createRequest(j), context, Version.CURRENT).                 if (i == j) {                     assertThat(q, instanceOf(MatchAllDocsQuery.class)).                 } else {                     assertThat(q, instanceOf(MatchNoDocsQuery.class)).                 }             }         }     } }
false;public;0;13;;public void testInvalidField() throws IOException {     Directory dir = new RAMDirectory().     try (IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())))) {         writer.commit().     }     try (IndexReader reader = DirectoryReader.open(dir)) {         QueryShardContext context = createShardContext(Version.CURRENT, reader, "field", null, 1, 0).         SliceBuilder builder = new SliceBuilder("field", 5, 10).         IllegalArgumentException exc = expectThrows(IllegalArgumentException.class, () -> builder.toFilter(null, createRequest(0), context, Version.CURRENT)).         assertThat(exc.getMessage(), containsString("cannot load numeric doc values")).     } }
false;public;0;14;;public void testToFilterDeprecationMessage() throws IOException {     Directory dir = new RAMDirectory().     try (IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())))) {         writer.commit().     }     try (IndexReader reader = DirectoryReader.open(dir)) {         QueryShardContext context = createShardContext(Version.V_6_3_0, reader, "_uid", null, 1, 0).         SliceBuilder builder = new SliceBuilder("_uid", 5, 10).         Query query = builder.toFilter(null, createRequest(0), context, Version.CURRENT).         assertThat(query, instanceOf(TermsSliceQuery.class)).         assertThat(builder.toFilter(null, createRequest(0), context, Version.CURRENT), equalTo(query)).         assertWarnings("Computing slices on the [_uid] field is deprecated for 6.x indices, use [_id] instead").     } }
false;public;0;14;;public void testSerializationBackcompat() throws IOException {     SliceBuilder sliceBuilder = new SliceBuilder(1, 5).     assertEquals(IdFieldMapper.NAME, sliceBuilder.getField()).     SliceBuilder copy62 = copyWriteable(sliceBuilder, new NamedWriteableRegistry(Collections.emptyList()), SliceBuilder::new, Version.V_6_2_0).     assertEquals(sliceBuilder, copy62).     SliceBuilder copy63 = copyWriteable(copy62, new NamedWriteableRegistry(Collections.emptyList()), SliceBuilder::new, Version.V_6_3_0).     assertEquals(sliceBuilder, copy63). }
false;public;0;30;;public void testToFilterWithRouting() throws IOException {     Directory dir = new RAMDirectory().     try (IndexWriter writer = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random())))) {         writer.commit().     }     ClusterService clusterService = mock(ClusterService.class).     ClusterState state = mock(ClusterState.class).     when(state.metaData()).thenReturn(MetaData.EMPTY_META_DATA).     when(clusterService.state()).thenReturn(state).     OperationRouting routing = mock(OperationRouting.class).     GroupShardsIterator<ShardIterator> it = new GroupShardsIterator<>(Collections.singletonList(new SearchShardIterator(null, new ShardId("index", "index", 1), null, null))).     when(routing.searchShards(any(), any(), any(), any())).thenReturn(it).     when(clusterService.operationRouting()).thenReturn(routing).     when(clusterService.getSettings()).thenReturn(Settings.EMPTY).     try (IndexReader reader = DirectoryReader.open(dir)) {         QueryShardContext context = createShardContext(Version.CURRENT, reader, "field", DocValuesType.SORTED, 5, 0).         SliceBuilder builder = new SliceBuilder("field", 6, 10).         String[] routings = new String[] { "foo" }.         Query query = builder.toFilter(clusterService, createRequest(1, routings, null), context, Version.CURRENT).         assertEquals(new DocValuesSliceQuery("field", 6, 10), query).         query = builder.toFilter(clusterService, createRequest(1, Strings.EMPTY_ARRAY, "foo"), context, Version.CURRENT).         assertEquals(new DocValuesSliceQuery("field", 6, 10), query).         query = builder.toFilter(clusterService, createRequest(1, Strings.EMPTY_ARRAY, "foo"), context, Version.V_6_2_0).         assertEquals(new DocValuesSliceQuery("field", 1, 2), query).     } }
