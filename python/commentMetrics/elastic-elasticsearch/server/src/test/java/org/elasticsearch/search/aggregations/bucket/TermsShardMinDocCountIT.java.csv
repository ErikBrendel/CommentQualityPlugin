commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;3;;private static String randomExecutionHint() {     return randomBoolean() ? null : randomFrom(SignificantTermsAggregatorFactory.ExecutionMode.values()).toString(). }
true;public;0;46;// see https://github.com/elastic/elasticsearch/issues/5998 ;// see https://github.com/elastic/elasticsearch/issues/5998 public void testShardMinDocCountSignificantTermsTest() throws Exception {     String textMappings.     if (randomBoolean()) {         textMappings = "type=long".     } else {         textMappings = "type=text,fielddata=true".     }     assertAcked(prepareCreate(index).setSettings(Settings.builder().put(SETTING_NUMBER_OF_SHARDS, 1).put(SETTING_NUMBER_OF_REPLICAS, 0)).addMapping(type, "text", textMappings)).     List<IndexRequestBuilder> indexBuilders = new ArrayList<>().     // high score but low doc freq     addTermsDocs("1", 1, 0, indexBuilders).     addTermsDocs("2", 1, 0, indexBuilders).     addTermsDocs("3", 1, 0, indexBuilders).     addTermsDocs("4", 1, 0, indexBuilders).     // low score but high doc freq     addTermsDocs("5", 3, 1, indexBuilders).     addTermsDocs("6", 3, 1, indexBuilders).     // make sure the terms all get score > 0 except for this one     addTermsDocs("7", 0, 3, indexBuilders).     indexRandom(true, false, indexBuilders).     // first, check that indeed when not setting the shardMinDocCount parameter 0 terms are returned     SearchResponse response = client().prepareSearch(index).addAggregation((filter("inclass", QueryBuilders.termQuery("class", true))).subAggregation(significantTerms("mySignificantTerms").field("text").minDocCount(2).size(2).shardSize(2).executionHint(randomExecutionHint()))).get().     assertSearchResponse(response).     InternalFilter filteredBucket = response.getAggregations().get("inclass").     SignificantTerms sigterms = filteredBucket.getAggregations().get("mySignificantTerms").     assertThat(sigterms.getBuckets().size(), equalTo(0)).     response = client().prepareSearch(index).addAggregation((filter("inclass", QueryBuilders.termQuery("class", true))).subAggregation(significantTerms("mySignificantTerms").field("text").minDocCount(2).shardSize(2).shardMinDocCount(2).size(2).executionHint(randomExecutionHint()))).get().     assertSearchResponse(response).     filteredBucket = response.getAggregations().get("inclass").     sigterms = filteredBucket.getAggregations().get("mySignificantTerms").     assertThat(sigterms.getBuckets().size(), equalTo(2)). }
false;private;4;10;;private void addTermsDocs(String term, int numInClass, int numNotInClass, List<IndexRequestBuilder> builders) {     String sourceClass = "{\"text\": \"" + term + "\", \"class\":" + "true" + "}".     String sourceNotClass = "{\"text\": \"" + term + "\", \"class\":" + "false" + "}".     for (int i = 0. i < numInClass. i++) {         builders.add(client().prepareIndex(index, type).setSource(sourceClass, XContentType.JSON)).     }     for (int i = 0. i < numNotInClass. i++) {         builders.add(client().prepareIndex(index, type).setSource(sourceNotClass, XContentType.JSON)).     } }
true;public;0;41;// see https://github.com/elastic/elasticsearch/issues/5998 ;// see https://github.com/elastic/elasticsearch/issues/5998 public void testShardMinDocCountTermsTest() throws Exception {     final String[] termTypes = { "text", "long", "integer", "float", "double" }.     String termtype = termTypes[randomInt(termTypes.length - 1)].     String termMappings = "type=" + termtype.     if (termtype.equals("text")) {         termMappings += ",fielddata=true".     }     assertAcked(prepareCreate(index).setSettings(Settings.builder().put(SETTING_NUMBER_OF_SHARDS, 1).put(SETTING_NUMBER_OF_REPLICAS, 0)).addMapping(type, "text", termMappings)).     List<IndexRequestBuilder> indexBuilders = new ArrayList<>().     // low doc freq but high score     addTermsDocs("1", 1, indexBuilders).     addTermsDocs("2", 1, indexBuilders).     addTermsDocs("3", 1, indexBuilders).     addTermsDocs("4", 1, indexBuilders).     // low score but high doc freq     addTermsDocs("5", 3, indexBuilders).     addTermsDocs("6", 3, indexBuilders).     indexRandom(true, false, indexBuilders).     // first, check that indeed when not setting the shardMinDocCount parameter 0 terms are returned     SearchResponse response = client().prepareSearch(index).addAggregation(terms("myTerms").field("text").minDocCount(2).size(2).shardSize(2).executionHint(randomExecutionHint()).order(BucketOrder.key(true))).get().     assertSearchResponse(response).     Terms sigterms = response.getAggregations().get("myTerms").     assertThat(sigterms.getBuckets().size(), equalTo(0)).     response = client().prepareSearch(index).addAggregation(terms("myTerms").field("text").minDocCount(2).shardMinDocCount(2).size(2).shardSize(2).executionHint(randomExecutionHint()).order(BucketOrder.key(true))).get().     assertSearchResponse(response).     sigterms = response.getAggregations().get("myTerms").     assertThat(sigterms.getBuckets().size(), equalTo(2)). }
false;private,static;3;6;;private static void addTermsDocs(String term, int numDocs, List<IndexRequestBuilder> builders) {     String sourceClass = "{\"text\": \"" + term + "\"}".     for (int i = 0. i < numDocs. i++) {         builders.add(client().prepareIndex(index, type).setSource(sourceClass, XContentType.JSON)).     } }
