commented;modifiers;parameterAmount;loc;comment;code
false;public;0;15;;public void testVersion() throws Exception {     runTestThatVersionIsMutuallyExclusiveToOtherOptions("-V", "-d").     runTestThatVersionIsMutuallyExclusiveToOtherOptions("-V", "--daemonize").     runTestThatVersionIsMutuallyExclusiveToOtherOptions("-V", "-p", "/tmp/pid").     runTestThatVersionIsMutuallyExclusiveToOtherOptions("-V", "--pidfile", "/tmp/pid").     runTestThatVersionIsMutuallyExclusiveToOtherOptions("--version", "-d").     runTestThatVersionIsMutuallyExclusiveToOtherOptions("--version", "--daemonize").     runTestThatVersionIsMutuallyExclusiveToOtherOptions("--version", "-p", "/tmp/pid").     runTestThatVersionIsMutuallyExclusiveToOtherOptions("--version", "--pidfile", "/tmp/pid").     runTestThatVersionIsMutuallyExclusiveToOtherOptions("--version", "-q").     runTestThatVersionIsMutuallyExclusiveToOtherOptions("--version", "--quiet").     runTestThatVersionIsReturned("-V").     runTestThatVersionIsReturned("--version"). }
false;private;1;9;;private void runTestThatVersionIsMutuallyExclusiveToOtherOptions(String... args) throws Exception {     runTestVersion(ExitCodes.USAGE, output -> assertThat(output, allOf(containsString("ERROR:"), containsString("are unavailable given other options on the command line"))), args). }
false;private;1;14;;private void runTestThatVersionIsReturned(String... args) throws Exception {     runTestVersion(ExitCodes.OK, output -> {         assertThat(output, containsString("Version: " + Build.CURRENT.getQualifiedVersion())).         final String expectedBuildOutput = String.format(Locale.ROOT, "Build: %s/%s/%s/%s", Build.CURRENT.flavor().displayName(), Build.CURRENT.type().displayName(), Build.CURRENT.shortHash(), Build.CURRENT.date()).         assertThat(output, containsString(expectedBuildOutput)).         assertThat(output, containsString("JVM: " + JvmInfo.jvmInfo().version())).     }, args). }
false;private;3;3;;private void runTestVersion(int expectedStatus, Consumer<String> outputConsumer, String... args) throws Exception {     runTest(expectedStatus, false, outputConsumer, (foreground, pidFile, quiet, esSettings) -> {     }, args). }
false;public;0;20;;public void testPositionalArgs() throws Exception {     runTest(ExitCodes.USAGE, false, output -> assertThat(output, containsString("Positional arguments not allowed, found [foo]")), (foreground, pidFile, quiet, esSettings) -> {     }, "foo").     runTest(ExitCodes.USAGE, false, output -> assertThat(output, containsString("Positional arguments not allowed, found [foo, bar]")), (foreground, pidFile, quiet, esSettings) -> {     }, "foo", "bar").     runTest(ExitCodes.USAGE, false, output -> assertThat(output, containsString("Positional arguments not allowed, found [foo]")), (foreground, pidFile, quiet, esSettings) -> {     }, "-E", "foo=bar", "foo", "-E", "baz=qux"). }
false;public;0;8;;public void testThatPidFileCanBeConfigured() throws Exception {     Path tmpDir = createTempDir().     Path pidFile = tmpDir.resolve("pid").     runPidFileTest(ExitCodes.USAGE, false, output -> assertThat(output, containsString("Option p/pidfile requires an argument")), pidFile, "-p").     runPidFileTest(ExitCodes.OK, true, output -> {     }, pidFile, "-p", pidFile.toString()).     runPidFileTest(ExitCodes.OK, true, output -> {     }, pidFile, "--pidfile", tmpDir.toString() + "/pid"). }
false;private;5;10;;private void runPidFileTest(final int expectedStatus, final boolean expectedInit, Consumer<String> outputConsumer, Path expectedPidFile, final String... args) throws Exception {     runTest(expectedStatus, expectedInit, outputConsumer, (foreground, pidFile, quiet, esSettings) -> assertThat(pidFile.toString(), equalTo(expectedPidFile.toString())), args). }
false;public;0;5;;public void testThatParsingDaemonizeWorks() throws Exception {     runDaemonizeTest(true, "-d").     runDaemonizeTest(true, "--daemonize").     runDaemonizeTest(false). }
false;private;2;8;;private void runDaemonizeTest(final boolean expectedDaemonize, final String... args) throws Exception {     runTest(ExitCodes.OK, true, output -> {     }, (foreground, pidFile, quiet, esSettings) -> assertThat(foreground, equalTo(!expectedDaemonize)), args). }
false;public;0;5;;public void testThatParsingQuietOptionWorks() throws Exception {     runQuietTest(true, "-q").     runQuietTest(true, "--quiet").     runQuietTest(false). }
false;private;2;8;;private void runQuietTest(final boolean expectedQuiet, final String... args) throws Exception {     runTest(ExitCodes.OK, true, output -> {     }, (foreground, pidFile, quiet, esSettings) -> assertThat(quiet, equalTo(expectedQuiet)), args). }
false;public;0;12;;public void testElasticsearchSettings() throws Exception {     runTest(ExitCodes.OK, true, output -> {     }, (foreground, pidFile, quiet, env) -> {         Settings settings = env.settings().         assertEquals("bar", settings.get("foo")).         assertEquals("qux", settings.get("baz")).     }, "-Efoo=bar", "-E", "baz=qux"). }
false;public;0;8;;public void testElasticsearchSettingCanNotBeEmpty() throws Exception {     runTest(ExitCodes.USAGE, false, output -> assertThat(output, containsString("setting [foo] must not be empty")), (foreground, pidFile, quiet, esSettings) -> {     }, "-E", "foo="). }
false;public;0;8;;public void testElasticsearchSettingCanNotBeDuplicated() throws Exception {     runTest(ExitCodes.USAGE, false, output -> assertThat(output, containsString("setting [foo] already set, saw [bar] and [baz]")), (foreground, pidFile, quiet, initialEnv) -> {     }, "-E", "foo=bar", "-E", "foo=baz"). }
false;public;0;8;;public void testUnknownOption() throws Exception {     runTest(ExitCodes.USAGE, false, output -> assertThat(output, containsString("network.host is not a recognized option")), (foreground, pidFile, quiet, esSettings) -> {     }, "--network.host"). }
