commented;modifiers;parameterAmount;loc;comment;code
false;private,static;0;6;;private static ThreadPool createMockThreadPool() {     final ThreadContext context = new ThreadContext(Settings.EMPTY).     final ThreadPool mockThreadPool = mock(ThreadPool.class).     when(mockThreadPool.getThreadContext()).thenReturn(context).     return mockThreadPool. }
false;public;3;4;;@Override public void execute(Runnable command, final TimeValue timeout, final Runnable timeoutCallback) {     execute(command). }
false;public;1;5;;@Override public void execute(Runnable command) {     pendingTasks.add(command).     scheduleNextTaskIfNecessary(). }
false;protected;0;17;;@Override protected PrioritizedEsThreadPoolExecutor createThreadPoolExecutor() {     return new PrioritizedEsThreadPoolExecutor(name, 1, 1, 1, TimeUnit.SECONDS, EsExecutors.daemonThreadFactory(name), null, null) {          @Override         public void execute(Runnable command, final TimeValue timeout, final Runnable timeoutCallback) {             execute(command).         }          @Override         public void execute(Runnable command) {             pendingTasks.add(command).             scheduleNextTaskIfNecessary().         }     }. }
false;public;0;4;;@Override public String toString() {     return "master service scheduling next task". }
false;public;0;16;;@Override public void run() {     assert taskInProgress == false.     assert waitForPublish == false.     assert scheduledNextTask.     final int taskIndex = randomInt(pendingTasks.size() - 1).     logger.debug("next master service task: choosing task {} of {}", taskIndex, pendingTasks.size()).     final Runnable task = pendingTasks.remove(taskIndex).     taskInProgress = true.     scheduledNextTask = false.     task.run().     if (waitForPublish == false) {         taskInProgress = false.     }     FakeThreadPoolMasterService.this.scheduleNextTaskIfNecessary(). }
false;private;0;28;;private void scheduleNextTaskIfNecessary() {     if (taskInProgress == false && pendingTasks.isEmpty() == false && scheduledNextTask == false) {         scheduledNextTask = true.         onTaskAvailableToRun.accept(new Runnable() {              @Override             public String toString() {                 return "master service scheduling next task".             }              @Override             public void run() {                 assert taskInProgress == false.                 assert waitForPublish == false.                 assert scheduledNextTask.                 final int taskIndex = randomInt(pendingTasks.size() - 1).                 logger.debug("next master service task: choosing task {} of {}", taskIndex, pendingTasks.size()).                 final Runnable task = pendingTasks.remove(taskIndex).                 taskInProgress = true.                 scheduledNextTask = false.                 task.run().                 if (waitForPublish == false) {                     taskInProgress = false.                 }                 FakeThreadPoolMasterService.this.scheduleNextTaskIfNecessary().             }         }).     } }
false;public;1;5;;@Override public ClusterState.Builder incrementVersion(ClusterState clusterState) {     // generate cluster UUID deterministically for repeatable tests     return ClusterState.builder(clusterState).incrementVersion().stateUUID(UUIDs.randomBase64UUID(random())). }
false;public;1;13;;@Override public void onResponse(Void aVoid) {     assert listenerCalled == false.     listenerCalled = true.     assert waitForPublish.     waitForPublish = false.     try {         onPublicationSuccess(clusterChangedEvent, taskOutputs, startTimeNS).     } finally {         taskInProgress = false.         scheduleNextTaskIfNecessary().     } }
false;public;1;13;;@Override public void onFailure(Exception e) {     assert listenerCalled == false.     listenerCalled = true.     assert waitForPublish.     waitForPublish = false.     try {         onPublicationFailed(clusterChangedEvent, taskOutputs, startTimeNS, e).     } finally {         taskInProgress = false.         scheduleNextTaskIfNecessary().     } }
false;protected;3;38;;@Override protected void publish(ClusterChangedEvent clusterChangedEvent, TaskOutputs taskOutputs, long startTimeNS) {     assert waitForPublish == false.     waitForPublish = true.     final AckListener ackListener = taskOutputs.createAckListener(threadPool, clusterChangedEvent.state()).     clusterStatePublisher.publish(clusterChangedEvent, new ActionListener<Void>() {          private boolean listenerCalled = false.          @Override         public void onResponse(Void aVoid) {             assert listenerCalled == false.             listenerCalled = true.             assert waitForPublish.             waitForPublish = false.             try {                 onPublicationSuccess(clusterChangedEvent, taskOutputs, startTimeNS).             } finally {                 taskInProgress = false.                 scheduleNextTaskIfNecessary().             }         }          @Override         public void onFailure(Exception e) {             assert listenerCalled == false.             listenerCalled = true.             assert waitForPublish.             waitForPublish = false.             try {                 onPublicationFailed(clusterChangedEvent, taskOutputs, startTimeNS, e).             } finally {                 taskInProgress = false.                 scheduleNextTaskIfNecessary().             }         }     }, wrapAckListener(ackListener)). }
false;protected;1;3;;protected AckListener wrapAckListener(AckListener ackListener) {     return ackListener. }
