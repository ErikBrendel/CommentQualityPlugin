commented;modifiers;parameterAmount;loc;comment;code
true;protected;0;4;/**  * @return a {@link ConstantScoreQueryBuilder} with random boost between 0.1f and 2.0f  */ ;/**  * @return a {@link ConstantScoreQueryBuilder} with random boost between 0.1f and 2.0f  */ @Override protected ConstantScoreQueryBuilder doCreateTestQueryBuilder() {     return new ConstantScoreQueryBuilder(RandomQueryBuilder.createQuery(random())). }
false;protected;3;11;;@Override protected void doAssertLuceneQuery(ConstantScoreQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     Query innerQuery = queryBuilder.innerQuery().toQuery(context.getQueryShardContext()).     if (innerQuery == null) {         assertThat(query, nullValue()).     } else {         assertThat(query, instanceOf(ConstantScoreQuery.class)).         ConstantScoreQuery constantScoreQuery = (ConstantScoreQuery) query.         assertThat(constantScoreQuery.getQuery(), instanceOf(innerQuery.getClass())).     } }
true;public;0;5;/**  * test that missing "filter" element causes {@link ParsingException}  */ ;/**  * test that missing "filter" element causes {@link ParsingException}  */ public void testFilterElement() throws IOException {     String queryString = "{ \"" + ConstantScoreQueryBuilder.NAME + "\" : {} }".     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(queryString)).     assertThat(e.getMessage(), containsString("requires a 'filter' element")). }
true;public;0;8;/**  * test that "filter" does not accept an array of queries, throws {@link ParsingException}  */ ;/**  * test that "filter" does not accept an array of queries, throws {@link ParsingException}  */ public void testNoArrayAsFilterElements() throws IOException {     String queryString = "{ \"" + ConstantScoreQueryBuilder.NAME + "\" : {\n" + "\"filter\" : [ { \"term\": { \"foo\": \"a\" } },\n" + "{ \"term\": { \"foo\": \"x\" } } ]\n" + "} }".     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(queryString)).     assertThat(e.getMessage(), containsString("unexpected token [START_ARRAY]")). }
false;public;0;3;;public void testIllegalArguments() {     expectThrows(IllegalArgumentException.class, () -> new ConstantScoreQueryBuilder((QueryBuilder) null)). }
false;public;0;4;;@Override public void testUnknownField() {     assumeTrue("test doesn't apply for query filter queries", false). }
false;public;0;20;;public void testFromJson() throws IOException {     String json = "{\n" + "  \"constant_score\" : {\n" + "    \"filter\" : {\n" + "      \"terms\" : {\n" + "        \"user\" : [ \"kimchy\", \"elasticsearch\" ],\n" + "        \"boost\" : 42.0\n" + "      }\n" + "    },\n" + "    \"boost\" : 23.0\n" + "  }\n" + "}".     ConstantScoreQueryBuilder parsed = (ConstantScoreQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     assertEquals(json, 23.0, parsed.boost(), 0.0001).     assertEquals(json, 42.0, parsed.innerQuery().boost(), 0.0001). }
false;public;0;5;;public void testRewriteToMatchNone() throws IOException {     ConstantScoreQueryBuilder constantScoreQueryBuilder = new ConstantScoreQueryBuilder(new MatchNoneQueryBuilder()).     QueryBuilder rewrite = constantScoreQueryBuilder.rewrite(createShardContext()).     assertEquals(rewrite, new MatchNoneQueryBuilder()). }
