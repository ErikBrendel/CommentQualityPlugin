commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;4;;@Override protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {     return null. }
false;protected;3;4;;@Override protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard, final SearchActionListener<SearchPhaseResult> listener) { }
false;;0;5;;@Override long buildTookInMillis() {     runnable.run().     return super.buildTookInMillis(). }
false;public;3;4;;@Override public void sendReleaseSearchContext(long contextId, Transport.Connection connection, OriginalIndices originalIndices) {     releasedContexts.add(contextId). }
false;private;5;58;;private AbstractSearchAsyncAction<SearchPhaseResult> createAction(SearchRequest request, InitialSearchPhase.ArraySearchPhaseResults<SearchPhaseResult> results, ActionListener<SearchResponse> listener, final boolean controlled, final AtomicLong expected) {     final Runnable runnable.     final TransportSearchAction.SearchTimeProvider timeProvider.     if (controlled) {         runnable = () -> expected.set(randomNonNegativeLong()).         timeProvider = new TransportSearchAction.SearchTimeProvider(0, 0, expected::get).     } else {         runnable = () -> {             long elapsed = spinForAtLeastNMilliseconds(randomIntBetween(1, 10)).             expected.set(elapsed).         }.         timeProvider = new TransportSearchAction.SearchTimeProvider(0, System.nanoTime(), System::nanoTime).     }     BiFunction<String, String, Transport.Connection> nodeIdToConnection = (cluster, node) -> {         resolvedNodes.add(Tuple.tuple(cluster, node)).         return null.     }.     return new AbstractSearchAsyncAction<SearchPhaseResult>("test", null, null, nodeIdToConnection, Collections.singletonMap("foo", new AliasFilter(new MatchAllQueryBuilder())), Collections.singletonMap("foo", 2.0f), Collections.singletonMap("name", Sets.newHashSet("bar", "baz")), null, request, listener, new GroupShardsIterator<>(Collections.singletonList(new SearchShardIterator(null, null, Collections.emptyList(), null))), timeProvider, 0, null, results, request.getMaxConcurrentShardRequests(), SearchResponse.Clusters.EMPTY) {          @Override         protected SearchPhase getNextPhase(final SearchPhaseResults<SearchPhaseResult> results, final SearchPhaseContext context) {             return null.         }          @Override         protected void executePhaseOnShard(final SearchShardIterator shardIt, final ShardRouting shard, final SearchActionListener<SearchPhaseResult> listener) {         }          @Override         long buildTookInMillis() {             runnable.run().             return super.buildTookInMillis().         }          @Override         public void sendReleaseSearchContext(long contextId, Transport.Connection connection, OriginalIndices originalIndices) {             releasedContexts.add(contextId).         }     }. }
false;public;0;3;;public void testTookWithControlledClock() {     runTestTook(true). }
false;public;0;3;;public void testTookWithRealClock() {     runTestTook(false). }
false;private;1;13;;private void runTestTook(final boolean controlled) {     final AtomicLong expected = new AtomicLong().     AbstractSearchAsyncAction<SearchPhaseResult> action = createAction(new SearchRequest(), new InitialSearchPhase.ArraySearchPhaseResults<>(10), null, controlled, expected).     final long actual = action.buildTookInMillis().     if (controlled) {         // with a controlled clock, we can assert the exact took time         assertThat(actual, equalTo(TimeUnit.NANOSECONDS.toMillis(expected.get()))).     } else {         // with a real clock, the best we can say is that it took as long as we spun for         assertThat(actual, greaterThanOrEqualTo(TimeUnit.NANOSECONDS.toMillis(expected.get()))).     } }
false;public;0;18;;public void testBuildShardSearchTransportRequest() {     SearchRequest searchRequest = new SearchRequest().allowPartialSearchResults(randomBoolean()).preference("_shards:1,3").     final AtomicLong expected = new AtomicLong().     AbstractSearchAsyncAction<SearchPhaseResult> action = createAction(searchRequest, new InitialSearchPhase.ArraySearchPhaseResults<>(10), null, false, expected).     String clusterAlias = randomBoolean() ? null : randomAlphaOfLengthBetween(5, 10).     SearchShardIterator iterator = new SearchShardIterator(clusterAlias, new ShardId(new Index("name", "foo"), 1), Collections.emptyList(), new OriginalIndices(new String[] { "name", "name1" }, IndicesOptions.strictExpand())).     ShardSearchTransportRequest shardSearchTransportRequest = action.buildShardSearchRequest(iterator).     assertEquals(IndicesOptions.strictExpand(), shardSearchTransportRequest.indicesOptions()).     assertArrayEquals(new String[] { "name", "name1" }, shardSearchTransportRequest.indices()).     assertEquals(new MatchAllQueryBuilder(), shardSearchTransportRequest.getAliasFilter().getQueryBuilder()).     assertEquals(2.0f, shardSearchTransportRequest.indexBoost(), 0.0f).     assertArrayEquals(new String[] { "name", "name1" }, shardSearchTransportRequest.indices()).     assertArrayEquals(new String[] { "bar", "baz" }, shardSearchTransportRequest.indexRoutings()).     assertEquals("_shards:1,3", shardSearchTransportRequest.preference()).     assertEquals(clusterAlias, shardSearchTransportRequest.getClusterAlias()). }
false;public;0;13;;public void testBuildSearchResponse() {     SearchRequest searchRequest = new SearchRequest().allowPartialSearchResults(randomBoolean()).     AbstractSearchAsyncAction<SearchPhaseResult> action = createAction(searchRequest, new InitialSearchPhase.ArraySearchPhaseResults<>(10), null, false, new AtomicLong()).     String scrollId = randomBoolean() ? null : randomAlphaOfLengthBetween(5, 10).     InternalSearchResponse internalSearchResponse = InternalSearchResponse.empty().     SearchResponse searchResponse = action.buildSearchResponse(internalSearchResponse, scrollId).     assertEquals(scrollId, searchResponse.getScrollId()).     assertSame(searchResponse.getAggregations(), internalSearchResponse.aggregations()).     assertSame(searchResponse.getSuggest(), internalSearchResponse.suggest()).     assertSame(searchResponse.getProfileResults(), internalSearchResponse.profile()).     assertSame(searchResponse.getHits(), internalSearchResponse.hits()). }
false;public;0;15;;public void testBuildSearchResponseAllowPartialFailures() {     SearchRequest searchRequest = new SearchRequest().allowPartialSearchResults(true).     AbstractSearchAsyncAction<SearchPhaseResult> action = createAction(searchRequest, new InitialSearchPhase.ArraySearchPhaseResults<>(10), null, false, new AtomicLong()).     action.onShardFailure(0, new SearchShardTarget("node", new ShardId("index", "index-uuid", 0), null, OriginalIndices.NONE), new IllegalArgumentException()).     String scrollId = randomBoolean() ? null : randomAlphaOfLengthBetween(5, 10).     InternalSearchResponse internalSearchResponse = InternalSearchResponse.empty().     SearchResponse searchResponse = action.buildSearchResponse(internalSearchResponse, scrollId).     assertEquals(scrollId, searchResponse.getScrollId()).     assertSame(searchResponse.getAggregations(), internalSearchResponse.aggregations()).     assertSame(searchResponse.getSuggest(), internalSearchResponse.suggest()).     assertSame(searchResponse.getProfileResults(), internalSearchResponse.profile()).     assertSame(searchResponse.getHits(), internalSearchResponse.hits()). }
false;public;0;27;;public void testBuildSearchResponseDisallowPartialFailures() {     SearchRequest searchRequest = new SearchRequest().allowPartialSearchResults(false).     AtomicReference<Exception> exception = new AtomicReference<>().     ActionListener<SearchResponse> listener = ActionListener.wrap(response -> fail("onResponse should not be called"), exception::set).     Set<Long> requestIds = new HashSet<>().     List<Tuple<String, String>> nodeLookups = new ArrayList<>().     int numFailures = randomIntBetween(1, 5).     InitialSearchPhase.ArraySearchPhaseResults<SearchPhaseResult> phaseResults = phaseResults(requestIds, nodeLookups, numFailures).     AbstractSearchAsyncAction<SearchPhaseResult> action = createAction(searchRequest, phaseResults, listener, false, new AtomicLong()).     for (int i = 0. i < numFailures. i++) {         ShardId failureShardId = new ShardId("index", "index-uuid", i).         String failureClusterAlias = randomBoolean() ? null : randomAlphaOfLengthBetween(5, 10).         String failureNodeId = randomAlphaOfLengthBetween(5, 10).         action.onShardFailure(i, new SearchShardTarget(failureNodeId, failureShardId, failureClusterAlias, OriginalIndices.NONE), new IllegalArgumentException()).     }     action.buildSearchResponse(InternalSearchResponse.empty(), randomBoolean() ? null : randomAlphaOfLengthBetween(5, 10)).     assertThat(exception.get(), instanceOf(SearchPhaseExecutionException.class)).     SearchPhaseExecutionException searchPhaseExecutionException = (SearchPhaseExecutionException) exception.get().     assertEquals(0, searchPhaseExecutionException.getSuppressed().length).     assertEquals(numFailures, searchPhaseExecutionException.shardFailures().length).     for (ShardSearchFailure shardSearchFailure : searchPhaseExecutionException.shardFailures()) {         assertThat(shardSearchFailure.getCause(), instanceOf(IllegalArgumentException.class)).     }     assertEquals(nodeLookups, resolvedNodes).     assertEquals(requestIds, releasedContexts). }
false;public;0;4;;@Override public void run() { }
false;public;0;23;;public void testOnPhaseFailure() {     SearchRequest searchRequest = new SearchRequest().allowPartialSearchResults(false).     AtomicReference<Exception> exception = new AtomicReference<>().     ActionListener<SearchResponse> listener = ActionListener.wrap(response -> fail("onResponse should not be called"), exception::set).     Set<Long> requestIds = new HashSet<>().     List<Tuple<String, String>> nodeLookups = new ArrayList<>().     InitialSearchPhase.ArraySearchPhaseResults<SearchPhaseResult> phaseResults = phaseResults(requestIds, nodeLookups, 0).     AbstractSearchAsyncAction<SearchPhaseResult> action = createAction(searchRequest, phaseResults, listener, false, new AtomicLong()).     action.onPhaseFailure(new SearchPhase("test") {          @Override         public void run() {         }     }, "message", null).     assertThat(exception.get(), instanceOf(SearchPhaseExecutionException.class)).     SearchPhaseExecutionException searchPhaseExecutionException = (SearchPhaseExecutionException) exception.get().     assertEquals("message", searchPhaseExecutionException.getMessage()).     assertEquals("test", searchPhaseExecutionException.getPhaseName()).     assertEquals(0, searchPhaseExecutionException.shardFailures().length).     assertEquals(0, searchPhaseExecutionException.getSuppressed().length).     assertEquals(nodeLookups, resolvedNodes).     assertEquals(requestIds, releasedContexts). }
false;private,static;3;21;;private static InitialSearchPhase.ArraySearchPhaseResults<SearchPhaseResult> phaseResults(Set<Long> requestIds, List<Tuple<String, String>> nodeLookups, int numFailures) {     int numResults = randomIntBetween(1, 10).     InitialSearchPhase.ArraySearchPhaseResults<SearchPhaseResult> phaseResults = new InitialSearchPhase.ArraySearchPhaseResults<>(numResults + numFailures).     for (int i = 0. i < numResults. i++) {         long requestId = randomLong().         requestIds.add(requestId).         SearchPhaseResult phaseResult = new PhaseResult(requestId).         String resultClusterAlias = randomBoolean() ? null : randomAlphaOfLengthBetween(5, 10).         String resultNodeId = randomAlphaOfLengthBetween(5, 10).         ShardId resultShardId = new ShardId("index", "index-uuid", i).         nodeLookups.add(Tuple.tuple(resultClusterAlias, resultNodeId)).         phaseResult.setSearchShardTarget(new SearchShardTarget(resultNodeId, resultShardId, resultClusterAlias, OriginalIndices.NONE)).         phaseResult.setShardIndex(i).         phaseResults.consumeResult(phaseResult).     }     return phaseResults. }
