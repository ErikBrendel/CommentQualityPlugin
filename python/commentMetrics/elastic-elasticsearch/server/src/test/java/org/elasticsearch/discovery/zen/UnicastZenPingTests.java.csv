commented;modifiers;parameterAmount;loc;comment;code
false;public;0;10;;@Before public void setUp() throws Exception {     super.setUp().     threadPool = new TestThreadPool(getClass().getName()).     final ThreadFactory threadFactory = EsExecutors.daemonThreadFactory("[" + getClass().getName() + "]").     executorService = EsExecutors.newScaling(getClass().getName() + "/" + getTestName(), 0, 2, 60, TimeUnit.SECONDS, threadFactory, threadPool.getThreadContext()).     closeables = new Stack<>(). }
false;public;0;16;;@After public void tearDown() throws Exception {     try {         logger.info("shutting down...").         // JDK stack is broken, it does not iterate in the expected order (http://bugs.java.com/bugdatabase/view_bug.do?bug_id=4475301)         final List<Closeable> reverse = new ArrayList<>().         while (!closeables.isEmpty()) {             reverse.add(closeables.pop()).         }         IOUtils.close(reverse).     } finally {         terminate(executorService).         terminate(threadPool).         super.tearDown().     } }
false;protected;0;4;;@Override protected Version getVersion() {     return versionD. }
false;public;0;125;;public void testSimplePings() throws IOException, InterruptedException, ExecutionException {     // use ephemeral ports     final Settings settings = Settings.builder().put("cluster.name", "test").put(TransportSettings.PORT.getKey(), 0).build().     final Settings settingsMismatch = Settings.builder().put(settings).put("cluster.name", "mismatch").put(TransportSettings.PORT.getKey(), 0).build().     NetworkService networkService = new NetworkService(Collections.emptyList()).     final BiFunction<Settings, Version, Transport> supplier = (s, v) -> new MockNioTransport(s, v, threadPool, networkService, PageCacheRecycler.NON_RECYCLING_INSTANCE, new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService()).     NetworkHandle handleA = startServices(settings, threadPool, "UZP_A", Version.CURRENT, supplier).     closeables.push(handleA.transportService).     NetworkHandle handleB = startServices(settings, threadPool, "UZP_B", Version.CURRENT, supplier).     closeables.push(handleB.transportService).     NetworkHandle handleC = startServices(settingsMismatch, threadPool, "UZP_C", Version.CURRENT, supplier).     closeables.push(handleC.transportService).     final Version versionD.     if (randomBoolean()) {         versionD = VersionUtils.randomVersionBetween(random(), Version.CURRENT.minimumCompatibilityVersion(), Version.CURRENT).     } else {         versionD = Version.CURRENT.     }     logger.info("UZP_D version set to [{}]", versionD).     NetworkHandle handleD = startServices(settingsMismatch, threadPool, "UZP_D", versionD, supplier).     closeables.push(handleD.transportService).     final ClusterState state = ClusterState.builder(new ClusterName("test")).version(randomNonNegativeLong()).build().     final ClusterState stateMismatch = ClusterState.builder(new ClusterName("mismatch")).version(randomNonNegativeLong()).build().     final Settings hostsSettings = Settings.builder().putList(DISCOVERY_SEED_HOSTS_SETTING.getKey(), NetworkAddress.format(new InetSocketAddress(handleA.address.address().getAddress(), handleA.address.address().getPort())), NetworkAddress.format(new InetSocketAddress(handleB.address.address().getAddress(), handleB.address.address().getPort())), NetworkAddress.format(new InetSocketAddress(handleC.address.address().getAddress(), handleC.address.address().getPort())), NetworkAddress.format(new InetSocketAddress(handleD.address.address().getAddress(), handleD.address.address().getPort()))).put("cluster.name", "test").build().     Settings hostsSettingsMismatch = Settings.builder().put(hostsSettings).put(settingsMismatch).build().     ClusterState stateA = ClusterState.builder(state).blocks(ClusterBlocks.builder().addGlobalBlock(STATE_NOT_RECOVERED_BLOCK)).nodes(DiscoveryNodes.builder().add(handleA.node).localNodeId("UZP_A")).build().     TestUnicastZenPing zenPingA = new TestUnicastZenPing(hostsSettings, threadPool, handleA, () -> stateA).     zenPingA.start().     closeables.push(zenPingA).     ClusterState stateB = ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(handleB.node).localNodeId("UZP_B")).build().     TestUnicastZenPing zenPingB = new TestUnicastZenPing(hostsSettings, threadPool, handleB, () -> stateB).     zenPingB.start().     closeables.push(zenPingB).     ClusterState stateC = ClusterState.builder(stateMismatch).nodes(DiscoveryNodes.builder().add(handleC.node).localNodeId("UZP_C")).build().     TestUnicastZenPing zenPingC = new TestUnicastZenPing(hostsSettingsMismatch, threadPool, handleC, () -> stateC) {          @Override         protected Version getVersion() {             return versionD.         }     }.     zenPingC.start().     closeables.push(zenPingC).     ClusterState stateD = ClusterState.builder(stateMismatch).nodes(DiscoveryNodes.builder().add(handleD.node).localNodeId("UZP_D")).build().     TestUnicastZenPing zenPingD = new TestUnicastZenPing(hostsSettingsMismatch, threadPool, handleD, () -> stateD).     zenPingD.start().     closeables.push(zenPingD).     logger.info("ping from UZP_A").     Collection<ZenPing.PingResponse> pingResponses = zenPingA.pingAndWait().toList().     assertThat(pingResponses.size(), equalTo(1)).     ZenPing.PingResponse ping = pingResponses.iterator().next().     assertThat(ping.node().getId(), equalTo("UZP_B")).     assertThat(ping.getClusterStateVersion(), equalTo(state.version())).     assertPings(handleA, handleB).     // mismatch, shouldn't ping     assertNoPings(handleA, handleC).     // mismatch, shouldn't ping     assertNoPings(handleA, handleD).     // ping again, this time from B,     logger.info("ping from UZP_B").     pingResponses = zenPingB.pingAndWait().toList().     assertThat(pingResponses.size(), equalTo(1)).     ping = pingResponses.iterator().next().     assertThat(ping.node().getId(), equalTo("UZP_A")).     assertThat(ping.getClusterStateVersion(), equalTo(ElectMasterService.MasterCandidate.UNRECOVERED_CLUSTER_VERSION)).     assertPings(handleB, handleA).     // mismatch, shouldn't ping     assertNoPings(handleB, handleC).     // mismatch, shouldn't ping     assertNoPings(handleB, handleD).     logger.info("ping from UZP_C").     pingResponses = zenPingC.pingAndWait().toList().     assertThat(pingResponses.size(), equalTo(1)).     assertNoPings(handleC, handleA).     assertNoPings(handleC, handleB).     assertPings(handleC, handleD).     logger.info("ping from UZP_D").     pingResponses = zenPingD.pingAndWait().toList().     assertThat(pingResponses.size(), equalTo(1)).     assertNoPings(handleD, handleA).     assertNoPings(handleD, handleB).     assertPings(handleD, handleC).     zenPingC.close().     handleD.counters.clear().     logger.info("ping from UZP_D after closing UZP_C").     pingResponses = zenPingD.pingAndWait().toList().     // check that node does not respond to pings anymore after the ping service has been closed     assertThat(pingResponses.size(), equalTo(0)).     assertNoPings(handleD, handleA).     assertNoPings(handleD, handleB).     assertPings(handleD, handleC). }
false;public;2;9;;@Override public TransportAddress[] addressesFromString(String address, int perAddressLimit) throws UnknownHostException {     final TransportAddress[] transportAddresses = addresses.get(address).     if (transportAddresses == null) {         throw new UnknownHostException(address).     } else {         return transportAddresses.     } }
false;public;0;108;;public void testUnknownHostNotCached() throws ExecutionException, InterruptedException {     // use ephemeral ports     final Settings settings = Settings.builder().put("cluster.name", "test").put(TransportSettings.PORT.getKey(), 0).build().     final NetworkService networkService = new NetworkService(Collections.emptyList()).     final Map<String, TransportAddress[]> addresses = new HashMap<>().     final BiFunction<Settings, Version, Transport> supplier = (s, v) -> new MockNioTransport(s, v, threadPool, networkService, PageCacheRecycler.NON_RECYCLING_INSTANCE, new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService()) {          @Override         public TransportAddress[] addressesFromString(String address, int perAddressLimit) throws UnknownHostException {             final TransportAddress[] transportAddresses = addresses.get(address).             if (transportAddresses == null) {                 throw new UnknownHostException(address).             } else {                 return transportAddresses.             }         }     }.     final NetworkHandle handleA = startServices(settings, threadPool, "UZP_A", Version.CURRENT, supplier).     closeables.push(handleA.transportService).     final NetworkHandle handleB = startServices(settings, threadPool, "UZP_B", Version.CURRENT, supplier).     closeables.push(handleB.transportService).     final NetworkHandle handleC = startServices(settings, threadPool, "UZP_C", Version.CURRENT, supplier).     closeables.push(handleC.transportService).     addresses.put("UZP_A", new TransportAddress[] { new TransportAddress(new InetSocketAddress(handleA.address.address().getAddress(), handleA.address.address().getPort())) }).     addresses.put("UZP_C", new TransportAddress[] { new TransportAddress(new InetSocketAddress(handleC.address.address().getAddress(), handleC.address.address().getPort())) }).     final Settings hostsSettings = Settings.builder().putList(DISCOVERY_SEED_HOSTS_SETTING.getKey(), "UZP_A", "UZP_B", "UZP_C").put("cluster.name", "test").build().     final ClusterState state = ClusterState.builder(new ClusterName("test")).version(randomNonNegativeLong()).build().     ClusterState stateA = ClusterState.builder(state).blocks(ClusterBlocks.builder().addGlobalBlock(STATE_NOT_RECOVERED_BLOCK)).nodes(DiscoveryNodes.builder().add(handleA.node).localNodeId("UZP_A")).build().     final TestUnicastZenPing zenPingA = new TestUnicastZenPing(hostsSettings, threadPool, handleA, () -> stateA).     zenPingA.start().     closeables.push(zenPingA).     ClusterState stateB = ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(handleB.node).localNodeId("UZP_B")).build().     TestUnicastZenPing zenPingB = new TestUnicastZenPing(hostsSettings, threadPool, handleB, () -> stateB).     zenPingB.start().     closeables.push(zenPingB).     ClusterState stateC = ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(handleC.node).localNodeId("UZP_C")).build().     TestUnicastZenPing zenPingC = new TestUnicastZenPing(hostsSettings, threadPool, handleC, () -> stateC).     zenPingC.start().     closeables.push(zenPingC).     // the presence of an unresolvable host should not prevent resolvable hosts from being pinged     {         final Collection<ZenPing.PingResponse> pingResponses = zenPingA.pingAndWait().toList().         assertThat(pingResponses.size(), equalTo(1)).         ZenPing.PingResponse ping = pingResponses.iterator().next().         assertThat(ping.node().getId(), equalTo("UZP_C")).         assertThat(ping.getClusterStateVersion(), equalTo(state.version())).         assertNoPings(handleA, handleB).         assertPings(handleA, handleC).         assertNull(handleA.counters.get(handleB.address)).     }     final HashMap<TransportAddress, Integer> moreThan = new HashMap<>().     // we should see at least one ping to UZP_B, and one more ping than we have already seen to UZP_C     moreThan.put(handleB.address, 0).     moreThan.put(handleC.address, handleA.counters.get(handleC.address).intValue()).     // now allow UZP_B to be resolvable     addresses.put("UZP_B", new TransportAddress[] { new TransportAddress(new InetSocketAddress(handleB.address.address().getAddress(), handleB.address.address().getPort())) }).     // now we should see pings to UZP_B. this establishes that host resolutions are not cached     {         handleA.counters.clear().         final Collection<ZenPing.PingResponse> secondPingResponses = zenPingA.pingAndWait().toList().         assertThat(secondPingResponses.size(), equalTo(2)).         final Set<String> ids = new HashSet<>(secondPingResponses.stream().map(p -> p.node().getId()).collect(Collectors.toList())).         assertThat(ids, equalTo(new HashSet<>(Arrays.asList("UZP_B", "UZP_C")))).         assertPings(handleA, handleB).         assertPings(handleA, handleC).     } }
false;public;0;7;;@Override public BoundTransportAddress boundAddress() {     return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(InetAddress.getLoopbackAddress(), 9500) }, new TransportAddress(InetAddress.getLoopbackAddress(), 9500)). }
false;public;0;40;;public void testPortLimit() throws InterruptedException {     final NetworkService networkService = new NetworkService(Collections.emptyList()).     final Transport transport = new MockNioTransport(Settings.EMPTY, Version.CURRENT, threadPool, networkService, PageCacheRecycler.NON_RECYCLING_INSTANCE, new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService()) {          @Override         public BoundTransportAddress boundAddress() {             return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(InetAddress.getLoopbackAddress(), 9500) }, new TransportAddress(InetAddress.getLoopbackAddress(), 9500)).         }     }.     closeables.push(transport).     final TransportService transportService = new TransportService(Settings.EMPTY, transport, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, x -> null, null, Collections.emptySet()).     closeables.push(transportService).     final int limitPortCounts = randomIntBetween(1, 10).     final List<TransportAddress> transportAddresses = UnicastZenPing.resolveHostsLists(executorService, logger, Collections.singletonList("127.0.0.1"), limitPortCounts, transportService, TimeValue.timeValueSeconds(30)).     assertThat(transportAddresses, hasSize(limitPortCounts)).     final Set<Integer> ports = new HashSet<>().     for (final TransportAddress address : transportAddresses) {         assertTrue(address.address().getAddress().isLoopbackAddress()).         ports.add(address.getPort()).     }     assertThat(ports, equalTo(IntStream.range(9300, 9300 + limitPortCounts).mapToObj(m -> m).collect(Collectors.toSet()))). }
false;public;0;10;;@Override public BoundTransportAddress boundAddress() {     return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(loopbackAddress, 9300), new TransportAddress(loopbackAddress, 9301) }, new TransportAddress(loopbackAddress, 9302)). }
false;public;0;43;;public void testRemovingLocalAddresses() throws InterruptedException {     final NetworkService networkService = new NetworkService(Collections.emptyList()).     final InetAddress loopbackAddress = InetAddress.getLoopbackAddress().     final Transport transport = new MockNioTransport(Settings.EMPTY, Version.CURRENT, threadPool, networkService, PageCacheRecycler.NON_RECYCLING_INSTANCE, new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService()) {          @Override         public BoundTransportAddress boundAddress() {             return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(loopbackAddress, 9300), new TransportAddress(loopbackAddress, 9301) }, new TransportAddress(loopbackAddress, 9302)).         }     }.     closeables.push(transport).     final TransportService transportService = new TransportService(Settings.EMPTY, transport, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, x -> null, null, Collections.emptySet()).     closeables.push(transportService).     final List<TransportAddress> transportAddresses = UnicastZenPing.resolveHostsLists(executorService, logger, Collections.singletonList(NetworkAddress.format(loopbackAddress)), 10, transportService, TimeValue.timeValueSeconds(30)).     assertThat(transportAddresses, hasSize(7)).     final Set<Integer> ports = new HashSet<>().     for (final TransportAddress address : transportAddresses) {         assertTrue(address.address().getAddress().isLoopbackAddress()).         ports.add(address.getPort()).     }     assertThat(ports, equalTo(IntStream.range(9303, 9310).mapToObj(m -> m).collect(Collectors.toSet()))). }
false;public;0;7;;@Override public BoundTransportAddress boundAddress() {     return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(InetAddress.getLoopbackAddress(), 9300) }, new TransportAddress(InetAddress.getLoopbackAddress(), 9300)). }
false;public;2;4;;@Override public TransportAddress[] addressesFromString(String address, int perAddressLimit) throws UnknownHostException {     throw unknownHostException. }
false;public;0;47;;public void testUnknownHost() throws InterruptedException {     final Logger logger = mock(Logger.class).     final NetworkService networkService = new NetworkService(Collections.emptyList()).     final String hostname = randomAlphaOfLength(8).     final UnknownHostException unknownHostException = new UnknownHostException(hostname).     final Transport transport = new MockNioTransport(Settings.EMPTY, Version.CURRENT, threadPool, networkService, PageCacheRecycler.NON_RECYCLING_INSTANCE, new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService()) {          @Override         public BoundTransportAddress boundAddress() {             return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(InetAddress.getLoopbackAddress(), 9300) }, new TransportAddress(InetAddress.getLoopbackAddress(), 9300)).         }          @Override         public TransportAddress[] addressesFromString(String address, int perAddressLimit) throws UnknownHostException {             throw unknownHostException.         }     }.     closeables.push(transport).     final TransportService transportService = new TransportService(Settings.EMPTY, transport, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, x -> null, null, Collections.emptySet()).     closeables.push(transportService).     final List<TransportAddress> transportAddresses = UnicastZenPing.resolveHostsLists(executorService, logger, Arrays.asList(hostname), 1, transportService, TimeValue.timeValueSeconds(30)).     assertThat(transportAddresses, empty()).     verify(logger).warn("failed to resolve host [" + hostname + "]", unknownHostException). }
false;public;0;7;;@Override public BoundTransportAddress boundAddress() {     return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(InetAddress.getLoopbackAddress(), 9500) }, new TransportAddress(InetAddress.getLoopbackAddress(), 9500)). }
false;public;2;15;;@Override public TransportAddress[] addressesFromString(String address, int perAddressLimit) throws UnknownHostException {     if ("hostname1".equals(address)) {         return new TransportAddress[] { new TransportAddress(TransportAddress.META_ADDRESS, 9300) }.     } else if ("hostname2".equals(address)) {         try {             latch.await().             return new TransportAddress[] { new TransportAddress(TransportAddress.META_ADDRESS, 9300) }.         } catch (InterruptedException e) {             throw new RuntimeException(e).         }     } else {         throw new UnknownHostException(address).     } }
false;public;0;64;;public void testResolveTimeout() throws InterruptedException {     final Logger logger = mock(Logger.class).     final NetworkService networkService = new NetworkService(Collections.emptyList()).     final CountDownLatch latch = new CountDownLatch(1).     final Transport transport = new MockNioTransport(Settings.EMPTY, Version.CURRENT, threadPool, networkService, PageCacheRecycler.NON_RECYCLING_INSTANCE, new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService()) {          @Override         public BoundTransportAddress boundAddress() {             return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(InetAddress.getLoopbackAddress(), 9500) }, new TransportAddress(InetAddress.getLoopbackAddress(), 9500)).         }          @Override         public TransportAddress[] addressesFromString(String address, int perAddressLimit) throws UnknownHostException {             if ("hostname1".equals(address)) {                 return new TransportAddress[] { new TransportAddress(TransportAddress.META_ADDRESS, 9300) }.             } else if ("hostname2".equals(address)) {                 try {                     latch.await().                     return new TransportAddress[] { new TransportAddress(TransportAddress.META_ADDRESS, 9300) }.                 } catch (InterruptedException e) {                     throw new RuntimeException(e).                 }             } else {                 throw new UnknownHostException(address).             }         }     }.     closeables.push(transport).     final TransportService transportService = new TransportService(Settings.EMPTY, transport, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, x -> null, null, Collections.emptySet()).     closeables.push(transportService).     final TimeValue resolveTimeout = TimeValue.timeValueSeconds(randomIntBetween(3, 5)).     try {         final List<TransportAddress> transportAddresses = UnicastZenPing.resolveHostsLists(executorService, logger, Arrays.asList("hostname1", "hostname2"), 1, transportService, resolveTimeout).         assertThat(transportAddresses, hasSize(1)).         verify(logger).trace("resolved host [{}] to {}", "hostname1", new TransportAddress[] { new TransportAddress(TransportAddress.META_ADDRESS, 9300) }).         verify(logger).warn("timed out after [{}] resolving host [{}]", resolveTimeout, "hostname2").         verifyNoMoreInteractions(logger).     } finally {         latch.countDown().     } }
false;public;1;4;;@Override public void onConnectionOpened(Transport.Connection connection) {     fail("should not open any connections. got [" + connection.getNode() + "]"). }
false;public;0;65;;public void testResolveReuseExistingNodeConnections() throws ExecutionException, InterruptedException {     final Settings settings = Settings.builder().put("cluster.name", "test").put(TransportSettings.PORT.getKey(), 0).build().     NetworkService networkService = new NetworkService(Collections.emptyList()).     final BiFunction<Settings, Version, Transport> supplier = (s, v) -> new MockNioTransport(s, Version.CURRENT, threadPool, networkService, PageCacheRecycler.NON_RECYCLING_INSTANCE, new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService()).     NetworkHandle handleA = startServices(settings, threadPool, "UZP_A", Version.CURRENT, supplier, EnumSet.allOf(Role.class)).     closeables.push(handleA.transportService).     NetworkHandle handleB = startServices(settings, threadPool, "UZP_B", Version.CURRENT, supplier, EnumSet.allOf(Role.class)).     closeables.push(handleB.transportService).     final boolean useHosts = randomBoolean().     final Settings.Builder hostsSettingsBuilder = Settings.builder().put("cluster.name", "test").     if (useHosts) {         hostsSettingsBuilder.putList(DISCOVERY_SEED_HOSTS_SETTING.getKey(), NetworkAddress.format(new InetSocketAddress(handleB.address.address().getAddress(), handleB.address.address().getPort()))).     } else {         hostsSettingsBuilder.put(DISCOVERY_SEED_HOSTS_SETTING.getKey(), (String) null).     }     final Settings hostsSettings = hostsSettingsBuilder.build().     final ClusterState state = ClusterState.builder(new ClusterName("test")).version(randomNonNegativeLong()).build().     // connection to reuse     handleA.transportService.connectToNode(handleB.node).     // install a listener to check that no new connections are made     handleA.transportService.addConnectionListener(new TransportConnectionListener() {          @Override         public void onConnectionOpened(Transport.Connection connection) {             fail("should not open any connections. got [" + connection.getNode() + "]").         }     }).     final ClusterState stateA = ClusterState.builder(state).blocks(ClusterBlocks.builder().addGlobalBlock(STATE_NOT_RECOVERED_BLOCK)).nodes(DiscoveryNodes.builder().add(handleA.node).add(handleB.node).localNodeId("UZP_A")).build().     final TestUnicastZenPing zenPingA = new TestUnicastZenPing(hostsSettings, threadPool, handleA, () -> stateA).     zenPingA.start().     closeables.push(zenPingA).     final ClusterState stateB = ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(handleB.node).localNodeId("UZP_B")).build().     TestUnicastZenPing zenPingB = new TestUnicastZenPing(hostsSettings, threadPool, handleB, () -> stateB).     zenPingB.start().     closeables.push(zenPingB).     Collection<ZenPing.PingResponse> pingResponses = zenPingA.pingAndWait().toList().     assertThat(pingResponses.size(), equalTo(1)).     ZenPing.PingResponse ping = pingResponses.iterator().next().     assertThat(ping.node().getId(), equalTo("UZP_B")).     assertThat(ping.getClusterStateVersion(), equalTo(state.version())). }
false;public;0;57;;public void testPingingTemporalPings() throws ExecutionException, InterruptedException {     final Settings settings = Settings.builder().put("cluster.name", "test").put(TransportSettings.PORT.getKey(), 0).build().     NetworkService networkService = new NetworkService(Collections.emptyList()).     final BiFunction<Settings, Version, Transport> supplier = (s, v) -> new MockNioTransport(s, v, threadPool, networkService, PageCacheRecycler.NON_RECYCLING_INSTANCE, new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService()).     NetworkHandle handleA = startServices(settings, threadPool, "UZP_A", Version.CURRENT, supplier, EnumSet.allOf(Role.class)).     closeables.push(handleA.transportService).     NetworkHandle handleB = startServices(settings, threadPool, "UZP_B", Version.CURRENT, supplier, EnumSet.allOf(Role.class)).     closeables.push(handleB.transportService).     final Settings hostsSettings = Settings.builder().put("cluster.name", "test").put(DISCOVERY_SEED_HOSTS_SETTING.getKey(), // use nodes for simplicity     (String) null).build().     final ClusterState state = ClusterState.builder(new ClusterName("test")).version(randomNonNegativeLong()).build().     final ClusterState stateA = ClusterState.builder(state).blocks(ClusterBlocks.builder().addGlobalBlock(STATE_NOT_RECOVERED_BLOCK)).nodes(DiscoveryNodes.builder().add(handleA.node).add(handleB.node).localNodeId("UZP_A")).build().     final TestUnicastZenPing zenPingA = new TestUnicastZenPing(hostsSettings, threadPool, handleA, () -> stateA).     zenPingA.start().     closeables.push(zenPingA).     // Node B doesn't know about A!     final ClusterState stateB = ClusterState.builder(state).nodes(DiscoveryNodes.builder().add(handleB.node).localNodeId("UZP_B")).build().     TestUnicastZenPing zenPingB = new TestUnicastZenPing(hostsSettings, threadPool, handleB, () -> stateB).     zenPingB.start().     closeables.push(zenPingB).     {         logger.info("pinging from UZP_A so UZP_B will learn about it").         Collection<ZenPing.PingResponse> pingResponses = zenPingA.pingAndWait().toList().         assertThat(pingResponses.size(), equalTo(1)).         ZenPing.PingResponse ping = pingResponses.iterator().next().         assertThat(ping.node().getId(), equalTo("UZP_B")).         assertThat(ping.getClusterStateVersion(), equalTo(state.version())).     }     {         logger.info("pinging from UZP_B").         Collection<ZenPing.PingResponse> pingResponses = zenPingB.pingAndWait().toList().         assertThat(pingResponses.size(), equalTo(1)).         ZenPing.PingResponse ping = pingResponses.iterator().next().         assertThat(ping.node().getId(), equalTo("UZP_A")).         // A has a block         assertThat(ping.getClusterStateVersion(), equalTo(-1L)).     } }
false;public;0;7;;@Override public BoundTransportAddress boundAddress() {     return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(InetAddress.getLoopbackAddress(), 9300) }, new TransportAddress(InetAddress.getLoopbackAddress(), 9300)). }
false;public;0;36;;public void testInvalidHosts() throws InterruptedException {     final Logger logger = mock(Logger.class).     final Transport transport = new MockNioTransport(Settings.EMPTY, Version.CURRENT, threadPool, new NetworkService(Collections.emptyList()), PageCacheRecycler.NON_RECYCLING_INSTANCE, new NamedWriteableRegistry(Collections.emptyList()), new NoneCircuitBreakerService()) {          @Override         public BoundTransportAddress boundAddress() {             return new BoundTransportAddress(new TransportAddress[] { new TransportAddress(InetAddress.getLoopbackAddress(), 9300) }, new TransportAddress(InetAddress.getLoopbackAddress(), 9300)).         }     }.     closeables.push(transport).     final TransportService transportService = new TransportService(Settings.EMPTY, transport, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, x -> null, null, Collections.emptySet()).     closeables.push(transportService).     final List<TransportAddress> transportAddresses = UnicastZenPing.resolveHostsLists(executorService, logger, Arrays.asList("127.0.0.1:9300:9300", "127.0.0.1:9301"), 1, transportService, TimeValue.timeValueSeconds(30)).     // only one of the two is valid and will be used     assertThat(transportAddresses, hasSize(1)).     assertThat(transportAddresses.get(0).getAddress(), equalTo("127.0.0.1")).     assertThat(transportAddresses.get(0).getPort(), equalTo(9301)).     verify(logger).warn(eq("failed to resolve host [127.0.0.1:9300:9300]"), Matchers.any(ExecutionException.class)). }
false;private;2;8;;private void assertNoPings(final NetworkHandle fromNode, final NetworkHandle toNode) {     final AtomicInteger counter = fromNode.counters.getOrDefault(toNode.address, new AtomicInteger()).     final String onNodeName = fromNode.node.getName().     assertNotNull("handle for [" + onNodeName + "] has no 'expected' counter", counter).     final String forNodeName = toNode.node.getName().     assertThat("node [" + onNodeName + "] ping count to [" + forNodeName + "] is unexpected", counter.get(), equalTo(0)). }
false;private;2;16;;private void assertPings(final NetworkHandle fromNode, final NetworkHandle toNode) {     final AtomicInteger counter = fromNode.counters.getOrDefault(toNode.address, new AtomicInteger()).     final String onNodeName = fromNode.node.getName().     assertNotNull("handle for [" + onNodeName + "] has no 'expected' counter", counter).     final String forNodeName = toNode.node.getName().     if (Constants.WINDOWS) {         // Some of the ping attempts seem to sporadically fail on Windows (see https://github.com/elastic/elasticsearch/issues/28685)         // Anyhow, the point of the test is not to assert the exact number of pings, but to check if pinging has taken place or not         assertThat("node [" + onNodeName + "] ping count to [" + forNodeName + "] is unexpected", counter.get(), greaterThan(0)).     } else {         assertThat("node [" + onNodeName + "] ping count to [" + forNodeName + "] is unexpected", counter.get(), equalTo(3)).     } }
false;private;5;9;;private NetworkHandle startServices(final Settings settings, final ThreadPool threadPool, final String nodeId, final Version version, final BiFunction<Settings, Version, Transport> supplier) {     return startServices(settings, threadPool, nodeId, version, supplier, emptySet()). }
false;public;4;5;;@Override public void requestSent(DiscoveryNode node, long requestId, String action, TransportRequestOptions options) {     counters.computeIfAbsent(node.getAddress(), k -> new AtomicInteger()).     counters.get(node.getAddress()).incrementAndGet(). }
false;private;6;28;;private NetworkHandle startServices(final Settings settings, final ThreadPool threadPool, final String nodeId, final Version version, final BiFunction<Settings, Version, Transport> supplier, final Set<Role> nodeRoles) {     final Settings nodeSettings = Settings.builder().put(settings).put("node.name", nodeId).put(TransportSettings.TRACE_LOG_INCLUDE_SETTING.getKey(), "internal:discovery/zen/unicast").build().     final Transport transport = supplier.apply(nodeSettings, version).     final MockTransportService transportService = new MockTransportService(nodeSettings, transport, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, boundAddress -> new DiscoveryNode(nodeId, nodeId, boundAddress.publishAddress(), emptyMap(), nodeRoles, version), null, Collections.emptySet()).     transportService.start().     transportService.acceptIncomingRequests().     final ConcurrentMap<TransportAddress, AtomicInteger> counters = ConcurrentCollections.newConcurrentMap().     transportService.addTracer(new MockTransportService.Tracer() {          @Override         public void requestSent(DiscoveryNode node, long requestId, String action, TransportRequestOptions options) {             counters.computeIfAbsent(node.getAddress(), k -> new AtomicInteger()).             counters.get(node.getAddress()).incrementAndGet().         }     }).     return new NetworkHandle(transport.boundAddress().publishAddress(), transportService, transportService.getLocalNode(), counters). }
false;;0;15;;PingCollection pingAndWait() throws ExecutionException, InterruptedException {     allTasksCompleted = new CountDownLatch(1).     pingingRoundClosed = new CountDownLatch(1).     pendingTasks = new AtomicInteger().     // mark the three sending rounds as ongoing     markTaskAsStarted("send pings").     markTaskAsStarted("send pings").     markTaskAsStarted("send pings").     final AtomicReference<PingCollection> response = new AtomicReference<>().     ping(response::set, TimeValue.timeValueMillis(1), TimeValue.timeValueSeconds(30)).     pingingRoundClosed.await().     final PingCollection result = response.get().     assertNotNull("pinging didn't complete", result).     return result. }
false;protected;1;11;;@Override protected void finishPingingRound(PingingRound pingingRound) {     // wait for all activity to finish before closing     try {         allTasksCompleted.await().     } catch (InterruptedException e) {     // ok, finish anyway     }     super.finishPingingRound(pingingRound).     pingingRoundClosed.countDown(). }
false;protected;2;5;;@Override protected void sendPings(TimeValue timeout, PingingRound pingingRound) {     super.sendPings(timeout, pingingRound).     markTaskAsCompleted("send pings"). }
false;public;1;8;;@Override public void onRejection(Exception e) {     try {         super.onRejection(e).     } finally {         markTaskAsCompleted("executor runnable (rejected)").     } }
false;public;0;4;;@Override public void onAfter() {     markTaskAsCompleted("executor runnable"). }
false;protected;0;4;;@Override protected void doRun() throws Exception {     abstractRunnable.run(). }
false;public;1;5;;@Override public void onFailure(Exception e) {     // we shouldn't really end up here.     throw new AssertionError("unexpected error", e). }
false;protected;1;30;;@Override protected void submitToExecutor(AbstractRunnable abstractRunnable) {     markTaskAsStarted("executor runnable").     super.submitToExecutor(new AbstractRunnable() {          @Override         public void onRejection(Exception e) {             try {                 super.onRejection(e).             } finally {                 markTaskAsCompleted("executor runnable (rejected)").             }         }          @Override         public void onAfter() {             markTaskAsCompleted("executor runnable").         }          @Override         protected void doRun() throws Exception {             abstractRunnable.run().         }          @Override         public void onFailure(Exception e) {             // we shouldn't really end up here.             throw new AssertionError("unexpected error", e).         }     }). }
false;private;1;3;;private void markTaskAsStarted(String task) {     logger.trace("task [{}] started. count [{}]", task, pendingTasks.incrementAndGet()). }
false;private;1;7;;private void markTaskAsCompleted(String task) {     final int left = pendingTasks.decrementAndGet().     logger.trace("task [{}] completed. count [{}]", task, left).     if (left == 0) {         allTasksCompleted.countDown().     } }
false;public;1;4;;@Override public UnicastPingResponse read(StreamInput in) throws IOException {     return original.read(in). }
false;public;1;5;;@Override public void handleResponse(UnicastPingResponse response) {     original.handleResponse(response).     markTaskAsCompleted("ping [" + node + "]"). }
false;public;1;5;;@Override public void handleException(TransportException exp) {     original.handleException(exp).     markTaskAsCompleted("ping [" + node + "] (error)"). }
false;public;0;4;;@Override public String executor() {     return original.executor(). }
false;protected;2;28;;@Override protected TransportResponseHandler<UnicastPingResponse> getPingResponseHandler(PingingRound pingingRound, DiscoveryNode node) {     markTaskAsStarted("ping [" + node + "]").     TransportResponseHandler<UnicastPingResponse> original = super.getPingResponseHandler(pingingRound, node).     return new TransportResponseHandler<UnicastPingResponse>() {          @Override         public UnicastPingResponse read(StreamInput in) throws IOException {             return original.read(in).         }          @Override         public void handleResponse(UnicastPingResponse response) {             original.handleResponse(response).             markTaskAsCompleted("ping [" + node + "]").         }          @Override         public void handleException(TransportException exp) {             original.handleException(exp).             markTaskAsCompleted("ping [" + node + "] (error)").         }          @Override         public String executor() {             return original.executor().         }     }. }
