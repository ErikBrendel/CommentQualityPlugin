commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;public void testEmpty() throws IOException {     MappedFieldType ft = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG).     ft.setName("field").     testCase(ft, iw -> {     }, stats -> {         assertEquals(0d, stats.getCount(), 0).         assertEquals(0d, stats.getSum(), 0).         assertEquals(Float.NaN, stats.getAvg(), 0).         assertEquals(Double.POSITIVE_INFINITY, stats.getMin(), 0).         assertEquals(Double.NEGATIVE_INFINITY, stats.getMax(), 0).         assertEquals(Double.NaN, stats.getVariance(), 0).         assertEquals(Double.NaN, stats.getStdDeviation(), 0).         assertEquals(0d, stats.getSumOfSquares(), 0).         assertFalse(AggregationInspectionHelper.hasValue(stats)).     }). }
false;public;0;37;;public void testRandomDoubles() throws IOException {     MappedFieldType ft = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE).     ft.setName("field").     final ExtendedSimpleStatsAggregator expected = new ExtendedSimpleStatsAggregator().     testCase(ft, iw -> {         int numDocs = randomIntBetween(10, 50).         for (int i = 0. i < numDocs. i++) {             Document doc = new Document().             int numValues = randomIntBetween(1, 5).             for (int j = 0. j < numValues. j++) {                 double value = randomDoubleBetween(-100d, 100d, true).                 long valueAsLong = NumericUtils.doubleToSortableLong(value).                 doc.add(new SortedNumericDocValuesField("field", valueAsLong)).                 expected.add(value).             }             iw.addDocument(doc).         }     }, stats -> {         assertEquals(expected.count, stats.getCount(), 0).         assertEquals(expected.sum, stats.getSum(), TOLERANCE).         assertEquals(expected.min, stats.getMin(), 0).         assertEquals(expected.max, stats.getMax(), 0).         assertEquals(expected.sum / expected.count, stats.getAvg(), TOLERANCE).         assertEquals(expected.sumOfSqrs, stats.getSumOfSquares(), TOLERANCE).         assertEquals(expected.stdDev(), stats.getStdDeviation(), TOLERANCE).         assertEquals(expected.variance(), stats.getVariance(), TOLERANCE).         assertEquals(expected.stdDevBound(ExtendedStats.Bounds.LOWER, stats.getSigma()), stats.getStdDeviationBound(ExtendedStats.Bounds.LOWER), TOLERANCE).         assertEquals(expected.stdDevBound(ExtendedStats.Bounds.UPPER, stats.getSigma()), stats.getStdDeviationBound(ExtendedStats.Bounds.UPPER), TOLERANCE).         assertTrue(AggregationInspectionHelper.hasValue(stats)).     }). }
true;public;0;24;/**  * Testcase for https://github.com/elastic/elasticsearch/issues/37303  */ ;/**  * Testcase for https://github.com/elastic/elasticsearch/issues/37303  */ public void testVarianceNonNegative() throws IOException {     MappedFieldType ft = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE).     ft.setName("field").     final ExtendedSimpleStatsAggregator expected = new ExtendedSimpleStatsAggregator().     testCase(ft, iw -> {         int numDocs = 3.         for (int i = 0. i < numDocs. i++) {             Document doc = new Document().             double value = 49.95d.             long valueAsLong = NumericUtils.doubleToSortableLong(value).             doc.add(new SortedNumericDocValuesField("field", valueAsLong)).             expected.add(value).             iw.addDocument(doc).         }     }, stats -> {         // since the value(49.95) is a constant, variance should be 0         assertEquals(0.0d, stats.getVariance(), TOLERANCE).         assertEquals(0.0d, stats.getStdDeviation(), TOLERANCE).     }). }
false;public;0;36;;public void testRandomLongs() throws IOException {     MappedFieldType ft = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.LONG).     ft.setName("field").     final ExtendedSimpleStatsAggregator expected = new ExtendedSimpleStatsAggregator().     testCase(ft, iw -> {         int numDocs = randomIntBetween(10, 50).         for (int i = 0. i < numDocs. i++) {             Document doc = new Document().             int numValues = randomIntBetween(1, 5).             for (int j = 0. j < numValues. j++) {                 long value = randomIntBetween(-100, 100).                 doc.add(new SortedNumericDocValuesField("field", value)).                 expected.add(value).             }             iw.addDocument(doc).         }     }, stats -> {         assertEquals(expected.count, stats.getCount(), 0).         assertEquals(expected.sum, stats.getSum(), TOLERANCE).         assertEquals(expected.min, stats.getMin(), 0).         assertEquals(expected.max, stats.getMax(), 0).         assertEquals(expected.sum / expected.count, stats.getAvg(), TOLERANCE).         assertEquals(expected.sumOfSqrs, stats.getSumOfSquares(), TOLERANCE).         assertEquals(expected.stdDev(), stats.getStdDeviation(), TOLERANCE).         assertEquals(expected.variance(), stats.getVariance(), TOLERANCE).         assertEquals(expected.stdDevBound(ExtendedStats.Bounds.LOWER, stats.getSigma()), stats.getStdDeviationBound(ExtendedStats.Bounds.LOWER), TOLERANCE).         assertEquals(expected.stdDevBound(ExtendedStats.Bounds.UPPER, stats.getSigma()), stats.getStdDeviationBound(ExtendedStats.Bounds.UPPER), TOLERANCE).         assertTrue(AggregationInspectionHelper.hasValue(stats)).     }). }
false;public;0;31;;public void testSummationAccuracy() throws IOException {     double[] values = new double[] { 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.9, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7 }.     verifyStatsOfDoubles(values, 13.5, 16.21, 0d).     // Summing up an array which contains NaN and infinities and expect a result same as naive summation     int n = randomIntBetween(5, 10).     values = new double[n].     double sum = 0.     double sumOfSqrs = 0.     for (int i = 0. i < n. i++) {         values[i] = frequently() ? randomFrom(Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY) : randomDoubleBetween(Double.MIN_VALUE, Double.MAX_VALUE, true).         sum += values[i].         sumOfSqrs += values[i] * values[i].     }     verifyStatsOfDoubles(values, sum, sumOfSqrs, TOLERANCE).     // Summing up some big double values and expect infinity result     n = randomIntBetween(5, 10).     double[] largeValues = new double[n].     for (int i = 0. i < n. i++) {         largeValues[i] = Double.MAX_VALUE.     }     verifyStatsOfDoubles(largeValues, Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY, 0d).     for (int i = 0. i < n. i++) {         largeValues[i] = -Double.MAX_VALUE.     }     verifyStatsOfDoubles(largeValues, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, 0d). }
false;private;4;29;;private void verifyStatsOfDoubles(double[] values, double expectedSum, double expectedSumOfSqrs, double delta) throws IOException {     MappedFieldType ft = new NumberFieldMapper.NumberFieldType(NumberFieldMapper.NumberType.DOUBLE).     final String fieldName = "field".     ft.setName(fieldName).     double max = Double.NEGATIVE_INFINITY.     double min = Double.POSITIVE_INFINITY.     for (double value : values) {         max = Math.max(max, value).         min = Math.min(min, value).     }     double expectedMax = max.     double expectedMin = min.     testCase(ft, iw -> {         for (double value : values) {             iw.addDocument(singleton(new NumericDocValuesField(fieldName, NumericUtils.doubleToSortableLong(value)))).         }     }, stats -> {         assertEquals(values.length, stats.getCount()).         assertEquals(expectedSum / values.length, stats.getAvg(), delta).         assertEquals(expectedSum, stats.getSum(), delta).         assertEquals(expectedSumOfSqrs, stats.getSumOfSquares(), delta).         assertEquals(expectedMax, stats.getMax(), 0d).         assertEquals(expectedMin, stats.getMin(), 0d).     }). }
false;public;3;16;;public void testCase(MappedFieldType ft, CheckedConsumer<RandomIndexWriter, IOException> buildIndex, Consumer<InternalExtendedStats> verify) throws IOException {     try (Directory directory = newDirectory().         RandomIndexWriter indexWriter = new RandomIndexWriter(random(), directory)) {         buildIndex.accept(indexWriter).         try (IndexReader reader = indexWriter.getReader()) {             IndexSearcher searcher = new IndexSearcher(reader).             ExtendedStatsAggregationBuilder aggBuilder = new ExtendedStatsAggregationBuilder("my_agg").field("field").sigma(randomDoubleBetween(0, 10, true)).             InternalExtendedStats stats = search(searcher, new MatchAllDocsQuery(), aggBuilder, ft).             verify.accept(stats).         }     } }
false;;1;4;;void add(double value) {     super.add(value).     sumOfSqrs += (value * value). }
false;;0;3;;double stdDev() {     return Math.sqrt(variance()). }
false;;2;7;;double stdDevBound(ExtendedStats.Bounds bounds, double sigma) {     if (bounds == ExtendedStats.Bounds.UPPER) {         return (sum / count) + (Math.sqrt(variance()) * sigma).     } else {         return (sum / count) - (Math.sqrt(variance()) * sigma).     } }
false;;0;4;;double variance() {     double variance = (sumOfSqrs - ((sum * sum) / count)) / count.     return variance < 0 ? 0 : variance. }
