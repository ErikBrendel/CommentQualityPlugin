commented;modifiers;parameterAmount;loc;comment;code
false;public;0;11;;public void testCancelOnThreadPool() {     ThreadPool threadPool = new TestThreadPool("test").     AtomicLong executed = new AtomicLong().     try {         ThreadPool.THREAD_POOL_TYPES.keySet().forEach(type -> scheduleAndCancel(threadPool, executed, type)).         assertEquals(0, executed.get()).     } finally {         ThreadPool.terminate(threadPool, 10, TimeUnit.SECONDS).     } }
false;private;3;8;;private void scheduleAndCancel(ThreadPool threadPool, AtomicLong executed, String type) {     Scheduler.ScheduledCancellable scheduled = threadPool.schedule(executed::incrementAndGet, TimeValue.timeValueSeconds(20), type).     assertEquals(1, schedulerQueueSize(threadPool)).     assertFalse(scheduled.isCancelled()).     assertTrue(scheduled.cancel()).     assertTrue(scheduled.isCancelled()).     assertEquals("Cancel must auto-remove", 0, schedulerQueueSize(threadPool)). }
false;private;1;3;;private int schedulerQueueSize(ThreadPool threadPool) {     return ((Scheduler.SafeScheduledThreadPoolExecutor) threadPool.scheduler()).getQueue().size(). }
false;public;0;19;;public void testCancelOnScheduler() {     ScheduledThreadPoolExecutor executor = Scheduler.initScheduler(Settings.EMPTY).     Scheduler scheduler = (command, delay, name) -> Scheduler.wrapAsScheduledCancellable(executor.schedule(command, delay.millis(), TimeUnit.MILLISECONDS)).     AtomicLong executed = new AtomicLong().     try {         Scheduler.ScheduledCancellable scheduled = scheduler.schedule(executed::incrementAndGet, TimeValue.timeValueSeconds(20), ThreadPool.Names.SAME).         assertEquals(1, executor.getQueue().size()).         assertFalse(scheduled.isCancelled()).         assertTrue(scheduled.cancel()).         assertTrue(scheduled.isCancelled()).         assertEquals("Cancel must auto-remove", 0, executor.getQueue().size()).         assertEquals(0, executed.get()).     } finally {         Scheduler.terminate(executor, 10, TimeUnit.SECONDS).     } }
false;public;0;21;;public void testDelay() throws InterruptedException {     ThreadPool threadPool = new TestThreadPool("test").     try {         List<Scheduler.ScheduledCancellable> jobs = LongStream.range(20, 30).mapToObj(delay -> threadPool.schedule(() -> {         }, TimeValue.timeValueSeconds(delay), ThreadPool.Names.SAME)).collect(Collectors.toCollection(ArrayList::new)).         Collections.reverse(jobs).         List<Long> initialDelays = verifyJobDelays(jobs).         Thread.sleep(50).         List<Long> laterDelays = verifyJobDelays(jobs).         assertThat(laterDelays, Matchers.contains(initialDelays.stream().map(Matchers::lessThan).collect(Collectors.toList()))).     } finally {         ThreadPool.terminate(threadPool, 10, TimeUnit.SECONDS).     } }
false;private;1;19;;private List<Long> verifyJobDelays(List<Scheduler.ScheduledCancellable> jobs) {     List<Long> delays = new ArrayList<>(jobs.size()).     Scheduler.ScheduledCancellable previous = null.     for (Scheduler.ScheduledCancellable job : jobs) {         if (previous != null) {             long previousDelay = previous.getDelay(TimeUnit.MILLISECONDS).             long delay = job.getDelay(TimeUnit.MILLISECONDS).             assertThat(delay, Matchers.lessThan(previousDelay)).             assertThat(job, Matchers.lessThan(previous)).         }         assertThat(job.getDelay(TimeUnit.SECONDS), Matchers.greaterThan(1L)).         assertThat(job.getDelay(TimeUnit.SECONDS), Matchers.lessThanOrEqualTo(30L)).         delays.add(job.getDelay(TimeUnit.NANOSECONDS)).         previous = job.     }     return delays. }
true;public;0;13;// simple test for successful scheduling, exceptions tested more thoroughly in EvilThreadPoolTests ;// simple test for successful scheduling, exceptions tested more thoroughly in EvilThreadPoolTests public void testScheduledOnThreadPool() throws InterruptedException {     ThreadPool threadPool = new TestThreadPool("test").     CountDownLatch missingExecutions = new CountDownLatch(ThreadPool.THREAD_POOL_TYPES.keySet().size()).     try {         ThreadPool.THREAD_POOL_TYPES.keySet().forEach(type -> threadPool.schedule(missingExecutions::countDown, TimeValue.timeValueMillis(randomInt(5)), type)).         assertTrue(missingExecutions.await(30, TimeUnit.SECONDS)).     } finally {         ThreadPool.terminate(threadPool, 10, TimeUnit.SECONDS).     } }
true;public;0;13;// simple test for successful scheduling, exceptions tested more thoroughly in EvilThreadPoolTests ;// simple test for successful scheduling, exceptions tested more thoroughly in EvilThreadPoolTests public void testScheduledOnScheduler() throws InterruptedException {     ScheduledThreadPoolExecutor executor = Scheduler.initScheduler(Settings.EMPTY).     Scheduler scheduler = (command, delay, name) -> Scheduler.wrapAsScheduledCancellable(executor.schedule(command, delay.millis(), TimeUnit.MILLISECONDS)).     CountDownLatch missingExecutions = new CountDownLatch(1).     try {         scheduler.schedule(missingExecutions::countDown, TimeValue.timeValueMillis(randomInt(5)), ThreadPool.Names.SAME).         assertTrue(missingExecutions.await(30, TimeUnit.SECONDS)).     } finally {         Scheduler.terminate(executor, 10, TimeUnit.SECONDS).     } }
