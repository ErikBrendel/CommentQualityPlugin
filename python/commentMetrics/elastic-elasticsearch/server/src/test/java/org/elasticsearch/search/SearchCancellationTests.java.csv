commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;13;;@BeforeClass public static void setup() throws IOException {     dir = newDirectory().     RandomIndexWriter w = new RandomIndexWriter(random(), dir).     // we need at least 2 segments - so no merges should be allowed     w.w.getConfig().setMergePolicy(NoMergePolicy.INSTANCE).     w.setDoRandomForceMerge(false).     indexRandomDocuments(w, TestUtil.nextInt(random(), 2, 20)).     w.flush().     indexRandomDocuments(w, TestUtil.nextInt(random(), 1, 20)).     reader = w.getReader().     w.close(). }
false;private,static;2;7;;private static void indexRandomDocuments(RandomIndexWriter w, int numDocs) throws IOException {     for (int i = 0. i < numDocs. ++i) {         Document doc = new Document().         doc.add(new StringField("foo", "bar", Field.Store.NO)).         w.addDocument(doc).     } }
false;public,static;0;6;;@AfterClass public static void cleanup() throws IOException {     IOUtils.close(reader, dir).     dir = null.     reader = null. }
false;public;0;10;;public void testCancellableCollector() throws IOException {     TotalHitCountCollector collector = new TotalHitCountCollector().     AtomicBoolean cancelled = new AtomicBoolean().     CancellableCollector cancellableCollector = new CancellableCollector(cancelled::get, collector).     final LeafCollector leafCollector = cancellableCollector.getLeafCollector(reader.leaves().get(0)).     leafCollector.collect(0).     cancelled.set(true).     leafCollector.collect(1).     expectThrows(TaskCancelledException.class, () -> cancellableCollector.getLeafCollector(reader.leaves().get(1))). }
