# id;timestamp;commentText;codeText;commentWords;codeWords
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1544523743;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        onNode(nonLeader.getLocalNode(), () -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,on,node,non,leader,get,local,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1544546419;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        onNode(nonLeader.getLocalNode(), () -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,on,node,non,leader,get,local,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1545223874;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        onNode(nonLeader.getLocalNode(), () -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,on,node,non,leader,get,local,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1546251441;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        onNode(nonLeader.getLocalNode(), () -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,on,node,non,leader,get,local,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1546850547;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        onNode(nonLeader.getLocalNode(), () -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,on,node,non,leader,get,local,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1547022744;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        onNode(nonLeader.getLocalNode(), () -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,on,node,non,leader,get,local,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1547121470;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        onNode(nonLeader.getLocalNode(), () -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,on,node,non,leader,get,local,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1547219208;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1547494744;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1547577205;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1548155031;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1548245411;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1548335343;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1548762184;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1548772865;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1549029235;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1549094096;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1549356476;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1549452878;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1550166171;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1551165559;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
CoordinatorTests -> public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster();1551258457;Simulates a situation where a follower becomes disconnected from the leader, but only for such a short time where_it becomes candidate and puts up a NO_MASTER_BLOCK, but then receives a follower check from the leader. If the leader_does not notice the node disconnecting, it is important for the node not to be turned back into a follower but try_and join the leader again.;public void testStayCandidateAfterReceivingFollowerCheckFromKnownMaster() {_        final Cluster cluster = new Cluster(2, false)__        cluster.runRandomly()__        cluster.stabilise()___        final ClusterNode leader = cluster.getAnyLeader()__        final ClusterNode nonLeader = cluster.getAnyNodeExcept(leader)__        nonLeader.onNode(() -> {_            logger.debug("forcing {} to become candidate", nonLeader.getId())__            synchronized (nonLeader.coordinator.mutex) {_                nonLeader.coordinator.becomeCandidate("forced")__            }_            logger.debug("simulate follower check coming through from {} to {}", leader.getId(), nonLeader.getId())__            nonLeader.coordinator.onFollowerCheckRequest(new FollowersChecker.FollowerCheckRequest(leader.coordinator.getCurrentTerm(),_                leader.getLocalNode()))__        }).run()__        cluster.stabilise()__    };simulates,a,situation,where,a,follower,becomes,disconnected,from,the,leader,but,only,for,such,a,short,time,where,it,becomes,candidate,and,puts,up,a,but,then,receives,a,follower,check,from,the,leader,if,the,leader,does,not,notice,the,node,disconnecting,it,is,important,for,the,node,not,to,be,turned,back,into,a,follower,but,try,and,join,the,leader,again;public,void,test,stay,candidate,after,receiving,follower,check,from,known,master,final,cluster,cluster,new,cluster,2,false,cluster,run,randomly,cluster,stabilise,final,cluster,node,leader,cluster,get,any,leader,final,cluster,node,non,leader,cluster,get,any,node,except,leader,non,leader,on,node,logger,debug,forcing,to,become,candidate,non,leader,get,id,synchronized,non,leader,coordinator,mutex,non,leader,coordinator,become,candidate,forced,logger,debug,simulate,follower,check,coming,through,from,to,leader,get,id,non,leader,get,id,non,leader,coordinator,on,follower,check,request,new,followers,checker,follower,check,request,leader,coordinator,get,current,term,leader,get,local,node,run,cluster,stabilise
