commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;3;/**  * Consumes a snapshot and make sure it's size is as expected  */ ;/**  * Consumes a snapshot and make sure it's size is as expected  */ public static Matcher<Translog.Snapshot> size(int size) {     return new SizeMatcher(size). }
true;public,static;1;3;/**  * Consumes a snapshot and make sure it's content is as expected  */ ;/**  * Consumes a snapshot and make sure it's content is as expected  */ public static Matcher<Translog.Snapshot> equalsTo(Translog.Operation... ops) {     return new EqualMatcher(ops). }
true;public,static;1;3;/**  * Consumes a snapshot and make sure it's content is as expected  */ ;/**  * Consumes a snapshot and make sure it's content is as expected  */ public static Matcher<Translog.Snapshot> equalsTo(List<Translog.Operation> ops) {     return new EqualMatcher(ops.toArray(new Translog.Operation[ops.size()])). }
false;public,static;1;3;;public static Matcher<Translog.Snapshot> containsOperationsInAnyOrder(Collection<Translog.Operation> expectedOperations) {     return new ContainingInAnyOrderMatcher(expectedOperations). }
true;public,static;2;3;/**  * Consumes a snapshot and makes sure that its operations have all seqno between minSeqNo(inclusive) and maxSeqNo(inclusive).  */ ;/**  * Consumes a snapshot and makes sure that its operations have all seqno between minSeqNo(inclusive) and maxSeqNo(inclusive).  */ public static Matcher<Translog.Snapshot> containsSeqNoRange(long minSeqNo, long maxSeqNo) {     return new ContainingSeqNoRangeMatcher(minSeqNo, maxSeqNo). }
false;public;1;12;;@Override public boolean matchesSafely(Translog.Snapshot snapshot) {     int count = 0.     try {         while (snapshot.next() != null) {             count++.         }     } catch (IOException ex) {         throw new ElasticsearchException("failed to advance snapshot", ex).     }     return size == count. }
false;public;1;4;;@Override public void describeTo(Description description) {     description.appendText("a snapshot with size ").appendValue(size). }
false;protected;1;30;;@Override protected boolean matchesSafely(Translog.Snapshot snapshot) {     try {         Translog.Operation op.         int i.         for (i = 0, op = snapshot.next(). op != null && i < expectedOps.length. i++, op = snapshot.next()) {             if (expectedOps[i].equals(op) == false) {                 failureMsg = "position [" + i + "] expected [" + expectedOps[i] + "] but found [" + op + "]".                 return false.             }         }         if (i < expectedOps.length) {             failureMsg = "expected [" + expectedOps.length + "] ops but only found [" + i + "]".             return false.         }         if (op != null) {             // to account for the op we already read             int count = 1.             while (snapshot.next() != null) {                 count++.             }             failureMsg = "expected [" + expectedOps.length + "] ops but got [" + (expectedOps.length + count) + "]".             return false.         }         return true.     } catch (IOException ex) {         throw new ElasticsearchException("failed to read snapshot content", ex).     } }
false;public;1;4;;@Override public void describeTo(Description description) {     description.appendText(failureMsg). }
false;static;1;8;;static List<Translog.Operation> drainAll(Translog.Snapshot snapshot) throws IOException {     final List<Translog.Operation> actualOps = new ArrayList<>().     Translog.Operation op.     while ((op = snapshot.next()) != null) {         actualOps.add(op).     }     return actualOps. }
false;protected;1;15;;@Override protected boolean matchesSafely(Translog.Snapshot snapshot) {     try {         List<Translog.Operation> actualOps = drainAll(snapshot).         notFoundOps = expectedOps.stream().filter(o -> actualOps.contains(o) == false).collect(Collectors.toList()).         notExpectedOps = actualOps.stream().filter(o -> expectedOps.contains(o) == false).collect(Collectors.toList()).         return notFoundOps.isEmpty() && notExpectedOps.isEmpty().     } catch (IOException ex) {         throw new ElasticsearchException("failed to read snapshot content", ex).     } }
false;protected;2;14;;@Override protected void describeMismatchSafely(Translog.Snapshot snapshot, Description mismatchDescription) {     if (notFoundOps.isEmpty() == false) {         mismatchDescription.appendText("not found ").appendValueList("[", ", ", "]", notFoundOps).     }     if (notExpectedOps.isEmpty() == false) {         if (notFoundOps.isEmpty() == false) {             mismatchDescription.appendText(". ").         }         mismatchDescription.appendText("not expected ").appendValueList("[", ", ", "]", notExpectedOps).     } }
false;public;1;6;;@Override public void describeTo(Description description) {     description.appendText("snapshot contains ").appendValueList("[", ", ", "]", expectedOps).appendText(" in any order."). }
false;protected;1;18;;@Override protected boolean matchesSafely(Translog.Snapshot snapshot) {     try {         final LongSet seqNoList = new LongHashSet().         Translog.Operation op.         while ((op = snapshot.next()) != null) {             seqNoList.add(op.seqNo()).         }         for (long i = minSeqNo. i <= maxSeqNo. i++) {             if (seqNoList.contains(i) == false) {                 notFoundSeqNo.add(i).             }         }         return notFoundSeqNo.isEmpty().     } catch (IOException ex) {         throw new ElasticsearchException("failed to read snapshot content", ex).     } }
false;protected;2;5;;@Override protected void describeMismatchSafely(Translog.Snapshot snapshot, Description mismatchDescription) {     mismatchDescription.appendText("not found seqno ").appendValueList("[", ", ", "]", notFoundSeqNo). }
false;public;1;4;;@Override public void describeTo(Description description) {     description.appendText("snapshot contains all seqno from [" + minSeqNo + " to " + maxSeqNo + "]"). }
