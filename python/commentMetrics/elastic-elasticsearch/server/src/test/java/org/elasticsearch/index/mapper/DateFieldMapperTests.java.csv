commented;modifiers;parameterAmount;loc;comment;code
false;public;0;5;;@Before public void setup() {     indexService = createIndex("test").     parser = indexService.mapperService().documentMapperParser(). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> getPlugins() {     return pluginList(InternalSettingsPlugin.class). }
false;public;0;28;;public void testDefaults() throws Exception {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").endObject().endObject().endObject().endObject()).     DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping)).     assertEquals(mapping, mapper.mappingSource().toString()).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field("field", "2016-03-11").endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(2, fields.length).     IndexableField pointField = fields[0].     assertEquals(1, pointField.fieldType().pointIndexDimensionCount()).     assertEquals(8, pointField.fieldType().pointNumBytes()).     assertFalse(pointField.fieldType().stored()).     assertEquals(1457654400000L, pointField.numericValue().longValue()).     IndexableField dvField = fields[1].     assertEquals(DocValuesType.SORTED_NUMERIC, dvField.fieldType().docValuesType()).     assertEquals(1457654400000L, dvField.numericValue().longValue()).     assertFalse(dvField.fieldType().stored()). }
false;public;0;21;;public void testNotIndexed() throws Exception {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").field("index", false).endObject().endObject().endObject().endObject()).     DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping)).     assertEquals(mapping, mapper.mappingSource().toString()).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field("field", "2016-03-11").endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(1, fields.length).     IndexableField dvField = fields[0].     assertEquals(DocValuesType.SORTED_NUMERIC, dvField.fieldType().docValuesType()). }
false;public;0;21;;public void testNoDocValues() throws Exception {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").field("doc_values", false).endObject().endObject().endObject().endObject()).     DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping)).     assertEquals(mapping, mapper.mappingSource().toString()).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field("field", "2016-03-11").endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(1, fields.length).     IndexableField pointField = fields[0].     assertEquals(1, pointField.fieldType().pointIndexDimensionCount()). }
false;public;0;26;;public void testStore() throws Exception {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").field("store", true).endObject().endObject().endObject().endObject()).     DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping)).     assertEquals(mapping, mapper.mappingSource().toString()).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field("field", "2016-03-11").endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(3, fields.length).     IndexableField pointField = fields[0].     assertEquals(1, pointField.fieldType().pointIndexDimensionCount()).     IndexableField dvField = fields[1].     assertEquals(DocValuesType.SORTED_NUMERIC, dvField.fieldType().docValuesType()).     IndexableField storedField = fields[2].     assertTrue(storedField.fieldType().stored()).     assertEquals(1457654400000L, storedField.numericValue().longValue()). }
false;public;0;37;;public void testIgnoreMalformed() throws Exception {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").endObject().endObject().endObject().endObject()).     DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping)).     assertEquals(mapping, mapper.mappingSource().toString()).     ThrowingRunnable runnable = () -> mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field("field", "2016-03-99").endObject()), XContentType.JSON)).     MapperParsingException e = expectThrows(MapperParsingException.class, runnable).     assertThat(e.getCause().getMessage(), containsString("failed to parse date field [2016-03-99] with format [strict_date_optional_time||epoch_millis]")).     mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").field("ignore_malformed", true).endObject().endObject().endObject().endObject()).     DocumentMapper mapper2 = parser.parse("type", new CompressedXContent(mapping)).     ParsedDocument doc = mapper2.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field("field", ":1").endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(0, fields.length).     assertArrayEquals(new String[] { "field" }, doc.rootDoc().getValues("_ignored")). }
false;public;0;22;;public void testChangeFormat() throws IOException {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").field("format", "epoch_second").endObject().endObject().endObject().endObject()).     DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping)).     assertEquals(mapping, mapper.mappingSource().toString()).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field("field", 1457654400).endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(2, fields.length).     IndexableField pointField = fields[0].     assertEquals(1457654400000L, pointField.numericValue().longValue()). }
false;public;0;19;;public void testChangeLocale() throws IOException {     assumeTrue("need java 9 for testing ", JavaVersion.current().compareTo(JavaVersion.parse("9")) >= 0).     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").field("format", "E, d MMM yyyy HH:mm:ss Z").field("locale", "de").endObject().endObject().endObject().endObject()).     DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping)).     assertEquals(mapping, mapper.mappingSource().toString()).     mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field("field", "Mi., 06 Dez. 2000 02:55:00 -0800").endObject()), XContentType.JSON)). }
false;public;0;52;;public void testNullValue() throws IOException {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").endObject().endObject().endObject().endObject()).     DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping)).     assertEquals(mapping, mapper.mappingSource().toString()).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().nullField("field").endObject()), XContentType.JSON)).     assertArrayEquals(new IndexableField[0], doc.rootDoc().getFields("field")).     mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").field("null_value", "2016-03-11").endObject().endObject().endObject().endObject()).     mapper = parser.parse("type", new CompressedXContent(mapping)).     assertEquals(mapping, mapper.mappingSource().toString()).     doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().nullField("field").endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(2, fields.length).     IndexableField pointField = fields[0].     assertEquals(1, pointField.fieldType().pointIndexDimensionCount()).     assertEquals(8, pointField.fieldType().pointNumBytes()).     assertFalse(pointField.fieldType().stored()).     assertEquals(1457654400000L, pointField.numericValue().longValue()).     IndexableField dvField = fields[1].     assertEquals(DocValuesType.SORTED_NUMERIC, dvField.fieldType().docValuesType()).     assertEquals(1457654400000L, dvField.numericValue().longValue()).     assertFalse(dvField.fieldType().stored()). }
false;public;0;14;;public void testNullConfigValuesFail() throws MapperParsingException, IOException {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").field("format", (String) null).endObject().endObject().endObject().endObject()).     Exception e = expectThrows(MapperParsingException.class, () -> parser.parse("type", new CompressedXContent(mapping))).     assertEquals("[format] must not have a [null] value", e.getMessage()). }
false;public;0;11;;public void testEmptyName() throws IOException {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("").field("type", "date").field("format", "epoch_second").endObject().endObject().endObject().endObject()).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> parser.parse("type", new CompressedXContent(mapping))).     assertThat(e.getMessage(), containsString("name cannot be empty string")). }
false;public;0;33;;public void testTimeZoneParsing() throws Exception {     final String timeZonePattern = "yyyy-MM-dd" + randomFrom("XXX", "[XXX]", "'['XXX']'").     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").field("format", timeZonePattern).endObject().endObject().endObject().endObject()).     DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping)).     assertEquals(mapping, mapper.mappingSource().toString()).     DateFormatter formatter = DateFormatter.forPattern(timeZonePattern).     final ZoneId randomTimeZone = randomBoolean() ? ZoneId.of(randomFrom("UTC", "CET")) : randomZone().     final ZonedDateTime randomDate = ZonedDateTime.of(2016, 3, 11, 0, 0, 0, 0, randomTimeZone).     ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference.bytes(XContentFactory.jsonBuilder().startObject().field("field", formatter.format(randomDate)).endObject()), XContentType.JSON)).     IndexableField[] fields = doc.rootDoc().getFields("field").     assertEquals(2, fields.length).     long millis = randomDate.withZoneSameInstant(ZoneOffset.UTC).toInstant().toEpochMilli().     assertEquals(millis, fields[0].numericValue().longValue()). }
false;public;0;21;;public void testMergeDate() throws IOException {     String initMapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("movie").startObject("properties").startObject("release_date").field("type", "date").field("format", "yyyy/MM/dd").endObject().endObject().endObject().endObject()).     indexService.mapperService().merge("movie", new CompressedXContent(initMapping), MapperService.MergeReason.MAPPING_UPDATE).     assertThat(indexService.mapperService().fullName("release_date"), notNullValue()).     assertFalse(indexService.mapperService().fullName("release_date").stored()).     String updateFormatMapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("movie").startObject("properties").startObject("release_date").field("type", "date").field("format", "epoch_millis").endObject().endObject().endObject().endObject()).     Exception e = expectThrows(IllegalArgumentException.class, () -> indexService.mapperService().merge("movie", new CompressedXContent(updateFormatMapping), MapperService.MergeReason.MAPPING_UPDATE)).     assertThat(e.getMessage(), containsString("[mapper [release_date] has different [format] values]")). }
false;public;0;15;;public void testMergeText() throws Exception {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("_doc").startObject("properties").startObject("date").field("type", "date").endObject().endObject().endObject().endObject()).     DocumentMapper mapper = indexService.mapperService().parse("_doc", new CompressedXContent(mapping), false).     String mappingUpdate = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("_doc").startObject("properties").startObject("date").field("type", "text").endObject().endObject().endObject().endObject()).     DocumentMapper update = indexService.mapperService().parse("_doc", new CompressedXContent(mappingUpdate), false).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> mapper.merge(update.mapping())).     assertEquals("mapper [date] of different type, current_type [date], merged_type [text]", e.getMessage()). }
false;public;0;17;;public void testIllegalFormatField() throws Exception {     String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject().startObject("type").startObject("properties").startObject("field").field("type", "date").array("format", "test_format").endObject().endObject().endObject().endObject()).     IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> parser.parse("type", new CompressedXContent(mapping))).     assertEquals("Invalid format: [[test_format]]: Unknown pattern letter: t", e.getMessage()). }
