# id;timestamp;commentText;codeText;commentWords;codeWords
DateFieldMapperTests -> public void testTimeZoneParsing() throws Exception;1524684173;Test that time zones are correctly parsed by the {@link DateFieldMapper}._There is a known bug with Joda 2.9.4 reported in https://github.com/JodaOrg/joda-time/issues/373.;public void testTimeZoneParsing() throws Exception {_        final String timeZonePattern = "yyyy-MM-dd" + randomFrom("ZZZ", "[ZZZ]", "'['ZZZ']'")___        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject()_                .startObject("type")_                    .startObject("properties")_                        .startObject("field")_                            .field("type", "date")_                            .field("format", timeZonePattern)_                        .endObject()_                    .endObject()_                .endObject().endObject())___        DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping))__        assertEquals(mapping, mapper.mappingSource().toString())___        final DateTimeZone randomTimeZone = randomBoolean() ? DateTimeZone.forID(randomFrom("UTC", "CET")) : randomDateTimeZone()__        final DateTime randomDate = new DateTime(2016, 03, 11, 0, 0, 0, randomTimeZone)___        ParsedDocument doc = mapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject()_                            .field("field", DateTimeFormat.forPattern(timeZonePattern).print(randomDate))_                        .endObject()),_                XContentType.JSON))___        IndexableField[] fields = doc.rootDoc().getFields("field")__        assertEquals(2, fields.length)___        assertEquals(randomDate.withZone(DateTimeZone.UTC).getMillis(), fields[0].numericValue().longValue())__    };test,that,time,zones,are,correctly,parsed,by,the,link,date,field,mapper,there,is,a,known,bug,with,joda,2,9,4,reported,in,https,github,com,joda,org,joda,time,issues,373;public,void,test,time,zone,parsing,throws,exception,final,string,time,zone,pattern,yyyy,mm,dd,random,from,zzz,zzz,zzz,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field,field,type,date,field,format,time,zone,pattern,end,object,end,object,end,object,end,object,document,mapper,mapper,parser,parse,type,new,compressed,xcontent,mapping,assert,equals,mapping,mapper,mapping,source,to,string,final,date,time,zone,random,time,zone,random,boolean,date,time,zone,for,id,random,from,utc,cet,random,date,time,zone,final,date,time,random,date,new,date,time,2016,03,11,0,0,0,random,time,zone,parsed,document,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,field,field,date,time,format,for,pattern,time,zone,pattern,print,random,date,end,object,xcontent,type,json,indexable,field,fields,doc,root,doc,get,fields,field,assert,equals,2,fields,length,assert,equals,random,date,with,zone,date,time,zone,utc,get,millis,fields,0,numeric,value,long,value
DateFieldMapperTests -> public void testTimeZoneParsing() throws Exception;1525334055;Test that time zones are correctly parsed by the {@link DateFieldMapper}._There is a known bug with Joda 2.9.4 reported in https://github.com/JodaOrg/joda-time/issues/373.;public void testTimeZoneParsing() throws Exception {_        final String timeZonePattern = "yyyy-MM-dd" + randomFrom("ZZZ", "[ZZZ]", "'['ZZZ']'")___        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject()_                .startObject("type")_                    .startObject("properties")_                        .startObject("field")_                            .field("type", "date")_                            .field("format", timeZonePattern)_                        .endObject()_                    .endObject()_                .endObject().endObject())___        DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping))__        assertEquals(mapping, mapper.mappingSource().toString())___        final DateTimeZone randomTimeZone = randomBoolean() ? DateTimeZone.forID(randomFrom("UTC", "CET")) : randomDateTimeZone()__        final DateTime randomDate = new DateTime(2016, 03, 11, 0, 0, 0, randomTimeZone)___        ParsedDocument doc = mapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject()_                            .field("field", DateTimeFormat.forPattern(timeZonePattern).print(randomDate))_                        .endObject()),_                XContentType.JSON))___        IndexableField[] fields = doc.rootDoc().getFields("field")__        assertEquals(2, fields.length)___        assertEquals(randomDate.withZone(DateTimeZone.UTC).getMillis(), fields[0].numericValue().longValue())__    };test,that,time,zones,are,correctly,parsed,by,the,link,date,field,mapper,there,is,a,known,bug,with,joda,2,9,4,reported,in,https,github,com,joda,org,joda,time,issues,373;public,void,test,time,zone,parsing,throws,exception,final,string,time,zone,pattern,yyyy,mm,dd,random,from,zzz,zzz,zzz,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field,field,type,date,field,format,time,zone,pattern,end,object,end,object,end,object,end,object,document,mapper,mapper,parser,parse,type,new,compressed,xcontent,mapping,assert,equals,mapping,mapper,mapping,source,to,string,final,date,time,zone,random,time,zone,random,boolean,date,time,zone,for,id,random,from,utc,cet,random,date,time,zone,final,date,time,random,date,new,date,time,2016,03,11,0,0,0,random,time,zone,parsed,document,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,field,field,date,time,format,for,pattern,time,zone,pattern,print,random,date,end,object,xcontent,type,json,indexable,field,fields,doc,root,doc,get,fields,field,assert,equals,2,fields,length,assert,equals,random,date,with,zone,date,time,zone,utc,get,millis,fields,0,numeric,value,long,value
DateFieldMapperTests -> public void testTimeZoneParsing() throws Exception;1531937412;Test that time zones are correctly parsed by the {@link DateFieldMapper}._There is a known bug with Joda 2.9.4 reported in https://github.com/JodaOrg/joda-time/issues/373.;public void testTimeZoneParsing() throws Exception {_        final String timeZonePattern = "yyyy-MM-dd" + randomFrom("ZZZ", "[ZZZ]", "'['ZZZ']'")___        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject()_                .startObject("type")_                    .startObject("properties")_                        .startObject("field")_                            .field("type", "date")_                            .field("format", timeZonePattern)_                        .endObject()_                    .endObject()_                .endObject().endObject())___        DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping))__        assertEquals(mapping, mapper.mappingSource().toString())___        final DateTimeZone randomTimeZone = randomBoolean() ? DateTimeZone.forID(randomFrom("UTC", "CET")) : randomDateTimeZone()__        final DateTime randomDate = new DateTime(2016, 03, 11, 0, 0, 0, randomTimeZone)___        ParsedDocument doc = mapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject()_                            .field("field", DateTimeFormat.forPattern(timeZonePattern).print(randomDate))_                        .endObject()),_                XContentType.JSON))___        IndexableField[] fields = doc.rootDoc().getFields("field")__        assertEquals(2, fields.length)___        assertEquals(randomDate.withZone(DateTimeZone.UTC).getMillis(), fields[0].numericValue().longValue())__    };test,that,time,zones,are,correctly,parsed,by,the,link,date,field,mapper,there,is,a,known,bug,with,joda,2,9,4,reported,in,https,github,com,joda,org,joda,time,issues,373;public,void,test,time,zone,parsing,throws,exception,final,string,time,zone,pattern,yyyy,mm,dd,random,from,zzz,zzz,zzz,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field,field,type,date,field,format,time,zone,pattern,end,object,end,object,end,object,end,object,document,mapper,mapper,parser,parse,type,new,compressed,xcontent,mapping,assert,equals,mapping,mapper,mapping,source,to,string,final,date,time,zone,random,time,zone,random,boolean,date,time,zone,for,id,random,from,utc,cet,random,date,time,zone,final,date,time,random,date,new,date,time,2016,03,11,0,0,0,random,time,zone,parsed,document,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,field,field,date,time,format,for,pattern,time,zone,pattern,print,random,date,end,object,xcontent,type,json,indexable,field,fields,doc,root,doc,get,fields,field,assert,equals,2,fields,length,assert,equals,random,date,with,zone,date,time,zone,utc,get,millis,fields,0,numeric,value,long,value
DateFieldMapperTests -> public void testTimeZoneParsing() throws Exception;1535383145;Test that time zones are correctly parsed by the {@link DateFieldMapper}._There is a known bug with Joda 2.9.4 reported in https://github.com/JodaOrg/joda-time/issues/373.;public void testTimeZoneParsing() throws Exception {_        final String timeZonePattern = "yyyy-MM-dd" + randomFrom("ZZZ", "[ZZZ]", "'['ZZZ']'")___        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject()_                .startObject("type")_                    .startObject("properties")_                        .startObject("field")_                            .field("type", "date")_                            .field("format", timeZonePattern)_                        .endObject()_                    .endObject()_                .endObject().endObject())___        DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping))__        assertEquals(mapping, mapper.mappingSource().toString())___        final DateTimeZone randomTimeZone = randomBoolean() ? DateTimeZone.forID(randomFrom("UTC", "CET")) : randomDateTimeZone()__        final DateTime randomDate = new DateTime(2016, 03, 11, 0, 0, 0, randomTimeZone)___        ParsedDocument doc = mapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject()_                            .field("field", DateTimeFormat.forPattern(timeZonePattern).print(randomDate))_                        .endObject()),_                XContentType.JSON))___        IndexableField[] fields = doc.rootDoc().getFields("field")__        assertEquals(2, fields.length)___        assertEquals(randomDate.withZone(DateTimeZone.UTC).getMillis(), fields[0].numericValue().longValue())__    };test,that,time,zones,are,correctly,parsed,by,the,link,date,field,mapper,there,is,a,known,bug,with,joda,2,9,4,reported,in,https,github,com,joda,org,joda,time,issues,373;public,void,test,time,zone,parsing,throws,exception,final,string,time,zone,pattern,yyyy,mm,dd,random,from,zzz,zzz,zzz,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field,field,type,date,field,format,time,zone,pattern,end,object,end,object,end,object,end,object,document,mapper,mapper,parser,parse,type,new,compressed,xcontent,mapping,assert,equals,mapping,mapper,mapping,source,to,string,final,date,time,zone,random,time,zone,random,boolean,date,time,zone,for,id,random,from,utc,cet,random,date,time,zone,final,date,time,random,date,new,date,time,2016,03,11,0,0,0,random,time,zone,parsed,document,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,field,field,date,time,format,for,pattern,time,zone,pattern,print,random,date,end,object,xcontent,type,json,indexable,field,fields,doc,root,doc,get,fields,field,assert,equals,2,fields,length,assert,equals,random,date,with,zone,date,time,zone,utc,get,millis,fields,0,numeric,value,long,value
DateFieldMapperTests -> public void testTimeZoneParsing() throws Exception;1541501723;Test that time zones are correctly parsed by the {@link DateFieldMapper}._There is a known bug with Joda 2.9.4 reported in https://github.com/JodaOrg/joda-time/issues/373.;public void testTimeZoneParsing() throws Exception {_        final String timeZonePattern = "yyyy-MM-dd" + randomFrom("ZZZ", "[ZZZ]", "'['ZZZ']'")___        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject()_                .startObject("type")_                    .startObject("properties")_                        .startObject("field")_                            .field("type", "date")_                            .field("format", timeZonePattern)_                        .endObject()_                    .endObject()_                .endObject().endObject())___        DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping))__        assertEquals(mapping, mapper.mappingSource().toString())___        final DateTimeZone randomTimeZone = randomBoolean() ? DateTimeZone.forID(randomFrom("UTC", "CET")) : randomDateTimeZone()__        final DateTime randomDate = new DateTime(2016, 03, 11, 0, 0, 0, randomTimeZone)___        ParsedDocument doc = mapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject()_                            .field("field", DateTimeFormat.forPattern(timeZonePattern).print(randomDate))_                        .endObject()),_                XContentType.JSON))___        IndexableField[] fields = doc.rootDoc().getFields("field")__        assertEquals(2, fields.length)___        assertEquals(randomDate.withZone(DateTimeZone.UTC).getMillis(), fields[0].numericValue().longValue())__    };test,that,time,zones,are,correctly,parsed,by,the,link,date,field,mapper,there,is,a,known,bug,with,joda,2,9,4,reported,in,https,github,com,joda,org,joda,time,issues,373;public,void,test,time,zone,parsing,throws,exception,final,string,time,zone,pattern,yyyy,mm,dd,random,from,zzz,zzz,zzz,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field,field,type,date,field,format,time,zone,pattern,end,object,end,object,end,object,end,object,document,mapper,mapper,parser,parse,type,new,compressed,xcontent,mapping,assert,equals,mapping,mapper,mapping,source,to,string,final,date,time,zone,random,time,zone,random,boolean,date,time,zone,for,id,random,from,utc,cet,random,date,time,zone,final,date,time,random,date,new,date,time,2016,03,11,0,0,0,random,time,zone,parsed,document,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,field,field,date,time,format,for,pattern,time,zone,pattern,print,random,date,end,object,xcontent,type,json,indexable,field,fields,doc,root,doc,get,fields,field,assert,equals,2,fields,length,assert,equals,random,date,with,zone,date,time,zone,utc,get,millis,fields,0,numeric,value,long,value
DateFieldMapperTests -> public void testTimeZoneParsing() throws Exception;1544600864;Test that time zones are correctly parsed by the {@link DateFieldMapper}._There is a known bug with Joda 2.9.4 reported in https://github.com/JodaOrg/joda-time/issues/373.;public void testTimeZoneParsing() throws Exception {_        final String timeZonePattern = "yyyy-MM-dd" + randomFrom("ZZZ", "[ZZZ]", "'['ZZZ']'")___        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject()_                .startObject("type")_                    .startObject("properties")_                        .startObject("field")_                            .field("type", "date")_                            .field("format", timeZonePattern)_                        .endObject()_                    .endObject()_                .endObject().endObject())___        DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping))__        assertEquals(mapping, mapper.mappingSource().toString())___        final DateTimeZone randomTimeZone = randomBoolean() ? DateTimeZone.forID(randomFrom("UTC", "CET")) : randomDateTimeZone()__        final DateTime randomDate = new DateTime(2016, 03, 11, 0, 0, 0, randomTimeZone)___        ParsedDocument doc = mapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject()_                            .field("field", DateTimeFormat.forPattern(timeZonePattern).print(randomDate))_                        .endObject()),_                XContentType.JSON))___        IndexableField[] fields = doc.rootDoc().getFields("field")__        assertEquals(2, fields.length)___        assertEquals(randomDate.withZone(DateTimeZone.UTC).getMillis(), fields[0].numericValue().longValue())__    };test,that,time,zones,are,correctly,parsed,by,the,link,date,field,mapper,there,is,a,known,bug,with,joda,2,9,4,reported,in,https,github,com,joda,org,joda,time,issues,373;public,void,test,time,zone,parsing,throws,exception,final,string,time,zone,pattern,yyyy,mm,dd,random,from,zzz,zzz,zzz,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field,field,type,date,field,format,time,zone,pattern,end,object,end,object,end,object,end,object,document,mapper,mapper,parser,parse,type,new,compressed,xcontent,mapping,assert,equals,mapping,mapper,mapping,source,to,string,final,date,time,zone,random,time,zone,random,boolean,date,time,zone,for,id,random,from,utc,cet,random,date,time,zone,final,date,time,random,date,new,date,time,2016,03,11,0,0,0,random,time,zone,parsed,document,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,field,field,date,time,format,for,pattern,time,zone,pattern,print,random,date,end,object,xcontent,type,json,indexable,field,fields,doc,root,doc,get,fields,field,assert,equals,2,fields,length,assert,equals,random,date,with,zone,date,time,zone,utc,get,millis,fields,0,numeric,value,long,value
DateFieldMapperTests -> public void testTimeZoneParsing() throws Exception;1545247235;Test that time zones are correctly parsed by the {@link DateFieldMapper}._There is a known bug with Joda 2.9.4 reported in https://github.com/JodaOrg/joda-time/issues/373.;public void testTimeZoneParsing() throws Exception {_        final String timeZonePattern = "yyyy-MM-dd" + randomFrom("ZZZ", "[ZZZ]", "'['ZZZ']'")___        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject()_                .startObject("type")_                    .startObject("properties")_                        .startObject("field")_                            .field("type", "date")_                            .field("format", timeZonePattern)_                        .endObject()_                    .endObject()_                .endObject().endObject())___        DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping))__        assertEquals(mapping, mapper.mappingSource().toString())___        final DateTimeZone randomTimeZone = randomBoolean() ? DateTimeZone.forID(randomFrom("UTC", "CET")) : randomDateTimeZone()__        final DateTime randomDate = new DateTime(2016, 03, 11, 0, 0, 0, randomTimeZone)___        ParsedDocument doc = mapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject()_                            .field("field", DateTimeFormat.forPattern(timeZonePattern).print(randomDate))_                        .endObject()),_                XContentType.JSON))___        IndexableField[] fields = doc.rootDoc().getFields("field")__        assertEquals(2, fields.length)___        assertEquals(randomDate.withZone(DateTimeZone.UTC).getMillis(), fields[0].numericValue().longValue())__    };test,that,time,zones,are,correctly,parsed,by,the,link,date,field,mapper,there,is,a,known,bug,with,joda,2,9,4,reported,in,https,github,com,joda,org,joda,time,issues,373;public,void,test,time,zone,parsing,throws,exception,final,string,time,zone,pattern,yyyy,mm,dd,random,from,zzz,zzz,zzz,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field,field,type,date,field,format,time,zone,pattern,end,object,end,object,end,object,end,object,document,mapper,mapper,parser,parse,type,new,compressed,xcontent,mapping,assert,equals,mapping,mapper,mapping,source,to,string,final,date,time,zone,random,time,zone,random,boolean,date,time,zone,for,id,random,from,utc,cet,random,date,time,zone,final,date,time,random,date,new,date,time,2016,03,11,0,0,0,random,time,zone,parsed,document,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,field,field,date,time,format,for,pattern,time,zone,pattern,print,random,date,end,object,xcontent,type,json,indexable,field,fields,doc,root,doc,get,fields,field,assert,equals,2,fields,length,assert,equals,random,date,with,zone,date,time,zone,utc,get,millis,fields,0,numeric,value,long,value
DateFieldMapperTests -> public void testTimeZoneParsing() throws Exception;1545293826;Test that time zones are correctly parsed by the {@link DateFieldMapper}._There is a known bug with Joda 2.9.4 reported in https://github.com/JodaOrg/joda-time/issues/373.;public void testTimeZoneParsing() throws Exception {_        final String timeZonePattern = "yyyy-MM-dd" + randomFrom("ZZZ", "[ZZZ]", "'['ZZZ']'")___        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject()_                .startObject("type")_                    .startObject("properties")_                        .startObject("field")_                            .field("type", "date")_                            .field("format", timeZonePattern)_                        .endObject()_                    .endObject()_                .endObject().endObject())___        DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping))__        assertEquals(mapping, mapper.mappingSource().toString())___        final DateTimeZone randomTimeZone = randomBoolean() ? DateTimeZone.forID(randomFrom("UTC", "CET")) : randomDateTimeZone()__        final DateTime randomDate = new DateTime(2016, 03, 11, 0, 0, 0, randomTimeZone)___        ParsedDocument doc = mapper.parse(SourceToParse.source("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject()_                            .field("field", DateTimeFormat.forPattern(timeZonePattern).print(randomDate))_                        .endObject()),_                XContentType.JSON))___        IndexableField[] fields = doc.rootDoc().getFields("field")__        assertEquals(2, fields.length)___        assertEquals(randomDate.withZone(DateTimeZone.UTC).getMillis(), fields[0].numericValue().longValue())__    };test,that,time,zones,are,correctly,parsed,by,the,link,date,field,mapper,there,is,a,known,bug,with,joda,2,9,4,reported,in,https,github,com,joda,org,joda,time,issues,373;public,void,test,time,zone,parsing,throws,exception,final,string,time,zone,pattern,yyyy,mm,dd,random,from,zzz,zzz,zzz,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field,field,type,date,field,format,time,zone,pattern,end,object,end,object,end,object,end,object,document,mapper,mapper,parser,parse,type,new,compressed,xcontent,mapping,assert,equals,mapping,mapper,mapping,source,to,string,final,date,time,zone,random,time,zone,random,boolean,date,time,zone,for,id,random,from,utc,cet,random,date,time,zone,final,date,time,random,date,new,date,time,2016,03,11,0,0,0,random,time,zone,parsed,document,doc,mapper,parse,source,to,parse,source,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,field,field,date,time,format,for,pattern,time,zone,pattern,print,random,date,end,object,xcontent,type,json,indexable,field,fields,doc,root,doc,get,fields,field,assert,equals,2,fields,length,assert,equals,random,date,with,zone,date,time,zone,utc,get,millis,fields,0,numeric,value,long,value
DateFieldMapperTests -> public void testTimeZoneParsing() throws Exception;1545678410;Test that time zones are correctly parsed by the {@link DateFieldMapper}._There is a known bug with Joda 2.9.4 reported in https://github.com/JodaOrg/joda-time/issues/373.;public void testTimeZoneParsing() throws Exception {_        final String timeZonePattern = "yyyy-MM-dd" + randomFrom("ZZZ", "[ZZZ]", "'['ZZZ']'")___        String mapping = Strings.toString(XContentFactory.jsonBuilder().startObject()_                .startObject("type")_                    .startObject("properties")_                        .startObject("field")_                            .field("type", "date")_                            .field("format", timeZonePattern)_                        .endObject()_                    .endObject()_                .endObject().endObject())___        DocumentMapper mapper = parser.parse("type", new CompressedXContent(mapping))__        assertEquals(mapping, mapper.mappingSource().toString())___        final DateTimeZone randomTimeZone = randomBoolean() ? DateTimeZone.forID(randomFrom("UTC", "CET")) : randomDateTimeZone()__        final DateTime randomDate = new DateTime(2016, 03, 11, 0, 0, 0, randomTimeZone)___        ParsedDocument doc = mapper.parse(new SourceToParse("test", "type", "1", BytesReference_                .bytes(XContentFactory.jsonBuilder()_                        .startObject()_                            .field("field", DateTimeFormat.forPattern(timeZonePattern).print(randomDate))_                        .endObject()),_                XContentType.JSON))___        IndexableField[] fields = doc.rootDoc().getFields("field")__        assertEquals(2, fields.length)___        assertEquals(randomDate.withZone(DateTimeZone.UTC).getMillis(), fields[0].numericValue().longValue())__    };test,that,time,zones,are,correctly,parsed,by,the,link,date,field,mapper,there,is,a,known,bug,with,joda,2,9,4,reported,in,https,github,com,joda,org,joda,time,issues,373;public,void,test,time,zone,parsing,throws,exception,final,string,time,zone,pattern,yyyy,mm,dd,random,from,zzz,zzz,zzz,string,mapping,strings,to,string,xcontent,factory,json,builder,start,object,start,object,type,start,object,properties,start,object,field,field,type,date,field,format,time,zone,pattern,end,object,end,object,end,object,end,object,document,mapper,mapper,parser,parse,type,new,compressed,xcontent,mapping,assert,equals,mapping,mapper,mapping,source,to,string,final,date,time,zone,random,time,zone,random,boolean,date,time,zone,for,id,random,from,utc,cet,random,date,time,zone,final,date,time,random,date,new,date,time,2016,03,11,0,0,0,random,time,zone,parsed,document,doc,mapper,parse,new,source,to,parse,test,type,1,bytes,reference,bytes,xcontent,factory,json,builder,start,object,field,field,date,time,format,for,pattern,time,zone,pattern,print,random,date,end,object,xcontent,type,json,indexable,field,fields,doc,root,doc,get,fields,field,assert,equals,2,fields,length,assert,equals,random,date,with,zone,date,time,zone,utc,get,millis,fields,0,numeric,value,long,value
