commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;13;;private static int top(Coordinate... points) {     int top = 0.     for (int i = 1. i < points.length. i++) {         if (points[i].y < points[top].y) {             top = i.         } else if (points[i].y == points[top].y) {             if (points[i].x <= points[top].x) {                 top = i.             }         }     }     return top. }
false;private,static;2;9;;private static int prev(int top, Coordinate... points) {     for (int i = 1. i < points.length. i++) {         int p = (top + points.length - i) % points.length.         if ((points[p].x != points[top].x) || (points[p].y != points[top].y)) {             return p.         }     }     return -1. }
false;private,static;2;9;;private static int next(int top, Coordinate... points) {     for (int i = 1. i < points.length. i++) {         int n = (top + i) % points.length.         if ((points[n].x != points[top].x) || (points[n].y != points[top].y)) {             return n.         }     }     return -1. }
false;private,static;2;3;;private static Coordinate[] fixedOrderedRing(List<Coordinate> coordinates, boolean direction) {     return fixedOrderedRing(coordinates.toArray(new Coordinate[coordinates.size()]), direction). }
false;private,static;2;24;;private static Coordinate[] fixedOrderedRing(Coordinate[] points, boolean direction) {     final int top = top(points).     final int next = next(top, points).     final int prev = prev(top, points).     final boolean orientation = points[next].x < points[prev].x.     if (orientation != direction) {         List<Coordinate> asList = Arrays.asList(points).         Collections.reverse(asList).         return fixedOrderedRing(asList, direction).     } else {         if (top > 0) {             Coordinate[] aligned = new Coordinate[points.length].             System.arraycopy(points, top, aligned, 0, points.length - top - 1).             System.arraycopy(points, 0, aligned, points.length - top - 1, top).             aligned[aligned.length - 1] = aligned[0].             return aligned.         } else {             return points.         }     } }
false;public,static;2;3;;public static void assertEquals(Coordinate c1, Coordinate c2) {     assertTrue("expected coordinate " + c1 + " but found " + c2, c1.x == c2.x && c1.y == c2.y). }
false;private,static;1;3;;private static boolean isRing(Coordinate[] c) {     return (c[0].x == c[c.length - 1].x) && (c[0].y == c[c.length - 1].y). }
false;public,static;2;12;;public static void assertEquals(Coordinate[] c1, Coordinate[] c2) {     Assert.assertEquals(c1.length, c2.length).     if (isRing(c1) && isRing(c2)) {         c1 = fixedOrderedRing(c1, true).         c2 = fixedOrderedRing(c2, true).     }     for (int i = 0. i < c2.length. i++) {         assertEquals(c1[i], c2[i]).     } }
false;public,static;2;3;;public static void assertEquals(LineString l1, LineString l2) {     assertEquals(l1.getCoordinates(), l2.getCoordinates()). }
false;public,static;2;3;;public static void assertEquals(MultiLineString l1, MultiLineString l2) {     assertEquals(l1.getCoordinates(), l2.getCoordinates()). }
false;public,static;2;11;;public static void assertEquals(Polygon p1, Polygon p2) {     Assert.assertEquals(p1.getNumInteriorRing(), p2.getNumInteriorRing()).     assertEquals(p1.getExteriorRing(), p2.getExteriorRing()).     // fails if the holes of the polygons are not ordered the same way     for (int i = 0. i < p1.getNumInteriorRing(). i++) {         assertEquals(p1.getInteriorRingN(i), p2.getInteriorRingN(i)).     } }
false;public,static;2;11;;public static void assertEquals(MultiPolygon p1, MultiPolygon p2) {     Assert.assertEquals(p1.getNumGeometries(), p2.getNumGeometries()).     // if the inner polygons are not ordered the same way in both Multipolygons     for (int i = 0. i < p1.getNumGeometries(). i++) {         Geometry a = p1.getGeometryN(i).         Geometry b = p2.getGeometryN(i).         assertEquals(a, b).     } }
false;public,static;2;21;;public static void assertEquals(Geometry s1, Geometry s2) {     if (s1 instanceof LineString && s2 instanceof LineString) {         assertEquals((LineString) s1, (LineString) s2).     } else if (s1 instanceof Polygon && s2 instanceof Polygon) {         assertEquals((Polygon) s1, (Polygon) s2).     } else if (s1 instanceof MultiPoint && s2 instanceof MultiPoint) {         Assert.assertEquals(s1, s2).     } else if (s1 instanceof MultiPolygon && s2 instanceof MultiPolygon) {         assertEquals((MultiPolygon) s1, (MultiPolygon) s2).     } else if (s1 instanceof MultiLineString && s2 instanceof MultiLineString) {         assertEquals((MultiLineString) s1, (MultiLineString) s2).     } else {         throw new RuntimeException("equality of shape types not supported [" + s1.getClass().getName() + " and " + s2.getClass().getName() + "]").     } }
false;public,static;2;3;;public static void assertEquals(JtsGeometry g1, JtsGeometry g2) {     assertEquals(g1.getGeom(), g2.getGeom()). }
false;public,static;2;6;;public static void assertEquals(ShapeCollection s1, ShapeCollection s2) {     Assert.assertEquals(s1.size(), s2.size()).     for (int i = 0. i < s1.size(). i++) {         assertEquals(s1.get(i), s2.get(i)).     } }
false;public,static;2;33;;public static void assertEquals(Object s1, Object s2) {     if (s1 instanceof JtsGeometry && s2 instanceof JtsGeometry) {         assertEquals((JtsGeometry) s1, (JtsGeometry) s2).     } else if (s1 instanceof JtsPoint && s2 instanceof JtsPoint) {         JtsPoint p1 = (JtsPoint) s1.         JtsPoint p2 = (JtsPoint) s2.         Assert.assertEquals(p1, p2).     } else if (s1 instanceof ShapeCollection && s2 instanceof ShapeCollection) {         assertEquals((ShapeCollection) s1, (ShapeCollection) s2).     } else if (s1 instanceof GeoCircle && s2 instanceof GeoCircle) {         Assert.assertEquals(s1, s2).     } else if (s1 instanceof RectangleImpl && s2 instanceof RectangleImpl) {         Assert.assertEquals(s1, s2).     } else if (s1 instanceof org.apache.lucene.geo.Line[] && s2 instanceof org.apache.lucene.geo.Line[]) {         Assert.assertArrayEquals((org.apache.lucene.geo.Line[]) s1, (org.apache.lucene.geo.Line[]) s2).     } else if (s1 instanceof org.apache.lucene.geo.Polygon[] && s2 instanceof org.apache.lucene.geo.Polygon[]) {         Assert.assertArrayEquals((org.apache.lucene.geo.Polygon[]) s1, (org.apache.lucene.geo.Polygon[]) s2).     } else if ((s1 instanceof org.apache.lucene.geo.Line && s2 instanceof org.apache.lucene.geo.Line) || (s1 instanceof org.apache.lucene.geo.Polygon && s2 instanceof org.apache.lucene.geo.Polygon) || (s1 instanceof org.apache.lucene.geo.Rectangle && s2 instanceof org.apache.lucene.geo.Rectangle) || (s1 instanceof GeoPoint && s2 instanceof GeoPoint)) {         Assert.assertEquals(s1, s2).     } else if (s1 instanceof Object[] && s2 instanceof Object[]) {         Assert.assertArrayEquals((Object[]) s1, (Object[]) s2).     } else if (s1 instanceof org.elasticsearch.geo.geometry.Geometry && s2 instanceof org.elasticsearch.geo.geometry.Geometry) {         Assert.assertEquals(s1, s2).     } else {         // ... in particular we test that one ring is equivalent to another ring even if the points are rotated or reversed.         throw new RuntimeException("equality of shape types not supported [" + s1.getClass().getName() + " and " + s2.getClass().getName() + "]").     } }
false;private,static;1;5;;@Deprecated private static Geometry unwrapJTS(Object shape) {     assertThat(shape, instanceOf(JtsGeometry.class)).     return ((JtsGeometry) shape).getGeom(). }
false;public,static;2;9;;public static void assertMultiPolygon(Object shape, boolean useJTS) {     if (useJTS) {         assertTrue("expected MultiPolygon but found " + unwrapJTS(shape).getClass().getName(), unwrapJTS(shape) instanceof MultiPolygon).     } else {         assertTrue("expected Polygon[] but found " + shape.getClass().getName(), shape instanceof org.elasticsearch.geo.geometry.MultiPolygon).     } }
false;public,static;2;9;;public static void assertPolygon(Object shape, boolean useJTS) {     if (useJTS) {         assertTrue("expected Polygon but found " + unwrapJTS(shape).getClass().getName(), unwrapJTS(shape) instanceof Polygon).     } else {         assertTrue("expected Polygon but found " + shape.getClass().getName(), shape instanceof org.elasticsearch.geo.geometry.Polygon).     } }
false;public,static;2;9;;public static void assertLineString(Object shape, boolean useJTS) {     if (useJTS) {         assertTrue("expected LineString but found " + unwrapJTS(shape).getClass().getName(), unwrapJTS(shape) instanceof LineString).     } else {         assertTrue("expected Line but found " + shape.getClass().getName(), shape instanceof org.elasticsearch.geo.geometry.Line).     } }
false;public,static;2;9;;public static void assertMultiLineString(Object shape, boolean useJTS) {     if (useJTS) {         assertTrue("expected MultiLineString but found " + unwrapJTS(shape).getClass().getName(), unwrapJTS(shape) instanceof MultiLineString).     } else {         assertTrue("expected Line[] but found " + shape.getClass().getName(), shape instanceof MultiLine).     } }
false;public,static;3;5;;public static void assertDistance(String geohash1, String geohash2, Matcher<Double> match) {     GeoPoint p1 = new GeoPoint(geohash1).     GeoPoint p2 = new GeoPoint(geohash2).     assertDistance(p1.lat(), p1.lon(), p2.lat(), p2.lon(), match). }
false;public,static;5;3;;public static void assertDistance(double lat1, double lon1, double lat2, double lon2, Matcher<Double> match) {     assertThat(distance(lat1, lon1, lat2, lon2), match). }
false;private,static;4;3;;private static double distance(double lat1, double lon1, double lat2, double lon2) {     return GeoDistance.ARC.calculate(lat1, lon1, lat2, lon2, DistanceUnit.DEFAULT). }
false;public,static;2;9;;public static void assertValidException(XContentParser parser, Class<?> expectedException) {     try {         ShapeParser.parse(parser).buildS4J().         Assert.fail("process completed successfully when " + expectedException.getName() + " expected").     } catch (Exception e) {         assertTrue("expected " + expectedException.getName() + " but found " + e.getClass().getName(), e.getClass().equals(expectedException)).     } }
