commented;modifiers;parameterAmount;loc;comment;code
false;public;0;7;;@Override public void close() throws IOException {     super.close().     if (this.closed.compareAndSet(false, true) == false) {         throw new IllegalStateException("DummyMultiCommand already closed").     } }
false;protected;2;4;;@Override protected void execute(Terminal terminal, OptionSet options) throws Exception {     terminal.println("Arguments: " + options.nonOptionArguments().toString()). }
false;public;0;9;;@Override public void close() throws IOException {     if (this.closeCalled.compareAndSet(false, true) == false) {         throw new IllegalStateException("DummySubCommand already closed").     }     if (throwsExceptionOnClose) {         throw new IOException("Error occurred while closing DummySubCommand").     } }
false;public;0;4;;@Before public void setupCommand() {     multiCommand = new DummyMultiCommand(). }
false;protected;0;4;;@Override protected Command newCommand() {     return multiCommand. }
false;public;0;6;;public void testNoCommandsConfigured() throws Exception {     IllegalStateException e = expectThrows(IllegalStateException.class, () -> {         execute().     }).     assertEquals("No subcommands configured", e.getMessage()). }
false;public;0;8;;public void testUnknownCommand() throws Exception {     multiCommand.subcommands.put("something", new DummySubCommand()).     UserException e = expectThrows(UserException.class, () -> {         execute("somethingelse").     }).     assertEquals(ExitCodes.USAGE, e.exitCode).     assertEquals("Unknown command [somethingelse]", e.getMessage()). }
false;public;0;8;;public void testMissingCommand() throws Exception {     multiCommand.subcommands.put("command1", new DummySubCommand()).     UserException e = expectThrows(UserException.class, () -> {         execute().     }).     assertEquals(ExitCodes.USAGE, e.exitCode).     assertEquals("Missing command", e.getMessage()). }
false;public;0;8;;public void testHelp() throws Exception {     multiCommand.subcommands.put("command1", new DummySubCommand()).     multiCommand.subcommands.put("command2", new DummySubCommand()).     execute("-h").     String output = terminal.getOutput().     assertTrue(output, output.contains("command1")).     assertTrue(output, output.contains("command2")). }
false;public;0;8;;public void testSubcommandHelp() throws Exception {     multiCommand.subcommands.put("command1", new DummySubCommand()).     multiCommand.subcommands.put("command2", new DummySubCommand()).     execute("command2", "-h").     String output = terminal.getOutput().     assertFalse(output, output.contains("command1")).     assertTrue(output, output.contains("A dummy subcommand")). }
false;public;0;7;;public void testSubcommandArguments() throws Exception {     multiCommand.subcommands.put("command1", new DummySubCommand()).     execute("command1", "foo", "bar").     String output = terminal.getOutput().     assertFalse(output, output.contains("command1")).     assertTrue(output, output.contains("Arguments: [foo, bar]")). }
false;public;0;10;;public void testClose() throws Exception {     DummySubCommand subCommand1 = new DummySubCommand().     DummySubCommand subCommand2 = new DummySubCommand().     multiCommand.subcommands.put("command1", subCommand1).     multiCommand.subcommands.put("command2", subCommand2).     multiCommand.close().     assertTrue("MultiCommand was not closed when close method is invoked", multiCommand.closed.get()).     assertTrue("SubCommand1 was not closed when close method is invoked", subCommand1.closeCalled.get()).     assertTrue("SubCommand2 was not closed when close method is invoked", subCommand2.closeCalled.get()). }
false;public;0;23;;public void testCloseWhenSubCommandCloseThrowsException() throws Exception {     final boolean command1Throws = randomBoolean().     final boolean command2Throws = randomBoolean().     final DummySubCommand subCommand1 = new DummySubCommand(command1Throws).     final DummySubCommand subCommand2 = new DummySubCommand(command2Throws).     multiCommand.subcommands.put("command1", subCommand1).     multiCommand.subcommands.put("command2", subCommand2).     if (command1Throws || command2Throws) {         // verify exception is thrown, as well as other non failed sub-commands closed         // properly.         IOException ioe = expectThrows(IOException.class, multiCommand::close).         assertEquals("Error occurred while closing DummySubCommand", ioe.getMessage()).         if (command1Throws && command2Throws) {             assertEquals(1, ioe.getSuppressed().length).             assertTrue("Missing suppressed exceptions", ioe.getSuppressed()[0] instanceof IOException).             assertEquals("Error occurred while closing DummySubCommand", ioe.getSuppressed()[0].getMessage()).         }     } else {         multiCommand.close().     }     assertTrue("SubCommand1 was not closed when close method is invoked", subCommand1.closeCalled.get()).     assertTrue("SubCommand2 was not closed when close method is invoked", subCommand2.closeCalled.get()). }
