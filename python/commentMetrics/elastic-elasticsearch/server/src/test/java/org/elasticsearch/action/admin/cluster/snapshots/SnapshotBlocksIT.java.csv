commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;31;;@Before protected void setUpRepository() throws Exception {     createIndex(INDEX_NAME, OTHER_INDEX_NAME).     int docs = between(10, 100).     for (int i = 0. i < docs. i++) {         client().prepareIndex(INDEX_NAME, "type").setSource("test", "init").execute().actionGet().     }     docs = between(10, 100).     for (int i = 0. i < docs. i++) {         client().prepareIndex(OTHER_INDEX_NAME, "type").setSource("test", "init").execute().actionGet().     }     logger.info("--> register a repository").     assertAcked(client().admin().cluster().preparePutRepository(REPOSITORY_NAME).setType("fs").setSettings(Settings.builder().put("location", randomRepoPath()))).     logger.info("--> verify the repository").     VerifyRepositoryResponse verifyResponse = client().admin().cluster().prepareVerifyRepository(REPOSITORY_NAME).get().     assertThat(verifyResponse.getNodes().size(), equalTo(cluster().numDataAndMasterNodes())).     logger.info("--> create a snapshot").     CreateSnapshotResponse snapshotResponse = client().admin().cluster().prepareCreateSnapshot(REPOSITORY_NAME, SNAPSHOT_NAME).setIncludeGlobalState(true).setWaitForCompletion(true).execute().actionGet().     assertThat(snapshotResponse.status(), equalTo(RestStatus.OK)).     ensureSearchable(). }
false;public;0;16;;public void testCreateSnapshotWithBlocks() {     logger.info("-->  creating a snapshot is allowed when the cluster is read only").     try {         setClusterReadOnly(true).         assertThat(client().admin().cluster().prepareCreateSnapshot(REPOSITORY_NAME, "snapshot-1").setWaitForCompletion(true).get().status(), equalTo(RestStatus.OK)).     } finally {         setClusterReadOnly(false).     }     logger.info("-->  creating a snapshot is allowed when the cluster is not read only").     CreateSnapshotResponse response = client().admin().cluster().prepareCreateSnapshot(REPOSITORY_NAME, "snapshot-2").setWaitForCompletion(true).execute().actionGet().     assertThat(response.status(), equalTo(RestStatus.OK)). }
false;public;0;22;;public void testCreateSnapshotWithIndexBlocks() {     logger.info("-->  creating a snapshot is not blocked when an index is read only").     try {         enableIndexBlock(INDEX_NAME, SETTING_READ_ONLY).         assertThat(client().admin().cluster().prepareCreateSnapshot(REPOSITORY_NAME, "snapshot-1").setIndices(COMMON_INDEX_NAME_MASK).setWaitForCompletion(true).get().status(), equalTo(RestStatus.OK)).     } finally {         disableIndexBlock(INDEX_NAME, SETTING_READ_ONLY).     }     logger.info("-->  creating a snapshot is blocked when an index is blocked for reads").     try {         enableIndexBlock(INDEX_NAME, SETTING_BLOCKS_READ).         assertBlocked(client().admin().cluster().prepareCreateSnapshot(REPOSITORY_NAME, "snapshot-2").setIndices(COMMON_INDEX_NAME_MASK), IndexMetaData.INDEX_READ_BLOCK).         logger.info("-->  creating a snapshot is not blocked when an read-blocked index is not part of the snapshot").         assertThat(client().admin().cluster().prepareCreateSnapshot(REPOSITORY_NAME, "snapshot-2").setIndices(OTHER_INDEX_NAME).setWaitForCompletion(true).get().status(), equalTo(RestStatus.OK)).     } finally {         disableIndexBlock(INDEX_NAME, SETTING_BLOCKS_READ).     } }
false;public;0;9;;public void testDeleteSnapshotWithBlocks() {     logger.info("-->  deleting a snapshot is allowed when the cluster is read only").     try {         setClusterReadOnly(true).         assertTrue(client().admin().cluster().prepareDeleteSnapshot(REPOSITORY_NAME, SNAPSHOT_NAME).get().isAcknowledged()).     } finally {         setClusterReadOnly(false).     } }
false;public;0;21;;public void testRestoreSnapshotWithBlocks() {     assertAcked(client().admin().indices().prepareDelete(INDEX_NAME, OTHER_INDEX_NAME)).     assertFalse(client().admin().indices().prepareExists(INDEX_NAME, OTHER_INDEX_NAME).get().isExists()).     logger.info("-->  restoring a snapshot is blocked when the cluster is read only").     try {         setClusterReadOnly(true).         assertBlocked(client().admin().cluster().prepareRestoreSnapshot(REPOSITORY_NAME, SNAPSHOT_NAME), MetaData.CLUSTER_READ_ONLY_BLOCK).     } finally {         setClusterReadOnly(false).     }     logger.info("-->  creating a snapshot is allowed when the cluster is not read only").     RestoreSnapshotResponse response = client().admin().cluster().prepareRestoreSnapshot(REPOSITORY_NAME, SNAPSHOT_NAME).setWaitForCompletion(true).execute().actionGet().     assertThat(response.status(), equalTo(RestStatus.OK)).     assertTrue(client().admin().indices().prepareExists(INDEX_NAME).get().isExists()).     assertTrue(client().admin().indices().prepareExists(OTHER_INDEX_NAME).get().isExists()). }
false;public;0;11;;public void testGetSnapshotWithBlocks() {     // This test checks that the Get Snapshot operation is never blocked, even if the cluster is read only.     try {         setClusterReadOnly(true).         GetSnapshotsResponse response = client().admin().cluster().prepareGetSnapshots(REPOSITORY_NAME).execute().actionGet().         assertThat(response.getSnapshots(), hasSize(1)).         assertThat(response.getSnapshots().get(0).snapshotId().getName(), equalTo(SNAPSHOT_NAME)).     } finally {         setClusterReadOnly(false).     } }
false;public;0;13;;public void testSnapshotStatusWithBlocks() {     // This test checks that the Snapshot Status operation is never blocked, even if the cluster is read only.     try {         setClusterReadOnly(true).         SnapshotsStatusResponse response = client().admin().cluster().prepareSnapshotStatus(REPOSITORY_NAME).setSnapshots(SNAPSHOT_NAME).execute().actionGet().         assertThat(response.getSnapshots(), hasSize(1)).         assertThat(response.getSnapshots().get(0).getState().completed(), equalTo(true)).     } finally {         setClusterReadOnly(false).     } }
