commented;modifiers;parameterAmount;loc;comment;code
false;public;0;73;;public void testReplication() throws Exception {     final String index = "test".     final ShardId shardId = new ShardId(index, "_na_", 0).     ClusterState initialState = stateWithActivePrimary(index, true, randomInt(5)).     IndexMetaData indexMetaData = initialState.getMetaData().index(index).     final long primaryTerm = indexMetaData.primaryTerm(0).     final IndexShardRoutingTable indexShardRoutingTable = initialState.getRoutingTable().shardRoutingTable(shardId).     ShardRouting primaryShard = indexShardRoutingTable.primaryShard().     if (primaryShard.relocating() && randomBoolean()) {         // simulate execution of the replication phase on the relocation target node after relocation source was marked as relocated         initialState = ClusterState.builder(initialState).nodes(DiscoveryNodes.builder(initialState.nodes()).localNodeId(primaryShard.relocatingNodeId())).build().         primaryShard = primaryShard.getTargetRelocatingShard().     }     // add a few in-sync allocation ids that don't have corresponding routing entries     final Set<String> staleAllocationIds = Sets.newHashSet(generateRandomStringArray(4, 10, false)).     final Set<String> inSyncAllocationIds = Sets.union(indexMetaData.inSyncAllocationIds(0), staleAllocationIds).     final Set<String> trackedShards = new HashSet<>().     final Set<String> untrackedShards = new HashSet<>().     addTrackingInfo(indexShardRoutingTable, primaryShard, trackedShards, untrackedShards).     trackedShards.addAll(staleAllocationIds).     final ReplicationGroup replicationGroup = new ReplicationGroup(indexShardRoutingTable, inSyncAllocationIds, trackedShards).     final Set<ShardRouting> expectedReplicas = getExpectedReplicas(shardId, initialState, trackedShards).     final Map<ShardRouting, Exception> simulatedFailures = new HashMap<>().     final Map<ShardRouting, Exception> reportedFailures = new HashMap<>().     for (ShardRouting replica : expectedReplicas) {         if (randomBoolean()) {             Exception t.             boolean criticalFailure = randomBoolean().             if (criticalFailure) {                 t = new CorruptIndexException("simulated", (String) null).                 reportedFailures.put(replica, t).             } else {                 t = new IndexShardNotStartedException(shardId, IndexShardState.RECOVERING).             }             logger.debug("--> simulating failure on {} with [{}]", replica, t.getClass().getSimpleName()).             simulatedFailures.put(replica, t).         }     }     Request request = new Request(shardId).     PlainActionFuture<TestPrimary.Result> listener = new PlainActionFuture<>().     final TestReplicaProxy replicasProxy = new TestReplicaProxy(primaryTerm, simulatedFailures).     final TestPrimary primary = new TestPrimary(primaryShard, () -> replicationGroup).     final TestReplicationOperation op = new TestReplicationOperation(request, primary, listener, replicasProxy).     op.execute().     assertThat("request was not processed on primary", request.processedOnPrimary.get(), equalTo(true)).     assertThat(request.processedOnReplicas, equalTo(expectedReplicas)).     assertThat(replicasProxy.failedReplicas, equalTo(simulatedFailures.keySet())).     assertThat(replicasProxy.markedAsStaleCopies, equalTo(staleAllocationIds)).     assertTrue("listener is not marked as done", listener.isDone()).     ShardInfo shardInfo = listener.actionGet().getShardInfo().     assertThat(shardInfo.getFailed(), equalTo(reportedFailures.size())).     assertThat(shardInfo.getFailures(), arrayWithSize(reportedFailures.size())).     assertThat(shardInfo.getSuccessful(), equalTo(1 + expectedReplicas.size() - simulatedFailures.size())).     final List<ShardRouting> unassignedShards = indexShardRoutingTable.shardsWithState(ShardRoutingState.UNASSIGNED).     final int totalShards = 1 + expectedReplicas.size() + unassignedShards.size() + untrackedShards.size().     assertThat(replicationGroup.toString(), shardInfo.getTotal(), equalTo(totalShards)).     assertThat(primary.knownLocalCheckpoints.remove(primaryShard.allocationId().getId()), equalTo(primary.localCheckpoint)).     assertThat(primary.knownLocalCheckpoints, equalTo(replicasProxy.generatedLocalCheckpoints)).     assertThat(primary.knownGlobalCheckpoints, equalTo(replicasProxy.generatedGlobalCheckpoints)). }
false;private;4;23;;private void addTrackingInfo(IndexShardRoutingTable indexShardRoutingTable, ShardRouting primaryShard, Set<String> trackedShards, Set<String> untrackedShards) {     for (ShardRouting shr : indexShardRoutingTable.shards()) {         if (shr.unassigned() == false) {             if (shr.initializing()) {                 if (randomBoolean()) {                     trackedShards.add(shr.allocationId().getId()).                 } else {                     untrackedShards.add(shr.allocationId().getId()).                 }             } else {                 trackedShards.add(shr.allocationId().getId()).                 if (shr.relocating()) {                     if (primaryShard == shr.getTargetRelocatingShard() || randomBoolean()) {                         trackedShards.add(shr.getTargetRelocatingShard().allocationId().getId()).                     } else {                         untrackedShards.add(shr.getTargetRelocatingShard().allocationId().getId()).                     }                 }             }         }     } }
false;public;6;11;;@Override public void failShardIfNeeded(ShardRouting replica, String message, Exception exception, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) {     if (testPrimaryDemotedOnStaleShardCopies) {         super.failShardIfNeeded(replica, message, exception, onSuccess, onPrimaryDemoted, onIgnoredFailure).     } else {         assertThat(replica, equalTo(failedReplica)).         onPrimaryDemoted.accept(new ElasticsearchException("the king is dead")).     } }
false;public;5;9;;@Override public void markShardCopyAsStaleIfNeeded(ShardId shardId, String allocationId, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) {     if (testPrimaryDemotedOnStaleShardCopies) {         onPrimaryDemoted.accept(new ElasticsearchException("the king is dead")).     } else {         super.markShardCopyAsStaleIfNeeded(shardId, allocationId, onSuccess, onPrimaryDemoted, onIgnoredFailure).     } }
false;public;2;4;;@Override public void failShard(String message, Exception exception) {     assertTrue(primaryFailed.compareAndSet(false, true)). }
false;public;0;75;;public void testDemotedPrimary() throws Exception {     final String index = "test".     final ShardId shardId = new ShardId(index, "_na_", 0).     ClusterState initialState = stateWithActivePrimary(index, true, 1 + randomInt(2), randomInt(2)).     IndexMetaData indexMetaData = initialState.getMetaData().index(index).     final long primaryTerm = indexMetaData.primaryTerm(0).     final IndexShardRoutingTable indexShardRoutingTable = initialState.getRoutingTable().shardRoutingTable(shardId).     ShardRouting primaryShard = indexShardRoutingTable.primaryShard().     if (primaryShard.relocating() && randomBoolean()) {         // simulate execution of the replication phase on the relocation target node after relocation source was marked as relocated         initialState = ClusterState.builder(initialState).nodes(DiscoveryNodes.builder(initialState.nodes()).localNodeId(primaryShard.relocatingNodeId())).build().         primaryShard = primaryShard.getTargetRelocatingShard().     }     // add an in-sync allocation id that doesn't have a corresponding routing entry     final Set<String> staleAllocationIds = Sets.newHashSet(randomAlphaOfLength(10)).     final Set<String> inSyncAllocationIds = Sets.union(indexMetaData.inSyncAllocationIds(0), staleAllocationIds).     final Set<String> trackedShards = new HashSet<>().     addTrackingInfo(indexShardRoutingTable, primaryShard, trackedShards, new HashSet<>()).     trackedShards.addAll(staleAllocationIds).     final ReplicationGroup replicationGroup = new ReplicationGroup(indexShardRoutingTable, inSyncAllocationIds, trackedShards).     final Set<ShardRouting> expectedReplicas = getExpectedReplicas(shardId, initialState, trackedShards).     final Map<ShardRouting, Exception> expectedFailures = new HashMap<>().     if (expectedReplicas.isEmpty()) {         return.     }     final ShardRouting failedReplica = randomFrom(new ArrayList<>(expectedReplicas)).     expectedFailures.put(failedReplica, new CorruptIndexException("simulated", (String) null)).     Request request = new Request(shardId).     PlainActionFuture<TestPrimary.Result> listener = new PlainActionFuture<>().     final boolean testPrimaryDemotedOnStaleShardCopies = randomBoolean().     final TestReplicaProxy replicasProxy = new TestReplicaProxy(primaryTerm, expectedFailures) {          @Override         public void failShardIfNeeded(ShardRouting replica, String message, Exception exception, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) {             if (testPrimaryDemotedOnStaleShardCopies) {                 super.failShardIfNeeded(replica, message, exception, onSuccess, onPrimaryDemoted, onIgnoredFailure).             } else {                 assertThat(replica, equalTo(failedReplica)).                 onPrimaryDemoted.accept(new ElasticsearchException("the king is dead")).             }         }          @Override         public void markShardCopyAsStaleIfNeeded(ShardId shardId, String allocationId, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) {             if (testPrimaryDemotedOnStaleShardCopies) {                 onPrimaryDemoted.accept(new ElasticsearchException("the king is dead")).             } else {                 super.markShardCopyAsStaleIfNeeded(shardId, allocationId, onSuccess, onPrimaryDemoted, onIgnoredFailure).             }         }     }.     AtomicBoolean primaryFailed = new AtomicBoolean().     final TestPrimary primary = new TestPrimary(primaryShard, () -> replicationGroup) {          @Override         public void failShard(String message, Exception exception) {             assertTrue(primaryFailed.compareAndSet(false, true)).         }     }.     final TestReplicationOperation op = new TestReplicationOperation(request, primary, listener, replicasProxy).     op.execute().     assertThat("request was not processed on primary", request.processedOnPrimary.get(), equalTo(true)).     assertTrue("listener is not marked as done", listener.isDone()).     assertTrue(primaryFailed.get()).     assertListenerThrows("should throw exception to trigger retry", listener, ReplicationOperation.RetryOnPrimaryException.class). }
false;public;1;7;;@Override public Result perform(Request request) throws Exception {     Result result = super.perform(request).     replicationGroup.set(updatedReplicationGroup).     logger.debug("--> state after primary operation:\n{}", replicationGroup.get()).     return result. }
false;public;0;49;;public void testAddedReplicaAfterPrimaryOperation() throws Exception {     final String index = "test".     final ShardId shardId = new ShardId(index, "_na_", 0).     final ClusterState initialState = stateWithActivePrimary(index, true, 0).     Set<String> inSyncAllocationIds = initialState.metaData().index(index).inSyncAllocationIds(0).     IndexShardRoutingTable shardRoutingTable = initialState.getRoutingTable().shardRoutingTable(shardId).     Set<String> trackedShards = new HashSet<>().     addTrackingInfo(shardRoutingTable, null, trackedShards, new HashSet<>()).     ReplicationGroup initialReplicationGroup = new ReplicationGroup(shardRoutingTable, inSyncAllocationIds, trackedShards).     final ClusterState stateWithAddedReplicas.     if (randomBoolean()) {         stateWithAddedReplicas = state(index, true, ShardRoutingState.STARTED, randomBoolean() ? ShardRoutingState.INITIALIZING : ShardRoutingState.STARTED).     } else {         stateWithAddedReplicas = state(index, true, ShardRoutingState.RELOCATING).     }     inSyncAllocationIds = stateWithAddedReplicas.metaData().index(index).inSyncAllocationIds(0).     shardRoutingTable = stateWithAddedReplicas.getRoutingTable().shardRoutingTable(shardId).     trackedShards = new HashSet<>().     addTrackingInfo(shardRoutingTable, null, trackedShards, new HashSet<>()).     ReplicationGroup updatedReplicationGroup = new ReplicationGroup(shardRoutingTable, inSyncAllocationIds, trackedShards).     final AtomicReference<ReplicationGroup> replicationGroup = new AtomicReference<>(initialReplicationGroup).     logger.debug("--> using initial replicationGroup:\n{}", replicationGroup.get()).     final long primaryTerm = initialState.getMetaData().index(shardId.getIndexName()).primaryTerm(shardId.id()).     final ShardRouting primaryShard = updatedReplicationGroup.getRoutingTable().primaryShard().     final TestPrimary primary = new TestPrimary(primaryShard, replicationGroup::get) {          @Override         public Result perform(Request request) throws Exception {             Result result = super.perform(request).             replicationGroup.set(updatedReplicationGroup).             logger.debug("--> state after primary operation:\n{}", replicationGroup.get()).             return result.         }     }.     Request request = new Request(shardId).     PlainActionFuture<TestPrimary.Result> listener = new PlainActionFuture<>().     final TestReplicationOperation op = new TestReplicationOperation(request, primary, listener, new TestReplicaProxy(primaryTerm)).     op.execute().     assertThat("request was not processed on primary", request.processedOnPrimary.get(), equalTo(true)).     Set<ShardRouting> expectedReplicas = getExpectedReplicas(shardId, stateWithAddedReplicas, trackedShards).     assertThat(request.processedOnReplicas, equalTo(expectedReplicas)). }
false;public;0;51;;public void testWaitForActiveShards() throws Exception {     final String index = "test".     final ShardId shardId = new ShardId(index, "_na_", 0).     final int assignedReplicas = randomInt(2).     final int unassignedReplicas = randomInt(2).     final int totalShards = 1 + assignedReplicas + unassignedReplicas.     final int activeShardCount = randomIntBetween(0, totalShards).     Request request = new Request(shardId).waitForActiveShards(activeShardCount == totalShards ? ActiveShardCount.ALL : ActiveShardCount.from(activeShardCount)).     final boolean passesActiveShardCheck = activeShardCount <= assignedReplicas + 1.     ShardRoutingState[] replicaStates = new ShardRoutingState[assignedReplicas + unassignedReplicas].     for (int i = 0. i < assignedReplicas. i++) {         replicaStates[i] = randomFrom(ShardRoutingState.STARTED, ShardRoutingState.RELOCATING).     }     for (int i = assignedReplicas. i < replicaStates.length. i++) {         replicaStates[i] = ShardRoutingState.UNASSIGNED.     }     final ClusterState state = state(index, true, ShardRoutingState.STARTED, replicaStates).     logger.debug("using active shard count of [{}], assigned shards [{}], total shards [{}]." + " expecting op to [{}]. using state: \n{}", request.waitForActiveShards(), 1 + assignedReplicas, 1 + assignedReplicas + unassignedReplicas, passesActiveShardCheck ? "succeed" : "retry", state).     final long primaryTerm = state.metaData().index(index).primaryTerm(shardId.id()).     final IndexShardRoutingTable shardRoutingTable = state.routingTable().index(index).shard(shardId.id()).     final Set<String> inSyncAllocationIds = state.metaData().index(index).inSyncAllocationIds(0).     Set<String> trackedShards = new HashSet<>().     addTrackingInfo(shardRoutingTable, null, trackedShards, new HashSet<>()).     final ReplicationGroup initialReplicationGroup = new ReplicationGroup(shardRoutingTable, inSyncAllocationIds, trackedShards).     PlainActionFuture<TestPrimary.Result> listener = new PlainActionFuture<>().     final ShardRouting primaryShard = shardRoutingTable.primaryShard().     final TestReplicationOperation op = new TestReplicationOperation(request, new TestPrimary(primaryShard, () -> initialReplicationGroup), listener, new TestReplicaProxy(primaryTerm), logger, "test").     if (passesActiveShardCheck) {         assertThat(op.checkActiveShardCount(), nullValue()).         op.execute().         assertTrue("operations should have been performed, active shard count is met", request.processedOnPrimary.get()).     } else {         assertThat(op.checkActiveShardCount(), notNullValue()).         op.execute().         assertFalse("operations should not have been perform, active shard count is *NOT* met", request.processedOnPrimary.get()).         assertListenerThrows("should throw exception to trigger retry", listener, UnavailableShardsException.class).     } }
false;public;2;4;;@Override public void failShard(String message, Exception exception) {     primaryFailed.set(true). }
false;public;2;12;;@Override public void updateLocalCheckpointForShard(String allocationId, long checkpoint) {     if (primaryRouting.allocationId().getId().equals(allocationId)) {         super.updateLocalCheckpointForShard(allocationId, checkpoint).     } else {         if (fatal) {             throw new NullPointerException().         } else {             throw new AlreadyClosedException("already closed").         }     } }
false;public;0;52;;public void testPrimaryFailureHandlingReplicaResponse() throws Exception {     final String index = "test".     final ShardId shardId = new ShardId(index, "_na_", 0).     final Request request = new Request(shardId).     final ClusterState state = stateWithActivePrimary(index, true, 1, 0).     final IndexMetaData indexMetaData = state.getMetaData().index(index).     final long primaryTerm = indexMetaData.primaryTerm(0).     final ShardRouting primaryRouting = state.getRoutingTable().shardRoutingTable(shardId).primaryShard().     final Set<String> inSyncAllocationIds = indexMetaData.inSyncAllocationIds(0).     final IndexShardRoutingTable shardRoutingTable = state.routingTable().index(index).shard(shardId.id()).     final Set<String> trackedShards = shardRoutingTable.getAllAllocationIds().     final ReplicationGroup initialReplicationGroup = new ReplicationGroup(shardRoutingTable, inSyncAllocationIds, trackedShards).     final boolean fatal = randomBoolean().     final AtomicBoolean primaryFailed = new AtomicBoolean().     final ReplicationOperation.Primary<Request, Request, TestPrimary.Result> primary = new TestPrimary(primaryRouting, () -> initialReplicationGroup) {          @Override         public void failShard(String message, Exception exception) {             primaryFailed.set(true).         }          @Override         public void updateLocalCheckpointForShard(String allocationId, long checkpoint) {             if (primaryRouting.allocationId().getId().equals(allocationId)) {                 super.updateLocalCheckpointForShard(allocationId, checkpoint).             } else {                 if (fatal) {                     throw new NullPointerException().                 } else {                     throw new AlreadyClosedException("already closed").                 }             }         }     }.     final PlainActionFuture<TestPrimary.Result> listener = new PlainActionFuture<>().     final ReplicationOperation.Replicas<Request> replicas = new TestReplicaProxy(primaryTerm, Collections.emptyMap()).     TestReplicationOperation operation = new TestReplicationOperation(request, primary, listener, replicas).     operation.execute().     assertThat(primaryFailed.get(), equalTo(fatal)).     final ShardInfo shardInfo = listener.actionGet().getShardInfo().     assertThat(shardInfo.getFailed(), equalTo(0)).     assertThat(shardInfo.getFailures(), arrayWithSize(0)).     assertThat(shardInfo.getSuccessful(), equalTo(1 + getExpectedReplicas(shardId, state, trackedShards).size())). }
false;private;3;23;;private Set<ShardRouting> getExpectedReplicas(ShardId shardId, ClusterState state, Set<String> trackedShards) {     Set<ShardRouting> expectedReplicas = new HashSet<>().     String localNodeId = state.nodes().getLocalNodeId().     if (state.routingTable().hasIndex(shardId.getIndexName())) {         for (ShardRouting shardRouting : state.routingTable().shardRoutingTable(shardId)) {             if (shardRouting.unassigned()) {                 continue.             }             if (localNodeId.equals(shardRouting.currentNodeId()) == false) {                 if (trackedShards.contains(shardRouting.allocationId().getId())) {                     expectedReplicas.add(shardRouting).                 }             }             if (shardRouting.relocating() && localNodeId.equals(shardRouting.relocatingNodeId()) == false) {                 if (trackedShards.contains(shardRouting.getTargetRelocatingShard().allocationId().getId())) {                     expectedReplicas.add(shardRouting.getTargetRelocatingShard()).                 }             }         }     }     return expectedReplicas. }
false;public;0;4;;@Override public String toString() {     return "Request{}". }
false;public;0;4;;@Override public ShardRouting routingEntry() {     return routing. }
false;public;2;4;;@Override public void failShard(String message, Exception exception) {     throw new AssertionError("should shouldn't be failed with [" + message + "]", exception). }
false;public;1;7;;@Override public Result perform(Request request) throws Exception {     if (request.processedOnPrimary.compareAndSet(false, true) == false) {         fail("processed [" + request + "] twice").     }     return new Result(request). }
false;public;0;4;;@Override public Request replicaRequest() {     return request. }
false;public;1;4;;@Override public void setShardInfo(ShardInfo shardInfo) {     this.shardInfo = shardInfo. }
false;public;0;3;;public ShardInfo getShardInfo() {     return shardInfo. }
false;public;2;4;;@Override public void updateLocalCheckpointForShard(String allocationId, long checkpoint) {     knownLocalCheckpoints.put(allocationId, checkpoint). }
false;public;2;4;;@Override public void updateGlobalCheckpointForShard(String allocationId, long globalCheckpoint) {     knownGlobalCheckpoints.put(allocationId, globalCheckpoint). }
false;public;0;4;;@Override public long localCheckpoint() {     return localCheckpoint. }
false;public;0;4;;@Override public long globalCheckpoint() {     return globalCheckpoint. }
false;public;0;4;;@Override public long maxSeqNoOfUpdatesOrDeletes() {     return maxSeqNoOfUpdatesOrDeletes. }
false;public;0;4;;@Override public ReplicationGroup getReplicationGroup() {     return replicationGroupSupplier.get(). }
false;public;0;4;;@Override public long localCheckpoint() {     return localCheckpoint. }
false;public;0;4;;@Override public long globalCheckpoint() {     return globalCheckpoint. }
false;public;5;19;;@Override public void performOn(final ShardRouting replica, final Request request, final long globalCheckpoint, final long maxSeqNoOfUpdatesOrDeletes, final ActionListener<ReplicationOperation.ReplicaResponse> listener) {     assertTrue("replica request processed twice on [" + replica + "]", request.processedOnReplicas.add(replica)).     if (opFailures.containsKey(replica)) {         listener.onFailure(opFailures.get(replica)).     } else {         final long generatedLocalCheckpoint = random().nextLong().         final long generatedGlobalCheckpoint = random().nextLong().         final String allocationId = replica.allocationId().getId().         assertNull(generatedLocalCheckpoints.put(allocationId, generatedLocalCheckpoint)).         assertNull(generatedGlobalCheckpoints.put(allocationId, generatedGlobalCheckpoint)).         listener.onResponse(new ReplicaResponse(generatedLocalCheckpoint, generatedGlobalCheckpoint)).     } }
false;public;6;16;;@Override public void failShardIfNeeded(ShardRouting replica, String message, Exception exception, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) {     if (failedReplicas.add(replica) == false) {         fail("replica [" + replica + "] was failed twice").     }     if (opFailures.containsKey(replica)) {         if (randomBoolean()) {             onSuccess.run().         } else {             onIgnoredFailure.accept(new ElasticsearchException("simulated")).         }     } else {         fail("replica [" + replica + "] was failed").     } }
false;public;5;12;;@Override public void markShardCopyAsStaleIfNeeded(ShardId shardId, String allocationId, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) {     if (markedAsStaleCopies.add(allocationId) == false) {         fail("replica [" + allocationId + "] was marked as stale twice").     }     if (randomBoolean()) {         onSuccess.run().     } else {         onIgnoredFailure.accept(new ElasticsearchException("simulated")).     } }
false;;3;8;;<T> void assertListenerThrows(String msg, PlainActionFuture<T> listener, Class<?> klass) throws InterruptedException {     try {         listener.get().         fail(msg).     } catch (ExecutionException ex) {         assertThat(ex.getCause(), instanceOf(klass)).     } }
