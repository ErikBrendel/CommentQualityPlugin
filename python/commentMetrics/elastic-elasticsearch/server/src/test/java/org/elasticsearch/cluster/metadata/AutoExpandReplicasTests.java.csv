# id;timestamp;commentText;codeText;commentWords;codeWords
AutoExpandReplicasTests -> public void testAutoExpandWhenNodeLeavesAndPossiblyRejoins() throws InterruptedException;1526374795;Checks that when nodes leave the cluster that the auto-expand-replica functionality only triggers after failing the shards on_the removed nodes. This ensures that active shards on other live nodes are not failed if the primary resided on a now dead node._Instead, one of the replicas on the live nodes first gets promoted to primary, and the auto-expansion (removing replicas) only_triggers in a follow-up step.;public void testAutoExpandWhenNodeLeavesAndPossiblyRejoins() throws InterruptedException {_        final ThreadPool threadPool = new TestThreadPool(getClass().getName())__        final ClusterStateChanges cluster = new ClusterStateChanges(xContentRegistry(), threadPool)___        try {_            List<DiscoveryNode> allNodes = new ArrayList<>()__            DiscoveryNode localNode = createNode(DiscoveryNode.Role.MASTER)_ _            allNodes.add(localNode)__            int numDataNodes = randomIntBetween(3, 5)__            List<DiscoveryNode> dataNodes = new ArrayList<>(numDataNodes)__            for (int i = 0_ i < numDataNodes_ i++) {_                dataNodes.add(createNode(DiscoveryNode.Role.DATA))__            }_            allNodes.addAll(dataNodes)__            ClusterState state = ClusterStateCreationUtils.state(localNode, localNode, allNodes.toArray(new DiscoveryNode[allNodes.size()]))___            CreateIndexRequest request = new CreateIndexRequest("index",_                Settings.builder()_                    .put(SETTING_NUMBER_OF_SHARDS, 1)_                    .put(SETTING_AUTO_EXPAND_REPLICAS, "0-all").build())_                .waitForActiveShards(ActiveShardCount.NONE)__            state = cluster.createIndex(state, request)__            assertTrue(state.metaData().hasIndex("index"))__            while (state.routingTable().index("index").shard(0).allShardsStarted() == false) {_                logger.info(state)__                state = cluster.applyStartedShards(state,_                    state.routingTable().index("index").shard(0).shardsWithState(ShardRoutingState.INITIALIZING))__                state = cluster.reroute(state, new ClusterRerouteRequest())__            }__            IndexShardRoutingTable preTable = state.routingTable().index("index").shard(0)__            final Set<String> unchangedNodeIds__            final IndexShardRoutingTable postTable___            if (randomBoolean()) {_                _                List<DiscoveryNode> nodesToRemove = randomSubsetOf(2, dataNodes)__                unchangedNodeIds = dataNodes.stream().filter(n -> nodesToRemove.contains(n) == false)_                    .map(DiscoveryNode::getId).collect(Collectors.toSet())___                state = cluster.removeNodes(state, nodesToRemove)__                postTable = state.routingTable().index("index").shard(0)___                assertTrue("not all shards started in " + state.toString(), postTable.allShardsStarted())__                assertThat(postTable.toString(), postTable.getAllAllocationIds(), everyItem(isIn(preTable.getAllAllocationIds())))__            } else {_                _                state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).masterNodeId(null).build()).build()___                List<DiscoveryNode> conflictingNodes = randomSubsetOf(2, dataNodes)__                unchangedNodeIds = dataNodes.stream().filter(n -> conflictingNodes.contains(n) == false)_                    .map(DiscoveryNode::getId).collect(Collectors.toSet())___                List<DiscoveryNode> nodesToAdd = conflictingNodes.stream()_                    .map(n -> new DiscoveryNode(n.getName(), n.getId(), buildNewFakeTransportAddress(), n.getAttributes(), n.getRoles(), n.getVersion()))_                    .collect(Collectors.toList())___                if (randomBoolean()) {_                    nodesToAdd.add(createNode(DiscoveryNode.Role.DATA))__                }__                state = cluster.joinNodesAndBecomeMaster(state, nodesToAdd)__                postTable = state.routingTable().index("index").shard(0)__            }__            Set<String> unchangedAllocationIds = preTable.getShards().stream().filter(shr -> unchangedNodeIds.contains(shr.currentNodeId()))_                .map(shr -> shr.allocationId().getId()).collect(Collectors.toSet())___            assertThat(postTable.toString(), unchangedAllocationIds, everyItem(isIn(postTable.getAllAllocationIds())))___            postTable.getShards().forEach(_                shardRouting -> {_                    if (shardRouting.assignedToNode() && unchangedAllocationIds.contains(shardRouting.allocationId().getId())) {_                        assertTrue("Shard should be active: " + shardRouting, shardRouting.active())__                    }_                }_            )__        } finally {_            terminate(threadPool)__        }_    };checks,that,when,nodes,leave,the,cluster,that,the,auto,expand,replica,functionality,only,triggers,after,failing,the,shards,on,the,removed,nodes,this,ensures,that,active,shards,on,other,live,nodes,are,not,failed,if,the,primary,resided,on,a,now,dead,node,instead,one,of,the,replicas,on,the,live,nodes,first,gets,promoted,to,primary,and,the,auto,expansion,removing,replicas,only,triggers,in,a,follow,up,step;public,void,test,auto,expand,when,node,leaves,and,possibly,rejoins,throws,interrupted,exception,final,thread,pool,thread,pool,new,test,thread,pool,get,class,get,name,final,cluster,state,changes,cluster,new,cluster,state,changes,x,content,registry,thread,pool,try,list,discovery,node,all,nodes,new,array,list,discovery,node,local,node,create,node,discovery,node,role,master,all,nodes,add,local,node,int,num,data,nodes,random,int,between,3,5,list,discovery,node,data,nodes,new,array,list,num,data,nodes,for,int,i,0,i,num,data,nodes,i,data,nodes,add,create,node,discovery,node,role,data,all,nodes,add,all,data,nodes,cluster,state,state,cluster,state,creation,utils,state,local,node,local,node,all,nodes,to,array,new,discovery,node,all,nodes,size,create,index,request,request,new,create,index,request,index,settings,builder,put,1,put,0,all,build,wait,for,active,shards,active,shard,count,none,state,cluster,create,index,state,request,assert,true,state,meta,data,has,index,index,while,state,routing,table,index,index,shard,0,all,shards,started,false,logger,info,state,state,cluster,apply,started,shards,state,state,routing,table,index,index,shard,0,shards,with,state,shard,routing,state,initializing,state,cluster,reroute,state,new,cluster,reroute,request,index,shard,routing,table,pre,table,state,routing,table,index,index,shard,0,final,set,string,unchanged,node,ids,final,index,shard,routing,table,post,table,if,random,boolean,list,discovery,node,nodes,to,remove,random,subset,of,2,data,nodes,unchanged,node,ids,data,nodes,stream,filter,n,nodes,to,remove,contains,n,false,map,discovery,node,get,id,collect,collectors,to,set,state,cluster,remove,nodes,state,nodes,to,remove,post,table,state,routing,table,index,index,shard,0,assert,true,not,all,shards,started,in,state,to,string,post,table,all,shards,started,assert,that,post,table,to,string,post,table,get,all,allocation,ids,every,item,is,in,pre,table,get,all,allocation,ids,else,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,master,node,id,null,build,build,list,discovery,node,conflicting,nodes,random,subset,of,2,data,nodes,unchanged,node,ids,data,nodes,stream,filter,n,conflicting,nodes,contains,n,false,map,discovery,node,get,id,collect,collectors,to,set,list,discovery,node,nodes,to,add,conflicting,nodes,stream,map,n,new,discovery,node,n,get,name,n,get,id,build,new,fake,transport,address,n,get,attributes,n,get,roles,n,get,version,collect,collectors,to,list,if,random,boolean,nodes,to,add,add,create,node,discovery,node,role,data,state,cluster,join,nodes,and,become,master,state,nodes,to,add,post,table,state,routing,table,index,index,shard,0,set,string,unchanged,allocation,ids,pre,table,get,shards,stream,filter,shr,unchanged,node,ids,contains,shr,current,node,id,map,shr,shr,allocation,id,get,id,collect,collectors,to,set,assert,that,post,table,to,string,unchanged,allocation,ids,every,item,is,in,post,table,get,all,allocation,ids,post,table,get,shards,for,each,shard,routing,if,shard,routing,assigned,to,node,unchanged,allocation,ids,contains,shard,routing,allocation,id,get,id,assert,true,shard,should,be,active,shard,routing,shard,routing,active,finally,terminate,thread,pool
AutoExpandReplicasTests -> public void testAutoExpandWhenNodeLeavesAndPossiblyRejoins() throws InterruptedException;1540847035;Checks that when nodes leave the cluster that the auto-expand-replica functionality only triggers after failing the shards on_the removed nodes. This ensures that active shards on other live nodes are not failed if the primary resided on a now dead node._Instead, one of the replicas on the live nodes first gets promoted to primary, and the auto-expansion (removing replicas) only_triggers in a follow-up step.;public void testAutoExpandWhenNodeLeavesAndPossiblyRejoins() throws InterruptedException {_        final ThreadPool threadPool = new TestThreadPool(getClass().getName())__        final ClusterStateChanges cluster = new ClusterStateChanges(xContentRegistry(), threadPool)___        try {_            List<DiscoveryNode> allNodes = new ArrayList<>()__            DiscoveryNode localNode = createNode(DiscoveryNode.Role.MASTER)_ _            allNodes.add(localNode)__            int numDataNodes = randomIntBetween(3, 5)__            List<DiscoveryNode> dataNodes = new ArrayList<>(numDataNodes)__            for (int i = 0_ i < numDataNodes_ i++) {_                dataNodes.add(createNode(DiscoveryNode.Role.DATA))__            }_            allNodes.addAll(dataNodes)__            ClusterState state = ClusterStateCreationUtils.state(localNode, localNode, allNodes.toArray(new DiscoveryNode[0]))___            CreateIndexRequest request = new CreateIndexRequest("index",_                Settings.builder()_                    .put(SETTING_NUMBER_OF_SHARDS, 1)_                    .put(SETTING_AUTO_EXPAND_REPLICAS, "0-all").build())_                .waitForActiveShards(ActiveShardCount.NONE)__            state = cluster.createIndex(state, request)__            assertTrue(state.metaData().hasIndex("index"))__            while (state.routingTable().index("index").shard(0).allShardsStarted() == false) {_                logger.info(state)__                state = cluster.applyStartedShards(state,_                    state.routingTable().index("index").shard(0).shardsWithState(ShardRoutingState.INITIALIZING))__                state = cluster.reroute(state, new ClusterRerouteRequest())__            }__            IndexShardRoutingTable preTable = state.routingTable().index("index").shard(0)__            final Set<String> unchangedNodeIds__            final IndexShardRoutingTable postTable___            if (randomBoolean()) {_                _                List<DiscoveryNode> nodesToRemove = randomSubsetOf(2, dataNodes)__                unchangedNodeIds = dataNodes.stream().filter(n -> nodesToRemove.contains(n) == false)_                    .map(DiscoveryNode::getId).collect(Collectors.toSet())___                state = cluster.removeNodes(state, nodesToRemove)__                postTable = state.routingTable().index("index").shard(0)___                assertTrue("not all shards started in " + state.toString(), postTable.allShardsStarted())__                assertThat(postTable.toString(), postTable.getAllAllocationIds(), everyItem(isIn(preTable.getAllAllocationIds())))__            } else {_                _                state = ClusterState.builder(state).nodes(DiscoveryNodes.builder(state.nodes()).masterNodeId(null).build()).build()___                List<DiscoveryNode> conflictingNodes = randomSubsetOf(2, dataNodes)__                unchangedNodeIds = dataNodes.stream().filter(n -> conflictingNodes.contains(n) == false)_                    .map(DiscoveryNode::getId).collect(Collectors.toSet())___                List<DiscoveryNode> nodesToAdd = conflictingNodes.stream()_                    .map(n -> new DiscoveryNode(n.getName(), n.getId(), buildNewFakeTransportAddress(),_                        n.getAttributes(), n.getRoles(), n.getVersion()))_                    .collect(Collectors.toList())___                if (randomBoolean()) {_                    nodesToAdd.add(createNode(DiscoveryNode.Role.DATA))__                }__                state = cluster.joinNodesAndBecomeMaster(state, nodesToAdd)__                postTable = state.routingTable().index("index").shard(0)__            }__            Set<String> unchangedAllocationIds = preTable.getShards().stream().filter(shr -> unchangedNodeIds.contains(shr.currentNodeId()))_                .map(shr -> shr.allocationId().getId()).collect(Collectors.toSet())___            assertThat(postTable.toString(), unchangedAllocationIds, everyItem(isIn(postTable.getAllAllocationIds())))___            postTable.getShards().forEach(_                shardRouting -> {_                    if (shardRouting.assignedToNode() && unchangedAllocationIds.contains(shardRouting.allocationId().getId())) {_                        assertTrue("Shard should be active: " + shardRouting, shardRouting.active())__                    }_                }_            )__        } finally {_            terminate(threadPool)__        }_    };checks,that,when,nodes,leave,the,cluster,that,the,auto,expand,replica,functionality,only,triggers,after,failing,the,shards,on,the,removed,nodes,this,ensures,that,active,shards,on,other,live,nodes,are,not,failed,if,the,primary,resided,on,a,now,dead,node,instead,one,of,the,replicas,on,the,live,nodes,first,gets,promoted,to,primary,and,the,auto,expansion,removing,replicas,only,triggers,in,a,follow,up,step;public,void,test,auto,expand,when,node,leaves,and,possibly,rejoins,throws,interrupted,exception,final,thread,pool,thread,pool,new,test,thread,pool,get,class,get,name,final,cluster,state,changes,cluster,new,cluster,state,changes,x,content,registry,thread,pool,try,list,discovery,node,all,nodes,new,array,list,discovery,node,local,node,create,node,discovery,node,role,master,all,nodes,add,local,node,int,num,data,nodes,random,int,between,3,5,list,discovery,node,data,nodes,new,array,list,num,data,nodes,for,int,i,0,i,num,data,nodes,i,data,nodes,add,create,node,discovery,node,role,data,all,nodes,add,all,data,nodes,cluster,state,state,cluster,state,creation,utils,state,local,node,local,node,all,nodes,to,array,new,discovery,node,0,create,index,request,request,new,create,index,request,index,settings,builder,put,1,put,0,all,build,wait,for,active,shards,active,shard,count,none,state,cluster,create,index,state,request,assert,true,state,meta,data,has,index,index,while,state,routing,table,index,index,shard,0,all,shards,started,false,logger,info,state,state,cluster,apply,started,shards,state,state,routing,table,index,index,shard,0,shards,with,state,shard,routing,state,initializing,state,cluster,reroute,state,new,cluster,reroute,request,index,shard,routing,table,pre,table,state,routing,table,index,index,shard,0,final,set,string,unchanged,node,ids,final,index,shard,routing,table,post,table,if,random,boolean,list,discovery,node,nodes,to,remove,random,subset,of,2,data,nodes,unchanged,node,ids,data,nodes,stream,filter,n,nodes,to,remove,contains,n,false,map,discovery,node,get,id,collect,collectors,to,set,state,cluster,remove,nodes,state,nodes,to,remove,post,table,state,routing,table,index,index,shard,0,assert,true,not,all,shards,started,in,state,to,string,post,table,all,shards,started,assert,that,post,table,to,string,post,table,get,all,allocation,ids,every,item,is,in,pre,table,get,all,allocation,ids,else,state,cluster,state,builder,state,nodes,discovery,nodes,builder,state,nodes,master,node,id,null,build,build,list,discovery,node,conflicting,nodes,random,subset,of,2,data,nodes,unchanged,node,ids,data,nodes,stream,filter,n,conflicting,nodes,contains,n,false,map,discovery,node,get,id,collect,collectors,to,set,list,discovery,node,nodes,to,add,conflicting,nodes,stream,map,n,new,discovery,node,n,get,name,n,get,id,build,new,fake,transport,address,n,get,attributes,n,get,roles,n,get,version,collect,collectors,to,list,if,random,boolean,nodes,to,add,add,create,node,discovery,node,role,data,state,cluster,join,nodes,and,become,master,state,nodes,to,add,post,table,state,routing,table,index,index,shard,0,set,string,unchanged,allocation,ids,pre,table,get,shards,stream,filter,shr,unchanged,node,ids,contains,shr,current,node,id,map,shr,shr,allocation,id,get,id,collect,collectors,to,set,assert,that,post,table,to,string,unchanged,allocation,ids,every,item,is,in,post,table,get,all,allocation,ids,post,table,get,shards,for,each,shard,routing,if,shard,routing,assigned,to,node,unchanged,allocation,ids,contains,shard,routing,allocation,id,get,id,assert,true,shard,should,be,active,shard,routing,shard,routing,active,finally,terminate,thread,pool
