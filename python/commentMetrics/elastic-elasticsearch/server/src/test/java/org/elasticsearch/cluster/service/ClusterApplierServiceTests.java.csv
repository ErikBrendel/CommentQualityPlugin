commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void createThreadPool() {     threadPool = new TestThreadPool(ClusterApplierServiceTests.class.getName()). }
false;public,static;0;7;;@AfterClass public static void stopThreadPool() {     if (threadPool != null) {         threadPool.shutdownNow().         threadPool = null.     } }
false;public;0;5;;@Before public void setUp() throws Exception {     super.setUp().     clusterApplierService = createTimedClusterService(true). }
false;public;0;5;;@After public void tearDown() throws Exception {     clusterApplierService.close().     super.tearDown(). }
false;public;1;4;;@Override public void connectToNodes(DiscoveryNodes discoveryNodes) { // skip }
false;public;1;4;;@Override public void disconnectFromNodesExcept(DiscoveryNodes nodesToKeep) { // skip }
false;;1;26;;TimedClusterApplierService createTimedClusterService(boolean makeMaster) throws InterruptedException {     DiscoveryNode localNode = new DiscoveryNode("node1", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT).     TimedClusterApplierService timedClusterApplierService = new TimedClusterApplierService(Settings.builder().put("cluster.name", "ClusterApplierServiceTests").build(), new ClusterSettings(Settings.EMPTY, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS), threadPool).     timedClusterApplierService.setNodeConnectionsService(new NodeConnectionsService(Settings.EMPTY, null, null) {          @Override         public void connectToNodes(DiscoveryNodes discoveryNodes) {         // skip         }          @Override         public void disconnectFromNodesExcept(DiscoveryNodes nodesToKeep) {         // skip         }     }).     timedClusterApplierService.setInitialState(ClusterState.builder(new ClusterName("ClusterApplierServiceTests")).nodes(DiscoveryNodes.builder().add(localNode).localNodeId(localNode.getId()).masterNodeId(makeMaster ? localNode.getId() : null)).blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).build()).     timedClusterApplierService.start().     return timedClusterApplierService. }
false;public;1;2;;@Override public void onSuccess(String source) { }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     fail(). }
false;public;1;4;;@Override public void onSuccess(String source) {     fail(). }
false;public;2;2;;@Override public void onFailure(String source, Exception e) { }
false;public;1;2;;@Override public void onSuccess(String source) { }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     fail(). }
false;public;0;70;;// To ensure that we log cluster state events on TRACE level @TestLogging("org.elasticsearch.cluster.service:TRACE") public void testClusterStateUpdateLogging() throws Exception {     MockLogAppender mockAppender = new MockLogAppender().     mockAppender.start().     mockAppender.addExpectation(new MockLogAppender.SeenEventExpectation("test1", ClusterApplierService.class.getCanonicalName(), Level.DEBUG, "*processing [test1]: took [1s] no change in cluster state")).     mockAppender.addExpectation(new MockLogAppender.SeenEventExpectation("test2", ClusterApplierService.class.getCanonicalName(), Level.TRACE, "*failed to execute cluster state applier in [2s]*")).     mockAppender.addExpectation(new MockLogAppender.SeenEventExpectation("test3", ClusterApplierService.class.getCanonicalName(), Level.DEBUG, "*processing [test3]: took [0s] no change in cluster state*")).     Logger clusterLogger = LogManager.getLogger(ClusterApplierService.class).     Loggers.addAppender(clusterLogger, mockAppender).     try {         clusterApplierService.currentTimeOverride = System.nanoTime().         clusterApplierService.runOnApplierThread("test1", currentState -> clusterApplierService.currentTimeOverride += TimeValue.timeValueSeconds(1).nanos(), new ClusterApplyListener() {              @Override             public void onSuccess(String source) {             }              @Override             public void onFailure(String source, Exception e) {                 fail().             }         }).         clusterApplierService.runOnApplierThread("test2", currentState -> {             clusterApplierService.currentTimeOverride += TimeValue.timeValueSeconds(2).nanos().             throw new IllegalArgumentException("Testing handling of exceptions in the cluster state task").         }, new ClusterApplyListener() {              @Override             public void onSuccess(String source) {                 fail().             }              @Override             public void onFailure(String source, Exception e) {             }         }).         // Additional update task to make sure all previous logging made it to the loggerName         clusterApplierService.runOnApplierThread("test3", currentState -> {         }, new ClusterApplyListener() {              @Override             public void onSuccess(String source) {             }              @Override             public void onFailure(String source, Exception e) {                 fail().             }         }).         assertBusy(mockAppender::assertAllExpectationsMatched).     } finally {         Loggers.removeAppender(clusterLogger, mockAppender).         mockAppender.stop().     } }
false;public;1;5;;@Override public void onSuccess(String source) {     latch.countDown().     processedFirstTask.countDown(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     fail(). }
false;public;1;4;;@Override public void onSuccess(String source) {     fail(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     latch.countDown(). }
false;public;1;4;;@Override public void onSuccess(String source) {     latch.countDown(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     fail(). }
false;public;1;4;;@Override public void onSuccess(String source) {     latch.countDown(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     fail(). }
false;public;0;95;;// To ensure that we log cluster state events on WARN level @TestLogging("org.elasticsearch.cluster.service:WARN") public void testLongClusterStateUpdateLogging() throws Exception {     MockLogAppender mockAppender = new MockLogAppender().     mockAppender.start().     mockAppender.addExpectation(new MockLogAppender.UnseenEventExpectation("test1 shouldn't see because setting is too low", ClusterApplierService.class.getCanonicalName(), Level.WARN, "*cluster state applier task [test1] took [*] which is above the warn threshold of *")).     mockAppender.addExpectation(new MockLogAppender.SeenEventExpectation("test2", ClusterApplierService.class.getCanonicalName(), Level.WARN, "*cluster state applier task [test2] took [32s] which is above the warn threshold of *")).     mockAppender.addExpectation(new MockLogAppender.SeenEventExpectation("test4", ClusterApplierService.class.getCanonicalName(), Level.WARN, "*cluster state applier task [test3] took [34s] which is above the warn threshold of *")).     Logger clusterLogger = LogManager.getLogger(ClusterApplierService.class).     Loggers.addAppender(clusterLogger, mockAppender).     try {         final CountDownLatch latch = new CountDownLatch(4).         final CountDownLatch processedFirstTask = new CountDownLatch(1).         clusterApplierService.currentTimeOverride = System.nanoTime().         clusterApplierService.runOnApplierThread("test1", currentState -> clusterApplierService.currentTimeOverride += TimeValue.timeValueSeconds(1).nanos(), new ClusterApplyListener() {              @Override             public void onSuccess(String source) {                 latch.countDown().                 processedFirstTask.countDown().             }              @Override             public void onFailure(String source, Exception e) {                 fail().             }         }).         processedFirstTask.await().         clusterApplierService.runOnApplierThread("test2", currentState -> {             clusterApplierService.currentTimeOverride += TimeValue.timeValueSeconds(32).nanos().             throw new IllegalArgumentException("Testing handling of exceptions in the cluster state task").         }, new ClusterApplyListener() {              @Override             public void onSuccess(String source) {                 fail().             }              @Override             public void onFailure(String source, Exception e) {                 latch.countDown().             }         }).         clusterApplierService.runOnApplierThread("test3", currentState -> clusterApplierService.currentTimeOverride += TimeValue.timeValueSeconds(34).nanos(), new ClusterApplyListener() {              @Override             public void onSuccess(String source) {                 latch.countDown().             }              @Override             public void onFailure(String source, Exception e) {                 fail().             }         }).         // Additional update task to make sure all previous logging made it to the loggerName         // We don't check logging for this on since there is no guarantee that it will occur before our check         clusterApplierService.runOnApplierThread("test4", currentState -> {         }, new ClusterApplyListener() {              @Override             public void onSuccess(String source) {                 latch.countDown().             }              @Override             public void onFailure(String source, Exception e) {                 fail().             }         }).         latch.await().     } finally {         Loggers.removeAppender(clusterLogger, mockAppender).         mockAppender.stop().     }     mockAppender.assertAllExpectationsMatched(). }
false;public;0;4;;@Override public void onMaster() {     isMaster.set(true). }
false;public;0;4;;@Override public void offMaster() {     isMaster.set(false). }
false;public;0;4;;@Override public String executorName() {     return ThreadPool.Names.SAME. }
false;public;0;41;;public void testLocalNodeMasterListenerCallbacks() throws Exception {     TimedClusterApplierService timedClusterApplierService = createTimedClusterService(false).     AtomicBoolean isMaster = new AtomicBoolean().     timedClusterApplierService.addLocalNodeMasterListener(new LocalNodeMasterListener() {          @Override         public void onMaster() {             isMaster.set(true).         }          @Override         public void offMaster() {             isMaster.set(false).         }          @Override         public String executorName() {             return ThreadPool.Names.SAME.         }     }).     ClusterState state = timedClusterApplierService.state().     DiscoveryNodes nodes = state.nodes().     DiscoveryNodes.Builder nodesBuilder = DiscoveryNodes.builder(nodes).masterNodeId(nodes.getLocalNodeId()).     state = ClusterState.builder(state).blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).nodes(nodesBuilder).build().     setState(timedClusterApplierService, state).     assertThat(isMaster.get(), is(true)).     nodes = state.nodes().     nodesBuilder = DiscoveryNodes.builder(nodes).masterNodeId(null).     state = ClusterState.builder(state).blocks(ClusterBlocks.builder().addGlobalBlock(NoMasterBlockService.NO_MASTER_BLOCK_WRITES)).nodes(nodesBuilder).build().     setState(timedClusterApplierService, state).     assertThat(isMaster.get(), is(false)).     nodesBuilder = DiscoveryNodes.builder(nodes).masterNodeId(nodes.getLocalNodeId()).     state = ClusterState.builder(state).blocks(ClusterBlocks.EMPTY_CLUSTER_BLOCK).nodes(nodesBuilder).build().     setState(timedClusterApplierService, state).     assertThat(isMaster.get(), is(true)).     timedClusterApplierService.close(). }
false;public;1;4;;@Override public void onSuccess(String source) {     latch.countDown(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     error.compareAndSet(null, e). }
false;public;0;35;;public void testClusterStateApplierCantSampleClusterState() throws InterruptedException {     AtomicReference<Throwable> error = new AtomicReference<>().     AtomicBoolean applierCalled = new AtomicBoolean().     clusterApplierService.addStateApplier(event -> {         try {             applierCalled.set(true).             clusterApplierService.state().             error.set(new AssertionError("successfully sampled state")).         } catch (AssertionError e) {             if (e.getMessage().contains("should not be called by a cluster state applier") == false) {                 error.set(e).             }         }     }).     CountDownLatch latch = new CountDownLatch(1).     clusterApplierService.onNewClusterState("test", () -> ClusterState.builder(clusterApplierService.state()).build(), new ClusterApplyListener() {          @Override         public void onSuccess(String source) {             latch.countDown().         }          @Override         public void onFailure(String source, Exception e) {             error.compareAndSet(null, e).         }     }).     latch.await().     assertNull(error.get()).     assertTrue(applierCalled.get()). }
false;public;1;5;;@Override public void onSuccess(String source) {     latch.countDown().     fail("should not be called"). }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     assertTrue(error.compareAndSet(null, e)).     latch.countDown(). }
false;public;0;28;;public void testClusterStateApplierBubblesUpExceptionsInApplier() throws InterruptedException {     AtomicReference<Throwable> error = new AtomicReference<>().     clusterApplierService.addStateApplier(event -> {         throw new RuntimeException("dummy exception").     }).     CountDownLatch latch = new CountDownLatch(1).     clusterApplierService.onNewClusterState("test", () -> ClusterState.builder(clusterApplierService.state()).build(), new ClusterApplyListener() {          @Override         public void onSuccess(String source) {             latch.countDown().             fail("should not be called").         }          @Override         public void onFailure(String source, Exception e) {             assertTrue(error.compareAndSet(null, e)).             latch.countDown().         }     }).     latch.await().     assertNotNull(error.get()).     assertThat(error.get().getMessage(), containsString("dummy exception")). }
false;public;1;5;;@Override public void onSuccess(String source) {     latch.countDown().     fail("should not be called"). }
false;public;2;5;;@Override public void onFailure(String source, Exception e) {     assertTrue(error.compareAndSet(null, e)).     latch.countDown(). }
false;public;0;32;;public void testClusterStateApplierBubblesUpExceptionsInSettingsApplier() throws InterruptedException {     AtomicReference<Throwable> error = new AtomicReference<>().     clusterApplierService.clusterSettings.addSettingsUpdateConsumer(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING, v -> {     }).     CountDownLatch latch = new CountDownLatch(1).     clusterApplierService.onNewClusterState("test", () -> ClusterState.builder(clusterApplierService.state()).metaData(MetaData.builder(clusterApplierService.state().metaData()).persistentSettings(Settings.builder().put(EnableAllocationDecider.CLUSTER_ROUTING_ALLOCATION_ENABLE_SETTING.getKey(), false).build()).build()).build(), new ClusterApplyListener() {          @Override         public void onSuccess(String source) {             latch.countDown().             fail("should not be called").         }          @Override         public void onFailure(String source, Exception e) {             assertTrue(error.compareAndSet(null, e)).             latch.countDown().         }     }).     latch.await().     assertNotNull(error.get()).     assertThat(error.get().getMessage(), containsString("illegal value can't update")). }
false;public;1;4;;@Override public void onSuccess(String source) {     latch.countDown(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     error.compareAndSet(null, e). }
false;public;0;28;;public void testClusterStateApplierSwallowsExceptionInListener() throws InterruptedException {     AtomicReference<Throwable> error = new AtomicReference<>().     AtomicBoolean applierCalled = new AtomicBoolean().     clusterApplierService.addListener(event -> {         assertTrue(applierCalled.compareAndSet(false, true)).         throw new RuntimeException("dummy exception").     }).     CountDownLatch latch = new CountDownLatch(1).     clusterApplierService.onNewClusterState("test", () -> ClusterState.builder(clusterApplierService.state()).build(), new ClusterApplyListener() {          @Override         public void onSuccess(String source) {             latch.countDown().         }          @Override         public void onFailure(String source, Exception e) {             error.compareAndSet(null, e).         }     }).     latch.await().     assertNull(error.get()).     assertTrue(applierCalled.get()). }
false;public;1;4;;@Override public void onNewClusterState(ClusterState state) { }
false;public;0;4;;@Override public void onClusterServiceClose() { }
false;public;1;4;;@Override public void onTimeout(TimeValue timeout) { }
false;public;1;4;;@Override public void onSuccess(String source) {     latch.countDown(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     error.compareAndSet(null, e). }
false;public;0;47;;public void testClusterStateApplierCanCreateAnObserver() throws InterruptedException {     AtomicReference<Throwable> error = new AtomicReference<>().     AtomicBoolean applierCalled = new AtomicBoolean().     clusterApplierService.addStateApplier(event -> {         try {             applierCalled.set(true).             ClusterStateObserver observer = new ClusterStateObserver(event.state(), clusterApplierService, null, logger, threadPool.getThreadContext()).             observer.waitForNextChange(new ClusterStateObserver.Listener() {                  @Override                 public void onNewClusterState(ClusterState state) {                 }                  @Override                 public void onClusterServiceClose() {                 }                  @Override                 public void onTimeout(TimeValue timeout) {                 }             }).         } catch (AssertionError e) {             error.set(e).         }     }).     CountDownLatch latch = new CountDownLatch(1).     clusterApplierService.onNewClusterState("test", () -> ClusterState.builder(clusterApplierService.state()).build(), new ClusterApplyListener() {          @Override         public void onSuccess(String source) {             latch.countDown().         }          @Override         public void onFailure(String source, Exception e) {             error.compareAndSet(null, e).         }     }).     latch.await().     assertNull(error.get()).     assertTrue(applierCalled.get()). }
false;protected;0;7;;@Override protected long currentTimeInNanos() {     if (currentTimeOverride != null) {         return currentTimeOverride.     }     return super.currentTimeInNanos(). }
