commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Before public void setup() throws Exception {     networkService = new NetworkService(Collections.emptyList()).     threadPool = new TestThreadPool("test").     bigArrays = new MockBigArrays(new MockPageCacheRecycler(Settings.EMPTY), new NoneCircuitBreakerService()). }
false;public;0;9;;@After public void shutdown() throws Exception {     if (threadPool != null) {         threadPool.shutdownNow().     }     threadPool = null.     networkService = null.     bigArrays = null. }
false;public;0;34;;public void testHttpPublishPort() throws Exception {     int boundPort = randomIntBetween(9000, 9100).     int otherBoundPort = randomIntBetween(9200, 9300).     int publishPort = resolvePublishPort(Settings.builder().put(HttpTransportSettings.SETTING_HTTP_PUBLISH_PORT.getKey(), 9080).build(), randomAddresses(), getByName("127.0.0.2")).     assertThat("Publish port should be explicitly set to 9080", publishPort, equalTo(9080)).     publishPort = resolvePublishPort(Settings.EMPTY, asList(address("127.0.0.1", boundPort), address("127.0.0.2", otherBoundPort)), getByName("127.0.0.1")).     assertThat("Publish port should be derived from matched address", publishPort, equalTo(boundPort)).     publishPort = resolvePublishPort(Settings.EMPTY, asList(address("127.0.0.1", boundPort), address("127.0.0.2", boundPort)), getByName("127.0.0.3")).     assertThat("Publish port should be derived from unique port of bound addresses", publishPort, equalTo(boundPort)).     final BindHttpException e = expectThrows(BindHttpException.class, () -> resolvePublishPort(Settings.EMPTY, asList(address("127.0.0.1", boundPort), address("127.0.0.2", otherBoundPort)), getByName("127.0.0.3"))).     assertThat(e.getMessage(), containsString("Failed to auto-resolve http publish port")).     publishPort = resolvePublishPort(Settings.EMPTY, asList(address("0.0.0.0", boundPort), address("127.0.0.2", otherBoundPort)), getByName("127.0.0.1")).     assertThat("Publish port should be derived from matching wildcard address", publishPort, equalTo(boundPort)).     if (NetworkUtils.SUPPORTS_V6) {         publishPort = resolvePublishPort(Settings.EMPTY, asList(address("0.0.0.0", boundPort), address("127.0.0.2", otherBoundPort)), getByName("::1")).         assertThat("Publish port should be derived from matching wildcard address", publishPort, equalTo(boundPort)).     } }
false;public;3;5;;@Override public void dispatchRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) {     threadContext.putHeader("foo", "bar").     threadContext.putTransient("bar", "baz"). }
false;public;4;8;;@Override public void dispatchBadRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext, final Throwable cause) {     threadContext.putHeader("foo_bad", "bar").     threadContext.putTransient("bar_bad", "baz"). }
false;protected;1;4;;@Override protected HttpServerChannel bind(InetSocketAddress hostAddress) {     return null. }
false;protected;0;4;;@Override protected void doStart() { }
false;protected;0;4;;@Override protected void stopInternal() { }
false;public;0;4;;@Override public HttpStats stats() {     return null. }
false;public;0;53;;public void testDispatchDoesNotModifyThreadContext() {     final HttpServerTransport.Dispatcher dispatcher = new HttpServerTransport.Dispatcher() {          @Override         public void dispatchRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext) {             threadContext.putHeader("foo", "bar").             threadContext.putTransient("bar", "baz").         }          @Override         public void dispatchBadRequest(final RestRequest request, final RestChannel channel, final ThreadContext threadContext, final Throwable cause) {             threadContext.putHeader("foo_bad", "bar").             threadContext.putTransient("bar_bad", "baz").         }     }.     try (AbstractHttpServerTransport transport = new AbstractHttpServerTransport(Settings.EMPTY, networkService, bigArrays, threadPool, xContentRegistry(), dispatcher) {          @Override         protected HttpServerChannel bind(InetSocketAddress hostAddress) {             return null.         }          @Override         protected void doStart() {         }          @Override         protected void stopInternal() {         }          @Override         public HttpStats stats() {             return null.         }     }) {         transport.dispatchRequest(null, null, null).         assertNull(threadPool.getThreadContext().getHeader("foo")).         assertNull(threadPool.getThreadContext().getTransient("bar")).         transport.dispatchRequest(null, null, new Exception()).         assertNull(threadPool.getThreadContext().getHeader("foo_bad")).         assertNull(threadPool.getThreadContext().getTransient("bar_bad")).     } }
false;private;2;3;;private TransportAddress address(String host, int port) throws UnknownHostException {     return new TransportAddress(getByName(host), port). }
false;private;0;3;;private TransportAddress randomAddress() throws UnknownHostException {     return address("127.0.0." + randomIntBetween(1, 100), randomIntBetween(9200, 9300)). }
false;private;0;7;;private List<TransportAddress> randomAddresses() throws UnknownHostException {     List<TransportAddress> addresses = new ArrayList<>().     for (int i = 0. i < randomIntBetween(1, 5). i++) {         addresses.add(randomAddress()).     }     return addresses. }
