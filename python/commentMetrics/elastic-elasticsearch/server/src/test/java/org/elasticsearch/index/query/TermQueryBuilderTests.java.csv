commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;44;;@Override protected TermQueryBuilder doCreateTestQueryBuilder() {     String fieldName = null.     Object value.     switch(randomIntBetween(0, 3)) {         case 0:             if (randomBoolean()) {                 fieldName = BOOLEAN_FIELD_NAME.             }             value = randomBoolean().             break.         case 1:             if (randomBoolean()) {                 fieldName = randomFrom(STRING_FIELD_NAME, STRING_ALIAS_FIELD_NAME).             }             if (frequently()) {                 value = randomAlphaOfLengthBetween(1, 10).             } else {                 // generate unicode string in 10% of cases                 JsonStringEncoder encoder = JsonStringEncoder.getInstance().                 value = new String(encoder.quoteAsString(randomUnicodeOfLength(10))).             }             break.         case 2:             if (randomBoolean()) {                 fieldName = INT_FIELD_NAME.             }             value = randomInt(10000).             break.         case 3:             if (randomBoolean()) {                 fieldName = DOUBLE_FIELD_NAME.             }             value = randomDouble().             break.         default:             throw new UnsupportedOperationException().     }     if (fieldName == null) {         fieldName = randomAlphaOfLengthBetween(1, 10).     }     return createQueryBuilder(fieldName, value). }
true;protected;2;4;/**  * @return a TermQuery with random field name and value, optional random boost and queryname  */ ;/**  * @return a TermQuery with random field name and value, optional random boost and queryname  */ @Override protected TermQueryBuilder createQueryBuilder(String fieldName, Object value) {     return new TermQueryBuilder(fieldName, value). }
false;protected;3;20;;@Override protected void doAssertLuceneQuery(TermQueryBuilder queryBuilder, Query query, SearchContext context) throws IOException {     assertThat(query, either(instanceOf(TermQuery.class)).or(instanceOf(PointRangeQuery.class))).     MappedFieldType mapper = context.getQueryShardContext().fieldMapper(queryBuilder.fieldName()).     if (query instanceof TermQuery) {         TermQuery termQuery = (TermQuery) query.         String expectedFieldName = expectedFieldName(queryBuilder.fieldName()).         assertThat(termQuery.getTerm().field(), equalTo(expectedFieldName)).         if (mapper != null) {             Term term = ((TermQuery) mapper.termQuery(queryBuilder.value(), null)).getTerm().             assertThat(termQuery.getTerm(), equalTo(term)).         } else {             assertThat(termQuery.getTerm().bytes(), equalTo(BytesRefs.toBytesRef(queryBuilder.value()))).         }     } else {         assertEquals(query, mapper.termQuery(queryBuilder.value(), null)).     } }
false;public;0;9;;public void testTermArray() throws IOException {     String queryAsString = "{\n" + "    \"term\": {\n" + "        \"age\": [34, 35]\n" + "    }\n" + "}".     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(queryAsString)).     assertEquals("[term] query does not support array of values", e.getMessage()). }
false;public;0;15;;public void testFromJson() throws IOException {     String json = "{\n" + "  \"term\" : {\n" + "    \"exact_value\" : {\n" + "      \"value\" : \"Quick Foxes!\",\n" + "      \"boost\" : 1.0\n" + "    }\n" + "  }\n" + "}".     TermQueryBuilder parsed = (TermQueryBuilder) parseQuery(json).     checkGeneratedJson(json, parsed).     assertEquals(json, "Quick Foxes!", parsed.value()). }
false;public;0;7;;public void testGeo() throws Exception {     TermQueryBuilder query = new TermQueryBuilder(GEO_POINT_FIELD_NAME, "2,3").     QueryShardContext context = createShardContext().     QueryShardException e = expectThrows(QueryShardException.class, () -> query.toQuery(context)).     assertEquals("Geo fields do not support exact searching, use dedicated geo queries instead: [mapped_geo_point]", e.getMessage()). }
false;public;0;23;;public void testParseFailsWithMultipleFields() throws IOException {     String json = "{\n" + "  \"term\" : {\n" + "    \"message1\" : {\n" + "      \"value\" : \"this\"\n" + "    },\n" + "    \"message2\" : {\n" + "      \"value\" : \"this\"\n" + "    }\n" + "  }\n" + "}".     ParsingException e = expectThrows(ParsingException.class, () -> parseQuery(json)).     assertEquals("[term] query doesn't support multiple fields, found [message1] and [message2]", e.getMessage()).     String shortJson = "{\n" + "  \"term\" : {\n" + "    \"message1\" : \"this\",\n" + "    \"message2\" : \"this\"\n" + "  }\n" + "}".     e = expectThrows(ParsingException.class, () -> parseQuery(shortJson)).     assertEquals("[term] query doesn't support multiple fields, found [message1] and [message2]", e.getMessage()). }
false;public;0;5;;public void testTypeField() throws IOException {     TermQueryBuilder builder = QueryBuilders.termQuery("_type", "value1").     builder.doToQuery(createShardContext()).     assertWarnings(QueryShardContext.TYPES_DEPRECATION_MESSAGE). }
