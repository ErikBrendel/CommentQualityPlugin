# id;timestamp;commentText;codeText;commentWords;codeWords
PrimaryShardAllocatorTests -> public void testRestoreDoesNotAssignIfNoShardAvailable();1524684173;Tests that when restoring from a snapshot and we don't find a node with a shard copy, the shard will remain in_the unassigned list to be allocated later.;public void testRestoreDoesNotAssignIfNoShardAvailable() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), "allocId")__        testAllocator.addData(node1, null, false)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(false))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,don,t,find,a,node,with,a,shard,copy,the,shard,will,remain,in,the,unassigned,list,to,be,allocated,later;public,void,test,restore,does,not,assign,if,no,shard,available,routing,allocation,allocation,get,restore,routing,allocation,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,null,false,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,false,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,unassigned,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreDoesNotAssignIfNoShardAvailable();1531179852;Tests that when restoring from a snapshot and we don't find a node with a shard copy, the shard will remain in_the unassigned list to be allocated later.;public void testRestoreDoesNotAssignIfNoShardAvailable() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), "allocId")__        testAllocator.addData(node1, null, false)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(false))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,don,t,find,a,node,with,a,shard,copy,the,shard,will,remain,in,the,unassigned,list,to,be,allocated,later;public,void,test,restore,does,not,assign,if,no,shard,available,routing,allocation,allocation,get,restore,routing,allocation,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,null,false,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,false,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,unassigned,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreDoesNotAssignIfNoShardAvailable();1540847035;Tests that when restoring from a snapshot and we don't find a node with a shard copy, the shard will remain in_the unassigned list to be allocated later.;public void testRestoreDoesNotAssignIfNoShardAvailable() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), "allocId")__        testAllocator.addData(node1, null, false)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(false))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,don,t,find,a,node,with,a,shard,copy,the,shard,will,remain,in,the,unassigned,list,to,be,allocated,later;public,void,test,restore,does,not,assign,if,no,shard,available,routing,allocation,allocation,get,restore,routing,allocation,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,null,false,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,false,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,unassigned,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreDoesNotAssignIfNoShardAvailable();1541092382;Tests that when restoring from a snapshot and we don't find a node with a shard copy, the shard will remain in_the unassigned list to be allocated later.;public void testRestoreDoesNotAssignIfNoShardAvailable() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), "allocId")__        testAllocator.addData(node1, null, false)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(false))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,don,t,find,a,node,with,a,shard,copy,the,shard,will,remain,in,the,unassigned,list,to,be,allocated,later;public,void,test,restore,does,not,assign,if,no,shard,available,routing,allocation,allocation,get,restore,routing,allocation,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,null,false,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,false,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,unassigned,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreDoesNotAssignIfNoShardAvailable();1544783963;Tests that when restoring from a snapshot and we don't find a node with a shard copy, the shard will remain in_the unassigned list to be allocated later.;public void testRestoreDoesNotAssignIfNoShardAvailable() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), "allocId")__        testAllocator.addData(node1, null, false)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(false))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,don,t,find,a,node,with,a,shard,copy,the,shard,will,remain,in,the,unassigned,list,to,be,allocated,later;public,void,test,restore,does,not,assign,if,no,shard,available,routing,allocation,allocation,get,restore,routing,allocation,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,null,false,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,false,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,unassigned,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoAsyncFetchData();1524684173;Tests that when async fetch returns that there is no data, the shard will not be allocated.;public void testNoAsyncFetchData() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,async,fetch,returns,that,there,is,no,data,the,shard,will,not,be,allocated;public,void,test,no,async,fetch,data,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoAsyncFetchData();1531179852;Tests that when async fetch returns that there is no data, the shard will not be allocated.;public void testNoAsyncFetchData() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,async,fetch,returns,that,there,is,no,data,the,shard,will,not,be,allocated;public,void,test,no,async,fetch,data,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoAsyncFetchData();1540847035;Tests that when async fetch returns that there is no data, the shard will not be allocated.;public void testNoAsyncFetchData() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,async,fetch,returns,that,there,is,no,data,the,shard,will,not,be,allocated;public,void,test,no,async,fetch,data,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoAsyncFetchData();1541092382;Tests that when async fetch returns that there is no data, the shard will not be allocated.;public void testNoAsyncFetchData() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,async,fetch,returns,that,there,is,no,data,the,shard,will,not,be,allocated;public,void,test,no,async,fetch,data,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoAsyncFetchData();1544783963;Tests that when async fetch returns that there is no data, the shard will not be allocated.;public void testNoAsyncFetchData() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,async,fetch,returns,that,there,is,no,data,the,shard,will,not,be,allocated;public,void,test,no,async,fetch,data,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testPreferAllocatingPreviousPrimary();1524684173;Tests that when there was a node that previously had the primary, it will be allocated to that same node again.;public void testPreferAllocatingPreviousPrimary() {_        String primaryAllocId = UUIDs.randomBase64UUID()__        String replicaAllocId = UUIDs.randomBase64UUID()__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(),_            randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED), primaryAllocId, replicaAllocId)__        boolean node1HasPrimaryShard = randomBoolean()__        testAllocator.addData(node1, node1HasPrimaryShard ? primaryAllocId : replicaAllocId, node1HasPrimaryShard)__        testAllocator.addData(node2, node1HasPrimaryShard ? replicaAllocId : primaryAllocId, !node1HasPrimaryShard)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        DiscoveryNode allocatedNode = node1HasPrimaryShard ? node1 : node2__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(allocatedNode.getId()))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,was,a,node,that,previously,had,the,primary,it,will,be,allocated,to,that,same,node,again;public,void,test,prefer,allocating,previous,primary,string,primary,alloc,id,uuids,random,base64uuid,string,replica,alloc,id,uuids,random,base64uuid,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,random,from,primary,alloc,id,replica,alloc,id,boolean,node1has,primary,shard,random,boolean,test,allocator,add,data,node1,node1has,primary,shard,primary,alloc,id,replica,alloc,id,node1has,primary,shard,test,allocator,add,data,node2,node1has,primary,shard,replica,alloc,id,primary,alloc,id,node1has,primary,shard,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,discovery,node,allocated,node,node1has,primary,shard,node1,node2,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,allocated,node,get,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testPreferAllocatingPreviousPrimary();1531179852;Tests that when there was a node that previously had the primary, it will be allocated to that same node again.;public void testPreferAllocatingPreviousPrimary() {_        String primaryAllocId = UUIDs.randomBase64UUID()__        String replicaAllocId = UUIDs.randomBase64UUID()__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(),_            randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED), primaryAllocId, replicaAllocId)__        boolean node1HasPrimaryShard = randomBoolean()__        testAllocator.addData(node1, node1HasPrimaryShard ? primaryAllocId : replicaAllocId, node1HasPrimaryShard)__        testAllocator.addData(node2, node1HasPrimaryShard ? replicaAllocId : primaryAllocId, !node1HasPrimaryShard)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        DiscoveryNode allocatedNode = node1HasPrimaryShard ? node1 : node2__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(allocatedNode.getId()))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,was,a,node,that,previously,had,the,primary,it,will,be,allocated,to,that,same,node,again;public,void,test,prefer,allocating,previous,primary,string,primary,alloc,id,uuids,random,base64uuid,string,replica,alloc,id,uuids,random,base64uuid,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,random,from,primary,alloc,id,replica,alloc,id,boolean,node1has,primary,shard,random,boolean,test,allocator,add,data,node1,node1has,primary,shard,primary,alloc,id,replica,alloc,id,node1has,primary,shard,test,allocator,add,data,node2,node1has,primary,shard,replica,alloc,id,primary,alloc,id,node1has,primary,shard,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,discovery,node,allocated,node,node1has,primary,shard,node1,node2,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,allocated,node,get,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testPreferAllocatingPreviousPrimary();1540847035;Tests that when there was a node that previously had the primary, it will be allocated to that same node again.;public void testPreferAllocatingPreviousPrimary() {_        String primaryAllocId = UUIDs.randomBase64UUID()__        String replicaAllocId = UUIDs.randomBase64UUID()__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(),_            randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED), primaryAllocId, replicaAllocId)__        boolean node1HasPrimaryShard = randomBoolean()__        testAllocator.addData(node1, node1HasPrimaryShard ? primaryAllocId : replicaAllocId, node1HasPrimaryShard)__        testAllocator.addData(node2, node1HasPrimaryShard ? replicaAllocId : primaryAllocId, !node1HasPrimaryShard)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        DiscoveryNode allocatedNode = node1HasPrimaryShard ? node1 : node2__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(allocatedNode.getId()))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,was,a,node,that,previously,had,the,primary,it,will,be,allocated,to,that,same,node,again;public,void,test,prefer,allocating,previous,primary,string,primary,alloc,id,uuids,random,base64uuid,string,replica,alloc,id,uuids,random,base64uuid,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,random,from,primary,alloc,id,replica,alloc,id,boolean,node1has,primary,shard,random,boolean,test,allocator,add,data,node1,node1has,primary,shard,primary,alloc,id,replica,alloc,id,node1has,primary,shard,test,allocator,add,data,node2,node1has,primary,shard,replica,alloc,id,primary,alloc,id,node1has,primary,shard,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,discovery,node,allocated,node,node1has,primary,shard,node1,node2,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,allocated,node,get,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testPreferAllocatingPreviousPrimary();1541092382;Tests that when there was a node that previously had the primary, it will be allocated to that same node again.;public void testPreferAllocatingPreviousPrimary() {_        String primaryAllocId = UUIDs.randomBase64UUID()__        String replicaAllocId = UUIDs.randomBase64UUID()__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(),_            randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED), primaryAllocId, replicaAllocId)__        boolean node1HasPrimaryShard = randomBoolean()__        testAllocator.addData(node1, node1HasPrimaryShard ? primaryAllocId : replicaAllocId, node1HasPrimaryShard)__        testAllocator.addData(node2, node1HasPrimaryShard ? replicaAllocId : primaryAllocId, !node1HasPrimaryShard)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        DiscoveryNode allocatedNode = node1HasPrimaryShard ? node1 : node2__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(allocatedNode.getId()))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,was,a,node,that,previously,had,the,primary,it,will,be,allocated,to,that,same,node,again;public,void,test,prefer,allocating,previous,primary,string,primary,alloc,id,uuids,random,base64uuid,string,replica,alloc,id,uuids,random,base64uuid,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,random,from,primary,alloc,id,replica,alloc,id,boolean,node1has,primary,shard,random,boolean,test,allocator,add,data,node1,node1has,primary,shard,primary,alloc,id,replica,alloc,id,node1has,primary,shard,test,allocator,add,data,node2,node1has,primary,shard,replica,alloc,id,primary,alloc,id,node1has,primary,shard,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,discovery,node,allocated,node,node1has,primary,shard,node1,node2,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,allocated,node,get,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testPreferAllocatingPreviousPrimary();1544783963;Tests that when there was a node that previously had the primary, it will be allocated to that same node again.;public void testPreferAllocatingPreviousPrimary() {_        String primaryAllocId = UUIDs.randomBase64UUID()__        String replicaAllocId = UUIDs.randomBase64UUID()__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(),_            randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED), primaryAllocId, replicaAllocId)__        boolean node1HasPrimaryShard = randomBoolean()__        testAllocator.addData(node1, node1HasPrimaryShard ? primaryAllocId : replicaAllocId, node1HasPrimaryShard)__        testAllocator.addData(node2, node1HasPrimaryShard ? replicaAllocId : primaryAllocId, !node1HasPrimaryShard)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        DiscoveryNode allocatedNode = node1HasPrimaryShard ? node1 : node2__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(allocatedNode.getId()))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,was,a,node,that,previously,had,the,primary,it,will,be,allocated,to,that,same,node,again;public,void,test,prefer,allocating,previous,primary,string,primary,alloc,id,uuids,random,base64uuid,string,replica,alloc,id,uuids,random,base64uuid,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,random,from,primary,alloc,id,replica,alloc,id,boolean,node1has,primary,shard,random,boolean,test,allocator,add,data,node1,node1has,primary,shard,primary,alloc,id,replica,alloc,id,node1has,primary,shard,test,allocator,add,data,node2,node1has,primary,shard,replica,alloc,id,primary,alloc,id,node1has,primary,shard,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,discovery,node,allocated,node,node1has,primary,shard,node1,node2,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,allocated,node,get,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testShardLockObtainFailedException();1524684173;Tests that when the node returns a ShardLockObtainFailedException, it will be considered as a valid shard copy;public void testShardLockObtainFailedException() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean(), new ShardLockObtainFailedException(shardId, "test"))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo("allocId1"))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,the,node,returns,a,shard,lock,obtain,failed,exception,it,will,be,considered,as,a,valid,shard,copy;public,void,test,shard,lock,obtain,failed,exception,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,new,shard,lock,obtain,failed,exception,shard,id,test,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testShardLockObtainFailedException();1531179852;Tests that when the node returns a ShardLockObtainFailedException, it will be considered as a valid shard copy;public void testShardLockObtainFailedException() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean(), new ShardLockObtainFailedException(shardId, "test"))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo("allocId1"))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,the,node,returns,a,shard,lock,obtain,failed,exception,it,will,be,considered,as,a,valid,shard,copy;public,void,test,shard,lock,obtain,failed,exception,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,new,shard,lock,obtain,failed,exception,shard,id,test,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testShardLockObtainFailedException();1540847035;Tests that when the node returns a ShardLockObtainFailedException, it will be considered as a valid shard copy;public void testShardLockObtainFailedException() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean(), new ShardLockObtainFailedException(shardId, "test"))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node1.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),_            equalTo("allocId1"))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,the,node,returns,a,shard,lock,obtain,failed,exception,it,will,be,considered,as,a,valid,shard,copy;public,void,test,shard,lock,obtain,failed,exception,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,new,shard,lock,obtain,failed,exception,shard,id,test,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testShardLockObtainFailedException();1541092382;Tests that when the node returns a ShardLockObtainFailedException, it will be considered as a valid shard copy;public void testShardLockObtainFailedException() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean(), new ShardLockObtainFailedException(shardId, "test"))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node1.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),_            equalTo("allocId1"))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,the,node,returns,a,shard,lock,obtain,failed,exception,it,will,be,considered,as,a,valid,shard,copy;public,void,test,shard,lock,obtain,failed,exception,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,new,shard,lock,obtain,failed,exception,shard,id,test,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testShardLockObtainFailedException();1544783963;Tests that when the node returns a ShardLockObtainFailedException, it will be considered as a valid shard copy;public void testShardLockObtainFailedException() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean(), new ShardLockObtainFailedException(shardId, "test"))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node1.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),_            equalTo("allocId1"))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,the,node,returns,a,shard,lock,obtain,failed,exception,it,will,be,considered,as,a,valid,shard,copy;public,void,test,shard,lock,obtain,failed,exception,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,new,shard,lock,obtain,failed,exception,shard,id,test,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationButThrottlingDecider();1524684173;Tests that when there is a node to allocate to, but it is throttling (and it is the only one),_it will be moved to ignore unassigned until it can be allocated to.;public void testFoundAllocationButThrottlingDecider() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(throttleAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,allocate,to,but,it,is,throttling,and,it,is,the,only,one,it,will,be,moved,to,ignore,unassigned,until,it,can,be,allocated,to;public,void,test,found,allocation,but,throttling,decider,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,throttle,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationButThrottlingDecider();1531179852;Tests that when there is a node to allocate to, but it is throttling (and it is the only one),_it will be moved to ignore unassigned until it can be allocated to.;public void testFoundAllocationButThrottlingDecider() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(throttleAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,allocate,to,but,it,is,throttling,and,it,is,the,only,one,it,will,be,moved,to,ignore,unassigned,until,it,can,be,allocated,to;public,void,test,found,allocation,but,throttling,decider,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,throttle,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationButThrottlingDecider();1540847035;Tests that when there is a node to allocate to, but it is throttling (and it is the only one),_it will be moved to ignore unassigned until it can be allocated to.;public void testFoundAllocationButThrottlingDecider() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(throttleAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,allocate,to,but,it,is,throttling,and,it,is,the,only,one,it,will,be,moved,to,ignore,unassigned,until,it,can,be,allocated,to;public,void,test,found,allocation,but,throttling,decider,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,throttle,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationButThrottlingDecider();1541092382;Tests that when there is a node to allocate to, but it is throttling (and it is the only one),_it will be moved to ignore unassigned until it can be allocated to.;public void testFoundAllocationButThrottlingDecider() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(throttleAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,allocate,to,but,it,is,throttling,and,it,is,the,only,one,it,will,be,moved,to,ignore,unassigned,until,it,can,be,allocated,to;public,void,test,found,allocation,but,throttling,decider,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,throttle,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationButThrottlingDecider();1544783963;Tests that when there is a node to allocate to, but it is throttling (and it is the only one),_it will be moved to ignore unassigned until it can be allocated to.;public void testFoundAllocationButThrottlingDecider() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(throttleAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,allocate,to,but,it,is,throttling,and,it,is,the,only,one,it,will,be,moved,to,ignore,unassigned,until,it,can,be,allocated,to;public,void,test,found,allocation,but,throttling,decider,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,throttle,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationButNoDecider();1524684173;Tests that when there is a node to be allocated to, but it the decider said "no", we still_force the allocation to it.;public void testFoundAllocationButNoDecider() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(noAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())___        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,be,allocated,to,but,it,the,decider,said,no,we,still,force,the,allocation,to,it;public,void,test,found,allocation,but,no,decider,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,no,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationButNoDecider();1531179852;Tests that when there is a node to be allocated to, but it the decider said "no", we still_force the allocation to it.;public void testFoundAllocationButNoDecider() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(noAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,be,allocated,to,but,it,the,decider,said,no,we,still,force,the,allocation,to,it;public,void,test,found,allocation,but,no,decider,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,no,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationButNoDecider();1540847035;Tests that when there is a node to be allocated to, but it the decider said "no", we still_force the allocation to it.;public void testFoundAllocationButNoDecider() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(noAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node1.getId()))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,be,allocated,to,but,it,the,decider,said,no,we,still,force,the,allocation,to,it;public,void,test,found,allocation,but,no,decider,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,no,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationButNoDecider();1541092382;Tests that when there is a node to be allocated to, but it the decider said "no", we still_force the allocation to it.;public void testFoundAllocationButNoDecider() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(noAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node1.getId()))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,be,allocated,to,but,it,the,decider,said,no,we,still,force,the,allocation,to,it;public,void,test,found,allocation,but,no,decider,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,no,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationButNoDecider();1544783963;Tests that when there is a node to be allocated to, but it the decider said "no", we still_force the allocation to it.;public void testFoundAllocationButNoDecider() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(noAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node1.getId()))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,be,allocated,to,but,it,the,decider,said,no,we,still,force,the,allocation,to,it;public,void,test,found,allocation,but,no,decider,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,no,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testDontAllocateOnNoOrThrottleForceAllocationDecision();1524684173;Tests that when the nodes with prior copies of the given shard all return a decision of NO, and_{@link AllocationDecider#canForceAllocatePrimary(ShardRouting, RoutingNode, RoutingAllocation)}_returns a NO or THROTTLE decision for a node, then we do not force allocate to that node.;public void testDontAllocateOnNoOrThrottleForceAllocationDecision() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        boolean forceDecisionNo = randomBoolean()__        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY, Arrays.asList(_            _            _            _            new TestAllocateDecision(Decision.NO), forceDecisionNo ? getNoDeciderThatDeniesForceAllocate() :_                                                                     getNoDeciderThatThrottlesForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        List<ShardRouting> ignored = allocation.routingNodes().unassigned().ignored()__        assertEquals(ignored.size(), 1)__        assertEquals(ignored.get(0).unassignedInfo().getLastAllocationStatus(),_            forceDecisionNo ? AllocationStatus.DECIDERS_NO : AllocationStatus.DECIDERS_THROTTLED)__        assertTrue(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).isEmpty())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,all,return,a,decision,of,no,and,link,allocation,decider,can,force,allocate,primary,shard,routing,routing,node,routing,allocation,returns,a,no,or,throttle,decision,for,a,node,then,we,do,not,force,allocate,to,that,node;public,void,test,dont,allocate,on,no,or,throttle,force,allocation,decision,test,allocator,add,data,node1,alloc,id1,random,boolean,boolean,force,decision,no,random,boolean,allocation,deciders,deciders,new,allocation,deciders,settings,empty,arrays,as,list,new,test,allocate,decision,decision,no,force,decision,no,get,no,decider,that,denies,force,allocate,get,no,decider,that,throttles,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,list,shard,routing,ignored,allocation,routing,nodes,unassigned,ignored,assert,equals,ignored,size,1,assert,equals,ignored,get,0,unassigned,info,get,last,allocation,status,force,decision,no,allocation,status,allocation,status,assert,true,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,is,empty
PrimaryShardAllocatorTests -> public void testDontAllocateOnNoOrThrottleForceAllocationDecision();1531179852;Tests that when the nodes with prior copies of the given shard all return a decision of NO, and_{@link AllocationDecider#canForceAllocatePrimary(ShardRouting, RoutingNode, RoutingAllocation)}_returns a NO or THROTTLE decision for a node, then we do not force allocate to that node.;public void testDontAllocateOnNoOrThrottleForceAllocationDecision() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        boolean forceDecisionNo = randomBoolean()__        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY, Arrays.asList(_            _            _            _            new TestAllocateDecision(Decision.NO), forceDecisionNo ? getNoDeciderThatDeniesForceAllocate() :_                                                                     getNoDeciderThatThrottlesForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        List<ShardRouting> ignored = allocation.routingNodes().unassigned().ignored()__        assertEquals(ignored.size(), 1)__        assertEquals(ignored.get(0).unassignedInfo().getLastAllocationStatus(),_            forceDecisionNo ? AllocationStatus.DECIDERS_NO : AllocationStatus.DECIDERS_THROTTLED)__        assertTrue(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).isEmpty())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,all,return,a,decision,of,no,and,link,allocation,decider,can,force,allocate,primary,shard,routing,routing,node,routing,allocation,returns,a,no,or,throttle,decision,for,a,node,then,we,do,not,force,allocate,to,that,node;public,void,test,dont,allocate,on,no,or,throttle,force,allocation,decision,test,allocator,add,data,node1,alloc,id1,random,boolean,boolean,force,decision,no,random,boolean,allocation,deciders,deciders,new,allocation,deciders,settings,empty,arrays,as,list,new,test,allocate,decision,decision,no,force,decision,no,get,no,decider,that,denies,force,allocate,get,no,decider,that,throttles,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,list,shard,routing,ignored,allocation,routing,nodes,unassigned,ignored,assert,equals,ignored,size,1,assert,equals,ignored,get,0,unassigned,info,get,last,allocation,status,force,decision,no,allocation,status,allocation,status,assert,true,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,is,empty
PrimaryShardAllocatorTests -> public void testDontAllocateOnNoOrThrottleForceAllocationDecision();1540847035;Tests that when the nodes with prior copies of the given shard all return a decision of NO, and_{@link AllocationDecider#canForceAllocatePrimary(ShardRouting, RoutingNode, RoutingAllocation)}_returns a NO or THROTTLE decision for a node, then we do not force allocate to that node.;public void testDontAllocateOnNoOrThrottleForceAllocationDecision() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        boolean forceDecisionNo = randomBoolean()__        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY, Arrays.asList(_            _            _            _            new TestAllocateDecision(Decision.NO), forceDecisionNo ? getNoDeciderThatDeniesForceAllocate() :_                                                                     getNoDeciderThatThrottlesForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        List<ShardRouting> ignored = allocation.routingNodes().unassigned().ignored()__        assertEquals(ignored.size(), 1)__        assertEquals(ignored.get(0).unassignedInfo().getLastAllocationStatus(),_            forceDecisionNo ? AllocationStatus.DECIDERS_NO : AllocationStatus.DECIDERS_THROTTLED)__        assertTrue(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).isEmpty())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,all,return,a,decision,of,no,and,link,allocation,decider,can,force,allocate,primary,shard,routing,routing,node,routing,allocation,returns,a,no,or,throttle,decision,for,a,node,then,we,do,not,force,allocate,to,that,node;public,void,test,dont,allocate,on,no,or,throttle,force,allocation,decision,test,allocator,add,data,node1,alloc,id1,random,boolean,boolean,force,decision,no,random,boolean,allocation,deciders,deciders,new,allocation,deciders,settings,empty,arrays,as,list,new,test,allocate,decision,decision,no,force,decision,no,get,no,decider,that,denies,force,allocate,get,no,decider,that,throttles,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,list,shard,routing,ignored,allocation,routing,nodes,unassigned,ignored,assert,equals,ignored,size,1,assert,equals,ignored,get,0,unassigned,info,get,last,allocation,status,force,decision,no,allocation,status,allocation,status,assert,true,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,is,empty
PrimaryShardAllocatorTests -> public void testDontAllocateOnNoOrThrottleForceAllocationDecision();1541092382;Tests that when the nodes with prior copies of the given shard all return a decision of NO, and_{@link AllocationDecider#canForceAllocatePrimary(ShardRouting, RoutingNode, RoutingAllocation)}_returns a NO or THROTTLE decision for a node, then we do not force allocate to that node.;public void testDontAllocateOnNoOrThrottleForceAllocationDecision() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        boolean forceDecisionNo = randomBoolean()__        AllocationDeciders deciders = new AllocationDeciders(Arrays.asList(_            _            _            _            new TestAllocateDecision(Decision.NO), forceDecisionNo ? getNoDeciderThatDeniesForceAllocate() :_                                                                     getNoDeciderThatThrottlesForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        List<ShardRouting> ignored = allocation.routingNodes().unassigned().ignored()__        assertEquals(ignored.size(), 1)__        assertEquals(ignored.get(0).unassignedInfo().getLastAllocationStatus(),_            forceDecisionNo ? AllocationStatus.DECIDERS_NO : AllocationStatus.DECIDERS_THROTTLED)__        assertTrue(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).isEmpty())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,all,return,a,decision,of,no,and,link,allocation,decider,can,force,allocate,primary,shard,routing,routing,node,routing,allocation,returns,a,no,or,throttle,decision,for,a,node,then,we,do,not,force,allocate,to,that,node;public,void,test,dont,allocate,on,no,or,throttle,force,allocation,decision,test,allocator,add,data,node1,alloc,id1,random,boolean,boolean,force,decision,no,random,boolean,allocation,deciders,deciders,new,allocation,deciders,arrays,as,list,new,test,allocate,decision,decision,no,force,decision,no,get,no,decider,that,denies,force,allocate,get,no,decider,that,throttles,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,list,shard,routing,ignored,allocation,routing,nodes,unassigned,ignored,assert,equals,ignored,size,1,assert,equals,ignored,get,0,unassigned,info,get,last,allocation,status,force,decision,no,allocation,status,allocation,status,assert,true,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,is,empty
PrimaryShardAllocatorTests -> public void testDontAllocateOnNoOrThrottleForceAllocationDecision();1544783963;Tests that when the nodes with prior copies of the given shard all return a decision of NO, and_{@link AllocationDecider#canForceAllocatePrimary(ShardRouting, RoutingNode, RoutingAllocation)}_returns a NO or THROTTLE decision for a node, then we do not force allocate to that node.;public void testDontAllocateOnNoOrThrottleForceAllocationDecision() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        boolean forceDecisionNo = randomBoolean()__        AllocationDeciders deciders = new AllocationDeciders(Arrays.asList(_            _            _            _            new TestAllocateDecision(Decision.NO), forceDecisionNo ? getNoDeciderThatDeniesForceAllocate() :_                                                                     getNoDeciderThatThrottlesForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        List<ShardRouting> ignored = allocation.routingNodes().unassigned().ignored()__        assertEquals(ignored.size(), 1)__        assertEquals(ignored.get(0).unassignedInfo().getLastAllocationStatus(),_            forceDecisionNo ? AllocationStatus.DECIDERS_NO : AllocationStatus.DECIDERS_THROTTLED)__        assertTrue(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).isEmpty())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,all,return,a,decision,of,no,and,link,allocation,decider,can,force,allocate,primary,shard,routing,routing,node,routing,allocation,returns,a,no,or,throttle,decision,for,a,node,then,we,do,not,force,allocate,to,that,node;public,void,test,dont,allocate,on,no,or,throttle,force,allocation,decision,test,allocator,add,data,node1,alloc,id1,random,boolean,boolean,force,decision,no,random,boolean,allocation,deciders,deciders,new,allocation,deciders,arrays,as,list,new,test,allocate,decision,decision,no,force,decision,no,get,no,decider,that,denies,force,allocate,get,no,decider,that,throttles,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,list,shard,routing,ignored,allocation,routing,nodes,unassigned,ignored,assert,equals,ignored,size,1,assert,equals,ignored,get,0,unassigned,info,get,last,allocation,status,force,decision,no,allocation,status,allocation,status,assert,true,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,is,empty
PrimaryShardAllocatorTests -> public void testRestoreForcesAllocateIfShardAvailable();1524684173;Tests that when restoring from a snapshot and we find a node with a shard copy but allocation_deciders say no, we still allocate to that node.;public void testRestoreForcesAllocateIfShardAvailable() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(noAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,but,allocation,deciders,say,no,we,still,allocate,to,that,node;public,void,test,restore,forces,allocate,if,shard,available,routing,allocation,allocation,get,restore,routing,allocation,no,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreForcesAllocateIfShardAvailable();1531179852;Tests that when restoring from a snapshot and we find a node with a shard copy but allocation_deciders say no, we still allocate to that node.;public void testRestoreForcesAllocateIfShardAvailable() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(noAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,but,allocation,deciders,say,no,we,still,allocate,to,that,node;public,void,test,restore,forces,allocate,if,shard,available,routing,allocation,allocation,get,restore,routing,allocation,no,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreForcesAllocateIfShardAvailable();1540847035;Tests that when restoring from a snapshot and we find a node with a shard copy but allocation_deciders say no, we still allocate to that node.;public void testRestoreForcesAllocateIfShardAvailable() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(noAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,but,allocation,deciders,say,no,we,still,allocate,to,that,node;public,void,test,restore,forces,allocate,if,shard,available,routing,allocation,allocation,get,restore,routing,allocation,no,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreForcesAllocateIfShardAvailable();1541092382;Tests that when restoring from a snapshot and we find a node with a shard copy but allocation_deciders say no, we still allocate to that node.;public void testRestoreForcesAllocateIfShardAvailable() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(noAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,but,allocation,deciders,say,no,we,still,allocate,to,that,node;public,void,test,restore,forces,allocate,if,shard,available,routing,allocation,allocation,get,restore,routing,allocation,no,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreForcesAllocateIfShardAvailable();1544783963;Tests that when restoring from a snapshot and we find a node with a shard copy but allocation_deciders say no, we still allocate to that node.;public void testRestoreForcesAllocateIfShardAvailable() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(noAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,but,allocation,deciders,say,no,we,still,allocate,to,that,node;public,void,test,restore,forces,allocate,if,shard,available,routing,allocation,allocation,get,restore,routing,allocation,no,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationAndAllocating();1524684173;Tests that when there is a node to allocate the shard to, it will be allocated to it.;public void testFoundAllocationAndAllocating() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED),_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo("allocId1"))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,allocate,the,shard,to,it,will,be,allocated,to,it;public,void,test,found,allocation,and,allocating,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,random,from,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationAndAllocating();1531179852;Tests that when there is a node to allocate the shard to, it will be allocated to it.;public void testFoundAllocationAndAllocating() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED),_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node1.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo("allocId1"))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,allocate,the,shard,to,it,will,be,allocated,to,it;public,void,test,found,allocation,and,allocating,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,random,from,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationAndAllocating();1540847035;Tests that when there is a node to allocate the shard to, it will be allocated to it.;public void testFoundAllocationAndAllocating() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(),_            randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED), "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node1.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),_            equalTo("allocId1"))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,allocate,the,shard,to,it,will,be,allocated,to,it;public,void,test,found,allocation,and,allocating,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,random,from,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationAndAllocating();1541092382;Tests that when there is a node to allocate the shard to, it will be allocated to it.;public void testFoundAllocationAndAllocating() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(),_            randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED), "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node1.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),_            equalTo("allocId1"))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,allocate,the,shard,to,it,will,be,allocated,to,it;public,void,test,found,allocation,and,allocating,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,random,from,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testFoundAllocationAndAllocating();1544783963;Tests that when there is a node to allocate the shard to, it will be allocated to it.;public void testFoundAllocationAndAllocating() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(),_            randomFrom(CLUSTER_RECOVERED, INDEX_REOPENED), "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node1.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),_            equalTo("allocId1"))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,there,is,a,node,to,allocate,the,shard,to,it,will,be,allocated,to,it;public,void,test,found,allocation,and,allocating,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,random,from,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node1,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreThrottle();1524684173;Tests that when restoring from a snapshot and we find a node with a shard copy and allocation_deciders say throttle, we add it to ignored shards.;public void testRestoreThrottle() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,and,allocation,deciders,say,throttle,we,add,it,to,ignored,shards;public,void,test,restore,throttle,routing,allocation,allocation,get,restore,routing,allocation,throttle,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,false,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreThrottle();1531179852;Tests that when restoring from a snapshot and we find a node with a shard copy and allocation_deciders say throttle, we add it to ignored shards.;public void testRestoreThrottle() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,and,allocation,deciders,say,throttle,we,add,it,to,ignored,shards;public,void,test,restore,throttle,routing,allocation,allocation,get,restore,routing,allocation,throttle,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,false,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreThrottle();1540847035;Tests that when restoring from a snapshot and we find a node with a shard copy and allocation_deciders say throttle, we add it to ignored shards.;public void testRestoreThrottle() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,and,allocation,deciders,say,throttle,we,add,it,to,ignored,shards;public,void,test,restore,throttle,routing,allocation,allocation,get,restore,routing,allocation,throttle,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,false,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreThrottle();1541092382;Tests that when restoring from a snapshot and we find a node with a shard copy and allocation_deciders say throttle, we add it to ignored shards.;public void testRestoreThrottle() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,and,allocation,deciders,say,throttle,we,add,it,to,ignored,shards;public,void,test,restore,throttle,routing,allocation,allocation,get,restore,routing,allocation,throttle,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,false,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestoreThrottle();1544783963;Tests that when restoring from a snapshot and we find a node with a shard copy and allocation_deciders say throttle, we add it to ignored shards.;public void testRestoreThrottle() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(throttleAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(false))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,and,allocation,deciders,say,throttle,we,add,it,to,ignored,shards;public,void,test,restore,throttle,routing,allocation,allocation,get,restore,routing,allocation,throttle,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,false,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testForceAllocatePrimary();1524684173;Tests that when the nodes with prior copies of the given shard all return a decision of NO, but_{@link AllocationDecider#canForceAllocatePrimary(ShardRouting, RoutingNode, RoutingAllocation)}_returns a YES decision for at least one of those NO nodes, then we force allocate to one of them;public void testForceAllocatePrimary() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY, Arrays.asList(_            _            _            new TestAllocateDecision(randomBoolean() ? Decision.YES : Decision.NO), getNoDeciderThatAllowsForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertTrue(allocation.routingNodes().unassigned().ignored().isEmpty())__        assertEquals(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), 1)__        assertEquals(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), node1.getId())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,all,return,a,decision,of,no,but,link,allocation,decider,can,force,allocate,primary,shard,routing,routing,node,routing,allocation,returns,a,yes,decision,for,at,least,one,of,those,no,nodes,then,we,force,allocate,to,one,of,them;public,void,test,force,allocate,primary,test,allocator,add,data,node1,alloc,id1,random,boolean,allocation,deciders,deciders,new,allocation,deciders,settings,empty,arrays,as,list,new,test,allocate,decision,random,boolean,decision,yes,decision,no,get,no,decider,that,allows,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,true,allocation,routing,nodes,unassigned,ignored,is,empty,assert,equals,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,1,assert,equals,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,node1,get,id
PrimaryShardAllocatorTests -> public void testForceAllocatePrimary();1531179852;Tests that when the nodes with prior copies of the given shard all return a decision of NO, but_{@link AllocationDecider#canForceAllocatePrimary(ShardRouting, RoutingNode, RoutingAllocation)}_returns a YES decision for at least one of those NO nodes, then we force allocate to one of them;public void testForceAllocatePrimary() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY, Arrays.asList(_            _            _            new TestAllocateDecision(randomBoolean() ? Decision.YES : Decision.NO), getNoDeciderThatAllowsForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertTrue(allocation.routingNodes().unassigned().ignored().isEmpty())__        assertEquals(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), 1)__        assertEquals(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), node1.getId())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,all,return,a,decision,of,no,but,link,allocation,decider,can,force,allocate,primary,shard,routing,routing,node,routing,allocation,returns,a,yes,decision,for,at,least,one,of,those,no,nodes,then,we,force,allocate,to,one,of,them;public,void,test,force,allocate,primary,test,allocator,add,data,node1,alloc,id1,random,boolean,allocation,deciders,deciders,new,allocation,deciders,settings,empty,arrays,as,list,new,test,allocate,decision,random,boolean,decision,yes,decision,no,get,no,decider,that,allows,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,true,allocation,routing,nodes,unassigned,ignored,is,empty,assert,equals,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,1,assert,equals,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,node1,get,id
PrimaryShardAllocatorTests -> public void testForceAllocatePrimary();1540847035;Tests that when the nodes with prior copies of the given shard all return a decision of NO, but_{@link AllocationDecider#canForceAllocatePrimary(ShardRouting, RoutingNode, RoutingAllocation)}_returns a YES decision for at least one of those NO nodes, then we force allocate to one of them;public void testForceAllocatePrimary() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY, Arrays.asList(_            _            _            new TestAllocateDecision(randomBoolean() ? Decision.YES : Decision.NO), getNoDeciderThatAllowsForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertTrue(allocation.routingNodes().unassigned().ignored().isEmpty())__        assertEquals(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), 1)__        assertEquals(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), node1.getId())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,all,return,a,decision,of,no,but,link,allocation,decider,can,force,allocate,primary,shard,routing,routing,node,routing,allocation,returns,a,yes,decision,for,at,least,one,of,those,no,nodes,then,we,force,allocate,to,one,of,them;public,void,test,force,allocate,primary,test,allocator,add,data,node1,alloc,id1,random,boolean,allocation,deciders,deciders,new,allocation,deciders,settings,empty,arrays,as,list,new,test,allocate,decision,random,boolean,decision,yes,decision,no,get,no,decider,that,allows,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,true,allocation,routing,nodes,unassigned,ignored,is,empty,assert,equals,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,1,assert,equals,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,node1,get,id
PrimaryShardAllocatorTests -> public void testForceAllocatePrimary();1541092382;Tests that when the nodes with prior copies of the given shard all return a decision of NO, but_{@link AllocationDecider#canForceAllocatePrimary(ShardRouting, RoutingNode, RoutingAllocation)}_returns a YES decision for at least one of those NO nodes, then we force allocate to one of them;public void testForceAllocatePrimary() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        AllocationDeciders deciders = new AllocationDeciders(Arrays.asList(_            _            _            new TestAllocateDecision(randomBoolean() ? Decision.YES : Decision.NO), getNoDeciderThatAllowsForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertTrue(allocation.routingNodes().unassigned().ignored().isEmpty())__        assertEquals(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), 1)__        assertEquals(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), node1.getId())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,all,return,a,decision,of,no,but,link,allocation,decider,can,force,allocate,primary,shard,routing,routing,node,routing,allocation,returns,a,yes,decision,for,at,least,one,of,those,no,nodes,then,we,force,allocate,to,one,of,them;public,void,test,force,allocate,primary,test,allocator,add,data,node1,alloc,id1,random,boolean,allocation,deciders,deciders,new,allocation,deciders,arrays,as,list,new,test,allocate,decision,random,boolean,decision,yes,decision,no,get,no,decider,that,allows,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,true,allocation,routing,nodes,unassigned,ignored,is,empty,assert,equals,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,1,assert,equals,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,node1,get,id
PrimaryShardAllocatorTests -> public void testForceAllocatePrimary();1544783963;Tests that when the nodes with prior copies of the given shard all return a decision of NO, but_{@link AllocationDecider#canForceAllocatePrimary(ShardRouting, RoutingNode, RoutingAllocation)}_returns a YES decision for at least one of those NO nodes, then we force allocate to one of them;public void testForceAllocatePrimary() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        AllocationDeciders deciders = new AllocationDeciders(Arrays.asList(_            _            _            new TestAllocateDecision(randomBoolean() ? Decision.YES : Decision.NO), getNoDeciderThatAllowsForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertTrue(allocation.routingNodes().unassigned().ignored().isEmpty())__        assertEquals(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), 1)__        assertEquals(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), node1.getId())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,all,return,a,decision,of,no,but,link,allocation,decider,can,force,allocate,primary,shard,routing,routing,node,routing,allocation,returns,a,yes,decision,for,at,least,one,of,those,no,nodes,then,we,force,allocate,to,one,of,them;public,void,test,force,allocate,primary,test,allocator,add,data,node1,alloc,id1,random,boolean,allocation,deciders,deciders,new,allocation,deciders,arrays,as,list,new,test,allocate,decision,random,boolean,decision,yes,decision,no,get,no,decider,that,allows,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,true,allocation,routing,nodes,unassigned,ignored,is,empty,assert,equals,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,1,assert,equals,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,node1,get,id
PrimaryShardAllocatorTests -> public void testNoMatchingAllocationIdFound();1524684173;Tests when the node returns data with a shard allocation id that does not match active allocation ids, it will be moved to ignore unassigned.;public void testNoMatchingAllocationIdFound() {_        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED, "id2")__        testAllocator.addData(node1, "id1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,data,with,a,shard,allocation,id,that,does,not,match,active,allocation,ids,it,will,be,moved,to,ignore,unassigned;public,void,test,no,matching,allocation,id,found,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,id2,test,allocator,add,data,node1,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoMatchingAllocationIdFound();1531179852;Tests when the node returns data with a shard allocation id that does not match active allocation ids, it will be moved to ignore unassigned.;public void testNoMatchingAllocationIdFound() {_        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED, "id2")__        testAllocator.addData(node1, "id1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,data,with,a,shard,allocation,id,that,does,not,match,active,allocation,ids,it,will,be,moved,to,ignore,unassigned;public,void,test,no,matching,allocation,id,found,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,id2,test,allocator,add,data,node1,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoMatchingAllocationIdFound();1540847035;Tests when the node returns data with a shard allocation id that does not match active allocation ids, it will be moved to ignore_unassigned.;public void testNoMatchingAllocationIdFound() {_        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED, "id2")__        testAllocator.addData(node1, "id1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,data,with,a,shard,allocation,id,that,does,not,match,active,allocation,ids,it,will,be,moved,to,ignore,unassigned;public,void,test,no,matching,allocation,id,found,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,id2,test,allocator,add,data,node1,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoMatchingAllocationIdFound();1541092382;Tests when the node returns data with a shard allocation id that does not match active allocation ids, it will be moved to ignore_unassigned.;public void testNoMatchingAllocationIdFound() {_        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED, "id2")__        testAllocator.addData(node1, "id1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,data,with,a,shard,allocation,id,that,does,not,match,active,allocation,ids,it,will,be,moved,to,ignore,unassigned;public,void,test,no,matching,allocation,id,found,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,id2,test,allocator,add,data,node1,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoMatchingAllocationIdFound();1544783963;Tests when the node returns data with a shard allocation id that does not match active allocation ids, it will be moved to ignore_unassigned.;public void testNoMatchingAllocationIdFound() {_        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED, "id2")__        testAllocator.addData(node1, "id1", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,data,with,a,shard,allocation,id,that,does,not,match,active,allocation,ids,it,will,be,moved,to,ignore,unassigned;public,void,test,no,matching,allocation,id,found,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,id2,test,allocator,add,data,node1,id1,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoAllocationFound();1524684173;Tests when the node returns that no data was found for it (null for allocation id),_it will be moved to ignore unassigned.;public void testNoAllocationFound() {_        final RoutingAllocation allocation =_            routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED, "allocId")__        testAllocator.addData(node1, null, randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,that,no,data,was,found,for,it,null,for,allocation,id,it,will,be,moved,to,ignore,unassigned;public,void,test,no,allocation,found,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,null,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoAllocationFound();1531179852;Tests when the node returns that no data was found for it (null for allocation id),_it will be moved to ignore unassigned.;public void testNoAllocationFound() {_        final RoutingAllocation allocation =_            routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED, "allocId")__        testAllocator.addData(node1, null, randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,that,no,data,was,found,for,it,null,for,allocation,id,it,will,be,moved,to,ignore,unassigned;public,void,test,no,allocation,found,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,null,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoAllocationFound();1540847035;Tests when the node returns that no data was found for it (null for allocation id),_it will be moved to ignore unassigned.;public void testNoAllocationFound() {_        final RoutingAllocation allocation =_            routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED, "allocId")__        testAllocator.addData(node1, null, randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,that,no,data,was,found,for,it,null,for,allocation,id,it,will,be,moved,to,ignore,unassigned;public,void,test,no,allocation,found,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,null,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoAllocationFound();1541092382;Tests when the node returns that no data was found for it (null for allocation id),_it will be moved to ignore unassigned.;public void testNoAllocationFound() {_        final RoutingAllocation allocation =_            routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED, "allocId")__        testAllocator.addData(node1, null, randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,that,no,data,was,found,for,it,null,for,allocation,id,it,will,be,moved,to,ignore,unassigned;public,void,test,no,allocation,found,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,null,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testNoAllocationFound();1544783963;Tests when the node returns that no data was found for it (null for allocation id),_it will be moved to ignore unassigned.;public void testNoAllocationFound() {_        final RoutingAllocation allocation =_            routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED, "allocId")__        testAllocator.addData(node1, null, randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,that,no,data,was,found,for,it,null,for,allocation,id,it,will,be,moved,to,ignore,unassigned;public,void,test,no,allocation,found,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,null,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testShardLockObtainFailedExceptionPreferOtherValidCopies();1524684173;Tests that when one node returns a ShardLockObtainFailedException and another properly loads the store, it will_select the second node as target;public void testShardLockObtainFailedExceptionPreferOtherValidCopies() {_        String allocId1 = randomAlphaOfLength(10)__        String allocId2 = randomAlphaOfLength(10)__        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            allocId1, allocId2)___        testAllocator.addData(node1, allocId1, randomBoolean(),_            new ShardLockObtainFailedException(shardId, "test"))__        testAllocator.addData(node2, allocId2, randomBoolean(), null)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node2.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(allocId2))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,one,node,returns,a,shard,lock,obtain,failed,exception,and,another,properly,loads,the,store,it,will,select,the,second,node,as,target;public,void,test,shard,lock,obtain,failed,exception,prefer,other,valid,copies,string,alloc,id1,random,alpha,of,length,10,string,alloc,id2,random,alpha,of,length,10,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,alloc,id2,test,allocator,add,data,node1,alloc,id1,random,boolean,new,shard,lock,obtain,failed,exception,shard,id,test,test,allocator,add,data,node2,alloc,id2,random,boolean,null,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node2,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id2,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testShardLockObtainFailedExceptionPreferOtherValidCopies();1531179852;Tests that when one node returns a ShardLockObtainFailedException and another properly loads the store, it will_select the second node as target;public void testShardLockObtainFailedExceptionPreferOtherValidCopies() {_        String allocId1 = randomAlphaOfLength(10)__        String allocId2 = randomAlphaOfLength(10)__        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            allocId1, allocId2)__        testAllocator.addData(node1, allocId1, randomBoolean(),_            new ShardLockObtainFailedException(shardId, "test"))__        testAllocator.addData(node2, allocId2, randomBoolean(), null)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(), equalTo(node2.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(), equalTo(allocId2))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,one,node,returns,a,shard,lock,obtain,failed,exception,and,another,properly,loads,the,store,it,will,select,the,second,node,as,target;public,void,test,shard,lock,obtain,failed,exception,prefer,other,valid,copies,string,alloc,id1,random,alpha,of,length,10,string,alloc,id2,random,alpha,of,length,10,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,alloc,id2,test,allocator,add,data,node1,alloc,id1,random,boolean,new,shard,lock,obtain,failed,exception,shard,id,test,test,allocator,add,data,node2,alloc,id2,random,boolean,null,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node2,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id2,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testShardLockObtainFailedExceptionPreferOtherValidCopies();1540847035;Tests that when one node returns a ShardLockObtainFailedException and another properly loads the store, it will_select the second node as target;public void testShardLockObtainFailedExceptionPreferOtherValidCopies() {_        String allocId1 = randomAlphaOfLength(10)__        String allocId2 = randomAlphaOfLength(10)__        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            allocId1, allocId2)__        testAllocator.addData(node1, allocId1, randomBoolean(),_            new ShardLockObtainFailedException(shardId, "test"))__        testAllocator.addData(node2, allocId2, randomBoolean(), null)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node2.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),_            equalTo(allocId2))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,one,node,returns,a,shard,lock,obtain,failed,exception,and,another,properly,loads,the,store,it,will,select,the,second,node,as,target;public,void,test,shard,lock,obtain,failed,exception,prefer,other,valid,copies,string,alloc,id1,random,alpha,of,length,10,string,alloc,id2,random,alpha,of,length,10,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,alloc,id2,test,allocator,add,data,node1,alloc,id1,random,boolean,new,shard,lock,obtain,failed,exception,shard,id,test,test,allocator,add,data,node2,alloc,id2,random,boolean,null,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node2,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id2,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testShardLockObtainFailedExceptionPreferOtherValidCopies();1541092382;Tests that when one node returns a ShardLockObtainFailedException and another properly loads the store, it will_select the second node as target;public void testShardLockObtainFailedExceptionPreferOtherValidCopies() {_        String allocId1 = randomAlphaOfLength(10)__        String allocId2 = randomAlphaOfLength(10)__        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            allocId1, allocId2)__        testAllocator.addData(node1, allocId1, randomBoolean(),_            new ShardLockObtainFailedException(shardId, "test"))__        testAllocator.addData(node2, allocId2, randomBoolean(), null)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node2.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),_            equalTo(allocId2))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,one,node,returns,a,shard,lock,obtain,failed,exception,and,another,properly,loads,the,store,it,will,select,the,second,node,as,target;public,void,test,shard,lock,obtain,failed,exception,prefer,other,valid,copies,string,alloc,id1,random,alpha,of,length,10,string,alloc,id2,random,alpha,of,length,10,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,alloc,id2,test,allocator,add,data,node1,alloc,id1,random,boolean,new,shard,lock,obtain,failed,exception,shard,id,test,test,allocator,add,data,node2,alloc,id2,random,boolean,null,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node2,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id2,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testShardLockObtainFailedExceptionPreferOtherValidCopies();1544783963;Tests that when one node returns a ShardLockObtainFailedException and another properly loads the store, it will_select the second node as target;public void testShardLockObtainFailedExceptionPreferOtherValidCopies() {_        String allocId1 = randomAlphaOfLength(10)__        String allocId2 = randomAlphaOfLength(10)__        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            allocId1, allocId2)__        testAllocator.addData(node1, allocId1, randomBoolean(),_            new ShardLockObtainFailedException(shardId, "test"))__        testAllocator.addData(node2, allocId2, randomBoolean(), null)__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).currentNodeId(),_            equalTo(node2.getId()))__        _        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).get(0).allocationId().getId(),_            equalTo(allocId2))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,one,node,returns,a,shard,lock,obtain,failed,exception,and,another,properly,loads,the,store,it,will,select,the,second,node,as,target;public,void,test,shard,lock,obtain,failed,exception,prefer,other,valid,copies,string,alloc,id1,random,alpha,of,length,10,string,alloc,id2,random,alpha,of,length,10,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,alloc,id2,test,allocator,add,data,node1,alloc,id1,random,boolean,new,shard,lock,obtain,failed,exception,shard,id,test,test,allocator,add,data,node2,alloc,id2,random,boolean,null,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,current,node,id,equal,to,node2,get,id,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,get,0,allocation,id,get,id,equal,to,alloc,id2,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testDontForceAllocateOnThrottleDecision();1524684173;Tests that when the nodes with prior copies of the given shard return a THROTTLE decision,_then we do not force allocate to that node but instead throttle.;public void testDontForceAllocateOnThrottleDecision() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY, Arrays.asList(_            _            _            _            _            _            new TestAllocateDecision(Decision.THROTTLE), getNoDeciderThatAllowsForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        List<ShardRouting> ignored = allocation.routingNodes().unassigned().ignored()__        assertEquals(ignored.size(), 1)__        assertEquals(ignored.get(0).unassignedInfo().getLastAllocationStatus(), AllocationStatus.DECIDERS_THROTTLED)__        assertTrue(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).isEmpty())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,return,a,throttle,decision,then,we,do,not,force,allocate,to,that,node,but,instead,throttle;public,void,test,dont,force,allocate,on,throttle,decision,test,allocator,add,data,node1,alloc,id1,random,boolean,allocation,deciders,deciders,new,allocation,deciders,settings,empty,arrays,as,list,new,test,allocate,decision,decision,throttle,get,no,decider,that,allows,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,list,shard,routing,ignored,allocation,routing,nodes,unassigned,ignored,assert,equals,ignored,size,1,assert,equals,ignored,get,0,unassigned,info,get,last,allocation,status,allocation,status,assert,true,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,is,empty
PrimaryShardAllocatorTests -> public void testDontForceAllocateOnThrottleDecision();1531179852;Tests that when the nodes with prior copies of the given shard return a THROTTLE decision,_then we do not force allocate to that node but instead throttle.;public void testDontForceAllocateOnThrottleDecision() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY, Arrays.asList(_            _            _            _            _            _            new TestAllocateDecision(Decision.THROTTLE), getNoDeciderThatAllowsForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        List<ShardRouting> ignored = allocation.routingNodes().unassigned().ignored()__        assertEquals(ignored.size(), 1)__        assertEquals(ignored.get(0).unassignedInfo().getLastAllocationStatus(), AllocationStatus.DECIDERS_THROTTLED)__        assertTrue(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).isEmpty())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,return,a,throttle,decision,then,we,do,not,force,allocate,to,that,node,but,instead,throttle;public,void,test,dont,force,allocate,on,throttle,decision,test,allocator,add,data,node1,alloc,id1,random,boolean,allocation,deciders,deciders,new,allocation,deciders,settings,empty,arrays,as,list,new,test,allocate,decision,decision,throttle,get,no,decider,that,allows,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,list,shard,routing,ignored,allocation,routing,nodes,unassigned,ignored,assert,equals,ignored,size,1,assert,equals,ignored,get,0,unassigned,info,get,last,allocation,status,allocation,status,assert,true,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,is,empty
PrimaryShardAllocatorTests -> public void testDontForceAllocateOnThrottleDecision();1540847035;Tests that when the nodes with prior copies of the given shard return a THROTTLE decision,_then we do not force allocate to that node but instead throttle.;public void testDontForceAllocateOnThrottleDecision() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        AllocationDeciders deciders = new AllocationDeciders(Settings.EMPTY, Arrays.asList(_            _            _            _            _            _            new TestAllocateDecision(Decision.THROTTLE), getNoDeciderThatAllowsForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        List<ShardRouting> ignored = allocation.routingNodes().unassigned().ignored()__        assertEquals(ignored.size(), 1)__        assertEquals(ignored.get(0).unassignedInfo().getLastAllocationStatus(), AllocationStatus.DECIDERS_THROTTLED)__        assertTrue(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).isEmpty())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,return,a,throttle,decision,then,we,do,not,force,allocate,to,that,node,but,instead,throttle;public,void,test,dont,force,allocate,on,throttle,decision,test,allocator,add,data,node1,alloc,id1,random,boolean,allocation,deciders,deciders,new,allocation,deciders,settings,empty,arrays,as,list,new,test,allocate,decision,decision,throttle,get,no,decider,that,allows,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,list,shard,routing,ignored,allocation,routing,nodes,unassigned,ignored,assert,equals,ignored,size,1,assert,equals,ignored,get,0,unassigned,info,get,last,allocation,status,allocation,status,assert,true,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,is,empty
PrimaryShardAllocatorTests -> public void testDontForceAllocateOnThrottleDecision();1541092382;Tests that when the nodes with prior copies of the given shard return a THROTTLE decision,_then we do not force allocate to that node but instead throttle.;public void testDontForceAllocateOnThrottleDecision() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        AllocationDeciders deciders = new AllocationDeciders(Arrays.asList(_            _            _            _            _            _            new TestAllocateDecision(Decision.THROTTLE), getNoDeciderThatAllowsForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        List<ShardRouting> ignored = allocation.routingNodes().unassigned().ignored()__        assertEquals(ignored.size(), 1)__        assertEquals(ignored.get(0).unassignedInfo().getLastAllocationStatus(), AllocationStatus.DECIDERS_THROTTLED)__        assertTrue(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).isEmpty())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,return,a,throttle,decision,then,we,do,not,force,allocate,to,that,node,but,instead,throttle;public,void,test,dont,force,allocate,on,throttle,decision,test,allocator,add,data,node1,alloc,id1,random,boolean,allocation,deciders,deciders,new,allocation,deciders,arrays,as,list,new,test,allocate,decision,decision,throttle,get,no,decider,that,allows,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,list,shard,routing,ignored,allocation,routing,nodes,unassigned,ignored,assert,equals,ignored,size,1,assert,equals,ignored,get,0,unassigned,info,get,last,allocation,status,allocation,status,assert,true,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,is,empty
PrimaryShardAllocatorTests -> public void testDontForceAllocateOnThrottleDecision();1544783963;Tests that when the nodes with prior copies of the given shard return a THROTTLE decision,_then we do not force allocate to that node but instead throttle.;public void testDontForceAllocateOnThrottleDecision() {_        testAllocator.addData(node1, "allocId1", randomBoolean())__        AllocationDeciders deciders = new AllocationDeciders(Arrays.asList(_            _            _            _            _            _            new TestAllocateDecision(Decision.THROTTLE), getNoDeciderThatAllowsForceAllocate()_        ))__        RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(deciders, CLUSTER_RECOVERED, "allocId1")__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        List<ShardRouting> ignored = allocation.routingNodes().unassigned().ignored()__        assertEquals(ignored.size(), 1)__        assertEquals(ignored.get(0).unassignedInfo().getLastAllocationStatus(), AllocationStatus.DECIDERS_THROTTLED)__        assertTrue(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).isEmpty())__    };tests,that,when,the,nodes,with,prior,copies,of,the,given,shard,return,a,throttle,decision,then,we,do,not,force,allocate,to,that,node,but,instead,throttle;public,void,test,dont,force,allocate,on,throttle,decision,test,allocator,add,data,node1,alloc,id1,random,boolean,allocation,deciders,deciders,new,allocation,deciders,arrays,as,list,new,test,allocate,decision,decision,throttle,get,no,decider,that,allows,force,allocate,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,deciders,alloc,id1,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,list,shard,routing,ignored,allocation,routing,nodes,unassigned,ignored,assert,equals,ignored,size,1,assert,equals,ignored,get,0,unassigned,info,get,last,allocation,status,allocation,status,assert,true,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,is,empty
PrimaryShardAllocatorTests -> public void testStoreException();1524684173;Tests when the node returns that no data was found for it, it will be moved to ignore unassigned.;public void testStoreException() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean(), new CorruptIndexException("test", "test"))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,that,no,data,was,found,for,it,it,will,be,moved,to,ignore,unassigned;public,void,test,store,exception,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,new,corrupt,index,exception,test,test,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testStoreException();1531179852;Tests when the node returns that no data was found for it, it will be moved to ignore unassigned.;public void testStoreException() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean(), new CorruptIndexException("test", "test"))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,that,no,data,was,found,for,it,it,will,be,moved,to,ignore,unassigned;public,void,test,store,exception,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,new,corrupt,index,exception,test,test,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testStoreException();1540847035;Tests when the node returns that no data was found for it, it will be moved to ignore unassigned.;public void testStoreException() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean(), new CorruptIndexException("test", "test"))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,that,no,data,was,found,for,it,it,will,be,moved,to,ignore,unassigned;public,void,test,store,exception,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,new,corrupt,index,exception,test,test,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testStoreException();1541092382;Tests when the node returns that no data was found for it, it will be moved to ignore unassigned.;public void testStoreException() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean(), new CorruptIndexException("test", "test"))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,that,no,data,was,found,for,it,it,will,be,moved,to,ignore,unassigned;public,void,test,store,exception,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,new,corrupt,index,exception,test,test,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testStoreException();1544783963;Tests when the node returns that no data was found for it, it will be moved to ignore unassigned.;public void testStoreException() {_        final RoutingAllocation allocation = routingAllocationWithOnePrimaryNoReplicas(yesAllocationDeciders(), CLUSTER_RECOVERED,_            "allocId1")__        testAllocator.addData(node1, "allocId1", randomBoolean(), new CorruptIndexException("test", "test"))__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().size(), equalTo(1))__        assertThat(allocation.routingNodes().unassigned().ignored().get(0).shardId(), equalTo(shardId))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,when,the,node,returns,that,no,data,was,found,for,it,it,will,be,moved,to,ignore,unassigned;public,void,test,store,exception,final,routing,allocation,allocation,routing,allocation,with,one,primary,no,replicas,yes,allocation,deciders,alloc,id1,test,allocator,add,data,node1,alloc,id1,random,boolean,new,corrupt,index,exception,test,test,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,size,equal,to,1,assert,that,allocation,routing,nodes,unassigned,ignored,get,0,shard,id,equal,to,shard,id,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestore();1524684173;Tests that when restoring from a snapshot and we find a node with a shard copy and allocation_deciders say yes, we allocate to that node.;public void testRestore() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,and,allocation,deciders,say,yes,we,allocate,to,that,node;public,void,test,restore,routing,allocation,allocation,get,restore,routing,allocation,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestore();1531179852;Tests that when restoring from a snapshot and we find a node with a shard copy and allocation_deciders say yes, we allocate to that node.;public void testRestore() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,and,allocation,deciders,say,yes,we,allocate,to,that,node;public,void,test,restore,routing,allocation,allocation,get,restore,routing,allocation,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestore();1540847035;Tests that when restoring from a snapshot and we find a node with a shard copy and allocation_deciders say yes, we allocate to that node.;public void testRestore() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,and,allocation,deciders,say,yes,we,allocate,to,that,node;public,void,test,restore,routing,allocation,allocation,get,restore,routing,allocation,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestore();1541092382;Tests that when restoring from a snapshot and we find a node with a shard copy and allocation_deciders say yes, we allocate to that node.;public void testRestore() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,and,allocation,deciders,say,yes,we,allocate,to,that,node;public,void,test,restore,routing,allocation,allocation,get,restore,routing,allocation,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
PrimaryShardAllocatorTests -> public void testRestore();1544783963;Tests that when restoring from a snapshot and we find a node with a shard copy and allocation_deciders say yes, we allocate to that node.;public void testRestore() {_        RoutingAllocation allocation = getRestoreRoutingAllocation(yesAllocationDeciders(), "allocId")__        testAllocator.addData(node1, "some allocId", randomBoolean())__        testAllocator.allocateUnassigned(allocation)__        assertThat(allocation.routingNodesChanged(), equalTo(true))__        assertThat(allocation.routingNodes().unassigned().ignored().isEmpty(), equalTo(true))__        assertThat(allocation.routingNodes().shardsWithState(ShardRoutingState.INITIALIZING).size(), equalTo(1))__        assertClusterHealthStatus(allocation, ClusterHealthStatus.YELLOW)__    };tests,that,when,restoring,from,a,snapshot,and,we,find,a,node,with,a,shard,copy,and,allocation,deciders,say,yes,we,allocate,to,that,node;public,void,test,restore,routing,allocation,allocation,get,restore,routing,allocation,yes,allocation,deciders,alloc,id,test,allocator,add,data,node1,some,alloc,id,random,boolean,test,allocator,allocate,unassigned,allocation,assert,that,allocation,routing,nodes,changed,equal,to,true,assert,that,allocation,routing,nodes,unassigned,ignored,is,empty,equal,to,true,assert,that,allocation,routing,nodes,shards,with,state,shard,routing,state,initializing,size,equal,to,1,assert,cluster,health,status,allocation,cluster,health,status,yellow
