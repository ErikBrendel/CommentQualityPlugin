commented;modifiers;parameterAmount;loc;comment;code
false;static;1;13;;static SimulateDocumentVerboseResult createTestInstance(boolean withFailures) {     int numDocs = randomIntBetween(0, 5).     List<SimulateProcessorResult> results = new ArrayList<>().     for (int i = 0. i < numDocs. i++) {         boolean isSuccessful = !(withFailures && randomBoolean()).         boolean isIgnoredError = withFailures && randomBoolean().         results.add(SimulateProcessorResultTests.createTestInstance(isSuccessful, isIgnoredError)).     }     return new SimulateDocumentVerboseResult(results). }
false;private,static;0;3;;private static SimulateDocumentVerboseResult createTestInstanceWithFailures() {     return createTestInstance(true). }
false;protected;0;4;;@Override protected SimulateDocumentVerboseResult createTestInstance() {     return createTestInstance(false). }
false;protected;1;4;;@Override protected SimulateDocumentVerboseResult doParseInstance(XContentParser parser) {     return SimulateDocumentVerboseResult.fromXContent(parser). }
false;protected;0;4;;@Override protected boolean supportsUnknownFields() {     return true. }
false;static;2;10;;static void assertEqualDocs(SimulateDocumentVerboseResult response, SimulateDocumentVerboseResult parsedResponse) {     assertEquals(response.getProcessorResults().size(), parsedResponse.getProcessorResults().size()).     for (int i = 0. i < response.getProcessorResults().size(). i++) {         SimulateProcessorResultTests.assertEqualProcessorResults(response.getProcessorResults().get(i), parsedResponse.getProcessorResults().get(i)).     } }
false;protected;2;5;;@Override protected void assertEqualInstances(SimulateDocumentVerboseResult response, SimulateDocumentVerboseResult parsedResponse) {     assertEqualDocs(response, parsedResponse). }
false;protected;0;15;;@Override protected Predicate<String> getRandomFieldsExcludeFilter() {     // We cannot have random fields in the _source field and _ingest field     return field -> field.contains(new StringJoiner(".").add(WriteableIngestDocument.DOC_FIELD).add(WriteableIngestDocument.SOURCE_FIELD).toString()) || field.contains(new StringJoiner(".").add(WriteableIngestDocument.DOC_FIELD).add(WriteableIngestDocument.INGEST_FIELD).toString()). }
true;public;0;8;/**  * Test parsing {@link SimulateDocumentVerboseResult} with inner failures as they don't support asserting on xcontent  * equivalence, given that exceptions are not parsed back as the same original class. We run the usual  * {@link AbstractXContentTestCase#testFromXContent()} without failures, and this other test with failures where we  * disable asserting on xcontent equivalence at the end.  */ ;/**  * Test parsing {@link SimulateDocumentVerboseResult} with inner failures as they don't support asserting on xcontent  * equivalence, given that exceptions are not parsed back as the same original class. We run the usual  * {@link AbstractXContentTestCase#testFromXContent()} without failures, and this other test with failures where we  * disable asserting on xcontent equivalence at the end.  */ public void testFromXContentWithFailures() throws IOException {     Supplier<SimulateDocumentVerboseResult> instanceSupplier = SimulateDocumentVerboseResultTests::createTestInstanceWithFailures.     // exceptions are not of the same type whenever parsed back     boolean assertToXContentEquivalence = false.     AbstractXContentTestCase.testFromXContent(NUMBER_OF_TEST_RUNS, instanceSupplier, supportsUnknownFields(), getShuffleFieldsExceptions(), getRandomFieldsExcludeFilter(), this::createParser, this::doParseInstance, this::assertEqualInstances, assertToXContentEquivalence, getToXContentParams()). }
