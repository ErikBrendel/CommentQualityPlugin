commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Before public void startThreadPool() {     threadPool = new TestThreadPool("BulkProcessorTests"). }
false;public;0;4;;@After public void stopThreadPool() throws InterruptedException {     terminate(threadPool). }
false;public;0;39;;public void testBulkProcessorFlushPreservesContext() throws InterruptedException {     final CountDownLatch latch = new CountDownLatch(1).     final String headerKey = randomAlphaOfLengthBetween(1, 8).     final String transientKey = randomAlphaOfLengthBetween(1, 8).     final String headerValue = randomAlphaOfLengthBetween(1, 32).     final Object transientValue = new Object().     BiConsumer<BulkRequest, ActionListener<BulkResponse>> consumer = (request, listener) -> {         ThreadContext threadContext = threadPool.getThreadContext().         assertEquals(headerValue, threadContext.getHeader(headerKey)).         assertSame(transientValue, threadContext.getTransient(transientKey)).         latch.countDown().     }.     final int bulkSize = randomIntBetween(2, 32).     final TimeValue flushInterval = TimeValue.timeValueSeconds(1L).     final BulkProcessor bulkProcessor.     assertNull(threadPool.getThreadContext().getHeader(headerKey)).     assertNull(threadPool.getThreadContext().getTransient(transientKey)).     try (ThreadContext.StoredContext ignore = threadPool.getThreadContext().stashContext()) {         threadPool.getThreadContext().putHeader(headerKey, headerValue).         threadPool.getThreadContext().putTransient(transientKey, transientValue).         bulkProcessor = new BulkProcessor(consumer, BackoffPolicy.noBackoff(), emptyListener(), 1, bulkSize, new ByteSizeValue(5, ByteSizeUnit.MB), flushInterval, threadPool, () -> {         }, BulkRequest::new).     }     assertNull(threadPool.getThreadContext().getHeader(headerKey)).     assertNull(threadPool.getThreadContext().getTransient(transientKey)).     // add a single item which won't be over the size or number of items     bulkProcessor.add(new IndexRequest()).     // wait for flush to execute     latch.await().     assertNull(threadPool.getThreadContext().getHeader(headerKey)).     assertNull(threadPool.getThreadContext().getTransient(transientKey)).     bulkProcessor.close(). }
false;public;0;11;;public void testAwaitOnCloseCallsOnClose() throws Exception {     final AtomicBoolean called = new AtomicBoolean(false).     BiConsumer<BulkRequest, ActionListener<BulkResponse>> consumer = (request, listener) -> {     }.     BulkProcessor bulkProcessor = new BulkProcessor(consumer, BackoffPolicy.noBackoff(), emptyListener(), 0, 10, new ByteSizeValue(1000), null, (command, delay, executor) -> null, () -> called.set(true), BulkRequest::new).     assertFalse(called.get()).     bulkProcessor.awaitClose(100, TimeUnit.MILLISECONDS).     assertTrue(called.get()). }
false;public;2;3;;@Override public void beforeBulk(long executionId, BulkRequest request) { }
false;public;3;3;;@Override public void afterBulk(long executionId, BulkRequest request, BulkResponse response) { }
false;public;3;3;;@Override public void afterBulk(long executionId, BulkRequest request, Throwable failure) { }
false;private;0;15;;private BulkProcessor.Listener emptyListener() {     return new BulkProcessor.Listener() {          @Override         public void beforeBulk(long executionId, BulkRequest request) {         }          @Override         public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {         }          @Override         public void afterBulk(long executionId, BulkRequest request, Throwable failure) {         }     }. }
