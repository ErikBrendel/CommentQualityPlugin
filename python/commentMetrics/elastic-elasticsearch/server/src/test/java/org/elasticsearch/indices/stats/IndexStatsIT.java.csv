# id;timestamp;commentText;codeText;commentWords;codeWords
IndexStatsIT -> public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException;1524684173;Test that we can safely concurrently index and get stats. This test was inspired by a serialization issue that arose due to a race_getting doc stats during heavy indexing. The race could lead to deleted docs being negative which would then be serialized as a_variable-length long. Since serialization of negative longs using a variable-length format was unsupported_({@link org.elasticsearch.common.io.stream.StreamOutput#writeVLong(long)}), the stream would become corrupted. Here, we want to test_that we can continue to get stats while indexing.;public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException {_        final AtomicInteger idGenerator = new AtomicInteger()__        final int numberOfIndexingThreads = Runtime.getRuntime().availableProcessors()__        final int numberOfStatsThreads = 4 * numberOfIndexingThreads__        final CyclicBarrier barrier = new CyclicBarrier(1 + numberOfIndexingThreads + numberOfStatsThreads)__        final AtomicBoolean stop = new AtomicBoolean()__        final List<Thread> threads = new ArrayList<>(numberOfIndexingThreads + numberOfIndexingThreads)___        final CountDownLatch latch = new CountDownLatch(1)__        final AtomicBoolean failed = new AtomicBoolean()__        final AtomicReference<List<DefaultShardOperationFailedException>> shardFailures =_                new AtomicReference<>(new CopyOnWriteArrayList<>())__        final AtomicReference<List<Exception>> executionFailures = new AtomicReference<>(new CopyOnWriteArrayList<>())___        _        final CreateIndexRequest createIndexRequest =_            new CreateIndexRequest("test", Settings.builder().put("index.number_of_shards", 10).build())__        client().admin().indices().create(createIndexRequest).get()___        _        for (int i = 0_ i < numberOfIndexingThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                while (!stop.get()) {_                    final String id = Integer.toString(idGenerator.incrementAndGet())__                    final IndexResponse response =_                        client()_                            .prepareIndex("test", "type", id)_                            .setSource("{}", XContentType.JSON)_                            .get()__                    assertThat(response.getResult(), equalTo(DocWriteResponse.Result.CREATED))__                }_            })__            thread.setName("indexing-" + i)__            threads.add(thread)__            thread.start()__        }__        _        for (int i = 0_ i < numberOfStatsThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                final IndicesStatsRequest request = new IndicesStatsRequest()__                request.all()__                request.indices(new String[0])__                while (!stop.get()) {_                    try {_                        final IndicesStatsResponse response = client().admin().indices().stats(request).get()__                        if (response.getFailedShards() > 0) {_                            failed.set(true)__                            shardFailures.get().addAll(Arrays.asList(response.getShardFailures()))__                            latch.countDown()__                        }_                    } catch (final ExecutionException | InterruptedException e) {_                        failed.set(true)__                        executionFailures.get().add(e)__                        latch.countDown()__                    }_                }_            })__            thread.setName("stats-" + i)__            threads.add(thread)__            thread.start()__        }__        _        barrier.await()___        _        latch.await(15, TimeUnit.SECONDS)___        _        stop.set(true)__        for (final Thread thread : threads) {_            thread.join()__        }__        assertThat(shardFailures.get(), emptyCollectionOf(DefaultShardOperationFailedException.class))__        assertThat(executionFailures.get(), emptyCollectionOf(Exception.class))__    };test,that,we,can,safely,concurrently,index,and,get,stats,this,test,was,inspired,by,a,serialization,issue,that,arose,due,to,a,race,getting,doc,stats,during,heavy,indexing,the,race,could,lead,to,deleted,docs,being,negative,which,would,then,be,serialized,as,a,variable,length,long,since,serialization,of,negative,longs,using,a,variable,length,format,was,unsupported,link,org,elasticsearch,common,io,stream,stream,output,write,vlong,long,the,stream,would,become,corrupted,here,we,want,to,test,that,we,can,continue,to,get,stats,while,indexing;public,void,test,concurrent,indexing,and,stats,requests,throws,broken,barrier,exception,interrupted,exception,execution,exception,final,atomic,integer,id,generator,new,atomic,integer,final,int,number,of,indexing,threads,runtime,get,runtime,available,processors,final,int,number,of,stats,threads,4,number,of,indexing,threads,final,cyclic,barrier,barrier,new,cyclic,barrier,1,number,of,indexing,threads,number,of,stats,threads,final,atomic,boolean,stop,new,atomic,boolean,final,list,thread,threads,new,array,list,number,of,indexing,threads,number,of,indexing,threads,final,count,down,latch,latch,new,count,down,latch,1,final,atomic,boolean,failed,new,atomic,boolean,final,atomic,reference,list,default,shard,operation,failed,exception,shard,failures,new,atomic,reference,new,copy,on,write,array,list,final,atomic,reference,list,exception,execution,failures,new,atomic,reference,new,copy,on,write,array,list,final,create,index,request,create,index,request,new,create,index,request,test,settings,builder,put,index,10,build,client,admin,indices,create,create,index,request,get,for,int,i,0,i,number,of,indexing,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,while,stop,get,final,string,id,integer,to,string,id,generator,increment,and,get,final,index,response,response,client,prepare,index,test,type,id,set,source,xcontent,type,json,get,assert,that,response,get,result,equal,to,doc,write,response,result,created,thread,set,name,indexing,i,threads,add,thread,thread,start,for,int,i,0,i,number,of,stats,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,final,indices,stats,request,request,new,indices,stats,request,request,all,request,indices,new,string,0,while,stop,get,try,final,indices,stats,response,response,client,admin,indices,stats,request,get,if,response,get,failed,shards,0,failed,set,true,shard,failures,get,add,all,arrays,as,list,response,get,shard,failures,latch,count,down,catch,final,execution,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,thread,set,name,stats,i,threads,add,thread,thread,start,barrier,await,latch,await,15,time,unit,seconds,stop,set,true,for,final,thread,thread,threads,thread,join,assert,that,shard,failures,get,empty,collection,of,default,shard,operation,failed,exception,class,assert,that,execution,failures,get,empty,collection,of,exception,class
IndexStatsIT -> public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException;1533063033;Test that we can safely concurrently index and get stats. This test was inspired by a serialization issue that arose due to a race_getting doc stats during heavy indexing. The race could lead to deleted docs being negative which would then be serialized as a_variable-length long. Since serialization of negative longs using a variable-length format was unsupported_({@link org.elasticsearch.common.io.stream.StreamOutput#writeVLong(long)}), the stream would become corrupted. Here, we want to test_that we can continue to get stats while indexing.;public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException {_        final AtomicInteger idGenerator = new AtomicInteger()__        final int numberOfIndexingThreads = Runtime.getRuntime().availableProcessors()__        final int numberOfStatsThreads = 4 * numberOfIndexingThreads__        final CyclicBarrier barrier = new CyclicBarrier(1 + numberOfIndexingThreads + numberOfStatsThreads)__        final AtomicBoolean stop = new AtomicBoolean()__        final List<Thread> threads = new ArrayList<>(numberOfIndexingThreads + numberOfIndexingThreads)___        final CountDownLatch latch = new CountDownLatch(1)__        final AtomicBoolean failed = new AtomicBoolean()__        final AtomicReference<List<DefaultShardOperationFailedException>> shardFailures =_                new AtomicReference<>(new CopyOnWriteArrayList<>())__        final AtomicReference<List<Exception>> executionFailures = new AtomicReference<>(new CopyOnWriteArrayList<>())___        _        final CreateIndexRequest createIndexRequest =_            new CreateIndexRequest("test", Settings.builder().put("index.number_of_shards", 10).build())__        client().admin().indices().create(createIndexRequest).get()___        _        for (int i = 0_ i < numberOfIndexingThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                while (!stop.get()) {_                    final String id = Integer.toString(idGenerator.incrementAndGet())__                    final IndexResponse response =_                        client()_                            .prepareIndex("test", "type", id)_                            .setSource("{}", XContentType.JSON)_                            .get()__                    assertThat(response.getResult(), equalTo(DocWriteResponse.Result.CREATED))__                }_            })__            thread.setName("indexing-" + i)__            threads.add(thread)__            thread.start()__        }__        _        for (int i = 0_ i < numberOfStatsThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                final IndicesStatsRequest request = new IndicesStatsRequest()__                request.all()__                request.indices(new String[0])__                while (!stop.get()) {_                    try {_                        final IndicesStatsResponse response = client().admin().indices().stats(request).get()__                        if (response.getFailedShards() > 0) {_                            failed.set(true)__                            shardFailures.get().addAll(Arrays.asList(response.getShardFailures()))__                            latch.countDown()__                        }_                    } catch (final ExecutionException | InterruptedException e) {_                        failed.set(true)__                        executionFailures.get().add(e)__                        latch.countDown()__                    }_                }_            })__            thread.setName("stats-" + i)__            threads.add(thread)__            thread.start()__        }__        _        barrier.await()___        _        latch.await(15, TimeUnit.SECONDS)___        _        stop.set(true)__        for (final Thread thread : threads) {_            thread.join()__        }__        assertThat(shardFailures.get(), emptyCollectionOf(DefaultShardOperationFailedException.class))__        assertThat(executionFailures.get(), emptyCollectionOf(Exception.class))__    };test,that,we,can,safely,concurrently,index,and,get,stats,this,test,was,inspired,by,a,serialization,issue,that,arose,due,to,a,race,getting,doc,stats,during,heavy,indexing,the,race,could,lead,to,deleted,docs,being,negative,which,would,then,be,serialized,as,a,variable,length,long,since,serialization,of,negative,longs,using,a,variable,length,format,was,unsupported,link,org,elasticsearch,common,io,stream,stream,output,write,vlong,long,the,stream,would,become,corrupted,here,we,want,to,test,that,we,can,continue,to,get,stats,while,indexing;public,void,test,concurrent,indexing,and,stats,requests,throws,broken,barrier,exception,interrupted,exception,execution,exception,final,atomic,integer,id,generator,new,atomic,integer,final,int,number,of,indexing,threads,runtime,get,runtime,available,processors,final,int,number,of,stats,threads,4,number,of,indexing,threads,final,cyclic,barrier,barrier,new,cyclic,barrier,1,number,of,indexing,threads,number,of,stats,threads,final,atomic,boolean,stop,new,atomic,boolean,final,list,thread,threads,new,array,list,number,of,indexing,threads,number,of,indexing,threads,final,count,down,latch,latch,new,count,down,latch,1,final,atomic,boolean,failed,new,atomic,boolean,final,atomic,reference,list,default,shard,operation,failed,exception,shard,failures,new,atomic,reference,new,copy,on,write,array,list,final,atomic,reference,list,exception,execution,failures,new,atomic,reference,new,copy,on,write,array,list,final,create,index,request,create,index,request,new,create,index,request,test,settings,builder,put,index,10,build,client,admin,indices,create,create,index,request,get,for,int,i,0,i,number,of,indexing,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,while,stop,get,final,string,id,integer,to,string,id,generator,increment,and,get,final,index,response,response,client,prepare,index,test,type,id,set,source,xcontent,type,json,get,assert,that,response,get,result,equal,to,doc,write,response,result,created,thread,set,name,indexing,i,threads,add,thread,thread,start,for,int,i,0,i,number,of,stats,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,final,indices,stats,request,request,new,indices,stats,request,request,all,request,indices,new,string,0,while,stop,get,try,final,indices,stats,response,response,client,admin,indices,stats,request,get,if,response,get,failed,shards,0,failed,set,true,shard,failures,get,add,all,arrays,as,list,response,get,shard,failures,latch,count,down,catch,final,execution,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,thread,set,name,stats,i,threads,add,thread,thread,start,barrier,await,latch,await,15,time,unit,seconds,stop,set,true,for,final,thread,thread,threads,thread,join,assert,that,shard,failures,get,empty,collection,of,default,shard,operation,failed,exception,class,assert,that,execution,failures,get,empty,collection,of,exception,class
IndexStatsIT -> public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException;1535139672;Test that we can safely concurrently index and get stats. This test was inspired by a serialization issue that arose due to a race_getting doc stats during heavy indexing. The race could lead to deleted docs being negative which would then be serialized as a_variable-length long. Since serialization of negative longs using a variable-length format was unsupported_({@link org.elasticsearch.common.io.stream.StreamOutput#writeVLong(long)}), the stream would become corrupted. Here, we want to test_that we can continue to get stats while indexing.;public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException {_        final AtomicInteger idGenerator = new AtomicInteger()__        final int numberOfIndexingThreads = Runtime.getRuntime().availableProcessors()__        final int numberOfStatsThreads = 4 * numberOfIndexingThreads__        final CyclicBarrier barrier = new CyclicBarrier(1 + numberOfIndexingThreads + numberOfStatsThreads)__        final AtomicBoolean stop = new AtomicBoolean()__        final List<Thread> threads = new ArrayList<>(numberOfIndexingThreads + numberOfIndexingThreads)___        final CountDownLatch latch = new CountDownLatch(1)__        final AtomicBoolean failed = new AtomicBoolean()__        final AtomicReference<List<DefaultShardOperationFailedException>> shardFailures =_                new AtomicReference<>(new CopyOnWriteArrayList<>())__        final AtomicReference<List<Exception>> executionFailures = new AtomicReference<>(new CopyOnWriteArrayList<>())___        _        final CreateIndexRequest createIndexRequest =_            new CreateIndexRequest("test", Settings.builder().put("index.number_of_shards", 10).build())__        client().admin().indices().create(createIndexRequest).get()___        _        for (int i = 0_ i < numberOfIndexingThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                while (!stop.get()) {_                    final String id = Integer.toString(idGenerator.incrementAndGet())__                    final IndexResponse response =_                        client()_                            .prepareIndex("test", "type", id)_                            .setSource("{}", XContentType.JSON)_                            .get()__                    assertThat(response.getResult(), equalTo(DocWriteResponse.Result.CREATED))__                }_            })__            thread.setName("indexing-" + i)__            threads.add(thread)__            thread.start()__        }__        _        for (int i = 0_ i < numberOfStatsThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                final IndicesStatsRequest request = new IndicesStatsRequest()__                request.all()__                request.indices(new String[0])__                while (!stop.get()) {_                    try {_                        final IndicesStatsResponse response = client().admin().indices().stats(request).get()__                        if (response.getFailedShards() > 0) {_                            failed.set(true)__                            shardFailures.get().addAll(Arrays.asList(response.getShardFailures()))__                            latch.countDown()__                        }_                    } catch (final ExecutionException | InterruptedException e) {_                        failed.set(true)__                        executionFailures.get().add(e)__                        latch.countDown()__                    }_                }_            })__            thread.setName("stats-" + i)__            threads.add(thread)__            thread.start()__        }__        _        barrier.await()___        _        latch.await(15, TimeUnit.SECONDS)___        _        stop.set(true)__        for (final Thread thread : threads) {_            thread.join()__        }__        assertThat(shardFailures.get(), emptyCollectionOf(DefaultShardOperationFailedException.class))__        assertThat(executionFailures.get(), emptyCollectionOf(Exception.class))__    };test,that,we,can,safely,concurrently,index,and,get,stats,this,test,was,inspired,by,a,serialization,issue,that,arose,due,to,a,race,getting,doc,stats,during,heavy,indexing,the,race,could,lead,to,deleted,docs,being,negative,which,would,then,be,serialized,as,a,variable,length,long,since,serialization,of,negative,longs,using,a,variable,length,format,was,unsupported,link,org,elasticsearch,common,io,stream,stream,output,write,vlong,long,the,stream,would,become,corrupted,here,we,want,to,test,that,we,can,continue,to,get,stats,while,indexing;public,void,test,concurrent,indexing,and,stats,requests,throws,broken,barrier,exception,interrupted,exception,execution,exception,final,atomic,integer,id,generator,new,atomic,integer,final,int,number,of,indexing,threads,runtime,get,runtime,available,processors,final,int,number,of,stats,threads,4,number,of,indexing,threads,final,cyclic,barrier,barrier,new,cyclic,barrier,1,number,of,indexing,threads,number,of,stats,threads,final,atomic,boolean,stop,new,atomic,boolean,final,list,thread,threads,new,array,list,number,of,indexing,threads,number,of,indexing,threads,final,count,down,latch,latch,new,count,down,latch,1,final,atomic,boolean,failed,new,atomic,boolean,final,atomic,reference,list,default,shard,operation,failed,exception,shard,failures,new,atomic,reference,new,copy,on,write,array,list,final,atomic,reference,list,exception,execution,failures,new,atomic,reference,new,copy,on,write,array,list,final,create,index,request,create,index,request,new,create,index,request,test,settings,builder,put,index,10,build,client,admin,indices,create,create,index,request,get,for,int,i,0,i,number,of,indexing,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,while,stop,get,final,string,id,integer,to,string,id,generator,increment,and,get,final,index,response,response,client,prepare,index,test,type,id,set,source,xcontent,type,json,get,assert,that,response,get,result,equal,to,doc,write,response,result,created,thread,set,name,indexing,i,threads,add,thread,thread,start,for,int,i,0,i,number,of,stats,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,final,indices,stats,request,request,new,indices,stats,request,request,all,request,indices,new,string,0,while,stop,get,try,final,indices,stats,response,response,client,admin,indices,stats,request,get,if,response,get,failed,shards,0,failed,set,true,shard,failures,get,add,all,arrays,as,list,response,get,shard,failures,latch,count,down,catch,final,execution,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,thread,set,name,stats,i,threads,add,thread,thread,start,barrier,await,latch,await,15,time,unit,seconds,stop,set,true,for,final,thread,thread,threads,thread,join,assert,that,shard,failures,get,empty,collection,of,default,shard,operation,failed,exception,class,assert,that,execution,failures,get,empty,collection,of,exception,class
IndexStatsIT -> public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException;1535723122;Test that we can safely concurrently index and get stats. This test was inspired by a serialization issue that arose due to a race_getting doc stats during heavy indexing. The race could lead to deleted docs being negative which would then be serialized as a_variable-length long. Since serialization of negative longs using a variable-length format was unsupported_({@link org.elasticsearch.common.io.stream.StreamOutput#writeVLong(long)}), the stream would become corrupted. Here, we want to test_that we can continue to get stats while indexing.;public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException {_        final AtomicInteger idGenerator = new AtomicInteger()__        final int numberOfIndexingThreads = Runtime.getRuntime().availableProcessors()__        final int numberOfStatsThreads = 4 * numberOfIndexingThreads__        final CyclicBarrier barrier = new CyclicBarrier(1 + numberOfIndexingThreads + numberOfStatsThreads)__        final AtomicBoolean stop = new AtomicBoolean()__        final List<Thread> threads = new ArrayList<>(numberOfIndexingThreads + numberOfIndexingThreads)___        final CountDownLatch latch = new CountDownLatch(1)__        final AtomicBoolean failed = new AtomicBoolean()__        final AtomicReference<List<DefaultShardOperationFailedException>> shardFailures =_                new AtomicReference<>(new CopyOnWriteArrayList<>())__        final AtomicReference<List<Exception>> executionFailures = new AtomicReference<>(new CopyOnWriteArrayList<>())___        _        final CreateIndexRequest createIndexRequest =_            new CreateIndexRequest("test", Settings.builder().put("index.number_of_shards", 10).build())__        client().admin().indices().create(createIndexRequest).get()___        _        for (int i = 0_ i < numberOfIndexingThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                while (!stop.get()) {_                    final String id = Integer.toString(idGenerator.incrementAndGet())__                    final IndexResponse response =_                        client()_                            .prepareIndex("test", "type", id)_                            .setSource("{}", XContentType.JSON)_                            .get()__                    assertThat(response.getResult(), equalTo(DocWriteResponse.Result.CREATED))__                }_            })__            thread.setName("indexing-" + i)__            threads.add(thread)__            thread.start()__        }__        _        for (int i = 0_ i < numberOfStatsThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                final IndicesStatsRequest request = new IndicesStatsRequest()__                request.all()__                request.indices(new String[0])__                while (!stop.get()) {_                    try {_                        final IndicesStatsResponse response = client().admin().indices().stats(request).get()__                        if (response.getFailedShards() > 0) {_                            failed.set(true)__                            shardFailures.get().addAll(Arrays.asList(response.getShardFailures()))__                            latch.countDown()__                        }_                    } catch (final ExecutionException | InterruptedException e) {_                        failed.set(true)__                        executionFailures.get().add(e)__                        latch.countDown()__                    }_                }_            })__            thread.setName("stats-" + i)__            threads.add(thread)__            thread.start()__        }__        _        barrier.await()___        _        latch.await(15, TimeUnit.SECONDS)___        _        stop.set(true)__        for (final Thread thread : threads) {_            thread.join()__        }__        assertThat(shardFailures.get(), emptyCollectionOf(DefaultShardOperationFailedException.class))__        assertThat(executionFailures.get(), emptyCollectionOf(Exception.class))__    };test,that,we,can,safely,concurrently,index,and,get,stats,this,test,was,inspired,by,a,serialization,issue,that,arose,due,to,a,race,getting,doc,stats,during,heavy,indexing,the,race,could,lead,to,deleted,docs,being,negative,which,would,then,be,serialized,as,a,variable,length,long,since,serialization,of,negative,longs,using,a,variable,length,format,was,unsupported,link,org,elasticsearch,common,io,stream,stream,output,write,vlong,long,the,stream,would,become,corrupted,here,we,want,to,test,that,we,can,continue,to,get,stats,while,indexing;public,void,test,concurrent,indexing,and,stats,requests,throws,broken,barrier,exception,interrupted,exception,execution,exception,final,atomic,integer,id,generator,new,atomic,integer,final,int,number,of,indexing,threads,runtime,get,runtime,available,processors,final,int,number,of,stats,threads,4,number,of,indexing,threads,final,cyclic,barrier,barrier,new,cyclic,barrier,1,number,of,indexing,threads,number,of,stats,threads,final,atomic,boolean,stop,new,atomic,boolean,final,list,thread,threads,new,array,list,number,of,indexing,threads,number,of,indexing,threads,final,count,down,latch,latch,new,count,down,latch,1,final,atomic,boolean,failed,new,atomic,boolean,final,atomic,reference,list,default,shard,operation,failed,exception,shard,failures,new,atomic,reference,new,copy,on,write,array,list,final,atomic,reference,list,exception,execution,failures,new,atomic,reference,new,copy,on,write,array,list,final,create,index,request,create,index,request,new,create,index,request,test,settings,builder,put,index,10,build,client,admin,indices,create,create,index,request,get,for,int,i,0,i,number,of,indexing,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,while,stop,get,final,string,id,integer,to,string,id,generator,increment,and,get,final,index,response,response,client,prepare,index,test,type,id,set,source,xcontent,type,json,get,assert,that,response,get,result,equal,to,doc,write,response,result,created,thread,set,name,indexing,i,threads,add,thread,thread,start,for,int,i,0,i,number,of,stats,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,final,indices,stats,request,request,new,indices,stats,request,request,all,request,indices,new,string,0,while,stop,get,try,final,indices,stats,response,response,client,admin,indices,stats,request,get,if,response,get,failed,shards,0,failed,set,true,shard,failures,get,add,all,arrays,as,list,response,get,shard,failures,latch,count,down,catch,final,execution,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,thread,set,name,stats,i,threads,add,thread,thread,start,barrier,await,latch,await,15,time,unit,seconds,stop,set,true,for,final,thread,thread,threads,thread,join,assert,that,shard,failures,get,empty,collection,of,default,shard,operation,failed,exception,class,assert,that,execution,failures,get,empty,collection,of,exception,class
IndexStatsIT -> public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException;1536137328;Test that we can safely concurrently index and get stats. This test was inspired by a serialization issue that arose due to a race_getting doc stats during heavy indexing. The race could lead to deleted docs being negative which would then be serialized as a_variable-length long. Since serialization of negative longs using a variable-length format was unsupported_({@link org.elasticsearch.common.io.stream.StreamOutput#writeVLong(long)}), the stream would become corrupted. Here, we want to test_that we can continue to get stats while indexing.;public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException {_        final AtomicInteger idGenerator = new AtomicInteger()__        final int numberOfIndexingThreads = Runtime.getRuntime().availableProcessors()__        final int numberOfStatsThreads = 4 * numberOfIndexingThreads__        final CyclicBarrier barrier = new CyclicBarrier(1 + numberOfIndexingThreads + numberOfStatsThreads)__        final AtomicBoolean stop = new AtomicBoolean()__        final List<Thread> threads = new ArrayList<>(numberOfIndexingThreads + numberOfIndexingThreads)___        final CountDownLatch latch = new CountDownLatch(1)__        final AtomicBoolean failed = new AtomicBoolean()__        final AtomicReference<List<DefaultShardOperationFailedException>> shardFailures =_                new AtomicReference<>(new CopyOnWriteArrayList<>())__        final AtomicReference<List<Exception>> executionFailures = new AtomicReference<>(new CopyOnWriteArrayList<>())___        _        final CreateIndexRequest createIndexRequest =_            new CreateIndexRequest("test", Settings.builder().put("index.number_of_shards", 10).build())__        client().admin().indices().create(createIndexRequest).get()___        _        for (int i = 0_ i < numberOfIndexingThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                while (!stop.get()) {_                    final String id = Integer.toString(idGenerator.incrementAndGet())__                    final IndexResponse response =_                        client()_                            .prepareIndex("test", "type", id)_                            .setSource("{}", XContentType.JSON)_                            .get()__                    assertThat(response.getResult(), equalTo(DocWriteResponse.Result.CREATED))__                }_            })__            thread.setName("indexing-" + i)__            threads.add(thread)__            thread.start()__        }__        _        for (int i = 0_ i < numberOfStatsThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                final IndicesStatsRequest request = new IndicesStatsRequest()__                request.all()__                request.indices(new String[0])__                while (!stop.get()) {_                    try {_                        final IndicesStatsResponse response = client().admin().indices().stats(request).get()__                        if (response.getFailedShards() > 0) {_                            failed.set(true)__                            shardFailures.get().addAll(Arrays.asList(response.getShardFailures()))__                            latch.countDown()__                        }_                    } catch (final ExecutionException | InterruptedException e) {_                        failed.set(true)__                        executionFailures.get().add(e)__                        latch.countDown()__                    }_                }_            })__            thread.setName("stats-" + i)__            threads.add(thread)__            thread.start()__        }__        _        barrier.await()___        _        latch.await(15, TimeUnit.SECONDS)___        _        stop.set(true)__        for (final Thread thread : threads) {_            thread.join()__        }__        assertThat(shardFailures.get(), emptyCollectionOf(DefaultShardOperationFailedException.class))__        assertThat(executionFailures.get(), emptyCollectionOf(Exception.class))__    };test,that,we,can,safely,concurrently,index,and,get,stats,this,test,was,inspired,by,a,serialization,issue,that,arose,due,to,a,race,getting,doc,stats,during,heavy,indexing,the,race,could,lead,to,deleted,docs,being,negative,which,would,then,be,serialized,as,a,variable,length,long,since,serialization,of,negative,longs,using,a,variable,length,format,was,unsupported,link,org,elasticsearch,common,io,stream,stream,output,write,vlong,long,the,stream,would,become,corrupted,here,we,want,to,test,that,we,can,continue,to,get,stats,while,indexing;public,void,test,concurrent,indexing,and,stats,requests,throws,broken,barrier,exception,interrupted,exception,execution,exception,final,atomic,integer,id,generator,new,atomic,integer,final,int,number,of,indexing,threads,runtime,get,runtime,available,processors,final,int,number,of,stats,threads,4,number,of,indexing,threads,final,cyclic,barrier,barrier,new,cyclic,barrier,1,number,of,indexing,threads,number,of,stats,threads,final,atomic,boolean,stop,new,atomic,boolean,final,list,thread,threads,new,array,list,number,of,indexing,threads,number,of,indexing,threads,final,count,down,latch,latch,new,count,down,latch,1,final,atomic,boolean,failed,new,atomic,boolean,final,atomic,reference,list,default,shard,operation,failed,exception,shard,failures,new,atomic,reference,new,copy,on,write,array,list,final,atomic,reference,list,exception,execution,failures,new,atomic,reference,new,copy,on,write,array,list,final,create,index,request,create,index,request,new,create,index,request,test,settings,builder,put,index,10,build,client,admin,indices,create,create,index,request,get,for,int,i,0,i,number,of,indexing,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,while,stop,get,final,string,id,integer,to,string,id,generator,increment,and,get,final,index,response,response,client,prepare,index,test,type,id,set,source,xcontent,type,json,get,assert,that,response,get,result,equal,to,doc,write,response,result,created,thread,set,name,indexing,i,threads,add,thread,thread,start,for,int,i,0,i,number,of,stats,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,final,indices,stats,request,request,new,indices,stats,request,request,all,request,indices,new,string,0,while,stop,get,try,final,indices,stats,response,response,client,admin,indices,stats,request,get,if,response,get,failed,shards,0,failed,set,true,shard,failures,get,add,all,arrays,as,list,response,get,shard,failures,latch,count,down,catch,final,execution,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,thread,set,name,stats,i,threads,add,thread,thread,start,barrier,await,latch,await,15,time,unit,seconds,stop,set,true,for,final,thread,thread,threads,thread,join,assert,that,shard,failures,get,empty,collection,of,default,shard,operation,failed,exception,class,assert,that,execution,failures,get,empty,collection,of,exception,class
IndexStatsIT -> public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException;1542609384;Test that we can safely concurrently index and get stats. This test was inspired by a serialization issue that arose due to a race_getting doc stats during heavy indexing. The race could lead to deleted docs being negative which would then be serialized as a_variable-length long. Since serialization of negative longs using a variable-length format was unsupported_({@link org.elasticsearch.common.io.stream.StreamOutput#writeVLong(long)}), the stream would become corrupted. Here, we want to test_that we can continue to get stats while indexing.;public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException {_        final AtomicInteger idGenerator = new AtomicInteger()__        final int numberOfIndexingThreads = Runtime.getRuntime().availableProcessors()__        final int numberOfStatsThreads = 4 * numberOfIndexingThreads__        final CyclicBarrier barrier = new CyclicBarrier(1 + numberOfIndexingThreads + numberOfStatsThreads)__        final AtomicBoolean stop = new AtomicBoolean()__        final List<Thread> threads = new ArrayList<>(numberOfIndexingThreads + numberOfIndexingThreads)___        final CountDownLatch latch = new CountDownLatch(1)__        final AtomicBoolean failed = new AtomicBoolean()__        final AtomicReference<List<DefaultShardOperationFailedException>> shardFailures =_                new AtomicReference<>(new CopyOnWriteArrayList<>())__        final AtomicReference<List<Exception>> executionFailures = new AtomicReference<>(new CopyOnWriteArrayList<>())___        _        final CreateIndexRequest createIndexRequest =_            new CreateIndexRequest("test", Settings.builder().put("index.number_of_shards", 10).build())__        client().admin().indices().create(createIndexRequest).get()___        _        for (int i = 0_ i < numberOfIndexingThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                while (!stop.get()) {_                    final String id = Integer.toString(idGenerator.incrementAndGet())__                    final IndexResponse response =_                        client()_                            .prepareIndex("test", "type", id)_                            .setSource("{}", XContentType.JSON)_                            .get()__                    assertThat(response.getResult(), equalTo(DocWriteResponse.Result.CREATED))__                }_            })__            thread.setName("indexing-" + i)__            threads.add(thread)__            thread.start()__        }__        _        for (int i = 0_ i < numberOfStatsThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                final IndicesStatsRequest request = new IndicesStatsRequest()__                request.all()__                request.indices(new String[0])__                while (!stop.get()) {_                    try {_                        final IndicesStatsResponse response = client().admin().indices().stats(request).get()__                        if (response.getFailedShards() > 0) {_                            failed.set(true)__                            shardFailures.get().addAll(Arrays.asList(response.getShardFailures()))__                            latch.countDown()__                        }_                    } catch (final ExecutionException | InterruptedException e) {_                        failed.set(true)__                        executionFailures.get().add(e)__                        latch.countDown()__                    }_                }_            })__            thread.setName("stats-" + i)__            threads.add(thread)__            thread.start()__        }__        _        barrier.await()___        _        latch.await(15, TimeUnit.SECONDS)___        _        stop.set(true)__        for (final Thread thread : threads) {_            thread.join()__        }__        assertThat(shardFailures.get(), emptyCollectionOf(DefaultShardOperationFailedException.class))__        assertThat(executionFailures.get(), emptyCollectionOf(Exception.class))__    };test,that,we,can,safely,concurrently,index,and,get,stats,this,test,was,inspired,by,a,serialization,issue,that,arose,due,to,a,race,getting,doc,stats,during,heavy,indexing,the,race,could,lead,to,deleted,docs,being,negative,which,would,then,be,serialized,as,a,variable,length,long,since,serialization,of,negative,longs,using,a,variable,length,format,was,unsupported,link,org,elasticsearch,common,io,stream,stream,output,write,vlong,long,the,stream,would,become,corrupted,here,we,want,to,test,that,we,can,continue,to,get,stats,while,indexing;public,void,test,concurrent,indexing,and,stats,requests,throws,broken,barrier,exception,interrupted,exception,execution,exception,final,atomic,integer,id,generator,new,atomic,integer,final,int,number,of,indexing,threads,runtime,get,runtime,available,processors,final,int,number,of,stats,threads,4,number,of,indexing,threads,final,cyclic,barrier,barrier,new,cyclic,barrier,1,number,of,indexing,threads,number,of,stats,threads,final,atomic,boolean,stop,new,atomic,boolean,final,list,thread,threads,new,array,list,number,of,indexing,threads,number,of,indexing,threads,final,count,down,latch,latch,new,count,down,latch,1,final,atomic,boolean,failed,new,atomic,boolean,final,atomic,reference,list,default,shard,operation,failed,exception,shard,failures,new,atomic,reference,new,copy,on,write,array,list,final,atomic,reference,list,exception,execution,failures,new,atomic,reference,new,copy,on,write,array,list,final,create,index,request,create,index,request,new,create,index,request,test,settings,builder,put,index,10,build,client,admin,indices,create,create,index,request,get,for,int,i,0,i,number,of,indexing,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,while,stop,get,final,string,id,integer,to,string,id,generator,increment,and,get,final,index,response,response,client,prepare,index,test,type,id,set,source,xcontent,type,json,get,assert,that,response,get,result,equal,to,doc,write,response,result,created,thread,set,name,indexing,i,threads,add,thread,thread,start,for,int,i,0,i,number,of,stats,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,final,indices,stats,request,request,new,indices,stats,request,request,all,request,indices,new,string,0,while,stop,get,try,final,indices,stats,response,response,client,admin,indices,stats,request,get,if,response,get,failed,shards,0,failed,set,true,shard,failures,get,add,all,arrays,as,list,response,get,shard,failures,latch,count,down,catch,final,execution,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,thread,set,name,stats,i,threads,add,thread,thread,start,barrier,await,latch,await,15,time,unit,seconds,stop,set,true,for,final,thread,thread,threads,thread,join,assert,that,shard,failures,get,empty,collection,of,default,shard,operation,failed,exception,class,assert,that,execution,failures,get,empty,collection,of,exception,class
IndexStatsIT -> public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException;1543814172;Test that we can safely concurrently index and get stats. This test was inspired by a serialization issue that arose due to a race_getting doc stats during heavy indexing. The race could lead to deleted docs being negative which would then be serialized as a_variable-length long. Since serialization of negative longs using a variable-length format was unsupported_({@link org.elasticsearch.common.io.stream.StreamOutput#writeVLong(long)}), the stream would become corrupted. Here, we want to test_that we can continue to get stats while indexing.;public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException {_        final AtomicInteger idGenerator = new AtomicInteger()__        final int numberOfIndexingThreads = Runtime.getRuntime().availableProcessors()__        final int numberOfStatsThreads = 4 * numberOfIndexingThreads__        final CyclicBarrier barrier = new CyclicBarrier(1 + numberOfIndexingThreads + numberOfStatsThreads)__        final AtomicBoolean stop = new AtomicBoolean()__        final List<Thread> threads = new ArrayList<>(numberOfIndexingThreads + numberOfIndexingThreads)___        final CountDownLatch latch = new CountDownLatch(1)__        final AtomicBoolean failed = new AtomicBoolean()__        final AtomicReference<List<DefaultShardOperationFailedException>> shardFailures =_                new AtomicReference<>(new CopyOnWriteArrayList<>())__        final AtomicReference<List<Exception>> executionFailures = new AtomicReference<>(new CopyOnWriteArrayList<>())___        _        final CreateIndexRequest createIndexRequest =_            new CreateIndexRequest("test", Settings.builder().put("index.number_of_shards", 10).build())__        client().admin().indices().create(createIndexRequest).get()___        _        for (int i = 0_ i < numberOfIndexingThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                while (!stop.get()) {_                    final String id = Integer.toString(idGenerator.incrementAndGet())__                    final IndexResponse response =_                        client()_                            .prepareIndex("test", "type", id)_                            .setSource("{}", XContentType.JSON)_                            .get()__                    assertThat(response.getResult(), equalTo(DocWriteResponse.Result.CREATED))__                }_            })__            thread.setName("indexing-" + i)__            threads.add(thread)__            thread.start()__        }__        _        for (int i = 0_ i < numberOfStatsThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                final IndicesStatsRequest request = new IndicesStatsRequest()__                request.all()__                request.indices(new String[0])__                while (!stop.get()) {_                    try {_                        final IndicesStatsResponse response = client().admin().indices().stats(request).get()__                        if (response.getFailedShards() > 0) {_                            failed.set(true)__                            shardFailures.get().addAll(Arrays.asList(response.getShardFailures()))__                            latch.countDown()__                        }_                    } catch (final ExecutionException | InterruptedException e) {_                        failed.set(true)__                        executionFailures.get().add(e)__                        latch.countDown()__                    }_                }_            })__            thread.setName("stats-" + i)__            threads.add(thread)__            thread.start()__        }__        _        barrier.await()___        _        latch.await(15, TimeUnit.SECONDS)___        _        stop.set(true)__        for (final Thread thread : threads) {_            thread.join()__        }__        assertThat(shardFailures.get(), emptyCollectionOf(DefaultShardOperationFailedException.class))__        assertThat(executionFailures.get(), emptyCollectionOf(Exception.class))__    };test,that,we,can,safely,concurrently,index,and,get,stats,this,test,was,inspired,by,a,serialization,issue,that,arose,due,to,a,race,getting,doc,stats,during,heavy,indexing,the,race,could,lead,to,deleted,docs,being,negative,which,would,then,be,serialized,as,a,variable,length,long,since,serialization,of,negative,longs,using,a,variable,length,format,was,unsupported,link,org,elasticsearch,common,io,stream,stream,output,write,vlong,long,the,stream,would,become,corrupted,here,we,want,to,test,that,we,can,continue,to,get,stats,while,indexing;public,void,test,concurrent,indexing,and,stats,requests,throws,broken,barrier,exception,interrupted,exception,execution,exception,final,atomic,integer,id,generator,new,atomic,integer,final,int,number,of,indexing,threads,runtime,get,runtime,available,processors,final,int,number,of,stats,threads,4,number,of,indexing,threads,final,cyclic,barrier,barrier,new,cyclic,barrier,1,number,of,indexing,threads,number,of,stats,threads,final,atomic,boolean,stop,new,atomic,boolean,final,list,thread,threads,new,array,list,number,of,indexing,threads,number,of,indexing,threads,final,count,down,latch,latch,new,count,down,latch,1,final,atomic,boolean,failed,new,atomic,boolean,final,atomic,reference,list,default,shard,operation,failed,exception,shard,failures,new,atomic,reference,new,copy,on,write,array,list,final,atomic,reference,list,exception,execution,failures,new,atomic,reference,new,copy,on,write,array,list,final,create,index,request,create,index,request,new,create,index,request,test,settings,builder,put,index,10,build,client,admin,indices,create,create,index,request,get,for,int,i,0,i,number,of,indexing,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,while,stop,get,final,string,id,integer,to,string,id,generator,increment,and,get,final,index,response,response,client,prepare,index,test,type,id,set,source,xcontent,type,json,get,assert,that,response,get,result,equal,to,doc,write,response,result,created,thread,set,name,indexing,i,threads,add,thread,thread,start,for,int,i,0,i,number,of,stats,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,final,indices,stats,request,request,new,indices,stats,request,request,all,request,indices,new,string,0,while,stop,get,try,final,indices,stats,response,response,client,admin,indices,stats,request,get,if,response,get,failed,shards,0,failed,set,true,shard,failures,get,add,all,arrays,as,list,response,get,shard,failures,latch,count,down,catch,final,execution,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,thread,set,name,stats,i,threads,add,thread,thread,start,barrier,await,latch,await,15,time,unit,seconds,stop,set,true,for,final,thread,thread,threads,thread,join,assert,that,shard,failures,get,empty,collection,of,default,shard,operation,failed,exception,class,assert,that,execution,failures,get,empty,collection,of,exception,class
IndexStatsIT -> public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException;1544035746;Test that we can safely concurrently index and get stats. This test was inspired by a serialization issue that arose due to a race_getting doc stats during heavy indexing. The race could lead to deleted docs being negative which would then be serialized as a_variable-length long. Since serialization of negative longs using a variable-length format was unsupported_({@link org.elasticsearch.common.io.stream.StreamOutput#writeVLong(long)}), the stream would become corrupted. Here, we want to test_that we can continue to get stats while indexing.;public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException {_        final AtomicInteger idGenerator = new AtomicInteger()__        final int numberOfIndexingThreads = Runtime.getRuntime().availableProcessors()__        final int numberOfStatsThreads = 4 * numberOfIndexingThreads__        final CyclicBarrier barrier = new CyclicBarrier(1 + numberOfIndexingThreads + numberOfStatsThreads)__        final AtomicBoolean stop = new AtomicBoolean()__        final List<Thread> threads = new ArrayList<>(numberOfIndexingThreads + numberOfIndexingThreads)___        final CountDownLatch latch = new CountDownLatch(1)__        final AtomicBoolean failed = new AtomicBoolean()__        final AtomicReference<List<DefaultShardOperationFailedException>> shardFailures =_                new AtomicReference<>(new CopyOnWriteArrayList<>())__        final AtomicReference<List<Exception>> executionFailures = new AtomicReference<>(new CopyOnWriteArrayList<>())___        _        final CreateIndexRequest createIndexRequest =_            new CreateIndexRequest("test", Settings.builder().put("index.number_of_shards", 10).build())__        client().admin().indices().create(createIndexRequest).get()___        _        for (int i = 0_ i < numberOfIndexingThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                while (!stop.get()) {_                    final String id = Integer.toString(idGenerator.incrementAndGet())__                    final IndexResponse response =_                        client()_                            .prepareIndex("test", "type", id)_                            .setSource("{}", XContentType.JSON)_                            .get()__                    assertThat(response.getResult(), equalTo(DocWriteResponse.Result.CREATED))__                }_            })__            thread.setName("indexing-" + i)__            threads.add(thread)__            thread.start()__        }__        _        for (int i = 0_ i < numberOfStatsThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                final IndicesStatsRequest request = new IndicesStatsRequest()__                request.all()__                request.indices(new String[0])__                while (!stop.get()) {_                    try {_                        final IndicesStatsResponse response = client().admin().indices().stats(request).get()__                        if (response.getFailedShards() > 0) {_                            failed.set(true)__                            shardFailures.get().addAll(Arrays.asList(response.getShardFailures()))__                            latch.countDown()__                        }_                    } catch (final ExecutionException | InterruptedException e) {_                        failed.set(true)__                        executionFailures.get().add(e)__                        latch.countDown()__                    }_                }_            })__            thread.setName("stats-" + i)__            threads.add(thread)__            thread.start()__        }__        _        barrier.await()___        _        latch.await(15, TimeUnit.SECONDS)___        _        stop.set(true)__        for (final Thread thread : threads) {_            thread.join()__        }__        assertThat(shardFailures.get(), emptyCollectionOf(DefaultShardOperationFailedException.class))__        assertThat(executionFailures.get(), emptyCollectionOf(Exception.class))__    };test,that,we,can,safely,concurrently,index,and,get,stats,this,test,was,inspired,by,a,serialization,issue,that,arose,due,to,a,race,getting,doc,stats,during,heavy,indexing,the,race,could,lead,to,deleted,docs,being,negative,which,would,then,be,serialized,as,a,variable,length,long,since,serialization,of,negative,longs,using,a,variable,length,format,was,unsupported,link,org,elasticsearch,common,io,stream,stream,output,write,vlong,long,the,stream,would,become,corrupted,here,we,want,to,test,that,we,can,continue,to,get,stats,while,indexing;public,void,test,concurrent,indexing,and,stats,requests,throws,broken,barrier,exception,interrupted,exception,execution,exception,final,atomic,integer,id,generator,new,atomic,integer,final,int,number,of,indexing,threads,runtime,get,runtime,available,processors,final,int,number,of,stats,threads,4,number,of,indexing,threads,final,cyclic,barrier,barrier,new,cyclic,barrier,1,number,of,indexing,threads,number,of,stats,threads,final,atomic,boolean,stop,new,atomic,boolean,final,list,thread,threads,new,array,list,number,of,indexing,threads,number,of,indexing,threads,final,count,down,latch,latch,new,count,down,latch,1,final,atomic,boolean,failed,new,atomic,boolean,final,atomic,reference,list,default,shard,operation,failed,exception,shard,failures,new,atomic,reference,new,copy,on,write,array,list,final,atomic,reference,list,exception,execution,failures,new,atomic,reference,new,copy,on,write,array,list,final,create,index,request,create,index,request,new,create,index,request,test,settings,builder,put,index,10,build,client,admin,indices,create,create,index,request,get,for,int,i,0,i,number,of,indexing,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,while,stop,get,final,string,id,integer,to,string,id,generator,increment,and,get,final,index,response,response,client,prepare,index,test,type,id,set,source,xcontent,type,json,get,assert,that,response,get,result,equal,to,doc,write,response,result,created,thread,set,name,indexing,i,threads,add,thread,thread,start,for,int,i,0,i,number,of,stats,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,final,indices,stats,request,request,new,indices,stats,request,request,all,request,indices,new,string,0,while,stop,get,try,final,indices,stats,response,response,client,admin,indices,stats,request,get,if,response,get,failed,shards,0,failed,set,true,shard,failures,get,add,all,arrays,as,list,response,get,shard,failures,latch,count,down,catch,final,execution,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,thread,set,name,stats,i,threads,add,thread,thread,start,barrier,await,latch,await,15,time,unit,seconds,stop,set,true,for,final,thread,thread,threads,thread,join,assert,that,shard,failures,get,empty,collection,of,default,shard,operation,failed,exception,class,assert,that,execution,failures,get,empty,collection,of,exception,class
IndexStatsIT -> public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException;1545082530;Test that we can safely concurrently index and get stats. This test was inspired by a serialization issue that arose due to a race_getting doc stats during heavy indexing. The race could lead to deleted docs being negative which would then be serialized as a_variable-length long. Since serialization of negative longs using a variable-length format was unsupported_({@link org.elasticsearch.common.io.stream.StreamOutput#writeVLong(long)}), the stream would become corrupted. Here, we want to test_that we can continue to get stats while indexing.;public void testConcurrentIndexingAndStatsRequests() throws BrokenBarrierException, InterruptedException, ExecutionException {_        final AtomicInteger idGenerator = new AtomicInteger()__        final int numberOfIndexingThreads = Runtime.getRuntime().availableProcessors()__        final int numberOfStatsThreads = 4 * numberOfIndexingThreads__        final CyclicBarrier barrier = new CyclicBarrier(1 + numberOfIndexingThreads + numberOfStatsThreads)__        final AtomicBoolean stop = new AtomicBoolean()__        final List<Thread> threads = new ArrayList<>(numberOfIndexingThreads + numberOfIndexingThreads)___        final CountDownLatch latch = new CountDownLatch(1)__        final AtomicBoolean failed = new AtomicBoolean()__        final AtomicReference<List<DefaultShardOperationFailedException>> shardFailures =_                new AtomicReference<>(new CopyOnWriteArrayList<>())__        final AtomicReference<List<Exception>> executionFailures = new AtomicReference<>(new CopyOnWriteArrayList<>())___        _        final CreateIndexRequest createIndexRequest =_            new CreateIndexRequest("test", Settings.builder().put("index.number_of_shards", 10).build())__        client().admin().indices().create(createIndexRequest).get()___        _        for (int i = 0_ i < numberOfIndexingThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                while (!stop.get()) {_                    final String id = Integer.toString(idGenerator.incrementAndGet())__                    final IndexResponse response =_                        client()_                            .prepareIndex("test", "type", id)_                            .setSource("{}", XContentType.JSON)_                            .get()__                    assertThat(response.getResult(), equalTo(DocWriteResponse.Result.CREATED))__                }_            })__            thread.setName("indexing-" + i)__            threads.add(thread)__            thread.start()__        }__        _        for (int i = 0_ i < numberOfStatsThreads_ i++) {_            final Thread thread = new Thread(() -> {_                try {_                    barrier.await()__                } catch (final BrokenBarrierException | InterruptedException e) {_                    failed.set(true)__                    executionFailures.get().add(e)__                    latch.countDown()__                }_                final IndicesStatsRequest request = new IndicesStatsRequest()__                request.all()__                request.indices(new String[0])__                while (!stop.get()) {_                    try {_                        final IndicesStatsResponse response = client().admin().indices().stats(request).get()__                        if (response.getFailedShards() > 0) {_                            failed.set(true)__                            shardFailures.get().addAll(Arrays.asList(response.getShardFailures()))__                            latch.countDown()__                        }_                    } catch (final ExecutionException | InterruptedException e) {_                        failed.set(true)__                        executionFailures.get().add(e)__                        latch.countDown()__                    }_                }_            })__            thread.setName("stats-" + i)__            threads.add(thread)__            thread.start()__        }__        _        barrier.await()___        _        latch.await(15, TimeUnit.SECONDS)___        _        stop.set(true)__        for (final Thread thread : threads) {_            thread.join()__        }__        assertThat(shardFailures.get(), emptyCollectionOf(DefaultShardOperationFailedException.class))__        assertThat(executionFailures.get(), emptyCollectionOf(Exception.class))__    };test,that,we,can,safely,concurrently,index,and,get,stats,this,test,was,inspired,by,a,serialization,issue,that,arose,due,to,a,race,getting,doc,stats,during,heavy,indexing,the,race,could,lead,to,deleted,docs,being,negative,which,would,then,be,serialized,as,a,variable,length,long,since,serialization,of,negative,longs,using,a,variable,length,format,was,unsupported,link,org,elasticsearch,common,io,stream,stream,output,write,vlong,long,the,stream,would,become,corrupted,here,we,want,to,test,that,we,can,continue,to,get,stats,while,indexing;public,void,test,concurrent,indexing,and,stats,requests,throws,broken,barrier,exception,interrupted,exception,execution,exception,final,atomic,integer,id,generator,new,atomic,integer,final,int,number,of,indexing,threads,runtime,get,runtime,available,processors,final,int,number,of,stats,threads,4,number,of,indexing,threads,final,cyclic,barrier,barrier,new,cyclic,barrier,1,number,of,indexing,threads,number,of,stats,threads,final,atomic,boolean,stop,new,atomic,boolean,final,list,thread,threads,new,array,list,number,of,indexing,threads,number,of,indexing,threads,final,count,down,latch,latch,new,count,down,latch,1,final,atomic,boolean,failed,new,atomic,boolean,final,atomic,reference,list,default,shard,operation,failed,exception,shard,failures,new,atomic,reference,new,copy,on,write,array,list,final,atomic,reference,list,exception,execution,failures,new,atomic,reference,new,copy,on,write,array,list,final,create,index,request,create,index,request,new,create,index,request,test,settings,builder,put,index,10,build,client,admin,indices,create,create,index,request,get,for,int,i,0,i,number,of,indexing,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,while,stop,get,final,string,id,integer,to,string,id,generator,increment,and,get,final,index,response,response,client,prepare,index,test,type,id,set,source,xcontent,type,json,get,assert,that,response,get,result,equal,to,doc,write,response,result,created,thread,set,name,indexing,i,threads,add,thread,thread,start,for,int,i,0,i,number,of,stats,threads,i,final,thread,thread,new,thread,try,barrier,await,catch,final,broken,barrier,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,final,indices,stats,request,request,new,indices,stats,request,request,all,request,indices,new,string,0,while,stop,get,try,final,indices,stats,response,response,client,admin,indices,stats,request,get,if,response,get,failed,shards,0,failed,set,true,shard,failures,get,add,all,arrays,as,list,response,get,shard,failures,latch,count,down,catch,final,execution,exception,interrupted,exception,e,failed,set,true,execution,failures,get,add,e,latch,count,down,thread,set,name,stats,i,threads,add,thread,thread,start,barrier,await,latch,await,15,time,unit,seconds,stop,set,true,for,final,thread,thread,threads,thread,join,assert,that,shard,failures,get,empty,collection,of,default,shard,operation,failed,exception,class,assert,that,execution,failures,get,empty,collection,of,exception,class
IndexStatsIT -> private void persistGlobalCheckpoint(String index) throws Exception;1535723122;Persist the global checkpoint on all shards of the given index into disk._This makes sure that the persisted global checkpoint on those shards will equal to the in-memory value.;private void persistGlobalCheckpoint(String index) throws Exception {_        final Set<String> nodes = internalCluster().nodesInclude(index)__        for (String node : nodes) {_            final IndicesService indexServices = internalCluster().getInstance(IndicesService.class, node)__            for (IndexService indexService : indexServices) {_                for (IndexShard indexShard : indexService) {_                    indexShard.sync()__                    assertThat(indexShard.getLastSyncedGlobalCheckpoint(), equalTo(indexShard.getGlobalCheckpoint()))__                }_            }_        }_    };persist,the,global,checkpoint,on,all,shards,of,the,given,index,into,disk,this,makes,sure,that,the,persisted,global,checkpoint,on,those,shards,will,equal,to,the,in,memory,value;private,void,persist,global,checkpoint,string,index,throws,exception,final,set,string,nodes,internal,cluster,nodes,include,index,for,string,node,nodes,final,indices,service,index,services,internal,cluster,get,instance,indices,service,class,node,for,index,service,index,service,index,services,for,index,shard,index,shard,index,service,index,shard,sync,assert,that,index,shard,get,last,synced,global,checkpoint,equal,to,index,shard,get,global,checkpoint
IndexStatsIT -> private void persistGlobalCheckpoint(String index) throws Exception;1536137328;Persist the global checkpoint on all shards of the given index into disk._This makes sure that the persisted global checkpoint on those shards will equal to the in-memory value.;private void persistGlobalCheckpoint(String index) throws Exception {_        final Set<String> nodes = internalCluster().nodesInclude(index)__        for (String node : nodes) {_            final IndicesService indexServices = internalCluster().getInstance(IndicesService.class, node)__            for (IndexService indexService : indexServices) {_                for (IndexShard indexShard : indexService) {_                    indexShard.sync()__                    assertThat(indexShard.getLastSyncedGlobalCheckpoint(), equalTo(indexShard.getGlobalCheckpoint()))__                }_            }_        }_    };persist,the,global,checkpoint,on,all,shards,of,the,given,index,into,disk,this,makes,sure,that,the,persisted,global,checkpoint,on,those,shards,will,equal,to,the,in,memory,value;private,void,persist,global,checkpoint,string,index,throws,exception,final,set,string,nodes,internal,cluster,nodes,include,index,for,string,node,nodes,final,indices,service,index,services,internal,cluster,get,instance,indices,service,class,node,for,index,service,index,service,index,services,for,index,shard,index,shard,index,service,index,shard,sync,assert,that,index,shard,get,last,synced,global,checkpoint,equal,to,index,shard,get,global,checkpoint
IndexStatsIT -> private void persistGlobalCheckpoint(String index) throws Exception;1542609384;Persist the global checkpoint on all shards of the given index into disk._This makes sure that the persisted global checkpoint on those shards will equal to the in-memory value.;private void persistGlobalCheckpoint(String index) throws Exception {_        final Set<String> nodes = internalCluster().nodesInclude(index)__        for (String node : nodes) {_            final IndicesService indexServices = internalCluster().getInstance(IndicesService.class, node)__            for (IndexService indexService : indexServices) {_                for (IndexShard indexShard : indexService) {_                    indexShard.sync()__                    assertThat(indexShard.getLastSyncedGlobalCheckpoint(), equalTo(indexShard.getGlobalCheckpoint()))__                }_            }_        }_    };persist,the,global,checkpoint,on,all,shards,of,the,given,index,into,disk,this,makes,sure,that,the,persisted,global,checkpoint,on,those,shards,will,equal,to,the,in,memory,value;private,void,persist,global,checkpoint,string,index,throws,exception,final,set,string,nodes,internal,cluster,nodes,include,index,for,string,node,nodes,final,indices,service,index,services,internal,cluster,get,instance,indices,service,class,node,for,index,service,index,service,index,services,for,index,shard,index,shard,index,service,index,shard,sync,assert,that,index,shard,get,last,synced,global,checkpoint,equal,to,index,shard,get,global,checkpoint
IndexStatsIT -> private void persistGlobalCheckpoint(String index) throws Exception;1543814172;Persist the global checkpoint on all shards of the given index into disk._This makes sure that the persisted global checkpoint on those shards will equal to the in-memory value.;private void persistGlobalCheckpoint(String index) throws Exception {_        final Set<String> nodes = internalCluster().nodesInclude(index)__        for (String node : nodes) {_            final IndicesService indexServices = internalCluster().getInstance(IndicesService.class, node)__            for (IndexService indexService : indexServices) {_                for (IndexShard indexShard : indexService) {_                    indexShard.sync()__                    assertThat(indexShard.getLastSyncedGlobalCheckpoint(), equalTo(indexShard.getGlobalCheckpoint()))__                }_            }_        }_    };persist,the,global,checkpoint,on,all,shards,of,the,given,index,into,disk,this,makes,sure,that,the,persisted,global,checkpoint,on,those,shards,will,equal,to,the,in,memory,value;private,void,persist,global,checkpoint,string,index,throws,exception,final,set,string,nodes,internal,cluster,nodes,include,index,for,string,node,nodes,final,indices,service,index,services,internal,cluster,get,instance,indices,service,class,node,for,index,service,index,service,index,services,for,index,shard,index,shard,index,service,index,shard,sync,assert,that,index,shard,get,last,synced,global,checkpoint,equal,to,index,shard,get,global,checkpoint
IndexStatsIT -> private void persistGlobalCheckpoint(String index) throws Exception;1544035746;Persist the global checkpoint on all shards of the given index into disk._This makes sure that the persisted global checkpoint on those shards will equal to the in-memory value.;private void persistGlobalCheckpoint(String index) throws Exception {_        final Set<String> nodes = internalCluster().nodesInclude(index)__        for (String node : nodes) {_            final IndicesService indexServices = internalCluster().getInstance(IndicesService.class, node)__            for (IndexService indexService : indexServices) {_                for (IndexShard indexShard : indexService) {_                    indexShard.sync()__                    assertThat(indexShard.getLastSyncedGlobalCheckpoint(), equalTo(indexShard.getGlobalCheckpoint()))__                }_            }_        }_    };persist,the,global,checkpoint,on,all,shards,of,the,given,index,into,disk,this,makes,sure,that,the,persisted,global,checkpoint,on,those,shards,will,equal,to,the,in,memory,value;private,void,persist,global,checkpoint,string,index,throws,exception,final,set,string,nodes,internal,cluster,nodes,include,index,for,string,node,nodes,final,indices,service,index,services,internal,cluster,get,instance,indices,service,class,node,for,index,service,index,service,index,services,for,index,shard,index,shard,index,service,index,shard,sync,assert,that,index,shard,get,last,synced,global,checkpoint,equal,to,index,shard,get,global,checkpoint
IndexStatsIT -> private void persistGlobalCheckpoint(String index) throws Exception;1545082530;Persist the global checkpoint on all shards of the given index into disk._This makes sure that the persisted global checkpoint on those shards will equal to the in-memory value.;private void persistGlobalCheckpoint(String index) throws Exception {_        final Set<String> nodes = internalCluster().nodesInclude(index)__        for (String node : nodes) {_            final IndicesService indexServices = internalCluster().getInstance(IndicesService.class, node)__            for (IndexService indexService : indexServices) {_                for (IndexShard indexShard : indexService) {_                    indexShard.sync()__                    assertThat(indexShard.getLastSyncedGlobalCheckpoint(), equalTo(indexShard.getGlobalCheckpoint()))__                }_            }_        }_    };persist,the,global,checkpoint,on,all,shards,of,the,given,index,into,disk,this,makes,sure,that,the,persisted,global,checkpoint,on,those,shards,will,equal,to,the,in,memory,value;private,void,persist,global,checkpoint,string,index,throws,exception,final,set,string,nodes,internal,cluster,nodes,include,index,for,string,node,nodes,final,indices,service,index,services,internal,cluster,get,instance,indices,service,class,node,for,index,service,index,service,index,services,for,index,shard,index,shard,index,service,index,shard,sync,assert,that,index,shard,get,last,synced,global,checkpoint,equal,to,index,shard,get,global,checkpoint
