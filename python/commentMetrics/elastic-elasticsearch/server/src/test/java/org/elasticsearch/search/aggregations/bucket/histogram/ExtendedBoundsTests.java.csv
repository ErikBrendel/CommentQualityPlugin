commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;7;/**  * Construct a random {@link ExtendedBounds}.  */ ;/**  * Construct a random {@link ExtendedBounds}.  */ public static ExtendedBounds randomExtendedBounds() {     ExtendedBounds bounds = randomParsedExtendedBounds().     if (randomBoolean()) {         bounds = unparsed(bounds).     }     return bounds. }
true;public,static;0;19;/**  * Construct a random {@link ExtendedBounds} in pre-parsed form.  */ ;/**  * Construct a random {@link ExtendedBounds} in pre-parsed form.  */ public static ExtendedBounds randomParsedExtendedBounds() {     // end of year 9999     long maxDateValue = 253402300799999L.     // beginning of year -9999     long minDateValue = -377705116800000L.     if (randomBoolean()) {         // Construct with one missing bound         if (randomBoolean()) {             return new ExtendedBounds(null, maxDateValue).         }         return new ExtendedBounds(minDateValue, null).     }     long a = randomLongBetween(minDateValue, maxDateValue).     long b.     do {         b = randomLongBetween(minDateValue, maxDateValue).     } while (a == b).     long min = min(a, b).     long max = max(a, b).     return new ExtendedBounds(min, max). }
true;public,static;1;7;/**  * Convert an extended bounds in parsed for into one in unparsed form.  */ ;/**  * Convert an extended bounds in parsed for into one in unparsed form.  */ public static ExtendedBounds unparsed(ExtendedBounds template) {     // It'd probably be better to randomize the formatter     DateFormatter formatter = DateFormatter.forPattern("strict_date_time").withZone(ZoneOffset.UTC).     String minAsStr = template.getMin() == null ? null : formatter.formatMillis(template.getMin()).     String maxAsStr = template.getMax() == null ? null : formatter.formatMillis(template.getMax()).     return new ExtendedBounds(minAsStr, maxAsStr). }
false;public;0;36;;public void testParseAndValidate() {     long now = randomLong().     Settings indexSettings = Settings.builder().put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1).put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).build().     SearchContext context = mock(SearchContext.class).     QueryShardContext qsc = new QueryShardContext(0, new IndexSettings(IndexMetaData.builder("foo").settings(indexSettings).build(), indexSettings), null, null, null, null, null, xContentRegistry(), writableRegistry(), null, null, () -> now, null).     when(context.getQueryShardContext()).thenReturn(qsc).     DateFormatter formatter = DateFormatter.forPattern("dateOptionalTime").     DocValueFormat format = new DocValueFormat.DateTime(formatter, ZoneOffset.UTC, DateFieldMapper.Resolution.MILLISECONDS).     ExtendedBounds expected = randomParsedExtendedBounds().     ExtendedBounds parsed = unparsed(expected).parseAndValidate("test", context, format).     // parsed won't *equal* expected because equal includes the String parts     assertEquals(expected.getMin(), parsed.getMin()).     assertEquals(expected.getMax(), parsed.getMax()).     parsed = new ExtendedBounds("now", null).parseAndValidate("test", context, format).     assertEquals(now, (long) parsed.getMin()).     assertNull(parsed.getMax()).     parsed = new ExtendedBounds(null, "now").parseAndValidate("test", context, format).     assertNull(parsed.getMin()).     assertEquals(now, (long) parsed.getMax()).     SearchParseException e = expectThrows(SearchParseException.class, () -> new ExtendedBounds(100L, 90L).parseAndValidate("test", context, format)).     assertEquals("[extended_bounds.min][100] cannot be greater than [extended_bounds.max][90] for histogram aggregation [test]", e.getMessage()).     e = expectThrows(SearchParseException.class, () -> unparsed(new ExtendedBounds(100L, 90L)).parseAndValidate("test", context, format)).     assertEquals("[extended_bounds.min][100] cannot be greater than [extended_bounds.max][90] for histogram aggregation [test]", e.getMessage()). }
false;public;0;24;;public void testTransportRoundTrip() throws IOException {     ExtendedBounds orig = randomExtendedBounds().     BytesReference origBytes.     try (BytesStreamOutput out = new BytesStreamOutput()) {         orig.writeTo(out).         origBytes = out.bytes().     }     ExtendedBounds read.     try (StreamInput in = origBytes.streamInput()) {         read = new ExtendedBounds(in).         assertEquals("read fully", 0, in.available()).     }     assertEquals(orig, read).     BytesReference readBytes.     try (BytesStreamOutput out = new BytesStreamOutput()) {         read.writeTo(out).         readBytes = out.bytes().     }     assertEquals(origBytes, readBytes). }
false;public;0;26;;public void testXContentRoundTrip() throws Exception {     ExtendedBounds orig = randomExtendedBounds().     try (XContentBuilder out = JsonXContent.contentBuilder()) {         out.startObject().         orig.toXContent(out, ToXContent.EMPTY_PARAMS).         out.endObject().         try (XContentParser in = createParser(JsonXContent.jsonXContent, BytesReference.bytes(out))) {             XContentParser.Token token = in.currentToken().             assertNull(token).             token = in.nextToken().             assertThat(token, equalTo(XContentParser.Token.START_OBJECT)).             token = in.nextToken().             assertThat(token, equalTo(XContentParser.Token.FIELD_NAME)).             assertThat(in.currentName(), equalTo(ExtendedBounds.EXTENDED_BOUNDS_FIELD.getPreferredName())).             ExtendedBounds read = ExtendedBounds.PARSER.apply(in, null).             assertEquals(orig, read).         } catch (Exception e) {             throw new Exception("Error parsing [" + BytesReference.bytes(out).utf8ToString() + "]", e).         }     } }
