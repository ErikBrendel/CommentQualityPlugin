commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public List<ActionFilter> getActionFilters() {     return singletonList(blockingActionFilter). }
false;protected;3;7;;@Override protected boolean apply(String action, ActionRequest request, ActionListener<?> listener) {     if (blockedActions.contains(action)) {         throw new ElasticsearchException("force exception on [" + action + "]").     }     return true. }
false;public;0;4;;@Override public int order() {     return 0. }
false;public;1;3;;public void blockActions(String... actions) {     blockedActions = unmodifiableSet(newHashSet(actions)). }
false;protected;1;8;;@Override protected Settings nodeSettings(int nodeOrdinal) {     return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put(NodeEnvironment.MAX_LOCAL_STORAGE_NODES_SETTING.getKey(), 2).build(). }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return Arrays.asList(TestPlugin.class, MockTransportService.TestPlugin.class). }
false;private;1;4;;private void setClusterInfoTimeout(String timeValue) {     assertAcked(client().admin().cluster().prepareUpdateSettings().setTransientSettings(Settings.builder().put(InternalClusterInfoService.INTERNAL_CLUSTER_INFO_TIMEOUT_SETTING.getKey(), timeValue).build())). }
false;public;0;47;;public void testClusterInfoServiceCollectsInformation() throws Exception {     internalCluster().startNodes(2).     assertAcked(prepareCreate("test").setSettings(Settings.builder().put(Store.INDEX_STORE_STATS_REFRESH_INTERVAL_SETTING.getKey(), 0).put(EnableAllocationDecider.INDEX_ROUTING_REBALANCE_ENABLE_SETTING.getKey(), EnableAllocationDecider.Rebalance.NONE).build())).     ensureGreen("test").     InternalTestCluster internalTestCluster = internalCluster().     // Get the cluster info service on the master node     final InternalClusterInfoService infoService = (InternalClusterInfoService) internalTestCluster.getInstance(ClusterInfoService.class, internalTestCluster.getMasterName()).     infoService.setUpdateFrequency(TimeValue.timeValueMillis(200)).     infoService.onMaster().     ClusterInfo info = infoService.refresh().     assertNotNull("info should not be null", info).     ImmutableOpenMap<String, DiskUsage> leastUsages = info.getNodeLeastAvailableDiskUsages().     ImmutableOpenMap<String, DiskUsage> mostUsages = info.getNodeMostAvailableDiskUsages().     ImmutableOpenMap<String, Long> shardSizes = info.shardSizes.     assertNotNull(leastUsages).     assertNotNull(shardSizes).     assertThat("some usages are populated", leastUsages.values().size(), Matchers.equalTo(2)).     assertThat("some shard sizes are populated", shardSizes.values().size(), greaterThan(0)).     for (ObjectCursor<DiskUsage> usage : leastUsages.values()) {         logger.info("--> usage: {}", usage.value).         assertThat("usage has be retrieved", usage.value.getFreeBytes(), greaterThan(0L)).     }     for (ObjectCursor<DiskUsage> usage : mostUsages.values()) {         logger.info("--> usage: {}", usage.value).         assertThat("usage has be retrieved", usage.value.getFreeBytes(), greaterThan(0L)).     }     for (ObjectCursor<Long> size : shardSizes.values()) {         logger.info("--> shard size: {}", size.value).         assertThat("shard size is greater than 0", size.value, greaterThanOrEqualTo(0L)).     }     ClusterService clusterService = internalTestCluster.getInstance(ClusterService.class, internalTestCluster.getMasterName()).     ClusterState state = clusterService.state().     for (ShardRouting shard : state.routingTable().allShards()) {         String dataPath = info.getDataPath(shard).         assertNotNull(dataPath).         String nodeId = shard.currentNodeId().         DiscoveryNode discoveryNode = state.getNodes().get(nodeId).         IndicesService indicesService = internalTestCluster.getInstance(IndicesService.class, discoveryNode.getName()).         IndexService indexService = indicesService.indexService(shard.index()).         IndexShard indexShard = indexService.getShardOrNull(shard.id()).         assertEquals(indexShard.shardPath().getRootDataPath().toString(), dataPath).     } }
false;public;0;78;;public void testClusterInfoServiceInformationClearOnError() {     internalCluster().startNodes(2, // manually control publishing     Settings.builder().put(InternalClusterInfoService.INTERNAL_CLUSTER_INFO_UPDATE_INTERVAL_SETTING.getKey(), "60m").build()).     prepareCreate("test").setSettings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1)).get().     ensureGreen("test").     InternalTestCluster internalTestCluster = internalCluster().     InternalClusterInfoService infoService = (InternalClusterInfoService) internalTestCluster.getInstance(ClusterInfoService.class, internalTestCluster.getMasterName()).     // get one healthy sample     ClusterInfo info = infoService.refresh().     assertNotNull("failed to collect info", info).     assertThat("some usages are populated", info.getNodeLeastAvailableDiskUsages().size(), Matchers.equalTo(2)).     assertThat("some shard sizes are populated", info.shardSizes.size(), greaterThan(0)).     MockTransportService mockTransportService = (MockTransportService) internalCluster().getInstance(TransportService.class, internalTestCluster.getMasterName()).     final AtomicBoolean timeout = new AtomicBoolean(false).     final Set<String> blockedActions = newHashSet(NodesStatsAction.NAME, NodesStatsAction.NAME + "[n]", IndicesStatsAction.NAME, IndicesStatsAction.NAME + "[n]").     // drop all outgoing stats requests to force a timeout.     for (DiscoveryNode node : internalTestCluster.clusterService().state().getNodes()) {         mockTransportService.addSendBehavior(internalTestCluster.getInstance(TransportService.class, node.getName()), (connection, requestId, action, request, options) -> {             if (blockedActions.contains(action)) {                 if (timeout.get()) {                     logger.info("dropping [{}] to [{}]", action, node).                     return.                 }             }             connection.sendRequest(requestId, action, request, options).         }).     }     setClusterInfoTimeout("1s").     // timeouts shouldn't clear the info     timeout.set(true).     info = infoService.refresh().     assertNotNull("info should not be null", info).     // node info will time out both on the request level on the count down latch. this means     // it is likely to update the node disk usage based on the one response that came be from local     // node.     assertThat(info.getNodeLeastAvailableDiskUsages().size(), greaterThanOrEqualTo(1)).     assertThat(info.getNodeMostAvailableDiskUsages().size(), greaterThanOrEqualTo(1)).     // indices is guaranteed to time out on the latch, not updating anything.     assertThat(info.shardSizes.size(), greaterThan(1)).     // now we cause an exception     timeout.set(false).     ActionFilters actionFilters = internalTestCluster.getInstance(ActionFilters.class, internalTestCluster.getMasterName()).     BlockingActionFilter blockingActionFilter = null.     for (ActionFilter filter : actionFilters.filters()) {         if (filter instanceof BlockingActionFilter) {             blockingActionFilter = (BlockingActionFilter) filter.             break.         }     }     assertNotNull("failed to find BlockingActionFilter", blockingActionFilter).     blockingActionFilter.blockActions(blockedActions.toArray(Strings.EMPTY_ARRAY)).     info = infoService.refresh().     assertNotNull("info should not be null", info).     assertThat(info.getNodeLeastAvailableDiskUsages().size(), equalTo(0)).     assertThat(info.getNodeMostAvailableDiskUsages().size(), equalTo(0)).     assertThat(info.shardSizes.size(), equalTo(0)).     // check we recover     blockingActionFilter.blockActions().     setClusterInfoTimeout("15s").     info = infoService.refresh().     assertNotNull("info should not be null", info).     assertThat(info.getNodeLeastAvailableDiskUsages().size(), equalTo(2)).     assertThat(info.getNodeMostAvailableDiskUsages().size(), equalTo(2)).     assertThat(info.shardSizes.size(), greaterThan(0)). }
