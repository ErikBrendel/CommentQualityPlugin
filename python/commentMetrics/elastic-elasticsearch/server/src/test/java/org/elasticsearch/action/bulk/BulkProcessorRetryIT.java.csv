commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;13;;@Override protected Settings nodeSettings(int nodeOrdinal) {     // Have very low pool and queue sizes to overwhelm internal pools easily     return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put("thread_pool.get.queue_size", 1).put("thread_pool.write.queue_size", 30).build(). }
false;public;0;4;;public void testBulkRejectionLoadWithoutBackoff() throws Throwable {     boolean rejectedExecutionExpected = true.     executeBulkRejectionLoad(BackoffPolicy.noBackoff(), rejectedExecutionExpected). }
false;public;0;4;;public void testBulkRejectionLoadWithBackoff() throws Throwable {     boolean rejectedExecutionExpected = false.     executeBulkRejectionLoad(BackoffPolicy.exponentialBackoff(), rejectedExecutionExpected). }
false;public;2;4;;@Override public void beforeBulk(long executionId, BulkRequest request) { // no op }
false;public;3;6;;@Override public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {     internalPolicy.logResponse(response).     responses.add(response).     latch.countDown(). }
false;public;3;5;;@Override public void afterBulk(long executionId, BulkRequest request, Throwable failure) {     responses.add(failure).     latch.countDown(). }
false;private;2;88;;private void executeBulkRejectionLoad(BackoffPolicy backoffPolicy, boolean rejectedExecutionExpected) throws Throwable {     final CorrelatingBackoffPolicy internalPolicy = new CorrelatingBackoffPolicy(backoffPolicy).     int numberOfAsyncOps = randomIntBetween(600, 700).     final CountDownLatch latch = new CountDownLatch(numberOfAsyncOps).     final Set<Object> responses = Collections.newSetFromMap(new ConcurrentHashMap<>()).     assertAcked(prepareCreate(INDEX_NAME)).     ensureGreen().     BulkProcessor bulkProcessor = BulkProcessor.builder(client(), new BulkProcessor.Listener() {          @Override         public void beforeBulk(long executionId, BulkRequest request) {         // no op         }          @Override         public void afterBulk(long executionId, BulkRequest request, BulkResponse response) {             internalPolicy.logResponse(response).             responses.add(response).             latch.countDown().         }          @Override         public void afterBulk(long executionId, BulkRequest request, Throwable failure) {             responses.add(failure).             latch.countDown().         }     }).setBulkActions(1).setConcurrentRequests(randomIntBetween(0, 100)).setBackoffPolicy(internalPolicy).build().     indexDocs(bulkProcessor, numberOfAsyncOps).     latch.await(10, TimeUnit.SECONDS).     bulkProcessor.close().     assertThat(responses.size(), equalTo(numberOfAsyncOps)).     // validate all responses     boolean rejectedAfterAllRetries = false.     for (Object response : responses) {         if (response instanceof BulkResponse) {             BulkResponse bulkResponse = (BulkResponse) response.             for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {                 if (bulkItemResponse.isFailed()) {                     BulkItemResponse.Failure failure = bulkItemResponse.getFailure().                     if (failure.getStatus() == RestStatus.TOO_MANY_REQUESTS) {                         if (rejectedExecutionExpected == false) {                             Iterator<TimeValue> backoffState = internalPolicy.backoffStateFor(bulkResponse).                             assertNotNull("backoffState is null (indicates a bulk request got rejected without retry)", backoffState).                             if (backoffState.hasNext()) {                                 // we're not expecting that we overwhelmed it even once when we maxed out the number of retries                                 throw new AssertionError("Got rejected although backoff policy would allow more retries", failure.getCause()).                             } else {                                 rejectedAfterAllRetries = true.                                 logger.debug("We maxed out the number of bulk retries and got rejected (this is ok).").                             }                         }                     } else {                         throw new AssertionError("Unexpected failure status: " + failure.getStatus()).                     }                 }             }         } else {             Throwable t = (Throwable) response.             // we're not expecting any other errors             throw new AssertionError("Unexpected failure", t).         }     }     client().admin().indices().refresh(new RefreshRequest()).get().     SearchResponse results = client().prepareSearch(INDEX_NAME).setTypes(TYPE_NAME).setQuery(QueryBuilders.matchAllQuery()).setSize(0).get().     if (rejectedExecutionExpected) {         assertThat((int) results.getHits().getTotalHits().value, lessThanOrEqualTo(numberOfAsyncOps)).     } else if (rejectedAfterAllRetries) {         assertThat((int) results.getHits().getTotalHits().value, lessThan(numberOfAsyncOps)).     } else {         assertThat((int) results.getHits().getTotalHits().value, equalTo(numberOfAsyncOps)).     } }
false;private,static;2;11;;private static void indexDocs(BulkProcessor processor, int numDocs) {     for (int i = 1. i <= numDocs. i++) {         processor.add(client().prepareIndex().setIndex(INDEX_NAME).setType(TYPE_NAME).setId(Integer.toString(i)).setSource("field", randomRealisticUnicodeOfLengthBetween(1, 30)).request()).     } }
false;public;1;3;;public Iterator<TimeValue> backoffStateFor(BulkResponse response) {     return correlations.get(response). }
true;public;1;9;// see also Retry.AbstractRetryHandler#onResponse(). ;// Assumption: This method is called from the same thread as the last call to the internal iterator's #hasNext() / #next() // see also Retry.AbstractRetryHandler#onResponse(). public void logResponse(BulkResponse response) {     Iterator<TimeValue> iterator = iterators.get().     // did we ever retry?     if (iterator != null) {         // we should correlate any iterator only once         iterators.remove().         correlations.put(response, iterator).     } }
false;public;0;4;;@Override public Iterator<TimeValue> iterator() {     return new CorrelatingIterator(iterators, delegate.iterator()). }
false;public;0;8;;@Override public boolean hasNext() {     // update on every invocation as we might get rescheduled on a different thread. Unfortunately, there is a chance that     // we pollute the thread local map with stale values. Due to the implementation of Retry and the life cycle of the     // enclosing class CorrelatingBackoffPolicy this should not pose a major problem though.     iterators.set(this).     return delegate.hasNext(). }
false;public;0;6;;@Override public TimeValue next() {     // update on every invocation     iterators.set(this).     return delegate.next(). }
