commented;modifiers;parameterAmount;loc;comment;code
false;;3;31;;@Override void sendExecuteMultiSearch(MultiSearchRequest request, SearchTask task, ActionListener<MultiSearchResponse> listener) {     assertTrue(executedMultiSearch.compareAndSet(false, true)).     assertEquals(numInnerHits, request.requests().size()).     SearchRequest searchRequest = request.requests().get(0).     assertTrue(searchRequest.source().query() instanceof BoolQueryBuilder).     BoolQueryBuilder groupBuilder = (BoolQueryBuilder) searchRequest.source().query().     if (collapseValue == null) {         assertThat(groupBuilder.mustNot(), Matchers.contains(QueryBuilders.existsQuery("someField"))).     } else {         assertThat(groupBuilder.filter(), Matchers.contains(QueryBuilders.matchQuery("someField", "boom"))).     }     if (originalQuery != null) {         assertThat(groupBuilder.must(), Matchers.contains(QueryBuilders.termQuery("foo", "bar"))).     }     assertArrayEquals(mockSearchPhaseContext.getRequest().indices(), searchRequest.indices()).     assertArrayEquals(mockSearchPhaseContext.getRequest().types(), searchRequest.types()).     List<MultiSearchResponse.Item> mSearchResponses = new ArrayList<>(numInnerHits).     for (int innerHitNum = 0. innerHitNum < numInnerHits. innerHitNum++) {         InternalSearchResponse internalSearchResponse = new InternalSearchResponse(collapsedHits.get(innerHitNum), null, null, null, false, null, 1).         SearchResponse response = mockSearchPhaseContext.buildSearchResponse(internalSearchResponse, null).         mSearchResponses.add(new MultiSearchResponse.Item(response, null)).     }     listener.onResponse(new MultiSearchResponse(mSearchResponses.toArray(new MultiSearchResponse.Item[0]), randomIntBetween(1, 10000))). }
false;public;0;4;;@Override public void run() throws IOException {     reference.set(mockSearchPhaseContext.buildSearchResponse(r, null)). }
false;public;0;85;;public void testCollapseSingleHit() throws IOException {     final int iters = randomIntBetween(5, 10).     for (int i = 0. i < iters. i++) {         final int numInnerHits = randomIntBetween(1, 5).         List<SearchHits> collapsedHits = new ArrayList<>(numInnerHits).         for (int innerHitNum = 0. innerHitNum < numInnerHits. innerHitNum++) {             SearchHits hits = new SearchHits(new SearchHit[] { new SearchHit(innerHitNum, "ID", new Text("type"), Collections.emptyMap()), new SearchHit(innerHitNum + 1, "ID", new Text("type"), Collections.emptyMap()) }, new TotalHits(2, TotalHits.Relation.EQUAL_TO), 1.0F).             collapsedHits.add(hits).         }         AtomicBoolean executedMultiSearch = new AtomicBoolean(false).         QueryBuilder originalQuery = randomBoolean() ? null : QueryBuilders.termQuery("foo", "bar").         final MockSearchPhaseContext mockSearchPhaseContext = new MockSearchPhaseContext(1).         String collapseValue = randomBoolean() ? null : "boom".         mockSearchPhaseContext.getRequest().source(new SearchSourceBuilder().collapse(new CollapseBuilder("someField").setInnerHits(IntStream.range(0, numInnerHits).mapToObj(hitNum -> new InnerHitBuilder().setName("innerHit" + hitNum)).collect(Collectors.toList())))).         mockSearchPhaseContext.getRequest().source().query(originalQuery).         mockSearchPhaseContext.searchTransport = new SearchTransportService(null, null) {              @Override             void sendExecuteMultiSearch(MultiSearchRequest request, SearchTask task, ActionListener<MultiSearchResponse> listener) {                 assertTrue(executedMultiSearch.compareAndSet(false, true)).                 assertEquals(numInnerHits, request.requests().size()).                 SearchRequest searchRequest = request.requests().get(0).                 assertTrue(searchRequest.source().query() instanceof BoolQueryBuilder).                 BoolQueryBuilder groupBuilder = (BoolQueryBuilder) searchRequest.source().query().                 if (collapseValue == null) {                     assertThat(groupBuilder.mustNot(), Matchers.contains(QueryBuilders.existsQuery("someField"))).                 } else {                     assertThat(groupBuilder.filter(), Matchers.contains(QueryBuilders.matchQuery("someField", "boom"))).                 }                 if (originalQuery != null) {                     assertThat(groupBuilder.must(), Matchers.contains(QueryBuilders.termQuery("foo", "bar"))).                 }                 assertArrayEquals(mockSearchPhaseContext.getRequest().indices(), searchRequest.indices()).                 assertArrayEquals(mockSearchPhaseContext.getRequest().types(), searchRequest.types()).                 List<MultiSearchResponse.Item> mSearchResponses = new ArrayList<>(numInnerHits).                 for (int innerHitNum = 0. innerHitNum < numInnerHits. innerHitNum++) {                     InternalSearchResponse internalSearchResponse = new InternalSearchResponse(collapsedHits.get(innerHitNum), null, null, null, false, null, 1).                     SearchResponse response = mockSearchPhaseContext.buildSearchResponse(internalSearchResponse, null).                     mSearchResponses.add(new MultiSearchResponse.Item(response, null)).                 }                 listener.onResponse(new MultiSearchResponse(mSearchResponses.toArray(new MultiSearchResponse.Item[0]), randomIntBetween(1, 10000))).             }         }.         SearchHits hits = new SearchHits(new SearchHit[] { new SearchHit(1, "ID", new Text("type"), Collections.singletonMap("someField", new DocumentField("someField", Collections.singletonList(collapseValue)))) }, new TotalHits(1, TotalHits.Relation.EQUAL_TO), 1.0F).         InternalSearchResponse internalSearchResponse = new InternalSearchResponse(hits, null, null, null, false, null, 1).         AtomicReference<SearchResponse> reference = new AtomicReference<>().         ExpandSearchPhase phase = new ExpandSearchPhase(mockSearchPhaseContext, internalSearchResponse, (r) -> new SearchPhase("test") {              @Override             public void run() throws IOException {                 reference.set(mockSearchPhaseContext.buildSearchResponse(r, null)).             }         }).         phase.run().         mockSearchPhaseContext.assertNoFailure().         assertNotNull(reference.get()).         SearchResponse theResponse = reference.get().         assertEquals(numInnerHits, theResponse.getHits().getHits()[0].getInnerHits().size()).         for (int innerHitNum = 0. innerHitNum < numInnerHits. innerHitNum++) {             assertSame(theResponse.getHits().getHits()[0].getInnerHits().get("innerHit" + innerHitNum), collapsedHits.get(innerHitNum)).         }         assertTrue(executedMultiSearch.get()).         assertEquals(1, mockSearchPhaseContext.phasesExecuted.get()).     } }
false;;3;12;;@Override void sendExecuteMultiSearch(MultiSearchRequest request, SearchTask task, ActionListener<MultiSearchResponse> listener) {     assertTrue(executedMultiSearch.compareAndSet(false, true)).     InternalSearchResponse internalSearchResponse = new InternalSearchResponse(collapsedHits, null, null, null, false, null, 1).     SearchResponse response = mockSearchPhaseContext.buildSearchResponse(internalSearchResponse, null).     listener.onResponse(new MultiSearchResponse(new MultiSearchResponse.Item[] { new MultiSearchResponse.Item(null, new RuntimeException("boom")), new MultiSearchResponse.Item(response, null) }, randomIntBetween(1, 10000))). }
false;public;0;4;;@Override public void run() throws IOException {     reference.set(mockSearchPhaseContext.buildSearchResponse(r, null)). }
false;public;0;47;;public void testFailOneItemFailsEntirePhase() throws IOException {     AtomicBoolean executedMultiSearch = new AtomicBoolean(false).     SearchHits collapsedHits = new SearchHits(new SearchHit[] { new SearchHit(2, "ID", new Text("type"), Collections.emptyMap()), new SearchHit(3, "ID", new Text("type"), Collections.emptyMap()) }, new TotalHits(1, TotalHits.Relation.EQUAL_TO), 1.0F).     MockSearchPhaseContext mockSearchPhaseContext = new MockSearchPhaseContext(1).     String collapseValue = randomBoolean() ? null : "boom".     mockSearchPhaseContext.getRequest().source(new SearchSourceBuilder().collapse(new CollapseBuilder("someField").setInnerHits(new InnerHitBuilder().setName("foobarbaz")))).     mockSearchPhaseContext.searchTransport = new SearchTransportService(null, null) {          @Override         void sendExecuteMultiSearch(MultiSearchRequest request, SearchTask task, ActionListener<MultiSearchResponse> listener) {             assertTrue(executedMultiSearch.compareAndSet(false, true)).             InternalSearchResponse internalSearchResponse = new InternalSearchResponse(collapsedHits, null, null, null, false, null, 1).             SearchResponse response = mockSearchPhaseContext.buildSearchResponse(internalSearchResponse, null).             listener.onResponse(new MultiSearchResponse(new MultiSearchResponse.Item[] { new MultiSearchResponse.Item(null, new RuntimeException("boom")), new MultiSearchResponse.Item(response, null) }, randomIntBetween(1, 10000))).         }     }.     SearchHits hits = new SearchHits(new SearchHit[] { new SearchHit(1, "ID", new Text("type"), Collections.singletonMap("someField", new DocumentField("someField", Collections.singletonList(collapseValue)))), new SearchHit(2, "ID2", new Text("type"), Collections.singletonMap("someField", new DocumentField("someField", Collections.singletonList(collapseValue)))) }, new TotalHits(1, TotalHits.Relation.EQUAL_TO), 1.0F).     InternalSearchResponse internalSearchResponse = new InternalSearchResponse(hits, null, null, null, false, null, 1).     AtomicReference<SearchResponse> reference = new AtomicReference<>().     ExpandSearchPhase phase = new ExpandSearchPhase(mockSearchPhaseContext, internalSearchResponse, r -> new SearchPhase("test") {          @Override         public void run() throws IOException {             reference.set(mockSearchPhaseContext.buildSearchResponse(r, null)).         }     }).     phase.run().     assertThat(mockSearchPhaseContext.phaseFailure.get(), Matchers.instanceOf(RuntimeException.class)).     assertEquals("boom", mockSearchPhaseContext.phaseFailure.get().getMessage()).     assertNotNull(mockSearchPhaseContext.phaseFailure.get()).     assertNull(reference.get()).     assertEquals(0, mockSearchPhaseContext.phasesExecuted.get()). }
false;;3;4;;@Override void sendExecuteMultiSearch(MultiSearchRequest request, SearchTask task, ActionListener<MultiSearchResponse> listener) {     fail("no collapsing here"). }
false;public;0;4;;@Override public void run() throws IOException {     reference.set(mockSearchPhaseContext.buildSearchResponse(r, null)). }
false;public;0;29;;public void testSkipPhase() throws IOException {     MockSearchPhaseContext mockSearchPhaseContext = new MockSearchPhaseContext(1).     mockSearchPhaseContext.searchTransport = new SearchTransportService(null, null) {          @Override         void sendExecuteMultiSearch(MultiSearchRequest request, SearchTask task, ActionListener<MultiSearchResponse> listener) {             fail("no collapsing here").         }     }.     SearchHits hits = new SearchHits(new SearchHit[] { new SearchHit(1, "ID", new Text("type"), Collections.singletonMap("someField", new DocumentField("someField", Collections.singletonList(null)))), new SearchHit(2, "ID2", new Text("type"), Collections.singletonMap("someField", new DocumentField("someField", Collections.singletonList(null)))) }, new TotalHits(1, TotalHits.Relation.EQUAL_TO), 1.0F).     InternalSearchResponse internalSearchResponse = new InternalSearchResponse(hits, null, null, null, false, null, 1).     AtomicReference<SearchResponse> reference = new AtomicReference<>().     ExpandSearchPhase phase = new ExpandSearchPhase(mockSearchPhaseContext, internalSearchResponse, r -> new SearchPhase("test") {          @Override         public void run() throws IOException {             reference.set(mockSearchPhaseContext.buildSearchResponse(r, null)).         }     }).     phase.run().     mockSearchPhaseContext.assertNoFailure().     assertNotNull(reference.get()).     assertEquals(1, mockSearchPhaseContext.phasesExecuted.get()). }
false;;3;4;;@Override void sendExecuteMultiSearch(MultiSearchRequest request, SearchTask task, ActionListener<MultiSearchResponse> listener) {     fail("expand should not try to send empty multi search request"). }
false;public;0;4;;@Override public void run() throws IOException {     reference.set(mockSearchPhaseContext.buildSearchResponse(r, null)). }
false;public;0;27;;public void testSkipExpandCollapseNoHits() throws IOException {     MockSearchPhaseContext mockSearchPhaseContext = new MockSearchPhaseContext(1).     mockSearchPhaseContext.searchTransport = new SearchTransportService(null, null) {          @Override         void sendExecuteMultiSearch(MultiSearchRequest request, SearchTask task, ActionListener<MultiSearchResponse> listener) {             fail("expand should not try to send empty multi search request").         }     }.     mockSearchPhaseContext.getRequest().source(new SearchSourceBuilder().collapse(new CollapseBuilder("someField").setInnerHits(new InnerHitBuilder().setName("foobarbaz")))).     SearchHits hits = new SearchHits(new SearchHit[0], new TotalHits(1, TotalHits.Relation.EQUAL_TO), 1.0f).     InternalSearchResponse internalSearchResponse = new InternalSearchResponse(hits, null, null, null, false, null, 1).     AtomicReference<SearchResponse> reference = new AtomicReference<>().     ExpandSearchPhase phase = new ExpandSearchPhase(mockSearchPhaseContext, internalSearchResponse, r -> new SearchPhase("test") {          @Override         public void run() throws IOException {             reference.set(mockSearchPhaseContext.buildSearchResponse(r, null)).         }     }).     phase.run().     mockSearchPhaseContext.assertNoFailure().     assertNotNull(reference.get()).     assertEquals(1, mockSearchPhaseContext.phasesExecuted.get()). }
false;;3;12;;@Override void sendExecuteMultiSearch(MultiSearchRequest request, SearchTask task, ActionListener<MultiSearchResponse> listener) {     final QueryBuilder postFilter = QueryBuilders.existsQuery("foo").     assertTrue(request.requests().stream().allMatch((r) -> "foo".equals(r.preference()))).     assertTrue(request.requests().stream().allMatch((r) -> "baz".equals(r.routing()))).     assertTrue(request.requests().stream().allMatch((r) -> version == r.source().version())).     assertTrue(request.requests().stream().allMatch((r) -> seqNoAndTerm == r.source().seqNoAndPrimaryTerm())).     assertTrue(request.requests().stream().allMatch((r) -> postFilter.equals(r.source().postFilter()))).     assertTrue(request.requests().stream().allMatch((r) -> r.source().fetchSource().fetchSource() == false)).     assertTrue(request.requests().stream().allMatch((r) -> r.source().fetchSource().includes().length == 0)).     assertTrue(request.requests().stream().allMatch((r) -> r.source().fetchSource().excludes().length == 0)). }
false;public;0;4;;@Override public void run() throws IOException {     reference.set(mockSearchPhaseContext.buildSearchResponse(r, null)). }
false;public;0;45;;public void testExpandRequestOptions() throws IOException {     MockSearchPhaseContext mockSearchPhaseContext = new MockSearchPhaseContext(1).     boolean version = randomBoolean().     final boolean seqNoAndTerm = randomBoolean().     mockSearchPhaseContext.searchTransport = new SearchTransportService(null, null) {          @Override         void sendExecuteMultiSearch(MultiSearchRequest request, SearchTask task, ActionListener<MultiSearchResponse> listener) {             final QueryBuilder postFilter = QueryBuilders.existsQuery("foo").             assertTrue(request.requests().stream().allMatch((r) -> "foo".equals(r.preference()))).             assertTrue(request.requests().stream().allMatch((r) -> "baz".equals(r.routing()))).             assertTrue(request.requests().stream().allMatch((r) -> version == r.source().version())).             assertTrue(request.requests().stream().allMatch((r) -> seqNoAndTerm == r.source().seqNoAndPrimaryTerm())).             assertTrue(request.requests().stream().allMatch((r) -> postFilter.equals(r.source().postFilter()))).             assertTrue(request.requests().stream().allMatch((r) -> r.source().fetchSource().fetchSource() == false)).             assertTrue(request.requests().stream().allMatch((r) -> r.source().fetchSource().includes().length == 0)).             assertTrue(request.requests().stream().allMatch((r) -> r.source().fetchSource().excludes().length == 0)).         }     }.     mockSearchPhaseContext.getRequest().source(new SearchSourceBuilder().collapse(new CollapseBuilder("someField").setInnerHits(new InnerHitBuilder().setName("foobarbaz").setVersion(version).setSeqNoAndPrimaryTerm(seqNoAndTerm))).fetchSource(false).postFilter(QueryBuilders.existsQuery("foo"))).preference("foobar").routing("baz").     SearchHits hits = new SearchHits(new SearchHit[0], new TotalHits(1, TotalHits.Relation.EQUAL_TO), 1.0f).     InternalSearchResponse internalSearchResponse = new InternalSearchResponse(hits, null, null, null, false, null, 1).     AtomicReference<SearchResponse> reference = new AtomicReference<>().     ExpandSearchPhase phase = new ExpandSearchPhase(mockSearchPhaseContext, internalSearchResponse, r -> new SearchPhase("test") {          @Override         public void run() throws IOException {             reference.set(mockSearchPhaseContext.buildSearchResponse(r, null)).         }     }).     phase.run().     mockSearchPhaseContext.assertNoFailure().     assertNotNull(reference.get()).     assertEquals(1, mockSearchPhaseContext.phasesExecuted.get()). }
