commented;modifiers;parameterAmount;loc;comment;code
false;public;0;14;;public void testTermsLookup() {     String index = randomAlphaOfLengthBetween(1, 10).     String type = randomAlphaOfLengthBetween(1, 10).     String id = randomAlphaOfLengthBetween(1, 10).     String path = randomAlphaOfLengthBetween(1, 10).     String routing = randomAlphaOfLengthBetween(1, 10).     TermsLookup termsLookup = new TermsLookup(index, type, id, path).     termsLookup.routing(routing).     assertEquals(index, termsLookup.index()).     assertEquals(type, termsLookup.type()).     assertEquals(id, termsLookup.id()).     assertEquals(path, termsLookup.path()).     assertEquals(routing, termsLookup.routing()). }
false;public;0;27;;public void testIllegalArguments() {     String type = randomAlphaOfLength(5).     String id = randomAlphaOfLength(5).     String path = randomAlphaOfLength(5).     String index = randomAlphaOfLength(5).     switch(randomIntBetween(0, 3)) {         case 0:             type = null.             break.         case 1:             id = null.             break.         case 2:             path = null.             break.         case 3:             index = null.             break.         default:             fail("unknown case").     }     try {         new TermsLookup(index, type, id, path).     } catch (IllegalArgumentException e) {         assertThat(e.getMessage(), containsString("[terms] query lookup element requires specifying")).     } }
false;public;0;19;;public void testSerialization() throws IOException {     TermsLookup termsLookup = randomTermsLookup().     try (BytesStreamOutput output = new BytesStreamOutput()) {         termsLookup.writeTo(output).         try (StreamInput in = output.bytes().streamInput()) {             TermsLookup deserializedLookup = new TermsLookup(in).             assertEquals(deserializedLookup, termsLookup).             assertEquals(deserializedLookup.hashCode(), termsLookup.hashCode()).             assertNotSame(deserializedLookup, termsLookup).         }     }     try (BytesStreamOutput output = new BytesStreamOutput()) {         output.setVersion(Version.V_6_7_0).         IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> termsLookup.writeTo(output)).         assertEquals("Typeless [terms] lookup queries are not supported if any " + "node is running a version before 7.0.", e.getMessage()).     } }
false;public;0;12;;public void testSerializationWithTypes() throws IOException {     TermsLookup termsLookup = randomTermsLookupWithTypes().     try (BytesStreamOutput output = new BytesStreamOutput()) {         termsLookup.writeTo(output).         try (StreamInput in = output.bytes().streamInput()) {             TermsLookup deserializedLookup = new TermsLookup(in).             assertEquals(deserializedLookup, termsLookup).             assertEquals(deserializedLookup.hashCode(), termsLookup.hashCode()).             assertNotSame(deserializedLookup, termsLookup).         }     } }
false;public,static;0;7;;public static TermsLookup randomTermsLookup() {     return new TermsLookup(randomAlphaOfLength(10), randomAlphaOfLength(10), randomAlphaOfLength(10).replace('.', '_')).routing(randomBoolean() ? randomAlphaOfLength(10) : null). }
false;public,static;0;8;;public static TermsLookup randomTermsLookupWithTypes() {     return new TermsLookup(randomAlphaOfLength(10), randomAlphaOfLength(10), randomAlphaOfLength(10), randomAlphaOfLength(10).replace('.', '_')).routing(randomBoolean() ? randomAlphaOfLength(10) : null). }
