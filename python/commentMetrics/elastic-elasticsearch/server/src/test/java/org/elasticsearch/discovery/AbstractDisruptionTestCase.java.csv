commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected Settings nodeSettings(int nodeOrdinal) {     return Settings.builder().put(super.nodeSettings(nodeOrdinal)).put(DEFAULT_SETTINGS).build(). }
false;public;0;6;;@Override public Settings indexSettings() {     return Settings.builder().put(super.indexSettings()).put(IndexService.GLOBAL_CHECKPOINT_SYNC_INTERVAL_SETTING.getKey(), "1s").build(). }
false;protected;0;4;;@Override protected int numberOfShards() {     return 3. }
false;protected;0;4;;@Override protected int numberOfReplicas() {     return 1. }
false;public;0;6;;@Override @Before public void setUp() throws Exception {     super.setUp().     disableBeforeIndexDeletion = false. }
false;public;1;11;;@Override public void setDisruptionScheme(ServiceDisruptionScheme scheme) {     if (scheme instanceof NetworkDisruption && ((NetworkDisruption) scheme).getNetworkLinkDisruptionType() instanceof NetworkDisruption.NetworkUnresponsive) {         // the network unresponsive disruption may leave operations in flight         // this is because this disruption scheme swallows requests by design         // as such, these operations will never be marked as finished         disableBeforeIndexDeletion = true.     }     super.setDisruptionScheme(scheme). }
false;protected;0;9;;@Override protected void beforeIndexDeletion() throws Exception {     if (disableBeforeIndexDeletion == false) {         super.beforeIndexDeletion().         internalCluster().assertConsistentHistoryBetweenTranslogAndLuceneIndex().         internalCluster().assertSeqNos().         internalCluster().assertSameDocIdsOnShards().     } }
false;;1;6;;List<String> startCluster(int numberOfNodes) {     InternalTestCluster internalCluster = internalCluster().     List<String> nodes = internalCluster.startNodes(numberOfNodes).     ensureStableCluster(numberOfNodes).     return nodes. }
false;protected;0;4;;@Override protected Collection<Class<? extends Plugin>> nodePlugins() {     return Arrays.asList(MockTransportService.TestPlugin.class, InternalSettingsPlugin.class). }
false;;1;3;;ClusterState getNodeClusterState(String node) {     return client(node).admin().cluster().prepareState().setLocal(true).get().getState(). }
false;;1;3;;void assertNoMaster(final String node) throws Exception {     assertNoMaster(node, null, TimeValue.timeValueSeconds(10)). }
false;;2;3;;void assertNoMaster(final String node, TimeValue maxWaitTime) throws Exception {     assertNoMaster(node, null, maxWaitTime). }
false;;3;13;;void assertNoMaster(final String node, @Nullable final ClusterBlock expectedBlocks, TimeValue maxWaitTime) throws Exception {     assertBusy(() -> {         ClusterState state = getNodeClusterState(node).         final DiscoveryNodes nodes = state.nodes().         assertNull("node [" + node + "] still has [" + nodes.getMasterNode() + "] as master", nodes.getMasterNode()).         if (expectedBlocks != null) {             for (ClusterBlockLevel level : expectedBlocks.levels()) {                 assertTrue("node [" + node + "] does have level [" + level + "] in it's blocks", state.getBlocks().hasGlobalBlockWithLevel(level)).             }         }     }, maxWaitTime.getMillis(), TimeUnit.MILLISECONDS). }
false;;2;12;;void assertDifferentMaster(final String node, final String oldMasterNode) throws Exception {     assertBusy(() -> {         ClusterState state = getNodeClusterState(node).         String masterNode = null.         if (state.nodes().getMasterNode() != null) {             masterNode = state.nodes().getMasterNode().getName().         }         logger.trace("[{}] master is [{}]", node, state.nodes().getMasterNode()).         assertThat("node [" + node + "] still has [" + masterNode + "] as master", oldMasterNode, not(equalTo(masterNode))).     }, 10, TimeUnit.SECONDS). }
false;;2;11;;void assertMaster(String masterNode, List<String> nodes) throws Exception {     assertBusy(() -> {         for (String node : nodes) {             ClusterState state = getNodeClusterState(node).             String failMsgSuffix = "cluster_state:\n" + state.             assertThat("wrong node count on [" + node + "]. " + failMsgSuffix, state.nodes().getSize(), equalTo(nodes.size())).             String otherMasterNodeName = state.nodes().getMasterNode() != null ? state.nodes().getMasterNode().getName() : null.             assertThat("wrong master on node [" + node + "]. " + failMsgSuffix, otherMasterNodeName, equalTo(masterNode)).         }     }). }
false;public;0;31;;public ServiceDisruptionScheme addRandomDisruptionScheme() {     // TODO: add partial partitions     final DisruptedLinks disruptedLinks.     if (randomBoolean()) {         disruptedLinks = TwoPartitions.random(random(), internalCluster().getNodeNames()).     } else {         disruptedLinks = Bridge.random(random(), internalCluster().getNodeNames()).     }     final NetworkLinkDisruptionType disruptionType.     switch(randomInt(2)) {         case 0:             disruptionType = new NetworkDisruption.NetworkUnresponsive().             break.         case 1:             disruptionType = new NetworkDisconnect().             break.         case 2:             disruptionType = NetworkDisruption.NetworkDelay.random(random()).             break.         default:             throw new IllegalArgumentException().     }     final ServiceDisruptionScheme scheme.     if (rarely()) {         scheme = new SlowClusterStateProcessing(random()).     } else {         scheme = new NetworkDisruption(disruptedLinks, disruptionType).     }     setDisruptionScheme(scheme).     return scheme. }
false;;1;13;;NetworkDisruption addRandomDisruptionType(TwoPartitions partitions) {     final NetworkLinkDisruptionType disruptionType.     if (randomBoolean()) {         disruptionType = new NetworkDisruption.NetworkUnresponsive().     } else {         disruptionType = new NetworkDisconnect().     }     NetworkDisruption partition = new NetworkDisruption(partitions, disruptionType).     setDisruptionScheme(partition).     return partition. }
false;;1;8;;TwoPartitions isolateNode(String isolatedNode) {     Set<String> side1 = new HashSet<>().     Set<String> side2 = new HashSet<>(Arrays.asList(internalCluster().getNodeNames())).     side1.add(isolatedNode).     side2.remove(isolatedNode).     return new TwoPartitions(side1, side2). }
