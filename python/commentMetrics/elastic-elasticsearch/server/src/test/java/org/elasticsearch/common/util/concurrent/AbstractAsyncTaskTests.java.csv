commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void setUpThreadPool() {     threadPool = new TestThreadPool(AbstractAsyncTaskTests.class.getSimpleName()). }
false;public,static;0;4;;@AfterClass public static void tearDownThreadPool() {     terminate(threadPool). }
false;protected;0;4;;@Override protected boolean mustReschedule() {     return true. }
false;protected;0;18;;@Override protected void runInternal() {     assertTrue("generic threadpool is configured", Thread.currentThread().getName().contains("[generic]")).     try {         barrier1.await().     } catch (Exception e) {         fail("interrupted").     }     count.incrementAndGet().     try {         barrier2.await().     } catch (Exception e) {         fail("interrupted").     }     if (shouldRunThrowException) {         throw new RuntimeException("foo").     } }
false;protected;0;4;;@Override protected String getThreadPool() {     return ThreadPool.Names.GENERIC. }
false;public;0;56;;public void testAutoRepeat() throws Exception {     boolean shouldRunThrowException = randomBoolean().     // 1 for runInternal plus 1 for the test sequence     final CyclicBarrier barrier1 = new CyclicBarrier(2).     // 1 for runInternal plus 1 for the test sequence     final CyclicBarrier barrier2 = new CyclicBarrier(2).     final AtomicInteger count = new AtomicInteger().     AbstractAsyncTask task = new AbstractAsyncTask(logger, threadPool, TimeValue.timeValueMillis(1), true) {          @Override         protected boolean mustReschedule() {             return true.         }          @Override         protected void runInternal() {             assertTrue("generic threadpool is configured", Thread.currentThread().getName().contains("[generic]")).             try {                 barrier1.await().             } catch (Exception e) {                 fail("interrupted").             }             count.incrementAndGet().             try {                 barrier2.await().             } catch (Exception e) {                 fail("interrupted").             }             if (shouldRunThrowException) {                 throw new RuntimeException("foo").             }         }          @Override         protected String getThreadPool() {             return ThreadPool.Names.GENERIC.         }     }.     assertFalse(task.isScheduled()).     task.rescheduleIfNecessary().     assertTrue(task.isScheduled()).     barrier1.await().     assertTrue(task.isScheduled()).     barrier2.await().     assertEquals(1, count.get()).     barrier1.reset().     barrier2.reset().     barrier1.await().     assertTrue(task.isScheduled()).     task.close().     barrier2.await().     assertEquals(2, count.get()).     assertTrue(task.isClosed()).     assertFalse(task.isScheduled()).     assertEquals(2, count.get()). }
false;protected;0;4;;@Override protected boolean mustReschedule() {     return true. }
false;protected;0;13;;@Override protected void runInternal() {     assertTrue("generic threadpool is configured", Thread.currentThread().getName().contains("[generic]")).     count.incrementAndGet().     try {         barrier.await().     } catch (Exception e) {         fail("interrupted").     }     if (shouldRunThrowException) {         throw new RuntimeException("foo").     } }
false;protected;0;4;;@Override protected String getThreadPool() {     return ThreadPool.Names.GENERIC. }
false;public;0;49;;public void testManualRepeat() throws Exception {     boolean shouldRunThrowException = randomBoolean().     // 1 for runInternal plus 1 for the test sequence     final CyclicBarrier barrier = new CyclicBarrier(2).     final AtomicInteger count = new AtomicInteger().     AbstractAsyncTask task = new AbstractAsyncTask(logger, threadPool, TimeValue.timeValueMillis(1), false) {          @Override         protected boolean mustReschedule() {             return true.         }          @Override         protected void runInternal() {             assertTrue("generic threadpool is configured", Thread.currentThread().getName().contains("[generic]")).             count.incrementAndGet().             try {                 barrier.await().             } catch (Exception e) {                 fail("interrupted").             }             if (shouldRunThrowException) {                 throw new RuntimeException("foo").             }         }          @Override         protected String getThreadPool() {             return ThreadPool.Names.GENERIC.         }     }.     assertFalse(task.isScheduled()).     task.rescheduleIfNecessary().     barrier.await().     assertEquals(1, count.get()).     assertFalse(task.isScheduled()).     barrier.reset().     expectThrows(TimeoutException.class, () -> barrier.await(10, TimeUnit.MILLISECONDS)).     assertEquals(1, count.get()).     barrier.reset().     task.rescheduleIfNecessary().     barrier.await().     assertEquals(2, count.get()).     assertFalse(task.isScheduled()).     assertFalse(task.isClosed()).     task.close().     assertTrue(task.isClosed()). }
false;protected;0;4;;@Override protected boolean mustReschedule() {     return true. }
false;protected;0;3;;@Override protected void runInternal() { }
false;public;0;21;;public void testCloseWithNoRun() {     AbstractAsyncTask task = new AbstractAsyncTask(logger, threadPool, TimeValue.timeValueMinutes(10), true) {          @Override         protected boolean mustReschedule() {             return true.         }          @Override         protected void runInternal() {         }     }.     assertFalse(task.isScheduled()).     task.rescheduleIfNecessary().     assertTrue(task.isScheduled()).     task.close().     assertTrue(task.isClosed()).     assertFalse(task.isScheduled()). }
false;protected;0;4;;@Override protected boolean mustReschedule() {     return latch.getCount() > 0. }
false;protected;0;4;;@Override protected void runInternal() {     latch.countDown(). }
false;public;0;29;;public void testChangeInterval() throws Exception {     final CountDownLatch latch = new CountDownLatch(2).     AbstractAsyncTask task = new AbstractAsyncTask(logger, threadPool, TimeValue.timeValueHours(1), true) {          @Override         protected boolean mustReschedule() {             return latch.getCount() > 0.         }          @Override         protected void runInternal() {             latch.countDown().         }     }.     assertFalse(task.isScheduled()).     task.rescheduleIfNecessary().     assertTrue(task.isScheduled()).     task.setInterval(TimeValue.timeValueMillis(1)).     assertTrue(task.isScheduled()).     // This should only take 2 milliseconds in ideal conditions, but allow 10 seconds in case of VM stalls     assertTrue(latch.await(10, TimeUnit.SECONDS)).     assertBusy(() -> assertFalse(task.isScheduled())).     task.close().     assertFalse(task.isScheduled()).     assertTrue(task.isClosed()). }
