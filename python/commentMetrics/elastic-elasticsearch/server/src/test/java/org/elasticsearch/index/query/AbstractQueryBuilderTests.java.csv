commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;4;;@BeforeClass public static void init() {     xContentRegistry = new NamedXContentRegistry(new SearchModule(Settings.EMPTY, false, emptyList()).getNamedXContents()). }
false;public,static;0;4;;@AfterClass public static void cleanup() {     xContentRegistry = null. }
false;public;0;8;;public void testParseInnerQueryBuilder() throws IOException {     QueryBuilder query = new MatchQueryBuilder("foo", "bar").     String source = query.toString().     try (XContentParser parser = createParser(JsonXContent.jsonXContent, source)) {         QueryBuilder actual = parseInnerQueryBuilder(parser).         assertEquals(query, actual).     } }
false;public;0;27;;public void testParseInnerQueryBuilderExceptions() throws IOException {     String source = "{ \"foo\": \"bar\" }".     try (XContentParser parser = createParser(JsonXContent.jsonXContent, source)) {         parser.nextToken().         // don't start with START_OBJECT to provoke exception         parser.nextToken().         ParsingException exception = expectThrows(ParsingException.class, () -> parseInnerQueryBuilder(parser)).         assertEquals("[_na] query malformed, must start with start_object", exception.getMessage()).     }     source = "{}".     try (XContentParser parser = createParser(JsonXContent.jsonXContent, source)) {         IllegalArgumentException exception = expectThrows(IllegalArgumentException.class, () -> parseInnerQueryBuilder(parser)).         assertEquals("query malformed, empty clause found at [1:2]", exception.getMessage()).     }     source = "{ \"foo\" : \"bar\" }".     try (XContentParser parser = createParser(JsonXContent.jsonXContent, source)) {         ParsingException exception = expectThrows(ParsingException.class, () -> parseInnerQueryBuilder(parser)).         assertEquals("[foo] query malformed, no start_object after query name", exception.getMessage()).     }     source = "{ \"foo\" : {} }".     try (XContentParser parser = createParser(JsonXContent.jsonXContent, source)) {         ParsingException exception = expectThrows(ParsingException.class, () -> parseInnerQueryBuilder(parser)).         assertEquals("no [query] registered for [foo]", exception.getMessage()).     } }
false;protected;0;4;;@Override protected NamedXContentRegistry xContentRegistry() {     return xContentRegistry. }
