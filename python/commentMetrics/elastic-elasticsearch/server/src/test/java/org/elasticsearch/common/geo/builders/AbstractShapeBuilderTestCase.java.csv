commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;6;/**  * setup for the whole base test class  */ ;/**  * setup for the whole base test class  */ @BeforeClass public static void init() {     if (namedWriteableRegistry == null) {         namedWriteableRegistry = new NamedWriteableRegistry(GeoShapeType.getShapeWriteables()).     } }
false;public,static;0;4;;@AfterClass public static void afterClass() throws Exception {     namedWriteableRegistry = null. }
true;protected,abstract;0;1;/**  * create random shape that is put under test  */ ;/**  * create random shape that is put under test  */ protected abstract SB createTestShapeBuilder().
true;protected,abstract;1;1;/**  * mutate the given shape so the returned shape is different  */ ;/**  * mutate the given shape so the returned shape is different  */ protected abstract SB createMutation(SB original) throws IOException.
true;public;0;18;/**  * Test that creates new shape from a random test shape and checks both for equality  */ ;/**  * Test that creates new shape from a random test shape and checks both for equality  */ public void testFromXContent() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         SB testShape = createTestShapeBuilder().         XContentBuilder contentBuilder = XContentFactory.contentBuilder(randomFrom(XContentType.values())).         if (randomBoolean()) {             contentBuilder.prettyPrint().         }         XContentBuilder builder = testShape.toXContent(contentBuilder, ToXContent.EMPTY_PARAMS).         XContentBuilder shuffled = shuffleXContent(builder).         try (XContentParser shapeContentParser = createParser(shuffled)) {             shapeContentParser.nextToken().             ShapeBuilder<?, ?, ?> parsedShape = ShapeParser.parse(shapeContentParser).             assertNotSame(testShape, parsedShape).             assertEquals(testShape, parsedShape).             assertEquals(testShape.hashCode(), parsedShape.hashCode()).         }     } }
true;public;0;9;/**  * Test serialization and deserialization of the test shape.  */ ;/**  * Test serialization and deserialization of the test shape.  */ public void testSerialization() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         SB testShape = createTestShapeBuilder().         SB deserializedShape = copyShape(testShape).         assertEquals(testShape, deserializedShape).         assertEquals(testShape.hashCode(), deserializedShape.hashCode()).         assertNotSame(testShape, deserializedShape).     } }
true;public;0;5;/**  * Test equality and hashCode properties  */ ;/**  * Test equality and hashCode properties  */ public void testEqualsAndHashcode() throws IOException {     for (int runs = 0. runs < NUMBER_OF_TESTBUILDERS. runs++) {         checkEqualsAndHashCode(createTestShapeBuilder(), AbstractShapeBuilderTestCase::copyShape, this::createMutation).     } }
false;protected,static;1;5;;protected static <T extends NamedWriteable> T copyShape(T original) throws IOException {     @SuppressWarnings("unchecked")     Reader<T> reader = (Reader<T>) namedWriteableRegistry.getReader(ShapeBuilder.class, original.getWriteableName()).     return ESTestCase.copyWriteable(original, namedWriteableRegistry, reader). }
