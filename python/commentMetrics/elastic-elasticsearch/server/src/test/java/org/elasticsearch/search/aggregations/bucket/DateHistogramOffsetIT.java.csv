commented;modifiers;parameterAmount;loc;comment;code
false;private;1;3;;private ZonedDateTime date(String date) {     return DateFormatters.from(DateFieldMapper.DEFAULT_DATE_TIME_FORMATTER.parse(date)). }
false;public;0;4;;@Before public void beforeEachTest() throws IOException {     prepareCreate("idx2").addMapping("type", "date", "type=date").get(). }
false;public;0;4;;@After public void afterEachTest() throws IOException {     internalCluster().wipeIndices("idx2"). }
false;private;4;11;;private void prepareIndex(ZonedDateTime date, int numHours, int stepSizeHours, int idxIdStart) throws IOException, InterruptedException {     IndexRequestBuilder[] reqs = new IndexRequestBuilder[numHours].     for (int i = idxIdStart. i < idxIdStart + reqs.length. i++) {         reqs[i - idxIdStart] = client().prepareIndex("idx2", "type", "" + i).setSource(jsonBuilder().startObject().timeField("date", date).endObject()).         date = date.plusHours(stepSizeHours).     }     indexRandom(true, reqs). }
false;public;0;21;;public void testSingleValueWithPositiveOffset() throws Exception {     prepareIndex(date("2014-03-11T00:00:00+00:00"), 5, 1, 0).     SearchResponse response = client().prepareSearch("idx2").setQuery(matchAllQuery()).addAggregation(dateHistogram("date_histo").field("date").offset("2h").format(DATE_FORMAT).dateHistogramInterval(DateHistogramInterval.DAY)).get().     assertThat(response.getHits().getTotalHits().value, equalTo(5L)).     Histogram histo = response.getAggregations().get("date_histo").     List<? extends Histogram.Bucket> buckets = histo.getBuckets().     assertThat(buckets.size(), equalTo(2)).     checkBucketFor(buckets.get(0), ZonedDateTime.of(2014, 3, 10, 2, 0, 0, 0, ZoneOffset.UTC), 2L).     checkBucketFor(buckets.get(1), ZonedDateTime.of(2014, 3, 11, 2, 0, 0, 0, ZoneOffset.UTC), 3L). }
false;public;0;21;;public void testSingleValueWithNegativeOffset() throws Exception {     prepareIndex(date("2014-03-11T00:00:00+00:00"), 5, -1, 0).     SearchResponse response = client().prepareSearch("idx2").setQuery(matchAllQuery()).addAggregation(dateHistogram("date_histo").field("date").offset("-2h").format(DATE_FORMAT).dateHistogramInterval(DateHistogramInterval.DAY)).get().     assertThat(response.getHits().getTotalHits().value, equalTo(5L)).     Histogram histo = response.getAggregations().get("date_histo").     List<? extends Histogram.Bucket> buckets = histo.getBuckets().     assertThat(buckets.size(), equalTo(2)).     checkBucketFor(buckets.get(0), ZonedDateTime.of(2014, 3, 9, 22, 0, 0, 0, ZoneOffset.UTC), 2L).     checkBucketFor(buckets.get(1), ZonedDateTime.of(2014, 3, 10, 22, 0, 0, 0, ZoneOffset.UTC), 3L). }
true;public;0;26;/**  * Set offset so day buckets start at 6am. Index first 12 hours for two days, with one day gap.  */ ;/**  * Set offset so day buckets start at 6am. Index first 12 hours for two days, with one day gap.  */ public void testSingleValueWithOffsetMinDocCount() throws Exception {     prepareIndex(date("2014-03-11T00:00:00+00:00"), 12, 1, 0).     prepareIndex(date("2014-03-14T00:00:00+00:00"), 12, 1, 13).     SearchResponse response = client().prepareSearch("idx2").setQuery(matchAllQuery()).addAggregation(dateHistogram("date_histo").field("date").offset("6h").minDocCount(0).format(DATE_FORMAT).dateHistogramInterval(DateHistogramInterval.DAY)).get().     assertThat(response.getHits().getTotalHits().value, equalTo(24L)).     Histogram histo = response.getAggregations().get("date_histo").     List<? extends Histogram.Bucket> buckets = histo.getBuckets().     assertThat(buckets.size(), equalTo(5)).     checkBucketFor(buckets.get(0), ZonedDateTime.of(2014, 3, 10, 6, 0, 0, 0, ZoneOffset.UTC), 6L).     checkBucketFor(buckets.get(1), ZonedDateTime.of(2014, 3, 11, 6, 0, 0, 0, ZoneOffset.UTC), 6L).     checkBucketFor(buckets.get(2), ZonedDateTime.of(2014, 3, 12, 6, 0, 0, 0, ZoneOffset.UTC), 0L).     checkBucketFor(buckets.get(3), ZonedDateTime.of(2014, 3, 13, 6, 0, 0, 0, ZoneOffset.UTC), 6L).     checkBucketFor(buckets.get(4), ZonedDateTime.of(2014, 3, 14, 6, 0, 0, 0, ZoneOffset.UTC), 6L). }
true;private,static;3;6;/**  * @param bucket the bucket to check assertions for  * @param key the expected key  * @param expectedSize the expected size of the bucket  */ ;/**  * @param bucket the bucket to check assertions for  * @param key the expected key  * @param expectedSize the expected size of the bucket  */ private static void checkBucketFor(Histogram.Bucket bucket, ZonedDateTime key, long expectedSize) {     assertThat(bucket, notNullValue()).     assertThat(bucket.getKeyAsString(), equalTo(FORMATTER.format(key))).     assertThat(((ZonedDateTime) bucket.getKey()), equalTo(key)).     assertThat(bucket.getDocCount(), equalTo(expectedSize)). }
