commented;modifiers;parameterAmount;loc;comment;code
false;public;0;8;;@Override public void setUp() throws Exception {     super.setUp().     AllocationService allocationService = createAllocationService(Settings.builder().put(CLUSTER_ROUTING_ALLOCATION_NODE_CONCURRENT_RECOVERIES_SETTING.getKey(), Integer.MAX_VALUE).build()).     executor = new ShardStateAction.ShardStartedClusterStateTaskExecutor(allocationService, logger). }
false;public;0;5;;public void testEmptyTaskListProducesSameClusterState() throws Exception {     final ClusterState clusterState = stateWithNoShard().     final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, Collections.emptyList()).     assertSame(clusterState, result.resultingState). }
false;public;0;10;;public void testNonExistentIndexMarkedAsSuccessful() throws Exception {     final ClusterState clusterState = stateWithNoShard().     final StartedShardEntry entry = new StartedShardEntry(new ShardId("test", "_na", 0), "aId", randomNonNegativeLong(), "test").     final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, singletonList(entry)).     assertSame(clusterState, result.resultingState).     assertThat(result.executionResults.size(), equalTo(1)).     assertThat(result.executionResults.containsKey(entry), is(true)).     assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(entry)).isSuccess(), is(true)). }
false;public;0;23;;public void testNonExistentShardsAreMarkedAsSuccessful() throws Exception {     final String indexName = "test".     final ClusterState clusterState = stateWithActivePrimary(indexName, true, randomInt(2), randomInt(2)).     final IndexMetaData indexMetaData = clusterState.metaData().index(indexName).     final List<StartedShardEntry> tasks = Stream.concat(// Existent shard id but different allocation id     IntStream.range(0, randomIntBetween(1, 5)).mapToObj(i -> new StartedShardEntry(new ShardId(indexMetaData.getIndex(), 0), String.valueOf(i), 0L, "allocation id")), // Non existent shard id     IntStream.range(1, randomIntBetween(2, 5)).mapToObj(i -> new StartedShardEntry(new ShardId(indexMetaData.getIndex(), i), String.valueOf(i), 0L, "shard id"))).collect(Collectors.toList()).     final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks).     assertSame(clusterState, result.resultingState).     assertThat(result.executionResults.size(), equalTo(tasks.size())).     tasks.forEach(task -> {         assertThat(result.executionResults.containsKey(task), is(true)).         assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true)).     }). }
false;public;0;27;;public void testNonInitializingShardAreMarkedAsSuccessful() throws Exception {     final String indexName = "test".     final ClusterState clusterState = stateWithAssignedPrimariesAndReplicas(new String[] { indexName }, randomIntBetween(2, 10), 1).     final IndexMetaData indexMetaData = clusterState.metaData().index(indexName).     final List<StartedShardEntry> tasks = IntStream.range(0, randomIntBetween(1, indexMetaData.getNumberOfShards())).mapToObj(i -> {         final ShardId shardId = new ShardId(indexMetaData.getIndex(), i).         final IndexShardRoutingTable shardRoutingTable = clusterState.routingTable().shardRoutingTable(shardId).         final String allocationId.         if (randomBoolean()) {             allocationId = shardRoutingTable.primaryShard().allocationId().getId().         } else {             allocationId = shardRoutingTable.replicaShards().iterator().next().allocationId().getId().         }         final long primaryTerm = indexMetaData.primaryTerm(shardId.id()).         return new StartedShardEntry(shardId, allocationId, primaryTerm, "test").     }).collect(Collectors.toList()).     final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks).     assertSame(clusterState, result.resultingState).     assertThat(result.executionResults.size(), equalTo(tasks.size())).     tasks.forEach(task -> {         assertThat(result.executionResults.containsKey(task), is(true)).         assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true)).     }). }
false;public;0;28;;public void testStartedShards() throws Exception {     final String indexName = "test".     final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING, ShardRoutingState.INITIALIZING).     final IndexMetaData indexMetaData = clusterState.metaData().index(indexName).     final ShardId shardId = new ShardId(indexMetaData.getIndex(), 0).     final long primaryTerm = indexMetaData.primaryTerm(shardId.id()).     final ShardRouting primaryShard = clusterState.routingTable().shardRoutingTable(shardId).primaryShard().     final String primaryAllocationId = primaryShard.allocationId().getId().     final List<StartedShardEntry> tasks = new ArrayList<>().     tasks.add(new StartedShardEntry(shardId, primaryAllocationId, primaryTerm, "test")).     if (randomBoolean()) {         final ShardRouting replicaShard = clusterState.routingTable().shardRoutingTable(shardId).replicaShards().iterator().next().         final String replicaAllocationId = replicaShard.allocationId().getId().         tasks.add(new StartedShardEntry(shardId, replicaAllocationId, primaryTerm, "test")).     }     final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks).     assertNotSame(clusterState, result.resultingState).     assertThat(result.executionResults.size(), equalTo(tasks.size())).     tasks.forEach(task -> {         assertThat(result.executionResults.containsKey(task), is(true)).         assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true)).         final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId).         assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED)).     }). }
false;public;0;25;;public void testDuplicateStartsAreOkay() throws Exception {     final String indexName = "test".     final ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING).     final IndexMetaData indexMetaData = clusterState.metaData().index(indexName).     final ShardId shardId = new ShardId(indexMetaData.getIndex(), 0).     final ShardRouting shardRouting = clusterState.routingTable().shardRoutingTable(shardId).primaryShard().     final String allocationId = shardRouting.allocationId().getId().     final long primaryTerm = indexMetaData.primaryTerm(shardId.id()).     final List<StartedShardEntry> tasks = IntStream.range(0, randomIntBetween(2, 10)).mapToObj(i -> new StartedShardEntry(shardId, allocationId, primaryTerm, "test")).collect(Collectors.toList()).     final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, tasks).     assertNotSame(clusterState, result.resultingState).     assertThat(result.executionResults.size(), equalTo(tasks.size())).     tasks.forEach(task -> {         assertThat(result.executionResults.containsKey(task), is(true)).         assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true)).         final IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId).         assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED)).     }). }
false;public;0;59;;public void testPrimaryTermsMismatch() throws Exception {     final String indexName = "test".     final int shard = 0.     final int primaryTerm = 2 + randomInt(200).     ClusterState clusterState = state(indexName, randomBoolean(), ShardRoutingState.INITIALIZING, ShardRoutingState.INITIALIZING).     clusterState = ClusterState.builder(clusterState).metaData(MetaData.builder(clusterState.metaData()).put(IndexMetaData.builder(clusterState.metaData().index(indexName)).primaryTerm(shard, primaryTerm).build(), true).build()).build().     final ShardId shardId = new ShardId(clusterState.metaData().index(indexName).getIndex(), shard).     final String primaryAllocationId = clusterState.routingTable().shardRoutingTable(shardId).primaryShard().allocationId().getId().     {         final StartedShardEntry task = new StartedShardEntry(shardId, primaryAllocationId, primaryTerm - 1, "primary terms does not match on primary").         final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, singletonList(task)).         assertSame(clusterState, result.resultingState).         assertThat(result.executionResults.size(), equalTo(1)).         assertThat(result.executionResults.containsKey(task), is(true)).         assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true)).         IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId).         assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.INITIALIZING)).         assertSame(clusterState, result.resultingState).     }     {         final StartedShardEntry task = new StartedShardEntry(shardId, primaryAllocationId, primaryTerm, "primary terms match on primary").         final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, singletonList(task)).         assertNotSame(clusterState, result.resultingState).         assertThat(result.executionResults.size(), equalTo(1)).         assertThat(result.executionResults.containsKey(task), is(true)).         assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true)).         IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId).         assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED)).         assertNotSame(clusterState, result.resultingState).         clusterState = result.resultingState.     }     {         final long replicaPrimaryTerm = randomBoolean() ? primaryTerm : primaryTerm - 1.         final String replicaAllocationId = clusterState.routingTable().shardRoutingTable(shardId).replicaShards().iterator().next().allocationId().getId().         final StartedShardEntry task = new StartedShardEntry(shardId, replicaAllocationId, replicaPrimaryTerm, "test on replica").         final ClusterStateTaskExecutor.ClusterTasksResult result = executeTasks(clusterState, singletonList(task)).         assertNotSame(clusterState, result.resultingState).         assertThat(result.executionResults.size(), equalTo(1)).         assertThat(result.executionResults.containsKey(task), is(true)).         assertThat(((ClusterStateTaskExecutor.TaskResult) result.executionResults.get(task)).isSuccess(), is(true)).         IndexShardRoutingTable shardRoutingTable = result.resultingState.routingTable().shardRoutingTable(task.shardId).         assertThat(shardRoutingTable.getByAllocationId(task.allocationId).state(), is(ShardRoutingState.STARTED)).         assertNotSame(clusterState, result.resultingState).     } }
false;private;2;6;;private ClusterStateTaskExecutor.ClusterTasksResult executeTasks(final ClusterState state, final List<StartedShardEntry> tasks) throws Exception {     final ClusterStateTaskExecutor.ClusterTasksResult<StartedShardEntry> result = executor.execute(state, tasks).     assertThat(result, notNullValue()).     return result. }
