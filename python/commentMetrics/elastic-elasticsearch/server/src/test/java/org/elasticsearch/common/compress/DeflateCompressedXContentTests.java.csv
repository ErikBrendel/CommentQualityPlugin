commented;modifiers;parameterAmount;loc;comment;code
false;private;2;5;;private void assertEquals(CompressedXContent s1, CompressedXContent s2) {     Assert.assertEquals(s1, s2).     assertArrayEquals(s1.uncompressed(), s2.uncompressed()).     assertEquals(s1.hashCode(), s2.hashCode()). }
false;public;0;12;;public void simpleTests() throws IOException {     String str = "---\nf:this is a simple string".     CompressedXContent cstr = new CompressedXContent(str).     assertThat(cstr.string(), equalTo(str)).     assertThat(new CompressedXContent(str), equalTo(cstr)).     String str2 = "---\nf:this is a simple string 2".     CompressedXContent cstr2 = new CompressedXContent(str2).     assertThat(cstr2.string(), not(equalTo(str))).     assertThat(new CompressedXContent(str2), not(equalTo(cstr))).     assertEquals(new CompressedXContent(str2), cstr2). }
false;public;0;10;;public void testRandom() throws IOException {     Random r = random().     for (int i = 0. i < 1000. i++) {         String string = TestUtil.randomUnicodeString(r, 10000).         // hack to make it detected as YAML         string = "---\n" + string.         CompressedXContent compressedXContent = new CompressedXContent(string).         assertThat(compressedXContent.string(), equalTo(string)).     } }
false;public;0;27;;public void testDifferentCompressedRepresentation() throws Exception {     byte[] b = "---\nf:abcdefghijabcdefghij".getBytes("UTF-8").     BytesStreamOutput bout = new BytesStreamOutput().     StreamOutput out = compressor.streamOutput(bout).     out.writeBytes(b).     out.flush().     out.writeBytes(b).     out.close().     final BytesReference b1 = bout.bytes().     bout = new BytesStreamOutput().     out = compressor.streamOutput(bout).     out.writeBytes(b).     out.writeBytes(b).     out.close().     final BytesReference b2 = bout.bytes().     // because of the intermediate flush, the two compressed representations     // are different. It can also happen for other reasons like if hash tables     // of different size are being used     assertFalse(b1.equals(b2)).     // we used the compressed representation directly and did not recompress     assertArrayEquals(BytesReference.toBytes(b1), new CompressedXContent(b1).compressed()).     assertArrayEquals(BytesReference.toBytes(b2), new CompressedXContent(b2).compressed()).     // but compressedstring instances are still equal     assertEquals(new CompressedXContent(b1), new CompressedXContent(b2)). }
false;public;0;3;;public void testHashCode() throws IOException {     assertFalse(new CompressedXContent("{\"a\":\"b\"}").hashCode() == new CompressedXContent("{\"a\":\"c\"}").hashCode()). }
