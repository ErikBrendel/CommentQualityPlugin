commented;modifiers;parameterAmount;loc;comment;code
false;public;0;12;;public void testNormal() throws Exception {     int numIndexExpressions = randomIntBetween(1, 9).     List<String> indexExpressions = new ArrayList<>(numIndexExpressions).     for (int i = 0. i < numIndexExpressions. i++) {         indexExpressions.add(randomAlphaOfLength(10)).     }     List<String> result = expressionResolver.resolve(context, indexExpressions).     assertThat(result.size(), equalTo(indexExpressions.size())).     for (int i = 0. i < indexExpressions.size(). i++) {         assertThat(result.get(i), equalTo(indexExpressions.get(i))).     } }
false;public;0;11;;public void testExpression() throws Exception {     List<String> indexExpressions = Arrays.asList("<.marvel-{now}>", "<.watch_history-{now}>", "<logstash-{now}>").     List<String> result = expressionResolver.resolve(context, indexExpressions).     assertThat(result.size(), equalTo(3)).     assertThat(result.get(0), equalTo(".marvel-" + DateTimeFormat.forPattern("YYYY.MM.dd").print(new DateTime(context.getStartTime(), UTC)))).     assertThat(result.get(1), equalTo(".watch_history-" + DateTimeFormat.forPattern("YYYY.MM.dd").print(new DateTime(context.getStartTime(), UTC)))).     assertThat(result.get(2), equalTo("logstash-" + DateTimeFormat.forPattern("YYYY.MM.dd").print(new DateTime(context.getStartTime(), UTC)))). }
false;public;0;4;;public void testEmpty() throws Exception {     List<String> result = expressionResolver.resolve(context, Collections.<String>emptyList()).     assertThat(result.size(), equalTo(0)). }
false;public;0;5;;public void testExpression_Static() throws Exception {     List<String> result = expressionResolver.resolve(context, Arrays.asList("<.marvel-test>")).     assertThat(result.size(), equalTo(1)).     assertThat(result.get(0), equalTo(".marvel-test")). }
false;public;0;8;;public void testExpression_MultiParts() throws Exception {     List<String> result = expressionResolver.resolve(context, Arrays.asList("<.text1-{now/d}-text2-{now/M}>")).     assertThat(result.size(), equalTo(1)).     assertThat(result.get(0), equalTo(".text1-" + DateTimeFormat.forPattern("YYYY.MM.dd").print(new DateTime(context.getStartTime(), UTC)) + "-text2-" + DateTimeFormat.forPattern("YYYY.MM.dd").print(new DateTime(context.getStartTime(), UTC).withDayOfMonth(1)))). }
false;public;0;6;;public void testExpression_CustomFormat() throws Exception {     List<String> results = expressionResolver.resolve(context, Arrays.asList("<.marvel-{now/d{yyyy.MM.dd}}>")).     assertThat(results.size(), equalTo(1)).     assertThat(results.get(0), equalTo(".marvel-" + DateTimeFormat.forPattern("yyyy.MM.dd").print(new DateTime(context.getStartTime(), UTC)))). }
false;public;0;6;;public void testExpression_EscapeStatic() throws Exception {     List<String> result = expressionResolver.resolve(context, Arrays.asList("<.mar\\{v\\}el-{now/d}>")).     assertThat(result.size(), equalTo(1)).     assertThat(result.get(0), equalTo(".mar{v}el-" + DateTimeFormat.forPattern("yyyy.MM.dd").print(new DateTime(context.getStartTime(), UTC)))). }
false;public;0;6;;public void testExpression_EscapeDateFormat() throws Exception {     List<String> result = expressionResolver.resolve(context, Arrays.asList("<.marvel-{now/d{'\\{year\\}'yyyy}}>")).     assertThat(result.size(), equalTo(1)).     assertThat(result.get(0), equalTo(".marvel-" + DateTimeFormat.forPattern("'{year}'yyyy").print(new DateTime(context.getStartTime(), UTC)))). }
false;public;0;12;;public void testExpression_MixedArray() throws Exception {     List<String> result = expressionResolver.resolve(context, Arrays.asList("name1", "<.marvel-{now/d}>", "name2", "<.logstash-{now/M{YYYY.MM}}>")).     assertThat(result.size(), equalTo(4)).     assertThat(result.get(0), equalTo("name1")).     assertThat(result.get(1), equalTo(".marvel-" + DateTimeFormat.forPattern("YYYY.MM.dd").print(new DateTime(context.getStartTime(), UTC)))).     assertThat(result.get(2), equalTo("name2")).     assertThat(result.get(3), equalTo(".logstash-" + DateTimeFormat.forPattern("YYYY.MM").print(new DateTime(context.getStartTime(), UTC).withDayOfMonth(1)))). }
false;public;0;27;;public void testExpression_CustomTimeZoneInIndexName() throws Exception {     DateTimeZone timeZone.     int hoursOffset.     int minutesOffset = 0.     if (randomBoolean()) {         hoursOffset = randomIntBetween(-12, 14).         timeZone = DateTimeZone.forOffsetHours(hoursOffset).     } else {         hoursOffset = randomIntBetween(-11, 13).         minutesOffset = randomIntBetween(0, 59).         timeZone = DateTimeZone.forOffsetHoursMinutes(hoursOffset, minutesOffset).     }     DateTime now.     if (hoursOffset >= 0) {         // rounding to next day 00:00         now = DateTime.now(UTC).plusHours(hoursOffset).plusMinutes(minutesOffset).withHourOfDay(0).withMinuteOfHour(0).withSecondOfMinute(0).     } else {         // rounding to today 00:00         now = DateTime.now(UTC).withHourOfDay(0).withMinuteOfHour(0).withSecondOfMinute(0).     }     Context context = new Context(this.context.getState(), this.context.getOptions(), now.getMillis()).     List<String> results = expressionResolver.resolve(context, Arrays.asList("<.marvel-{now/d{yyyy.MM.dd|" + timeZone.getID() + "}}>")).     assertThat(results.size(), equalTo(1)).     logger.info("timezone: [{}], now [{}], name: [{}]", timeZone, now, results.get(0)).     assertThat(results.get(0), equalTo(".marvel-" + DateTimeFormat.forPattern("yyyy.MM.dd").print(now.withZone(timeZone)))). }
false;public;0;6;;public void testExpressionInvalidUnescaped() throws Exception {     Exception e = expectThrows(ElasticsearchParseException.class, () -> expressionResolver.resolve(context, Arrays.asList("<.mar}vel-{now/d}>"))).     assertThat(e.getMessage(), containsString("invalid dynamic name expression")).     assertThat(e.getMessage(), containsString("invalid character at position [")). }
false;public;0;6;;public void testExpressionInvalidDateMathFormat() throws Exception {     Exception e = expectThrows(ElasticsearchParseException.class, () -> expressionResolver.resolve(context, Arrays.asList("<.marvel-{now/d{}>"))).     assertThat(e.getMessage(), containsString("invalid dynamic name expression")).     assertThat(e.getMessage(), containsString("date math placeholder is open ended")). }
false;public;0;6;;public void testExpressionInvalidEmptyDateMathFormat() throws Exception {     Exception e = expectThrows(ElasticsearchParseException.class, () -> expressionResolver.resolve(context, Arrays.asList("<.marvel-{now/d{}}>"))).     assertThat(e.getMessage(), containsString("invalid dynamic name expression")).     assertThat(e.getMessage(), containsString("missing date format")). }
false;public;0;6;;public void testExpressionInvalidOpenEnded() throws Exception {     Exception e = expectThrows(ElasticsearchParseException.class, () -> expressionResolver.resolve(context, Arrays.asList("<.marvel-{now/d>"))).     assertThat(e.getMessage(), containsString("invalid dynamic name expression")).     assertThat(e.getMessage(), containsString("date math placeholder is open ended")). }
