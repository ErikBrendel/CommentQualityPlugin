commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;10;;@BeforeClass public static void createThreadPoolAndClusterService() {     threadPool = new TestThreadPool("test", Settings.EMPTY).     localNode = new DiscoveryNode("local", buildNewFakeTransportAddress(), Version.CURRENT).     otherNode1 = new DiscoveryNode("other1", "other1", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT).     otherNode1Exclusion = new VotingConfigExclusion(otherNode1).     otherNode2 = new DiscoveryNode("other2", "other2", buildNewFakeTransportAddress(), emptyMap(), emptySet(), Version.CURRENT).     otherNode2Exclusion = new VotingConfigExclusion(otherNode2).     clusterService = createClusterService(threadPool, localNode). }
false;public,static;0;5;;@AfterClass public static void shutdownThreadPoolAndClusterService() {     clusterService.stop().     threadPool.shutdown(). }
false;public;0;22;;@Before public void setupForTest() {     final MockTransport transport = new MockTransport().     transportService = transport.createTransportService(Settings.EMPTY, threadPool, TransportService.NOOP_TRANSPORT_INTERCEPTOR, boundTransportAddress -> localNode, null, emptySet()).     new TransportClearVotingConfigExclusionsAction(transportService, clusterService, threadPool, new ActionFilters(emptySet()), // registers action     new IndexNameExpressionResolver()).     transportService.start().     transportService.acceptIncomingRequests().     final ClusterState.Builder builder = builder(new ClusterName("cluster")).nodes(new Builder().add(localNode).add(otherNode1).add(otherNode2).localNodeId(localNode.getId()).masterNodeId(localNode.getId())).     builder.metaData(MetaData.builder().coordinationMetaData(CoordinationMetaData.builder().addVotingConfigExclusion(otherNode1Exclusion).addVotingConfigExclusion(otherNode2Exclusion).build())).     setState(clusterService, builder). }
false;public;0;18;;public void testClearsVotingConfigExclusions() throws InterruptedException {     final CountDownLatch countDownLatch = new CountDownLatch(1).     final SetOnce<ClearVotingConfigExclusionsResponse> responseHolder = new SetOnce<>().     final ClearVotingConfigExclusionsRequest clearVotingConfigExclusionsRequest = new ClearVotingConfigExclusionsRequest().     clearVotingConfigExclusionsRequest.setWaitForRemoval(false).     transportService.sendRequest(localNode, ClearVotingConfigExclusionsAction.NAME, clearVotingConfigExclusionsRequest, expectSuccess(r -> {         responseHolder.set(r).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     assertNotNull(responseHolder.get()).     assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(), empty()). }
false;public;0;22;;public void testTimesOutIfWaitingForNodesThatAreNotRemoved() throws InterruptedException {     final CountDownLatch countDownLatch = new CountDownLatch(1).     final SetOnce<TransportException> responseHolder = new SetOnce<>().     final ClearVotingConfigExclusionsRequest clearVotingConfigExclusionsRequest = new ClearVotingConfigExclusionsRequest().     clearVotingConfigExclusionsRequest.setTimeout(TimeValue.timeValueMillis(100)).     transportService.sendRequest(localNode, ClearVotingConfigExclusionsAction.NAME, clearVotingConfigExclusionsRequest, expectError(e -> {         responseHolder.set(e).         countDownLatch.countDown().     })).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(), containsInAnyOrder(otherNode1Exclusion, otherNode2Exclusion)).     final Throwable rootCause = responseHolder.get().getRootCause().     assertThat(rootCause, instanceOf(ElasticsearchTimeoutException.class)).     assertThat(rootCause.getMessage(), startsWith("timed out waiting for removal of nodes. if nodes should not be removed, set waitForRemoval to false. [")). }
false;public;0;19;;public void testSucceedsIfNodesAreRemovedWhileWaiting() throws InterruptedException {     final CountDownLatch countDownLatch = new CountDownLatch(1).     final SetOnce<ClearVotingConfigExclusionsResponse> responseHolder = new SetOnce<>().     transportService.sendRequest(localNode, ClearVotingConfigExclusionsAction.NAME, new ClearVotingConfigExclusionsRequest(), expectSuccess(r -> {         responseHolder.set(r).         countDownLatch.countDown().     })).     final ClusterState.Builder builder = builder(clusterService.state()).     builder.nodes(DiscoveryNodes.builder(clusterService.state().nodes()).remove(otherNode1).remove(otherNode2)).     setState(clusterService, builder).     assertTrue(countDownLatch.await(30, TimeUnit.SECONDS)).     assertThat(clusterService.getClusterApplierService().state().getVotingConfigExclusions(), empty()). }
false;private;1;6;;private TransportResponseHandler<ClearVotingConfigExclusionsResponse> expectSuccess(Consumer<ClearVotingConfigExclusionsResponse> onResponse) {     return responseHandler(onResponse, e -> {         throw new AssertionError("unexpected", e).     }). }
false;private;1;5;;private TransportResponseHandler<ClearVotingConfigExclusionsResponse> expectError(Consumer<TransportException> onException) {     return responseHandler(r -> {         assert false : r.     }, onException). }
false;public;1;4;;@Override public void handleResponse(ClearVotingConfigExclusionsResponse response) {     onResponse.accept(response). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     onException.accept(exp). }
false;public;0;4;;@Override public String executor() {     return Names.SAME. }
false;public;1;4;;@Override public ClearVotingConfigExclusionsResponse read(StreamInput in) throws IOException {     return new ClearVotingConfigExclusionsResponse(in). }
false;private;2;24;;private TransportResponseHandler<ClearVotingConfigExclusionsResponse> responseHandler(Consumer<ClearVotingConfigExclusionsResponse> onResponse, Consumer<TransportException> onException) {     return new TransportResponseHandler<ClearVotingConfigExclusionsResponse>() {          @Override         public void handleResponse(ClearVotingConfigExclusionsResponse response) {             onResponse.accept(response).         }          @Override         public void handleException(TransportException exp) {             onException.accept(exp).         }          @Override         public String executor() {             return Names.SAME.         }          @Override         public ClearVotingConfigExclusionsResponse read(StreamInput in) throws IOException {             return new ClearVotingConfigExclusionsResponse(in).         }     }. }
