commented;modifiers;parameterAmount;loc;comment;code
true;public,static;4;91;/**  * Creates cluster state with and index that has one shard and #(replicaStates) replicas  *  * @param index              name of the index  * @param activePrimaryLocal if active primary should coincide with the local node in the cluster state  * @param primaryState       state of primary  * @param replicaStates      states of the replicas. length of this array determines also the number of replicas  */ ;/**  * Creates cluster state with and index that has one shard and #(replicaStates) replicas  *  * @param index              name of the index  * @param activePrimaryLocal if active primary should coincide with the local node in the cluster state  * @param primaryState       state of primary  * @param replicaStates      states of the replicas. length of this array determines also the number of replicas  */ public static ClusterState state(String index, boolean activePrimaryLocal, ShardRoutingState primaryState, ShardRoutingState... replicaStates) {     final int numberOfReplicas = replicaStates.length.     int numberOfNodes = numberOfReplicas + 1.     if (primaryState == ShardRoutingState.RELOCATING) {         numberOfNodes++.     }     for (ShardRoutingState state : replicaStates) {         if (state == ShardRoutingState.RELOCATING) {             numberOfNodes++.         }     }     // we need a non-local master to test shard failures     numberOfNodes = Math.max(2, numberOfNodes).     final ShardId shardId = new ShardId(index, "_na_", 0).     DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder().     Set<String> unassignedNodes = new HashSet<>().     for (int i = 0. i < numberOfNodes + 1. i++) {         final DiscoveryNode node = newNode(i).         discoBuilder = discoBuilder.add(node).         unassignedNodes.add(node.getId()).     }     discoBuilder.localNodeId(newNode(0).getId()).     // we need a non-local master to test shard failures     discoBuilder.masterNodeId(newNode(1).getId()).     final int primaryTerm = 1 + randomInt(200).     IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).put(SETTING_NUMBER_OF_SHARDS, 1).put(SETTING_NUMBER_OF_REPLICAS, numberOfReplicas).put(SETTING_CREATION_DATE, System.currentTimeMillis())).primaryTerm(0, primaryTerm).build().     RoutingTable.Builder routing = new RoutingTable.Builder().     routing.addAsNew(indexMetaData).     IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId).     String primaryNode = null.     String relocatingNode = null.     UnassignedInfo unassignedInfo = null.     if (primaryState != ShardRoutingState.UNASSIGNED) {         if (activePrimaryLocal) {             primaryNode = newNode(0).getId().             unassignedNodes.remove(primaryNode).         } else {             Set<String> unassignedNodesExecludingPrimary = new HashSet<>(unassignedNodes).             unassignedNodesExecludingPrimary.remove(newNode(0).getId()).             primaryNode = selectAndRemove(unassignedNodesExecludingPrimary).             unassignedNodes.remove(primaryNode).         }         if (primaryState == ShardRoutingState.RELOCATING) {             relocatingNode = selectAndRemove(unassignedNodes).         } else if (primaryState == ShardRoutingState.INITIALIZING) {             unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null).         }     } else {         unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null).     }     indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, 0, primaryNode, relocatingNode, true, primaryState, unassignedInfo)).     for (ShardRoutingState replicaState : replicaStates) {         String replicaNode = null.         relocatingNode = null.         unassignedInfo = null.         if (replicaState != ShardRoutingState.UNASSIGNED) {             assert primaryNode != null : "a replica is assigned but the primary isn't".             replicaNode = selectAndRemove(unassignedNodes).             if (replicaState == ShardRoutingState.RELOCATING) {                 relocatingNode = selectAndRemove(unassignedNodes).             }         } else {             unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null).         }         indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, shardId.id(), replicaNode, relocatingNode, false, replicaState, unassignedInfo)).     }     final IndexShardRoutingTable indexShardRoutingTable = indexShardRoutingBuilder.build().     IndexMetaData.Builder indexMetaDataBuilder = new IndexMetaData.Builder(indexMetaData).     indexMetaDataBuilder.putInSyncAllocationIds(0, indexShardRoutingTable.activeShards().stream().map(ShardRouting::allocationId).map(AllocationId::getId).collect(Collectors.toSet())).     ClusterState.Builder state = ClusterState.builder(new ClusterName("test")).     state.nodes(discoBuilder).     state.metaData(MetaData.builder().put(indexMetaDataBuilder.build(), false).generateClusterUuidIfNeeded()).     state.routingTable(RoutingTable.builder().add(IndexRoutingTable.builder(indexMetaData.getIndex()).addIndexShard(indexShardRoutingTable)).build()).     return state.build(). }
true;public,static;3;33;/**  * Creates cluster state with an index that has #(numberOfPrimaries) primary shards in the started state and no replicas.  * The cluster state contains #(numberOfNodes) nodes and assigns primaries to those nodes.  */ ;/**  * Creates cluster state with an index that has #(numberOfPrimaries) primary shards in the started state and no replicas.  * The cluster state contains #(numberOfNodes) nodes and assigns primaries to those nodes.  */ public static ClusterState state(String index, final int numberOfNodes, final int numberOfPrimaries) {     DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder().     Set<String> nodes = new HashSet<>().     for (int i = 0. i < numberOfNodes. i++) {         final DiscoveryNode node = newNode(i).         discoBuilder = discoBuilder.add(node).         nodes.add(node.getId()).     }     discoBuilder.localNodeId(newNode(0).getId()).     discoBuilder.masterNodeId(randomFrom(nodes)).     IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).put(SETTING_NUMBER_OF_SHARDS, numberOfPrimaries).put(SETTING_NUMBER_OF_REPLICAS, 0).put(SETTING_CREATION_DATE, System.currentTimeMillis())).build().     RoutingTable.Builder routing = new RoutingTable.Builder().     routing.addAsNew(indexMetaData).     IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(indexMetaData.getIndex()).     for (int i = 0. i < numberOfPrimaries. i++) {         ShardId shardId = new ShardId(indexMetaData.getIndex(), i).         IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId).         indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(shardId, randomFrom(nodes), true, ShardRoutingState.STARTED)).         indexRoutingTable.addIndexShard(indexShardRoutingBuilder.build()).     }     ClusterState.Builder state = ClusterState.builder(new ClusterName("test")).     state.nodes(discoBuilder).     state.metaData(MetaData.builder().put(indexMetaData, false).generateClusterUuidIfNeeded()).     state.routingTable(RoutingTable.builder().add(indexRoutingTable).build()).     return state.build(). }
true;public,static;3;44;/**  * Creates cluster state with the given indices, each index containing #(numberOfPrimaries)  * started primary shards and no replicas.  The cluster state contains #(numberOfNodes) nodes  * and assigns primaries to those nodes.  */ ;/**  * Creates cluster state with the given indices, each index containing #(numberOfPrimaries)  * started primary shards and no replicas.  The cluster state contains #(numberOfNodes) nodes  * and assigns primaries to those nodes.  */ public static ClusterState state(final int numberOfNodes, final String[] indices, final int numberOfPrimaries) {     DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder().     Set<String> nodes = new HashSet<>().     for (int i = 0. i < numberOfNodes. i++) {         final DiscoveryNode node = newNode(i).         discoBuilder = discoBuilder.add(node).         nodes.add(node.getId()).     }     discoBuilder.localNodeId(newNode(0).getId()).     discoBuilder.masterNodeId(newNode(0).getId()).     MetaData.Builder metaData = MetaData.builder().     RoutingTable.Builder routingTable = RoutingTable.builder().     List<String> nodesList = new ArrayList<>(nodes).     int currentNodeToAssign = 0.     for (String index : indices) {         IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).put(SETTING_NUMBER_OF_SHARDS, numberOfPrimaries).put(SETTING_NUMBER_OF_REPLICAS, 0).put(SETTING_CREATION_DATE, System.currentTimeMillis())).build().         RoutingTable.Builder routing = new RoutingTable.Builder().         routing.addAsNew(indexMetaData).         IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(indexMetaData.getIndex()).         for (int i = 0. i < numberOfPrimaries. i++) {             ShardId shardId = new ShardId(indexMetaData.getIndex(), i).             IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId).             indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(shardId, nodesList.get(currentNodeToAssign++), true, ShardRoutingState.STARTED)).             if (currentNodeToAssign == nodesList.size()) {                 currentNodeToAssign = 0.             }             indexRoutingTable.addIndexShard(indexShardRoutingBuilder.build()).         }         metaData.put(indexMetaData, false).         routingTable.add(indexRoutingTable).     }     ClusterState.Builder state = ClusterState.builder(new ClusterName("test")).     state.nodes(discoBuilder).     state.metaData(metaData.generateClusterUuidIfNeeded().build()).     state.routingTable(routingTable.build()).     return state.build(). }
true;public,static;2;32;/**  * Creates cluster state with several shards and one replica and all shards STARTED.  */ ;/**  * Creates cluster state with several shards and one replica and all shards STARTED.  */ public static ClusterState stateWithAssignedPrimariesAndOneReplica(String index, int numberOfShards) {     // we need a non-local master to test shard failures     int numberOfNodes = 2.     DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder().     for (int i = 0. i < numberOfNodes + 1. i++) {         final DiscoveryNode node = newNode(i).         discoBuilder = discoBuilder.add(node).     }     discoBuilder.localNodeId(newNode(0).getId()).     // we need a non-local master to test shard failures     discoBuilder.masterNodeId(newNode(1).getId()).     IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).put(SETTING_NUMBER_OF_SHARDS, numberOfShards).put(SETTING_NUMBER_OF_REPLICAS, 1).put(SETTING_CREATION_DATE, System.currentTimeMillis())).build().     ClusterState.Builder state = ClusterState.builder(new ClusterName("test")).     state.nodes(discoBuilder).     state.metaData(MetaData.builder().put(indexMetaData, false).generateClusterUuidIfNeeded()).     IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(indexMetaData.getIndex()).     for (int i = 0. i < numberOfShards. i++) {         RoutingTable.Builder routing = new RoutingTable.Builder().         routing.addAsNew(indexMetaData).         final ShardId shardId = new ShardId(index, "_na_", i).         IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId).         indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(0).getId(), null, true, ShardRoutingState.STARTED)).         indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(1).getId(), null, false, ShardRoutingState.STARTED)).         indexRoutingTableBuilder.addIndexShard(indexShardRoutingBuilder.build()).     }     state.routingTable(RoutingTable.builder().add(indexRoutingTableBuilder.build()).build()).     return state.build(). }
true;public,static;3;40;/**  * Creates cluster state with several indexes, shards and replicas and all shards STARTED.  */ ;/**  * Creates cluster state with several indexes, shards and replicas and all shards STARTED.  */ public static ClusterState stateWithAssignedPrimariesAndReplicas(String[] indices, int numberOfShards, int numberOfReplicas) {     int numberOfDataNodes = numberOfReplicas + 1.     DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder().     for (int i = 0. i < numberOfDataNodes + 1. i++) {         final DiscoveryNode node = newNode(i).         discoBuilder = discoBuilder.add(node).     }     discoBuilder.localNodeId(newNode(0).getId()).     discoBuilder.masterNodeId(newNode(numberOfDataNodes + 1).getId()).     ClusterState.Builder state = ClusterState.builder(new ClusterName("test")).     state.nodes(discoBuilder).     Builder routingTableBuilder = RoutingTable.builder().     org.elasticsearch.cluster.metadata.MetaData.Builder metadataBuilder = MetaData.builder().     for (String index : indices) {         IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).put(SETTING_NUMBER_OF_SHARDS, numberOfShards).put(SETTING_NUMBER_OF_REPLICAS, numberOfReplicas).put(SETTING_CREATION_DATE, System.currentTimeMillis())).build().         metadataBuilder.put(indexMetaData, false).generateClusterUuidIfNeeded().         IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(indexMetaData.getIndex()).         for (int i = 0. i < numberOfShards. i++) {             final ShardId shardId = new ShardId(index, "_na_", i).             IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId).             indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(0).getId(), null, true, ShardRoutingState.STARTED)).             for (int replica = 0. replica < numberOfReplicas. replica++) {                 indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(replica + 1).getId(), null, false, ShardRoutingState.STARTED)).             }             indexRoutingTableBuilder.addIndexShard(indexShardRoutingBuilder.build()).         }         routingTableBuilder.add(indexRoutingTableBuilder.build()).     }     state.metaData(metadataBuilder).     state.routingTable(routingTableBuilder.build()).     return state.build(). }
true;public,static;3;4;/**  * Creates cluster state with and index that has one shard and as many replicas as numberOfReplicas.  * Primary will be STARTED in cluster state but replicas will be one of UNASSIGNED, INITIALIZING, STARTED or RELOCATING.  *  * @param index              name of the index  * @param activePrimaryLocal if active primary should coincide with the local node in the cluster state  * @param numberOfReplicas   number of replicas  */ ;/**  * Creates cluster state with and index that has one shard and as many replicas as numberOfReplicas.  * Primary will be STARTED in cluster state but replicas will be one of UNASSIGNED, INITIALIZING, STARTED or RELOCATING.  *  * @param index              name of the index  * @param activePrimaryLocal if active primary should coincide with the local node in the cluster state  * @param numberOfReplicas   number of replicas  */ public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal, int numberOfReplicas) {     int assignedReplicas = randomIntBetween(0, numberOfReplicas).     return stateWithActivePrimary(index, activePrimaryLocal, assignedReplicas, numberOfReplicas - assignedReplicas). }
true;public,static;4;12;/**  * Creates cluster state with and index that has one shard and as many replicas as numberOfReplicas.  * Primary will be STARTED in cluster state. Some (unassignedReplicas) will be UNASSIGNED and  * some (assignedReplicas) will be one of INITIALIZING, STARTED or RELOCATING.  *  * @param index              name of the index  * @param activePrimaryLocal if active primary should coincide with the local node in the cluster state  * @param assignedReplicas   number of replicas that should have INITIALIZING, STARTED or RELOCATING state  * @param unassignedReplicas number of replicas that should be unassigned  */ ;/**  * Creates cluster state with and index that has one shard and as many replicas as numberOfReplicas.  * Primary will be STARTED in cluster state. Some (unassignedReplicas) will be UNASSIGNED and  * some (assignedReplicas) will be one of INITIALIZING, STARTED or RELOCATING.  *  * @param index              name of the index  * @param activePrimaryLocal if active primary should coincide with the local node in the cluster state  * @param assignedReplicas   number of replicas that should have INITIALIZING, STARTED or RELOCATING state  * @param unassignedReplicas number of replicas that should be unassigned  */ public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal, int assignedReplicas, int unassignedReplicas) {     ShardRoutingState[] replicaStates = new ShardRoutingState[assignedReplicas + unassignedReplicas].     // no point in randomizing - node assignment later on does it too.     for (int i = 0. i < assignedReplicas. i++) {         replicaStates[i] = randomFrom(ShardRoutingState.INITIALIZING, ShardRoutingState.STARTED, ShardRoutingState.RELOCATING).     }     for (int i = assignedReplicas. i < replicaStates.length. i++) {         replicaStates[i] = ShardRoutingState.UNASSIGNED.     }     return state(index, activePrimaryLocal, randomFrom(ShardRoutingState.STARTED, ShardRoutingState.RELOCATING), replicaStates). }
true;public,static;0;10;/**  * Creates a cluster state with no index  */ ;/**  * Creates a cluster state with no index  */ public static ClusterState stateWithNoShard() {     DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder().     discoBuilder.localNodeId(newNode(0).getId()).     discoBuilder.masterNodeId(newNode(1).getId()).     ClusterState.Builder state = ClusterState.builder(new ClusterName("test")).     state.nodes(discoBuilder).     state.metaData(MetaData.builder().generateClusterUuidIfNeeded()).     state.routingTable(RoutingTable.builder().build()).     return state.build(). }
true;public,static;3;15;/**  * Creates a cluster state where local node and master node can be specified  *  * @param localNode  node in allNodes that is the local node  * @param masterNode node in allNodes that is the master node. Can be null if no master exists  * @param allNodes   all nodes in the cluster  * @return cluster state  */ ;/**  * Creates a cluster state where local node and master node can be specified  *  * @param localNode  node in allNodes that is the local node  * @param masterNode node in allNodes that is the master node. Can be null if no master exists  * @param allNodes   all nodes in the cluster  * @return cluster state  */ public static ClusterState state(DiscoveryNode localNode, DiscoveryNode masterNode, DiscoveryNode... allNodes) {     DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder().     for (DiscoveryNode node : allNodes) {         discoBuilder.add(node).     }     if (masterNode != null) {         discoBuilder.masterNodeId(masterNode.getId()).     }     discoBuilder.localNodeId(localNode.getId()).     ClusterState.Builder state = ClusterState.builder(new ClusterName("test")).     state.nodes(discoBuilder).     state.metaData(MetaData.builder().generateClusterUuidIfNeeded()).     return state.build(). }
false;private,static;1;4;;private static DiscoveryNode newNode(int nodeId) {     return new DiscoveryNode("node_" + nodeId, ESTestCase.buildNewFakeTransportAddress(), Collections.emptyMap(), new HashSet<>(Arrays.asList(DiscoveryNode.Role.values())), Version.CURRENT). }
false;private,static;1;5;;private static String selectAndRemove(Set<String> strings) {     String selection = randomFrom(strings.toArray(new String[strings.size()])).     strings.remove(selection).     return selection. }
