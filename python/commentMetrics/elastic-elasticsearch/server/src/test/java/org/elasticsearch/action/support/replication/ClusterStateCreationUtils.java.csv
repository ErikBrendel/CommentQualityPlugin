# id;timestamp;commentText;codeText;commentWords;codeWords
ClusterStateCreationUtils -> public static ClusterState state(String index, boolean activePrimaryLocal, ShardRoutingState primaryState,                                      ShardRoutingState... replicaStates);1524684173;Creates cluster state with and index that has one shard and #(replicaStates) replicas__@param index              name of the index_@param activePrimaryLocal if active primary should coincide with the local node in the cluster state_@param primaryState       state of primary_@param replicaStates      states of the replicas. length of this array determines also the number of replicas;public static ClusterState state(String index, boolean activePrimaryLocal, ShardRoutingState primaryState,_                                     ShardRoutingState... replicaStates) {_        final int numberOfReplicas = replicaStates.length___        int numberOfNodes = numberOfReplicas + 1__        if (primaryState == ShardRoutingState.RELOCATING) {_            numberOfNodes++__        }_        for (ShardRoutingState state : replicaStates) {_            if (state == ShardRoutingState.RELOCATING) {_                numberOfNodes++__            }_        }_        numberOfNodes = Math.max(2, numberOfNodes)_ _        final ShardId shardId = new ShardId(index, "_na_", 0)__        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        Set<String> unassignedNodes = new HashSet<>()__        for (int i = 0_ i < numberOfNodes + 1_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__            unassignedNodes.add(node.getId())__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(1).getId())_ _        final int primaryTerm = 1 + randomInt(200)__        IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, 1).put(SETTING_NUMBER_OF_REPLICAS, numberOfReplicas)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).primaryTerm(0, primaryTerm).build()___        RoutingTable.Builder routing = new RoutingTable.Builder()__        routing.addAsNew(indexMetaData)__        IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)___        String primaryNode = null__        String relocatingNode = null__        UnassignedInfo unassignedInfo = null__        if (primaryState != ShardRoutingState.UNASSIGNED) {_            if (activePrimaryLocal) {_                primaryNode = newNode(0).getId()__                unassignedNodes.remove(primaryNode)__            } else {_                Set<String> unassignedNodesExecludingPrimary = new HashSet<>(unassignedNodes)__                unassignedNodesExecludingPrimary.remove(newNode(0).getId())__                primaryNode = selectAndRemove(unassignedNodesExecludingPrimary)__                unassignedNodes.remove(primaryNode)__            }_            if (primaryState == ShardRoutingState.RELOCATING) {_                relocatingNode = selectAndRemove(unassignedNodes)__            }_        } else {_            unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null)__        }_        indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, 0, primaryNode, relocatingNode, true,_                primaryState, unassignedInfo))___        for (ShardRoutingState replicaState : replicaStates) {_            String replicaNode = null__            relocatingNode = null__            unassignedInfo = null__            if (replicaState != ShardRoutingState.UNASSIGNED) {_                assert primaryNode != null : "a replica is assigned but the primary isn't"__                replicaNode = selectAndRemove(unassignedNodes)__                if (replicaState == ShardRoutingState.RELOCATING) {_                    relocatingNode = selectAndRemove(unassignedNodes)__                }_            } else {_                unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null)__            }_            indexShardRoutingBuilder.addShard(_                    TestShardRouting.newShardRouting(index, shardId.id(), replicaNode, relocatingNode, false, replicaState,_                            unassignedInfo))__        }__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().put(indexMetaData, false).generateClusterUuidIfNeeded())__        state.routingTable(RoutingTable.builder().add(IndexRoutingTable.builder(indexMetaData.getIndex())_                .addIndexShard(indexShardRoutingBuilder.build())).build())__        return state.build()__    };creates,cluster,state,with,and,index,that,has,one,shard,and,replica,states,replicas,param,index,name,of,the,index,param,active,primary,local,if,active,primary,should,coincide,with,the,local,node,in,the,cluster,state,param,primary,state,state,of,primary,param,replica,states,states,of,the,replicas,length,of,this,array,determines,also,the,number,of,replicas;public,static,cluster,state,state,string,index,boolean,active,primary,local,shard,routing,state,primary,state,shard,routing,state,replica,states,final,int,number,of,replicas,replica,states,length,int,number,of,nodes,number,of,replicas,1,if,primary,state,shard,routing,state,relocating,number,of,nodes,for,shard,routing,state,state,replica,states,if,state,shard,routing,state,relocating,number,of,nodes,number,of,nodes,math,max,2,number,of,nodes,final,shard,id,shard,id,new,shard,id,index,0,discovery,nodes,builder,disco,builder,discovery,nodes,builder,set,string,unassigned,nodes,new,hash,set,for,int,i,0,i,number,of,nodes,1,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,unassigned,nodes,add,node,get,id,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,1,get,id,final,int,primary,term,1,random,int,200,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,1,put,number,of,replicas,put,system,current,time,millis,primary,term,0,primary,term,build,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,string,primary,node,null,string,relocating,node,null,unassigned,info,unassigned,info,null,if,primary,state,shard,routing,state,unassigned,if,active,primary,local,primary,node,new,node,0,get,id,unassigned,nodes,remove,primary,node,else,set,string,unassigned,nodes,execluding,primary,new,hash,set,unassigned,nodes,unassigned,nodes,execluding,primary,remove,new,node,0,get,id,primary,node,select,and,remove,unassigned,nodes,execluding,primary,unassigned,nodes,remove,primary,node,if,primary,state,shard,routing,state,relocating,relocating,node,select,and,remove,unassigned,nodes,else,unassigned,info,new,unassigned,info,unassigned,info,reason,null,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,0,primary,node,relocating,node,true,primary,state,unassigned,info,for,shard,routing,state,replica,state,replica,states,string,replica,node,null,relocating,node,null,unassigned,info,null,if,replica,state,shard,routing,state,unassigned,assert,primary,node,null,a,replica,is,assigned,but,the,primary,isn,t,replica,node,select,and,remove,unassigned,nodes,if,replica,state,shard,routing,state,relocating,relocating,node,select,and,remove,unassigned,nodes,else,unassigned,info,new,unassigned,info,unassigned,info,reason,null,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,shard,id,id,replica,node,relocating,node,false,replica,state,unassigned,info,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,put,index,meta,data,false,generate,cluster,uuid,if,needed,state,routing,table,routing,table,builder,add,index,routing,table,builder,index,meta,data,get,index,add,index,shard,index,shard,routing,builder,build,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState state(String index, boolean activePrimaryLocal, ShardRoutingState primaryState,                                      ShardRoutingState... replicaStates);1533063033;Creates cluster state with and index that has one shard and #(replicaStates) replicas__@param index              name of the index_@param activePrimaryLocal if active primary should coincide with the local node in the cluster state_@param primaryState       state of primary_@param replicaStates      states of the replicas. length of this array determines also the number of replicas;public static ClusterState state(String index, boolean activePrimaryLocal, ShardRoutingState primaryState,_                                     ShardRoutingState... replicaStates) {_        final int numberOfReplicas = replicaStates.length___        int numberOfNodes = numberOfReplicas + 1__        if (primaryState == ShardRoutingState.RELOCATING) {_            numberOfNodes++__        }_        for (ShardRoutingState state : replicaStates) {_            if (state == ShardRoutingState.RELOCATING) {_                numberOfNodes++__            }_        }_        numberOfNodes = Math.max(2, numberOfNodes)_ _        final ShardId shardId = new ShardId(index, "_na_", 0)__        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        Set<String> unassignedNodes = new HashSet<>()__        for (int i = 0_ i < numberOfNodes + 1_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__            unassignedNodes.add(node.getId())__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(1).getId())_ _        final int primaryTerm = 1 + randomInt(200)__        IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, 1).put(SETTING_NUMBER_OF_REPLICAS, numberOfReplicas)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).primaryTerm(0, primaryTerm)_            .build()___        RoutingTable.Builder routing = new RoutingTable.Builder()__        routing.addAsNew(indexMetaData)__        IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)___        String primaryNode = null__        String relocatingNode = null__        UnassignedInfo unassignedInfo = null__        if (primaryState != ShardRoutingState.UNASSIGNED) {_            if (activePrimaryLocal) {_                primaryNode = newNode(0).getId()__                unassignedNodes.remove(primaryNode)__            } else {_                Set<String> unassignedNodesExecludingPrimary = new HashSet<>(unassignedNodes)__                unassignedNodesExecludingPrimary.remove(newNode(0).getId())__                primaryNode = selectAndRemove(unassignedNodesExecludingPrimary)__                unassignedNodes.remove(primaryNode)__            }_            if (primaryState == ShardRoutingState.RELOCATING) {_                relocatingNode = selectAndRemove(unassignedNodes)__            }_        } else {_            unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null)__        }_        indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, 0, primaryNode, relocatingNode, true,_                primaryState, unassignedInfo))___        for (ShardRoutingState replicaState : replicaStates) {_            String replicaNode = null__            relocatingNode = null__            unassignedInfo = null__            if (replicaState != ShardRoutingState.UNASSIGNED) {_                assert primaryNode != null : "a replica is assigned but the primary isn't"__                replicaNode = selectAndRemove(unassignedNodes)__                if (replicaState == ShardRoutingState.RELOCATING) {_                    relocatingNode = selectAndRemove(unassignedNodes)__                }_            } else {_                unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null)__            }_            indexShardRoutingBuilder.addShard(_                    TestShardRouting.newShardRouting(index, shardId.id(), replicaNode, relocatingNode, false, replicaState,_                            unassignedInfo))__        }_        final IndexShardRoutingTable indexShardRoutingTable = indexShardRoutingBuilder.build()___        IndexMetaData.Builder indexMetaDataBuilder = new IndexMetaData.Builder(indexMetaData)__        indexMetaDataBuilder.putInSyncAllocationIds(0,_            indexShardRoutingTable.activeShards().stream().map(ShardRouting::allocationId).map(AllocationId::getId)_            .collect(Collectors.toSet())_        )___        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().put(indexMetaDataBuilder.build(), false).generateClusterUuidIfNeeded())__        state.routingTable(RoutingTable.builder().add(IndexRoutingTable.builder(indexMetaData.getIndex())_                .addIndexShard(indexShardRoutingTable)).build())__        return state.build()__    };creates,cluster,state,with,and,index,that,has,one,shard,and,replica,states,replicas,param,index,name,of,the,index,param,active,primary,local,if,active,primary,should,coincide,with,the,local,node,in,the,cluster,state,param,primary,state,state,of,primary,param,replica,states,states,of,the,replicas,length,of,this,array,determines,also,the,number,of,replicas;public,static,cluster,state,state,string,index,boolean,active,primary,local,shard,routing,state,primary,state,shard,routing,state,replica,states,final,int,number,of,replicas,replica,states,length,int,number,of,nodes,number,of,replicas,1,if,primary,state,shard,routing,state,relocating,number,of,nodes,for,shard,routing,state,state,replica,states,if,state,shard,routing,state,relocating,number,of,nodes,number,of,nodes,math,max,2,number,of,nodes,final,shard,id,shard,id,new,shard,id,index,0,discovery,nodes,builder,disco,builder,discovery,nodes,builder,set,string,unassigned,nodes,new,hash,set,for,int,i,0,i,number,of,nodes,1,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,unassigned,nodes,add,node,get,id,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,1,get,id,final,int,primary,term,1,random,int,200,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,1,put,number,of,replicas,put,system,current,time,millis,primary,term,0,primary,term,build,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,string,primary,node,null,string,relocating,node,null,unassigned,info,unassigned,info,null,if,primary,state,shard,routing,state,unassigned,if,active,primary,local,primary,node,new,node,0,get,id,unassigned,nodes,remove,primary,node,else,set,string,unassigned,nodes,execluding,primary,new,hash,set,unassigned,nodes,unassigned,nodes,execluding,primary,remove,new,node,0,get,id,primary,node,select,and,remove,unassigned,nodes,execluding,primary,unassigned,nodes,remove,primary,node,if,primary,state,shard,routing,state,relocating,relocating,node,select,and,remove,unassigned,nodes,else,unassigned,info,new,unassigned,info,unassigned,info,reason,null,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,0,primary,node,relocating,node,true,primary,state,unassigned,info,for,shard,routing,state,replica,state,replica,states,string,replica,node,null,relocating,node,null,unassigned,info,null,if,replica,state,shard,routing,state,unassigned,assert,primary,node,null,a,replica,is,assigned,but,the,primary,isn,t,replica,node,select,and,remove,unassigned,nodes,if,replica,state,shard,routing,state,relocating,relocating,node,select,and,remove,unassigned,nodes,else,unassigned,info,new,unassigned,info,unassigned,info,reason,null,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,shard,id,id,replica,node,relocating,node,false,replica,state,unassigned,info,final,index,shard,routing,table,index,shard,routing,table,index,shard,routing,builder,build,index,meta,data,builder,index,meta,data,builder,new,index,meta,data,builder,index,meta,data,index,meta,data,builder,put,in,sync,allocation,ids,0,index,shard,routing,table,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,put,index,meta,data,builder,build,false,generate,cluster,uuid,if,needed,state,routing,table,routing,table,builder,add,index,routing,table,builder,index,meta,data,get,index,add,index,shard,index,shard,routing,table,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState state(String index, boolean activePrimaryLocal, ShardRoutingState primaryState,                                      ShardRoutingState... replicaStates);1548431513;Creates cluster state with and index that has one shard and #(replicaStates) replicas__@param index              name of the index_@param activePrimaryLocal if active primary should coincide with the local node in the cluster state_@param primaryState       state of primary_@param replicaStates      states of the replicas. length of this array determines also the number of replicas;public static ClusterState state(String index, boolean activePrimaryLocal, ShardRoutingState primaryState,_                                     ShardRoutingState... replicaStates) {_        final int numberOfReplicas = replicaStates.length___        int numberOfNodes = numberOfReplicas + 1__        if (primaryState == ShardRoutingState.RELOCATING) {_            numberOfNodes++__        }_        for (ShardRoutingState state : replicaStates) {_            if (state == ShardRoutingState.RELOCATING) {_                numberOfNodes++__            }_        }_        numberOfNodes = Math.max(2, numberOfNodes)_ _        final ShardId shardId = new ShardId(index, "_na_", 0)__        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        Set<String> unassignedNodes = new HashSet<>()__        for (int i = 0_ i < numberOfNodes + 1_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__            unassignedNodes.add(node.getId())__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(1).getId())_ _        final int primaryTerm = 1 + randomInt(200)__        IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, 1).put(SETTING_NUMBER_OF_REPLICAS, numberOfReplicas)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).primaryTerm(0, primaryTerm)_            .build()___        RoutingTable.Builder routing = new RoutingTable.Builder()__        routing.addAsNew(indexMetaData)__        IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)___        String primaryNode = null__        String relocatingNode = null__        UnassignedInfo unassignedInfo = null__        if (primaryState != ShardRoutingState.UNASSIGNED) {_            if (activePrimaryLocal) {_                primaryNode = newNode(0).getId()__                unassignedNodes.remove(primaryNode)__            } else {_                Set<String> unassignedNodesExecludingPrimary = new HashSet<>(unassignedNodes)__                unassignedNodesExecludingPrimary.remove(newNode(0).getId())__                primaryNode = selectAndRemove(unassignedNodesExecludingPrimary)__                unassignedNodes.remove(primaryNode)__            }_            if (primaryState == ShardRoutingState.RELOCATING) {_                relocatingNode = selectAndRemove(unassignedNodes)__            } else if (primaryState == ShardRoutingState.INITIALIZING) {_                unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null)__            }_        } else {_            unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null)__        }_        indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, 0, primaryNode, relocatingNode, true,_                primaryState, unassignedInfo))___        for (ShardRoutingState replicaState : replicaStates) {_            String replicaNode = null__            relocatingNode = null__            unassignedInfo = null__            if (replicaState != ShardRoutingState.UNASSIGNED) {_                assert primaryNode != null : "a replica is assigned but the primary isn't"__                replicaNode = selectAndRemove(unassignedNodes)__                if (replicaState == ShardRoutingState.RELOCATING) {_                    relocatingNode = selectAndRemove(unassignedNodes)__                }_            } else {_                unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.INDEX_CREATED, null)__            }_            indexShardRoutingBuilder.addShard(_                    TestShardRouting.newShardRouting(index, shardId.id(), replicaNode, relocatingNode, false, replicaState,_                            unassignedInfo))__        }_        final IndexShardRoutingTable indexShardRoutingTable = indexShardRoutingBuilder.build()___        IndexMetaData.Builder indexMetaDataBuilder = new IndexMetaData.Builder(indexMetaData)__        indexMetaDataBuilder.putInSyncAllocationIds(0,_            indexShardRoutingTable.activeShards().stream().map(ShardRouting::allocationId).map(AllocationId::getId)_            .collect(Collectors.toSet())_        )___        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().put(indexMetaDataBuilder.build(), false).generateClusterUuidIfNeeded())__        state.routingTable(RoutingTable.builder().add(IndexRoutingTable.builder(indexMetaData.getIndex())_                .addIndexShard(indexShardRoutingTable)).build())__        return state.build()__    };creates,cluster,state,with,and,index,that,has,one,shard,and,replica,states,replicas,param,index,name,of,the,index,param,active,primary,local,if,active,primary,should,coincide,with,the,local,node,in,the,cluster,state,param,primary,state,state,of,primary,param,replica,states,states,of,the,replicas,length,of,this,array,determines,also,the,number,of,replicas;public,static,cluster,state,state,string,index,boolean,active,primary,local,shard,routing,state,primary,state,shard,routing,state,replica,states,final,int,number,of,replicas,replica,states,length,int,number,of,nodes,number,of,replicas,1,if,primary,state,shard,routing,state,relocating,number,of,nodes,for,shard,routing,state,state,replica,states,if,state,shard,routing,state,relocating,number,of,nodes,number,of,nodes,math,max,2,number,of,nodes,final,shard,id,shard,id,new,shard,id,index,0,discovery,nodes,builder,disco,builder,discovery,nodes,builder,set,string,unassigned,nodes,new,hash,set,for,int,i,0,i,number,of,nodes,1,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,unassigned,nodes,add,node,get,id,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,1,get,id,final,int,primary,term,1,random,int,200,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,1,put,number,of,replicas,put,system,current,time,millis,primary,term,0,primary,term,build,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,string,primary,node,null,string,relocating,node,null,unassigned,info,unassigned,info,null,if,primary,state,shard,routing,state,unassigned,if,active,primary,local,primary,node,new,node,0,get,id,unassigned,nodes,remove,primary,node,else,set,string,unassigned,nodes,execluding,primary,new,hash,set,unassigned,nodes,unassigned,nodes,execluding,primary,remove,new,node,0,get,id,primary,node,select,and,remove,unassigned,nodes,execluding,primary,unassigned,nodes,remove,primary,node,if,primary,state,shard,routing,state,relocating,relocating,node,select,and,remove,unassigned,nodes,else,if,primary,state,shard,routing,state,initializing,unassigned,info,new,unassigned,info,unassigned,info,reason,null,else,unassigned,info,new,unassigned,info,unassigned,info,reason,null,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,0,primary,node,relocating,node,true,primary,state,unassigned,info,for,shard,routing,state,replica,state,replica,states,string,replica,node,null,relocating,node,null,unassigned,info,null,if,replica,state,shard,routing,state,unassigned,assert,primary,node,null,a,replica,is,assigned,but,the,primary,isn,t,replica,node,select,and,remove,unassigned,nodes,if,replica,state,shard,routing,state,relocating,relocating,node,select,and,remove,unassigned,nodes,else,unassigned,info,new,unassigned,info,unassigned,info,reason,null,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,shard,id,id,replica,node,relocating,node,false,replica,state,unassigned,info,final,index,shard,routing,table,index,shard,routing,table,index,shard,routing,builder,build,index,meta,data,builder,index,meta,data,builder,new,index,meta,data,builder,index,meta,data,index,meta,data,builder,put,in,sync,allocation,ids,0,index,shard,routing,table,active,shards,stream,map,shard,routing,allocation,id,map,allocation,id,get,id,collect,collectors,to,set,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,put,index,meta,data,builder,build,false,generate,cluster,uuid,if,needed,state,routing,table,routing,table,builder,add,index,routing,table,builder,index,meta,data,get,index,add,index,shard,index,shard,routing,table,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal,                                                       int assignedReplicas, int unassignedReplicas);1524684173;Creates cluster state with and index that has one shard and as many replicas as numberOfReplicas._Primary will be STARTED in cluster state. Some (unassignedReplicas) will be UNASSIGNED and_some (assignedReplicas) will be one of INITIALIZING, STARTED or RELOCATING.__@param index              name of the index_@param activePrimaryLocal if active primary should coincide with the local node in the cluster state_@param assignedReplicas   number of replicas that should have INITIALIZING, STARTED or RELOCATING state_@param unassignedReplicas number of replicas that should be unassigned;public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal,_                                                      int assignedReplicas, int unassignedReplicas) {_        ShardRoutingState[] replicaStates = new ShardRoutingState[assignedReplicas + unassignedReplicas]__        _        for (int i = 0_ i < assignedReplicas_ i++) {_            replicaStates[i] = randomFrom(ShardRoutingState.INITIALIZING, ShardRoutingState.STARTED, ShardRoutingState.RELOCATING)__        }_        for (int i = assignedReplicas_ i < replicaStates.length_ i++) {_            replicaStates[i] = ShardRoutingState.UNASSIGNED__        }_        return state(index, activePrimaryLocal, randomFrom(ShardRoutingState.STARTED, ShardRoutingState.RELOCATING), replicaStates)__    };creates,cluster,state,with,and,index,that,has,one,shard,and,as,many,replicas,as,number,of,replicas,primary,will,be,started,in,cluster,state,some,unassigned,replicas,will,be,unassigned,and,some,assigned,replicas,will,be,one,of,initializing,started,or,relocating,param,index,name,of,the,index,param,active,primary,local,if,active,primary,should,coincide,with,the,local,node,in,the,cluster,state,param,assigned,replicas,number,of,replicas,that,should,have,initializing,started,or,relocating,state,param,unassigned,replicas,number,of,replicas,that,should,be,unassigned;public,static,cluster,state,state,with,active,primary,string,index,boolean,active,primary,local,int,assigned,replicas,int,unassigned,replicas,shard,routing,state,replica,states,new,shard,routing,state,assigned,replicas,unassigned,replicas,for,int,i,0,i,assigned,replicas,i,replica,states,i,random,from,shard,routing,state,initializing,shard,routing,state,started,shard,routing,state,relocating,for,int,i,assigned,replicas,i,replica,states,length,i,replica,states,i,shard,routing,state,unassigned,return,state,index,active,primary,local,random,from,shard,routing,state,started,shard,routing,state,relocating,replica,states
ClusterStateCreationUtils -> public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal,                                                       int assignedReplicas, int unassignedReplicas);1533063033;Creates cluster state with and index that has one shard and as many replicas as numberOfReplicas._Primary will be STARTED in cluster state. Some (unassignedReplicas) will be UNASSIGNED and_some (assignedReplicas) will be one of INITIALIZING, STARTED or RELOCATING.__@param index              name of the index_@param activePrimaryLocal if active primary should coincide with the local node in the cluster state_@param assignedReplicas   number of replicas that should have INITIALIZING, STARTED or RELOCATING state_@param unassignedReplicas number of replicas that should be unassigned;public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal,_                                                      int assignedReplicas, int unassignedReplicas) {_        ShardRoutingState[] replicaStates = new ShardRoutingState[assignedReplicas + unassignedReplicas]__        _        for (int i = 0_ i < assignedReplicas_ i++) {_            replicaStates[i] = randomFrom(ShardRoutingState.INITIALIZING, ShardRoutingState.STARTED, ShardRoutingState.RELOCATING)__        }_        for (int i = assignedReplicas_ i < replicaStates.length_ i++) {_            replicaStates[i] = ShardRoutingState.UNASSIGNED__        }_        return state(index, activePrimaryLocal, randomFrom(ShardRoutingState.STARTED, ShardRoutingState.RELOCATING), replicaStates)__    };creates,cluster,state,with,and,index,that,has,one,shard,and,as,many,replicas,as,number,of,replicas,primary,will,be,started,in,cluster,state,some,unassigned,replicas,will,be,unassigned,and,some,assigned,replicas,will,be,one,of,initializing,started,or,relocating,param,index,name,of,the,index,param,active,primary,local,if,active,primary,should,coincide,with,the,local,node,in,the,cluster,state,param,assigned,replicas,number,of,replicas,that,should,have,initializing,started,or,relocating,state,param,unassigned,replicas,number,of,replicas,that,should,be,unassigned;public,static,cluster,state,state,with,active,primary,string,index,boolean,active,primary,local,int,assigned,replicas,int,unassigned,replicas,shard,routing,state,replica,states,new,shard,routing,state,assigned,replicas,unassigned,replicas,for,int,i,0,i,assigned,replicas,i,replica,states,i,random,from,shard,routing,state,initializing,shard,routing,state,started,shard,routing,state,relocating,for,int,i,assigned,replicas,i,replica,states,length,i,replica,states,i,shard,routing,state,unassigned,return,state,index,active,primary,local,random,from,shard,routing,state,started,shard,routing,state,relocating,replica,states
ClusterStateCreationUtils -> public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal,                                                       int assignedReplicas, int unassignedReplicas);1548431513;Creates cluster state with and index that has one shard and as many replicas as numberOfReplicas._Primary will be STARTED in cluster state. Some (unassignedReplicas) will be UNASSIGNED and_some (assignedReplicas) will be one of INITIALIZING, STARTED or RELOCATING.__@param index              name of the index_@param activePrimaryLocal if active primary should coincide with the local node in the cluster state_@param assignedReplicas   number of replicas that should have INITIALIZING, STARTED or RELOCATING state_@param unassignedReplicas number of replicas that should be unassigned;public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal,_                                                      int assignedReplicas, int unassignedReplicas) {_        ShardRoutingState[] replicaStates = new ShardRoutingState[assignedReplicas + unassignedReplicas]__        _        for (int i = 0_ i < assignedReplicas_ i++) {_            replicaStates[i] = randomFrom(ShardRoutingState.INITIALIZING, ShardRoutingState.STARTED, ShardRoutingState.RELOCATING)__        }_        for (int i = assignedReplicas_ i < replicaStates.length_ i++) {_            replicaStates[i] = ShardRoutingState.UNASSIGNED__        }_        return state(index, activePrimaryLocal, randomFrom(ShardRoutingState.STARTED, ShardRoutingState.RELOCATING), replicaStates)__    };creates,cluster,state,with,and,index,that,has,one,shard,and,as,many,replicas,as,number,of,replicas,primary,will,be,started,in,cluster,state,some,unassigned,replicas,will,be,unassigned,and,some,assigned,replicas,will,be,one,of,initializing,started,or,relocating,param,index,name,of,the,index,param,active,primary,local,if,active,primary,should,coincide,with,the,local,node,in,the,cluster,state,param,assigned,replicas,number,of,replicas,that,should,have,initializing,started,or,relocating,state,param,unassigned,replicas,number,of,replicas,that,should,be,unassigned;public,static,cluster,state,state,with,active,primary,string,index,boolean,active,primary,local,int,assigned,replicas,int,unassigned,replicas,shard,routing,state,replica,states,new,shard,routing,state,assigned,replicas,unassigned,replicas,for,int,i,0,i,assigned,replicas,i,replica,states,i,random,from,shard,routing,state,initializing,shard,routing,state,started,shard,routing,state,relocating,for,int,i,assigned,replicas,i,replica,states,length,i,replica,states,i,shard,routing,state,unassigned,return,state,index,active,primary,local,random,from,shard,routing,state,started,shard,routing,state,relocating,replica,states
ClusterStateCreationUtils -> public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal, int numberOfReplicas);1524684173;Creates cluster state with and index that has one shard and as many replicas as numberOfReplicas._Primary will be STARTED in cluster state but replicas will be one of UNASSIGNED, INITIALIZING, STARTED or RELOCATING.__@param index              name of the index_@param activePrimaryLocal if active primary should coincide with the local node in the cluster state_@param numberOfReplicas   number of replicas;public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal, int numberOfReplicas) {_        int assignedReplicas = randomIntBetween(0, numberOfReplicas)__        return stateWithActivePrimary(index, activePrimaryLocal, assignedReplicas, numberOfReplicas - assignedReplicas)__    };creates,cluster,state,with,and,index,that,has,one,shard,and,as,many,replicas,as,number,of,replicas,primary,will,be,started,in,cluster,state,but,replicas,will,be,one,of,unassigned,initializing,started,or,relocating,param,index,name,of,the,index,param,active,primary,local,if,active,primary,should,coincide,with,the,local,node,in,the,cluster,state,param,number,of,replicas,number,of,replicas;public,static,cluster,state,state,with,active,primary,string,index,boolean,active,primary,local,int,number,of,replicas,int,assigned,replicas,random,int,between,0,number,of,replicas,return,state,with,active,primary,index,active,primary,local,assigned,replicas,number,of,replicas,assigned,replicas
ClusterStateCreationUtils -> public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal, int numberOfReplicas);1533063033;Creates cluster state with and index that has one shard and as many replicas as numberOfReplicas._Primary will be STARTED in cluster state but replicas will be one of UNASSIGNED, INITIALIZING, STARTED or RELOCATING.__@param index              name of the index_@param activePrimaryLocal if active primary should coincide with the local node in the cluster state_@param numberOfReplicas   number of replicas;public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal, int numberOfReplicas) {_        int assignedReplicas = randomIntBetween(0, numberOfReplicas)__        return stateWithActivePrimary(index, activePrimaryLocal, assignedReplicas, numberOfReplicas - assignedReplicas)__    };creates,cluster,state,with,and,index,that,has,one,shard,and,as,many,replicas,as,number,of,replicas,primary,will,be,started,in,cluster,state,but,replicas,will,be,one,of,unassigned,initializing,started,or,relocating,param,index,name,of,the,index,param,active,primary,local,if,active,primary,should,coincide,with,the,local,node,in,the,cluster,state,param,number,of,replicas,number,of,replicas;public,static,cluster,state,state,with,active,primary,string,index,boolean,active,primary,local,int,number,of,replicas,int,assigned,replicas,random,int,between,0,number,of,replicas,return,state,with,active,primary,index,active,primary,local,assigned,replicas,number,of,replicas,assigned,replicas
ClusterStateCreationUtils -> public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal, int numberOfReplicas);1548431513;Creates cluster state with and index that has one shard and as many replicas as numberOfReplicas._Primary will be STARTED in cluster state but replicas will be one of UNASSIGNED, INITIALIZING, STARTED or RELOCATING.__@param index              name of the index_@param activePrimaryLocal if active primary should coincide with the local node in the cluster state_@param numberOfReplicas   number of replicas;public static ClusterState stateWithActivePrimary(String index, boolean activePrimaryLocal, int numberOfReplicas) {_        int assignedReplicas = randomIntBetween(0, numberOfReplicas)__        return stateWithActivePrimary(index, activePrimaryLocal, assignedReplicas, numberOfReplicas - assignedReplicas)__    };creates,cluster,state,with,and,index,that,has,one,shard,and,as,many,replicas,as,number,of,replicas,primary,will,be,started,in,cluster,state,but,replicas,will,be,one,of,unassigned,initializing,started,or,relocating,param,index,name,of,the,index,param,active,primary,local,if,active,primary,should,coincide,with,the,local,node,in,the,cluster,state,param,number,of,replicas,number,of,replicas;public,static,cluster,state,state,with,active,primary,string,index,boolean,active,primary,local,int,number,of,replicas,int,assigned,replicas,random,int,between,0,number,of,replicas,return,state,with,active,primary,index,active,primary,local,assigned,replicas,number,of,replicas,assigned,replicas
ClusterStateCreationUtils -> public static ClusterState state(String index, final int numberOfNodes, final int numberOfPrimaries);1524684173;Creates cluster state with an index that has #(numberOfPrimaries) primary shards in the started state and no replicas._The cluster state contains #(numberOfNodes) nodes and assigns primaries to those nodes.;public static ClusterState state(String index, final int numberOfNodes, final int numberOfPrimaries) {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        Set<String> nodes = new HashSet<>()__        for (int i = 0_ i < numberOfNodes_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__            nodes.add(node.getId())__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(randomFrom(nodes))__        IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_            .put(SETTING_VERSION_CREATED, Version.CURRENT)_            .put(SETTING_NUMBER_OF_SHARDS, numberOfPrimaries).put(SETTING_NUMBER_OF_REPLICAS, 0)_            .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()___        RoutingTable.Builder routing = new RoutingTable.Builder()__        routing.addAsNew(indexMetaData)___        IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(indexMetaData.getIndex())__        for (int i = 0_ i < numberOfPrimaries_ i++) {_            ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__            IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__            indexShardRoutingBuilder.addShard(_                TestShardRouting.newShardRouting(shardId, randomFrom(nodes), true, ShardRoutingState.STARTED))__            indexRoutingTable.addIndexShard(indexShardRoutingBuilder.build())__        }__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().put(indexMetaData, false).generateClusterUuidIfNeeded())__        state.routingTable(RoutingTable.builder().add(indexRoutingTable).build())__        return state.build()__    };creates,cluster,state,with,an,index,that,has,number,of,primaries,primary,shards,in,the,started,state,and,no,replicas,the,cluster,state,contains,number,of,nodes,nodes,and,assigns,primaries,to,those,nodes;public,static,cluster,state,state,string,index,final,int,number,of,nodes,final,int,number,of,primaries,discovery,nodes,builder,disco,builder,discovery,nodes,builder,set,string,nodes,new,hash,set,for,int,i,0,i,number,of,nodes,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,nodes,add,node,get,id,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,random,from,nodes,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,primaries,put,0,put,system,current,time,millis,build,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,index,routing,table,builder,index,routing,table,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,primaries,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,shard,id,random,from,nodes,true,shard,routing,state,started,index,routing,table,add,index,shard,index,shard,routing,builder,build,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,put,index,meta,data,false,generate,cluster,uuid,if,needed,state,routing,table,routing,table,builder,add,index,routing,table,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState state(String index, final int numberOfNodes, final int numberOfPrimaries);1533063033;Creates cluster state with an index that has #(numberOfPrimaries) primary shards in the started state and no replicas._The cluster state contains #(numberOfNodes) nodes and assigns primaries to those nodes.;public static ClusterState state(String index, final int numberOfNodes, final int numberOfPrimaries) {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        Set<String> nodes = new HashSet<>()__        for (int i = 0_ i < numberOfNodes_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__            nodes.add(node.getId())__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(randomFrom(nodes))__        IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_            .put(SETTING_VERSION_CREATED, Version.CURRENT)_            .put(SETTING_NUMBER_OF_SHARDS, numberOfPrimaries).put(SETTING_NUMBER_OF_REPLICAS, 0)_            .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()___        RoutingTable.Builder routing = new RoutingTable.Builder()__        routing.addAsNew(indexMetaData)___        IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(indexMetaData.getIndex())__        for (int i = 0_ i < numberOfPrimaries_ i++) {_            ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__            IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__            indexShardRoutingBuilder.addShard(_                TestShardRouting.newShardRouting(shardId, randomFrom(nodes), true, ShardRoutingState.STARTED))__            indexRoutingTable.addIndexShard(indexShardRoutingBuilder.build())__        }__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().put(indexMetaData, false).generateClusterUuidIfNeeded())__        state.routingTable(RoutingTable.builder().add(indexRoutingTable).build())__        return state.build()__    };creates,cluster,state,with,an,index,that,has,number,of,primaries,primary,shards,in,the,started,state,and,no,replicas,the,cluster,state,contains,number,of,nodes,nodes,and,assigns,primaries,to,those,nodes;public,static,cluster,state,state,string,index,final,int,number,of,nodes,final,int,number,of,primaries,discovery,nodes,builder,disco,builder,discovery,nodes,builder,set,string,nodes,new,hash,set,for,int,i,0,i,number,of,nodes,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,nodes,add,node,get,id,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,random,from,nodes,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,primaries,put,0,put,system,current,time,millis,build,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,index,routing,table,builder,index,routing,table,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,primaries,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,shard,id,random,from,nodes,true,shard,routing,state,started,index,routing,table,add,index,shard,index,shard,routing,builder,build,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,put,index,meta,data,false,generate,cluster,uuid,if,needed,state,routing,table,routing,table,builder,add,index,routing,table,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState state(String index, final int numberOfNodes, final int numberOfPrimaries);1548431513;Creates cluster state with an index that has #(numberOfPrimaries) primary shards in the started state and no replicas._The cluster state contains #(numberOfNodes) nodes and assigns primaries to those nodes.;public static ClusterState state(String index, final int numberOfNodes, final int numberOfPrimaries) {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        Set<String> nodes = new HashSet<>()__        for (int i = 0_ i < numberOfNodes_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__            nodes.add(node.getId())__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(randomFrom(nodes))__        IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_            .put(SETTING_VERSION_CREATED, Version.CURRENT)_            .put(SETTING_NUMBER_OF_SHARDS, numberOfPrimaries).put(SETTING_NUMBER_OF_REPLICAS, 0)_            .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()___        RoutingTable.Builder routing = new RoutingTable.Builder()__        routing.addAsNew(indexMetaData)___        IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(indexMetaData.getIndex())__        for (int i = 0_ i < numberOfPrimaries_ i++) {_            ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__            IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__            indexShardRoutingBuilder.addShard(_                TestShardRouting.newShardRouting(shardId, randomFrom(nodes), true, ShardRoutingState.STARTED))__            indexRoutingTable.addIndexShard(indexShardRoutingBuilder.build())__        }__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().put(indexMetaData, false).generateClusterUuidIfNeeded())__        state.routingTable(RoutingTable.builder().add(indexRoutingTable).build())__        return state.build()__    };creates,cluster,state,with,an,index,that,has,number,of,primaries,primary,shards,in,the,started,state,and,no,replicas,the,cluster,state,contains,number,of,nodes,nodes,and,assigns,primaries,to,those,nodes;public,static,cluster,state,state,string,index,final,int,number,of,nodes,final,int,number,of,primaries,discovery,nodes,builder,disco,builder,discovery,nodes,builder,set,string,nodes,new,hash,set,for,int,i,0,i,number,of,nodes,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,nodes,add,node,get,id,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,random,from,nodes,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,primaries,put,0,put,system,current,time,millis,build,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,index,routing,table,builder,index,routing,table,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,primaries,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,shard,id,random,from,nodes,true,shard,routing,state,started,index,routing,table,add,index,shard,index,shard,routing,builder,build,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,put,index,meta,data,false,generate,cluster,uuid,if,needed,state,routing,table,routing,table,builder,add,index,routing,table,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState state(final int numberOfNodes, final String[] indices, final int numberOfPrimaries);1524684173;Creates cluster state with the given indices, each index containing #(numberOfPrimaries)_started primary shards and no replicas.  The cluster state contains #(numberOfNodes) nodes_and assigns primaries to those nodes.;public static ClusterState state(final int numberOfNodes, final String[] indices, final int numberOfPrimaries) {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        Set<String> nodes = new HashSet<>()__        for (int i = 0_ i < numberOfNodes_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__            nodes.add(node.getId())__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(0).getId())__        MetaData.Builder metaData = MetaData.builder()__        RoutingTable.Builder routingTable = RoutingTable.builder()__        List<String> nodesList = new ArrayList<>(nodes)__        int currentNodeToAssign = 0__        for (String index : indices) {_            IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, numberOfPrimaries).put(SETTING_NUMBER_OF_REPLICAS, 0)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()___            RoutingTable.Builder routing = new RoutingTable.Builder()__            routing.addAsNew(indexMetaData)___            IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(indexMetaData.getIndex())__            for (int i = 0_ i < numberOfPrimaries_ i++) {_                ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                indexShardRoutingBuilder.addShard(_                    TestShardRouting.newShardRouting(shardId, nodesList.get(currentNodeToAssign++), true, ShardRoutingState.STARTED))__                if (currentNodeToAssign == nodesList.size()) {_                    currentNodeToAssign = 0__                }_                indexRoutingTable.addIndexShard(indexShardRoutingBuilder.build())__            }__            metaData.put(indexMetaData, false)__            routingTable.add(indexRoutingTable)__        }_        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(metaData.generateClusterUuidIfNeeded().build())__        state.routingTable(routingTable.build())__        return state.build()__    };creates,cluster,state,with,the,given,indices,each,index,containing,number,of,primaries,started,primary,shards,and,no,replicas,the,cluster,state,contains,number,of,nodes,nodes,and,assigns,primaries,to,those,nodes;public,static,cluster,state,state,final,int,number,of,nodes,final,string,indices,final,int,number,of,primaries,discovery,nodes,builder,disco,builder,discovery,nodes,builder,set,string,nodes,new,hash,set,for,int,i,0,i,number,of,nodes,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,nodes,add,node,get,id,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,0,get,id,meta,data,builder,meta,data,meta,data,builder,routing,table,builder,routing,table,routing,table,builder,list,string,nodes,list,new,array,list,nodes,int,current,node,to,assign,0,for,string,index,indices,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,primaries,put,0,put,system,current,time,millis,build,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,index,routing,table,builder,index,routing,table,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,primaries,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,shard,id,nodes,list,get,current,node,to,assign,true,shard,routing,state,started,if,current,node,to,assign,nodes,list,size,current,node,to,assign,0,index,routing,table,add,index,shard,index,shard,routing,builder,build,meta,data,put,index,meta,data,false,routing,table,add,index,routing,table,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,generate,cluster,uuid,if,needed,build,state,routing,table,routing,table,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState state(final int numberOfNodes, final String[] indices, final int numberOfPrimaries);1533063033;Creates cluster state with the given indices, each index containing #(numberOfPrimaries)_started primary shards and no replicas.  The cluster state contains #(numberOfNodes) nodes_and assigns primaries to those nodes.;public static ClusterState state(final int numberOfNodes, final String[] indices, final int numberOfPrimaries) {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        Set<String> nodes = new HashSet<>()__        for (int i = 0_ i < numberOfNodes_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__            nodes.add(node.getId())__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(0).getId())__        MetaData.Builder metaData = MetaData.builder()__        RoutingTable.Builder routingTable = RoutingTable.builder()__        List<String> nodesList = new ArrayList<>(nodes)__        int currentNodeToAssign = 0__        for (String index : indices) {_            IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, numberOfPrimaries).put(SETTING_NUMBER_OF_REPLICAS, 0)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()___            RoutingTable.Builder routing = new RoutingTable.Builder()__            routing.addAsNew(indexMetaData)___            IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(indexMetaData.getIndex())__            for (int i = 0_ i < numberOfPrimaries_ i++) {_                ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                indexShardRoutingBuilder.addShard(_                    TestShardRouting.newShardRouting(shardId, nodesList.get(currentNodeToAssign++), true, ShardRoutingState.STARTED))__                if (currentNodeToAssign == nodesList.size()) {_                    currentNodeToAssign = 0__                }_                indexRoutingTable.addIndexShard(indexShardRoutingBuilder.build())__            }__            metaData.put(indexMetaData, false)__            routingTable.add(indexRoutingTable)__        }_        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(metaData.generateClusterUuidIfNeeded().build())__        state.routingTable(routingTable.build())__        return state.build()__    };creates,cluster,state,with,the,given,indices,each,index,containing,number,of,primaries,started,primary,shards,and,no,replicas,the,cluster,state,contains,number,of,nodes,nodes,and,assigns,primaries,to,those,nodes;public,static,cluster,state,state,final,int,number,of,nodes,final,string,indices,final,int,number,of,primaries,discovery,nodes,builder,disco,builder,discovery,nodes,builder,set,string,nodes,new,hash,set,for,int,i,0,i,number,of,nodes,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,nodes,add,node,get,id,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,0,get,id,meta,data,builder,meta,data,meta,data,builder,routing,table,builder,routing,table,routing,table,builder,list,string,nodes,list,new,array,list,nodes,int,current,node,to,assign,0,for,string,index,indices,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,primaries,put,0,put,system,current,time,millis,build,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,index,routing,table,builder,index,routing,table,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,primaries,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,shard,id,nodes,list,get,current,node,to,assign,true,shard,routing,state,started,if,current,node,to,assign,nodes,list,size,current,node,to,assign,0,index,routing,table,add,index,shard,index,shard,routing,builder,build,meta,data,put,index,meta,data,false,routing,table,add,index,routing,table,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,generate,cluster,uuid,if,needed,build,state,routing,table,routing,table,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState state(final int numberOfNodes, final String[] indices, final int numberOfPrimaries);1548431513;Creates cluster state with the given indices, each index containing #(numberOfPrimaries)_started primary shards and no replicas.  The cluster state contains #(numberOfNodes) nodes_and assigns primaries to those nodes.;public static ClusterState state(final int numberOfNodes, final String[] indices, final int numberOfPrimaries) {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        Set<String> nodes = new HashSet<>()__        for (int i = 0_ i < numberOfNodes_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__            nodes.add(node.getId())__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(0).getId())__        MetaData.Builder metaData = MetaData.builder()__        RoutingTable.Builder routingTable = RoutingTable.builder()__        List<String> nodesList = new ArrayList<>(nodes)__        int currentNodeToAssign = 0__        for (String index : indices) {_            IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, numberOfPrimaries).put(SETTING_NUMBER_OF_REPLICAS, 0)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()___            RoutingTable.Builder routing = new RoutingTable.Builder()__            routing.addAsNew(indexMetaData)___            IndexRoutingTable.Builder indexRoutingTable = IndexRoutingTable.builder(indexMetaData.getIndex())__            for (int i = 0_ i < numberOfPrimaries_ i++) {_                ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                indexShardRoutingBuilder.addShard(_                    TestShardRouting.newShardRouting(shardId, nodesList.get(currentNodeToAssign++), true, ShardRoutingState.STARTED))__                if (currentNodeToAssign == nodesList.size()) {_                    currentNodeToAssign = 0__                }_                indexRoutingTable.addIndexShard(indexShardRoutingBuilder.build())__            }__            metaData.put(indexMetaData, false)__            routingTable.add(indexRoutingTable)__        }_        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(metaData.generateClusterUuidIfNeeded().build())__        state.routingTable(routingTable.build())__        return state.build()__    };creates,cluster,state,with,the,given,indices,each,index,containing,number,of,primaries,started,primary,shards,and,no,replicas,the,cluster,state,contains,number,of,nodes,nodes,and,assigns,primaries,to,those,nodes;public,static,cluster,state,state,final,int,number,of,nodes,final,string,indices,final,int,number,of,primaries,discovery,nodes,builder,disco,builder,discovery,nodes,builder,set,string,nodes,new,hash,set,for,int,i,0,i,number,of,nodes,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,nodes,add,node,get,id,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,0,get,id,meta,data,builder,meta,data,meta,data,builder,routing,table,builder,routing,table,routing,table,builder,list,string,nodes,list,new,array,list,nodes,int,current,node,to,assign,0,for,string,index,indices,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,primaries,put,0,put,system,current,time,millis,build,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,index,routing,table,builder,index,routing,table,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,primaries,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,shard,id,nodes,list,get,current,node,to,assign,true,shard,routing,state,started,if,current,node,to,assign,nodes,list,size,current,node,to,assign,0,index,routing,table,add,index,shard,index,shard,routing,builder,build,meta,data,put,index,meta,data,false,routing,table,add,index,routing,table,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,generate,cluster,uuid,if,needed,build,state,routing,table,routing,table,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState state(DiscoveryNode localNode, DiscoveryNode masterNode, DiscoveryNode... allNodes);1524684173;Creates a cluster state where local node and master node can be specified__@param localNode  node in allNodes that is the local node_@param masterNode node in allNodes that is the master node. Can be null if no master exists_@param allNodes   all nodes in the cluster_@return cluster state;public static ClusterState state(DiscoveryNode localNode, DiscoveryNode masterNode, DiscoveryNode... allNodes) {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        for (DiscoveryNode node : allNodes) {_            discoBuilder.add(node)__        }_        if (masterNode != null) {_            discoBuilder.masterNodeId(masterNode.getId())__        }_        discoBuilder.localNodeId(localNode.getId())___        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().generateClusterUuidIfNeeded())__        return state.build()__    };creates,a,cluster,state,where,local,node,and,master,node,can,be,specified,param,local,node,node,in,all,nodes,that,is,the,local,node,param,master,node,node,in,all,nodes,that,is,the,master,node,can,be,null,if,no,master,exists,param,all,nodes,all,nodes,in,the,cluster,return,cluster,state;public,static,cluster,state,state,discovery,node,local,node,discovery,node,master,node,discovery,node,all,nodes,discovery,nodes,builder,disco,builder,discovery,nodes,builder,for,discovery,node,node,all,nodes,disco,builder,add,node,if,master,node,null,disco,builder,master,node,id,master,node,get,id,disco,builder,local,node,id,local,node,get,id,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,generate,cluster,uuid,if,needed,return,state,build
ClusterStateCreationUtils -> public static ClusterState state(DiscoveryNode localNode, DiscoveryNode masterNode, DiscoveryNode... allNodes);1533063033;Creates a cluster state where local node and master node can be specified__@param localNode  node in allNodes that is the local node_@param masterNode node in allNodes that is the master node. Can be null if no master exists_@param allNodes   all nodes in the cluster_@return cluster state;public static ClusterState state(DiscoveryNode localNode, DiscoveryNode masterNode, DiscoveryNode... allNodes) {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        for (DiscoveryNode node : allNodes) {_            discoBuilder.add(node)__        }_        if (masterNode != null) {_            discoBuilder.masterNodeId(masterNode.getId())__        }_        discoBuilder.localNodeId(localNode.getId())___        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().generateClusterUuidIfNeeded())__        return state.build()__    };creates,a,cluster,state,where,local,node,and,master,node,can,be,specified,param,local,node,node,in,all,nodes,that,is,the,local,node,param,master,node,node,in,all,nodes,that,is,the,master,node,can,be,null,if,no,master,exists,param,all,nodes,all,nodes,in,the,cluster,return,cluster,state;public,static,cluster,state,state,discovery,node,local,node,discovery,node,master,node,discovery,node,all,nodes,discovery,nodes,builder,disco,builder,discovery,nodes,builder,for,discovery,node,node,all,nodes,disco,builder,add,node,if,master,node,null,disco,builder,master,node,id,master,node,get,id,disco,builder,local,node,id,local,node,get,id,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,generate,cluster,uuid,if,needed,return,state,build
ClusterStateCreationUtils -> public static ClusterState state(DiscoveryNode localNode, DiscoveryNode masterNode, DiscoveryNode... allNodes);1548431513;Creates a cluster state where local node and master node can be specified__@param localNode  node in allNodes that is the local node_@param masterNode node in allNodes that is the master node. Can be null if no master exists_@param allNodes   all nodes in the cluster_@return cluster state;public static ClusterState state(DiscoveryNode localNode, DiscoveryNode masterNode, DiscoveryNode... allNodes) {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        for (DiscoveryNode node : allNodes) {_            discoBuilder.add(node)__        }_        if (masterNode != null) {_            discoBuilder.masterNodeId(masterNode.getId())__        }_        discoBuilder.localNodeId(localNode.getId())___        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().generateClusterUuidIfNeeded())__        return state.build()__    };creates,a,cluster,state,where,local,node,and,master,node,can,be,specified,param,local,node,node,in,all,nodes,that,is,the,local,node,param,master,node,node,in,all,nodes,that,is,the,master,node,can,be,null,if,no,master,exists,param,all,nodes,all,nodes,in,the,cluster,return,cluster,state;public,static,cluster,state,state,discovery,node,local,node,discovery,node,master,node,discovery,node,all,nodes,discovery,nodes,builder,disco,builder,discovery,nodes,builder,for,discovery,node,node,all,nodes,disco,builder,add,node,if,master,node,null,disco,builder,master,node,id,master,node,get,id,disco,builder,local,node,id,local,node,get,id,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,generate,cluster,uuid,if,needed,return,state,build
ClusterStateCreationUtils -> public static ClusterState stateWithNoShard();1524684173;Creates a cluster state with no index;public static ClusterState stateWithNoShard() {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(1).getId())__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().generateClusterUuidIfNeeded())__        state.routingTable(RoutingTable.builder().build())__        return state.build()__    };creates,a,cluster,state,with,no,index;public,static,cluster,state,state,with,no,shard,discovery,nodes,builder,disco,builder,discovery,nodes,builder,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,1,get,id,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,generate,cluster,uuid,if,needed,state,routing,table,routing,table,builder,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState stateWithNoShard();1533063033;Creates a cluster state with no index;public static ClusterState stateWithNoShard() {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(1).getId())__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().generateClusterUuidIfNeeded())__        state.routingTable(RoutingTable.builder().build())__        return state.build()__    };creates,a,cluster,state,with,no,index;public,static,cluster,state,state,with,no,shard,discovery,nodes,builder,disco,builder,discovery,nodes,builder,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,1,get,id,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,generate,cluster,uuid,if,needed,state,routing,table,routing,table,builder,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState stateWithNoShard();1548431513;Creates a cluster state with no index;public static ClusterState stateWithNoShard() {_        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(1).getId())__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().generateClusterUuidIfNeeded())__        state.routingTable(RoutingTable.builder().build())__        return state.build()__    };creates,a,cluster,state,with,no,index;public,static,cluster,state,state,with,no,shard,discovery,nodes,builder,disco,builder,discovery,nodes,builder,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,1,get,id,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,generate,cluster,uuid,if,needed,state,routing,table,routing,table,builder,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState stateWithAssignedPrimariesAndOneReplica(String index, int numberOfShards);1524684173;Creates cluster state with several shards and one replica and all shards STARTED.;public static ClusterState stateWithAssignedPrimariesAndOneReplica(String index, int numberOfShards) {__        int numberOfNodes = 2_ _        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        for (int i = 0_ i < numberOfNodes + 1_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(1).getId())_ _        IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, numberOfShards).put(SETTING_NUMBER_OF_REPLICAS, 1)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().put(indexMetaData, false).generateClusterUuidIfNeeded())__        IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(indexMetaData.getIndex())__        for (int i = 0_ i < numberOfShards_ i++) {_            RoutingTable.Builder routing = new RoutingTable.Builder()__            routing.addAsNew(indexMetaData)__            final ShardId shardId = new ShardId(index, "_na_", i)__            IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__            indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(0).getId(), null, true,_                    ShardRoutingState.STARTED))__            indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(1).getId(), null, false,_                    ShardRoutingState.STARTED))__            indexRoutingTableBuilder.addIndexShard(indexShardRoutingBuilder.build())__        }_        state.routingTable(RoutingTable.builder().add(indexRoutingTableBuilder.build()).build())__        return state.build()__    };creates,cluster,state,with,several,shards,and,one,replica,and,all,shards,started;public,static,cluster,state,state,with,assigned,primaries,and,one,replica,string,index,int,number,of,shards,int,number,of,nodes,2,discovery,nodes,builder,disco,builder,discovery,nodes,builder,for,int,i,0,i,number,of,nodes,1,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,1,get,id,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,shards,put,1,put,system,current,time,millis,build,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,put,index,meta,data,false,generate,cluster,uuid,if,needed,index,routing,table,builder,index,routing,table,builder,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,shards,i,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,final,shard,id,shard,id,new,shard,id,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,0,get,id,null,true,shard,routing,state,started,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,1,get,id,null,false,shard,routing,state,started,index,routing,table,builder,add,index,shard,index,shard,routing,builder,build,state,routing,table,routing,table,builder,add,index,routing,table,builder,build,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState stateWithAssignedPrimariesAndOneReplica(String index, int numberOfShards);1533063033;Creates cluster state with several shards and one replica and all shards STARTED.;public static ClusterState stateWithAssignedPrimariesAndOneReplica(String index, int numberOfShards) {__        int numberOfNodes = 2_ _        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        for (int i = 0_ i < numberOfNodes + 1_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(1).getId())_ _        IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, numberOfShards).put(SETTING_NUMBER_OF_REPLICAS, 1)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().put(indexMetaData, false).generateClusterUuidIfNeeded())__        IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(indexMetaData.getIndex())__        for (int i = 0_ i < numberOfShards_ i++) {_            RoutingTable.Builder routing = new RoutingTable.Builder()__            routing.addAsNew(indexMetaData)__            final ShardId shardId = new ShardId(index, "_na_", i)__            IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__            indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(0).getId(), null, true,_                    ShardRoutingState.STARTED))__            indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(1).getId(), null, false,_                    ShardRoutingState.STARTED))__            indexRoutingTableBuilder.addIndexShard(indexShardRoutingBuilder.build())__        }_        state.routingTable(RoutingTable.builder().add(indexRoutingTableBuilder.build()).build())__        return state.build()__    };creates,cluster,state,with,several,shards,and,one,replica,and,all,shards,started;public,static,cluster,state,state,with,assigned,primaries,and,one,replica,string,index,int,number,of,shards,int,number,of,nodes,2,discovery,nodes,builder,disco,builder,discovery,nodes,builder,for,int,i,0,i,number,of,nodes,1,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,1,get,id,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,shards,put,1,put,system,current,time,millis,build,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,put,index,meta,data,false,generate,cluster,uuid,if,needed,index,routing,table,builder,index,routing,table,builder,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,shards,i,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,final,shard,id,shard,id,new,shard,id,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,0,get,id,null,true,shard,routing,state,started,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,1,get,id,null,false,shard,routing,state,started,index,routing,table,builder,add,index,shard,index,shard,routing,builder,build,state,routing,table,routing,table,builder,add,index,routing,table,builder,build,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState stateWithAssignedPrimariesAndOneReplica(String index, int numberOfShards);1548431513;Creates cluster state with several shards and one replica and all shards STARTED.;public static ClusterState stateWithAssignedPrimariesAndOneReplica(String index, int numberOfShards) {__        int numberOfNodes = 2_ _        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        for (int i = 0_ i < numberOfNodes + 1_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(1).getId())_ _        IndexMetaData indexMetaData = IndexMetaData.builder(index).settings(Settings.builder()_                .put(SETTING_VERSION_CREATED, Version.CURRENT)_                .put(SETTING_NUMBER_OF_SHARDS, numberOfShards).put(SETTING_NUMBER_OF_REPLICAS, 1)_                .put(SETTING_CREATION_DATE, System.currentTimeMillis())).build()__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        state.metaData(MetaData.builder().put(indexMetaData, false).generateClusterUuidIfNeeded())__        IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(indexMetaData.getIndex())__        for (int i = 0_ i < numberOfShards_ i++) {_            RoutingTable.Builder routing = new RoutingTable.Builder()__            routing.addAsNew(indexMetaData)__            final ShardId shardId = new ShardId(index, "_na_", i)__            IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__            indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(0).getId(), null, true,_                    ShardRoutingState.STARTED))__            indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(1).getId(), null, false,_                    ShardRoutingState.STARTED))__            indexRoutingTableBuilder.addIndexShard(indexShardRoutingBuilder.build())__        }_        state.routingTable(RoutingTable.builder().add(indexRoutingTableBuilder.build()).build())__        return state.build()__    };creates,cluster,state,with,several,shards,and,one,replica,and,all,shards,started;public,static,cluster,state,state,with,assigned,primaries,and,one,replica,string,index,int,number,of,shards,int,number,of,nodes,2,discovery,nodes,builder,disco,builder,discovery,nodes,builder,for,int,i,0,i,number,of,nodes,1,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,1,get,id,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,shards,put,1,put,system,current,time,millis,build,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,state,meta,data,meta,data,builder,put,index,meta,data,false,generate,cluster,uuid,if,needed,index,routing,table,builder,index,routing,table,builder,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,shards,i,routing,table,builder,routing,new,routing,table,builder,routing,add,as,new,index,meta,data,final,shard,id,shard,id,new,shard,id,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,0,get,id,null,true,shard,routing,state,started,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,1,get,id,null,false,shard,routing,state,started,index,routing,table,builder,add,index,shard,index,shard,routing,builder,build,state,routing,table,routing,table,builder,add,index,routing,table,builder,build,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState stateWithAssignedPrimariesAndReplicas(String[] indices, int numberOfShards, int numberOfReplicas);1524684173;Creates cluster state with several indexes, shards and replicas and all shards STARTED.;public static ClusterState stateWithAssignedPrimariesAndReplicas(String[] indices, int numberOfShards, int numberOfReplicas) {__        int numberOfDataNodes = numberOfReplicas + 1_ _        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        for (int i = 0_ i < numberOfDataNodes + 1_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(numberOfDataNodes + 1).getId())_ _        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        Builder routingTableBuilder = RoutingTable.builder()___        org.elasticsearch.cluster.metadata.MetaData.Builder metadataBuilder = MetaData.builder()___        for (String index : indices) {_            IndexMetaData indexMetaData = IndexMetaData.builder(index)_                    .settings(Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).put(SETTING_NUMBER_OF_SHARDS, numberOfShards)_                            .put(SETTING_NUMBER_OF_REPLICAS, numberOfReplicas).put(SETTING_CREATION_DATE, System.currentTimeMillis()))_                    .build()__            metadataBuilder.put(indexMetaData, false).generateClusterUuidIfNeeded()__            IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(indexMetaData.getIndex())__            for (int i = 0_ i < numberOfShards_ i++) {_                final ShardId shardId = new ShardId(index, "_na_", i)__                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                indexShardRoutingBuilder_                        .addShard(TestShardRouting.newShardRouting(index, i, newNode(0).getId(), null, true, ShardRoutingState.STARTED))__                for (int replica = 0_ replica < numberOfReplicas_ replica++) {_                    indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(replica + 1).getId(), null, false,_                            ShardRoutingState.STARTED))__                }_                indexRoutingTableBuilder.addIndexShard(indexShardRoutingBuilder.build())__            }_            routingTableBuilder.add(indexRoutingTableBuilder.build())__        }_        state.metaData(metadataBuilder)__        state.routingTable(routingTableBuilder.build())__        return state.build()__    };creates,cluster,state,with,several,indexes,shards,and,replicas,and,all,shards,started;public,static,cluster,state,state,with,assigned,primaries,and,replicas,string,indices,int,number,of,shards,int,number,of,replicas,int,number,of,data,nodes,number,of,replicas,1,discovery,nodes,builder,disco,builder,discovery,nodes,builder,for,int,i,0,i,number,of,data,nodes,1,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,number,of,data,nodes,1,get,id,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,builder,routing,table,builder,routing,table,builder,org,elasticsearch,cluster,metadata,meta,data,builder,metadata,builder,meta,data,builder,for,string,index,indices,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,shards,put,number,of,replicas,put,system,current,time,millis,build,metadata,builder,put,index,meta,data,false,generate,cluster,uuid,if,needed,index,routing,table,builder,index,routing,table,builder,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,shards,i,final,shard,id,shard,id,new,shard,id,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,0,get,id,null,true,shard,routing,state,started,for,int,replica,0,replica,number,of,replicas,replica,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,replica,1,get,id,null,false,shard,routing,state,started,index,routing,table,builder,add,index,shard,index,shard,routing,builder,build,routing,table,builder,add,index,routing,table,builder,build,state,meta,data,metadata,builder,state,routing,table,routing,table,builder,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState stateWithAssignedPrimariesAndReplicas(String[] indices, int numberOfShards, int numberOfReplicas);1533063033;Creates cluster state with several indexes, shards and replicas and all shards STARTED.;public static ClusterState stateWithAssignedPrimariesAndReplicas(String[] indices, int numberOfShards, int numberOfReplicas) {__        int numberOfDataNodes = numberOfReplicas + 1__        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        for (int i = 0_ i < numberOfDataNodes + 1_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(numberOfDataNodes + 1).getId())__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        Builder routingTableBuilder = RoutingTable.builder()___        org.elasticsearch.cluster.metadata.MetaData.Builder metadataBuilder = MetaData.builder()___        for (String index : indices) {_            IndexMetaData indexMetaData = IndexMetaData.builder(index)_                    .settings(Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).put(SETTING_NUMBER_OF_SHARDS, numberOfShards)_                            .put(SETTING_NUMBER_OF_REPLICAS, numberOfReplicas).put(SETTING_CREATION_DATE, System.currentTimeMillis()))_                    .build()__            metadataBuilder.put(indexMetaData, false).generateClusterUuidIfNeeded()__            IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(indexMetaData.getIndex())__            for (int i = 0_ i < numberOfShards_ i++) {_                final ShardId shardId = new ShardId(index, "_na_", i)__                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                indexShardRoutingBuilder_                        .addShard(TestShardRouting.newShardRouting(index, i, newNode(0).getId(), null, true, ShardRoutingState.STARTED))__                for (int replica = 0_ replica < numberOfReplicas_ replica++) {_                    indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(replica + 1).getId(), null, false,_                            ShardRoutingState.STARTED))__                }_                indexRoutingTableBuilder.addIndexShard(indexShardRoutingBuilder.build())__            }_            routingTableBuilder.add(indexRoutingTableBuilder.build())__        }_        state.metaData(metadataBuilder)__        state.routingTable(routingTableBuilder.build())__        return state.build()__    };creates,cluster,state,with,several,indexes,shards,and,replicas,and,all,shards,started;public,static,cluster,state,state,with,assigned,primaries,and,replicas,string,indices,int,number,of,shards,int,number,of,replicas,int,number,of,data,nodes,number,of,replicas,1,discovery,nodes,builder,disco,builder,discovery,nodes,builder,for,int,i,0,i,number,of,data,nodes,1,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,number,of,data,nodes,1,get,id,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,builder,routing,table,builder,routing,table,builder,org,elasticsearch,cluster,metadata,meta,data,builder,metadata,builder,meta,data,builder,for,string,index,indices,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,shards,put,number,of,replicas,put,system,current,time,millis,build,metadata,builder,put,index,meta,data,false,generate,cluster,uuid,if,needed,index,routing,table,builder,index,routing,table,builder,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,shards,i,final,shard,id,shard,id,new,shard,id,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,0,get,id,null,true,shard,routing,state,started,for,int,replica,0,replica,number,of,replicas,replica,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,replica,1,get,id,null,false,shard,routing,state,started,index,routing,table,builder,add,index,shard,index,shard,routing,builder,build,routing,table,builder,add,index,routing,table,builder,build,state,meta,data,metadata,builder,state,routing,table,routing,table,builder,build,return,state,build
ClusterStateCreationUtils -> public static ClusterState stateWithAssignedPrimariesAndReplicas(String[] indices, int numberOfShards, int numberOfReplicas);1548431513;Creates cluster state with several indexes, shards and replicas and all shards STARTED.;public static ClusterState stateWithAssignedPrimariesAndReplicas(String[] indices, int numberOfShards, int numberOfReplicas) {__        int numberOfDataNodes = numberOfReplicas + 1__        DiscoveryNodes.Builder discoBuilder = DiscoveryNodes.builder()__        for (int i = 0_ i < numberOfDataNodes + 1_ i++) {_            final DiscoveryNode node = newNode(i)__            discoBuilder = discoBuilder.add(node)__        }_        discoBuilder.localNodeId(newNode(0).getId())__        discoBuilder.masterNodeId(newNode(numberOfDataNodes + 1).getId())__        ClusterState.Builder state = ClusterState.builder(new ClusterName("test"))__        state.nodes(discoBuilder)__        Builder routingTableBuilder = RoutingTable.builder()___        org.elasticsearch.cluster.metadata.MetaData.Builder metadataBuilder = MetaData.builder()___        for (String index : indices) {_            IndexMetaData indexMetaData = IndexMetaData.builder(index)_                    .settings(Settings.builder().put(SETTING_VERSION_CREATED, Version.CURRENT).put(SETTING_NUMBER_OF_SHARDS, numberOfShards)_                            .put(SETTING_NUMBER_OF_REPLICAS, numberOfReplicas).put(SETTING_CREATION_DATE, System.currentTimeMillis()))_                    .build()__            metadataBuilder.put(indexMetaData, false).generateClusterUuidIfNeeded()__            IndexRoutingTable.Builder indexRoutingTableBuilder = IndexRoutingTable.builder(indexMetaData.getIndex())__            for (int i = 0_ i < numberOfShards_ i++) {_                final ShardId shardId = new ShardId(index, "_na_", i)__                IndexShardRoutingTable.Builder indexShardRoutingBuilder = new IndexShardRoutingTable.Builder(shardId)__                indexShardRoutingBuilder_                        .addShard(TestShardRouting.newShardRouting(index, i, newNode(0).getId(), null, true, ShardRoutingState.STARTED))__                for (int replica = 0_ replica < numberOfReplicas_ replica++) {_                    indexShardRoutingBuilder.addShard(TestShardRouting.newShardRouting(index, i, newNode(replica + 1).getId(), null, false,_                            ShardRoutingState.STARTED))__                }_                indexRoutingTableBuilder.addIndexShard(indexShardRoutingBuilder.build())__            }_            routingTableBuilder.add(indexRoutingTableBuilder.build())__        }_        state.metaData(metadataBuilder)__        state.routingTable(routingTableBuilder.build())__        return state.build()__    };creates,cluster,state,with,several,indexes,shards,and,replicas,and,all,shards,started;public,static,cluster,state,state,with,assigned,primaries,and,replicas,string,indices,int,number,of,shards,int,number,of,replicas,int,number,of,data,nodes,number,of,replicas,1,discovery,nodes,builder,disco,builder,discovery,nodes,builder,for,int,i,0,i,number,of,data,nodes,1,i,final,discovery,node,node,new,node,i,disco,builder,disco,builder,add,node,disco,builder,local,node,id,new,node,0,get,id,disco,builder,master,node,id,new,node,number,of,data,nodes,1,get,id,cluster,state,builder,state,cluster,state,builder,new,cluster,name,test,state,nodes,disco,builder,builder,routing,table,builder,routing,table,builder,org,elasticsearch,cluster,metadata,meta,data,builder,metadata,builder,meta,data,builder,for,string,index,indices,index,meta,data,index,meta,data,index,meta,data,builder,index,settings,settings,builder,put,version,current,put,number,of,shards,put,number,of,replicas,put,system,current,time,millis,build,metadata,builder,put,index,meta,data,false,generate,cluster,uuid,if,needed,index,routing,table,builder,index,routing,table,builder,index,routing,table,builder,index,meta,data,get,index,for,int,i,0,i,number,of,shards,i,final,shard,id,shard,id,new,shard,id,index,i,index,shard,routing,table,builder,index,shard,routing,builder,new,index,shard,routing,table,builder,shard,id,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,0,get,id,null,true,shard,routing,state,started,for,int,replica,0,replica,number,of,replicas,replica,index,shard,routing,builder,add,shard,test,shard,routing,new,shard,routing,index,i,new,node,replica,1,get,id,null,false,shard,routing,state,started,index,routing,table,builder,add,index,shard,index,shard,routing,builder,build,routing,table,builder,add,index,routing,table,builder,build,state,meta,data,metadata,builder,state,routing,table,routing,table,builder,build,return,state,build
