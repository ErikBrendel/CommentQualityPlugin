commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public int docID() {     return doc. }
false;public;0;4;;@Override public float score() {     return score. }
false;public;2;8;;@Override public void collect(int doc, long bucket) throws IOException {     if (count >= terminateAfter) {         throw new CollectionTerminatedException().     }     super.collect(doc, bucket).     count++. }
false;public;1;17;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext context) throws IOException {     if (count >= terminateAfter) {         throw new CollectionTerminatedException().     }     final LeafBucketCollector leafCollector = in.getLeafCollector(context).     return new LeafBucketCollectorBase(leafCollector, null) {          @Override         public void collect(int doc, long bucket) throws IOException {             if (count >= terminateAfter) {                 throw new CollectionTerminatedException().             }             super.collect(doc, bucket).             count++.         }     }. }
false;public;0;4;;@Override public ScoreMode scoreMode() {     return ScoreMode.COMPLETE. }
false;public;0;2;;@Override public void preCollection() { }
false;public;0;2;;@Override public void postCollection() { }
false;public;2;4;;@Override public void collect(int doc, long bucket) throws IOException {     count++. }
false;public;1;9;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext context) {     return new LeafBucketCollector() {          @Override         public void collect(int doc, long bucket) throws IOException {             count++.         }     }. }
false;public;0;4;;@Override public ScoreMode scoreMode() {     return ScoreMode.COMPLETE_NO_SCORES. }
false;public;0;2;;@Override public void preCollection() { }
false;public;0;2;;@Override public void postCollection() { }
false;;0;3;;int getTotalHits() {     return count. }
false;public;1;5;;@Override public void setScorer(Scorable scorer) throws IOException {     super.setScorer(scorer).     setScorerCalled.set(true). }
false;public;1;11;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext context) throws IOException {     final LeafBucketCollector leafCollector = in.getLeafCollector(context).     return new LeafBucketCollectorBase(leafCollector, null) {          @Override         public void setScorer(Scorable scorer) throws IOException {             super.setScorer(scorer).             setScorerCalled.set(true).         }     }. }
false;public;0;4;;@Override public ScoreMode scoreMode() {     return ScoreMode.COMPLETE. }
false;public;0;2;;@Override public void preCollection() { }
false;public;0;2;;@Override public void postCollection() { }
false;public;0;31;;public void testCollectionTerminatedExceptionHandling() throws IOException {     final int iters = atLeast(3).     for (int iter = 0. iter < iters. ++iter) {         Directory dir = newDirectory().         RandomIndexWriter w = new RandomIndexWriter(random(), dir).         final int numDocs = randomIntBetween(100, 1000).         final Document doc = new Document().         for (int i = 0. i < numDocs. ++i) {             w.addDocument(doc).         }         final IndexReader reader = w.getReader().         w.close().         final IndexSearcher searcher = newSearcher(reader).         Map<TotalHitCountBucketCollector, Integer> expectedCounts = new HashMap<>().         List<BucketCollector> collectors = new ArrayList<>().         final int numCollectors = randomIntBetween(1, 5).         for (int i = 0. i < numCollectors. ++i) {             final int terminateAfter = random().nextInt(numDocs + 10).             final int expectedCount = terminateAfter > numDocs ? numDocs : terminateAfter.             TotalHitCountBucketCollector collector = new TotalHitCountBucketCollector().             expectedCounts.put(collector, expectedCount).             collectors.add(new TerminateAfterBucketCollector(collector, terminateAfter)).         }         searcher.search(new MatchAllDocsQuery(), MultiBucketCollector.wrap(collectors)).         for (Map.Entry<TotalHitCountBucketCollector, Integer> expectedCount : expectedCounts.entrySet()) {             assertEquals(expectedCount.getValue().intValue(), expectedCount.getKey().getTotalHits()).         }         reader.close().         dir.close().     } }
false;public;0;43;;public void testSetScorerAfterCollectionTerminated() throws IOException {     BucketCollector collector1 = new TotalHitCountBucketCollector().     BucketCollector collector2 = new TotalHitCountBucketCollector().     AtomicBoolean setScorerCalled1 = new AtomicBoolean().     collector1 = new SetScorerBucketCollector(collector1, setScorerCalled1).     AtomicBoolean setScorerCalled2 = new AtomicBoolean().     collector2 = new SetScorerBucketCollector(collector2, setScorerCalled2).     collector1 = new TerminateAfterBucketCollector(collector1, 1).     collector2 = new TerminateAfterBucketCollector(collector2, 2).     Scorable scorer = new ScoreAndDoc().     List<BucketCollector> collectors = Arrays.asList(collector1, collector2).     Collections.shuffle(collectors, random()).     BucketCollector collector = MultiBucketCollector.wrap(collectors).     LeafBucketCollector leafCollector = collector.getLeafCollector(null).     leafCollector.setScorer(scorer).     assertTrue(setScorerCalled1.get()).     assertTrue(setScorerCalled2.get()).     leafCollector.collect(0).     leafCollector.collect(1).     setScorerCalled1.set(false).     setScorerCalled2.set(false).     leafCollector.setScorer(scorer).     assertFalse(setScorerCalled1.get()).     assertTrue(setScorerCalled2.get()).     expectThrows(CollectionTerminatedException.class, () -> {         leafCollector.collect(1).     }).     setScorerCalled1.set(false).     setScorerCalled2.set(false).     leafCollector.setScorer(scorer).     assertFalse(setScorerCalled1.get()).     assertFalse(setScorerCalled2.get()). }
