commented;modifiers;parameterAmount;loc;comment;code
true;public;0;74;/**  * Restoring a snapshot that contains multiple files must succeed even when  * some files already exist in the shard's store.  */ ;/**  * Restoring a snapshot that contains multiple files must succeed even when  * some files already exist in the shard's store.  */ public void testRestoreSnapshotWithExistingFiles() throws IOException {     final IndexId indexId = new IndexId(randomAlphaOfLength(10), UUIDs.randomBase64UUID()).     final ShardId shardId = new ShardId(indexId.getName(), indexId.getId(), 0).     IndexShard shard = newShard(shardId, true).     try {         // index documents in the shards         final int numDocs = scaledRandomIntBetween(1, 500).         recoverShardFromStore(shard).         for (int i = 0. i < numDocs. i++) {             indexDoc(shard, "_doc", Integer.toString(i)).             if (rarely()) {                 flushShard(shard, false).             }         }         assertDocCount(shard, numDocs).         // snapshot the shard         final Repository repository = createRepository().         final Snapshot snapshot = new Snapshot(repository.getMetadata().name(), new SnapshotId(randomAlphaOfLength(10), "_uuid")).         snapshotShard(shard, snapshot, repository).         // capture current store files         final Store.MetadataSnapshot storeFiles = shard.snapshotStoreMetadata().         assertFalse(storeFiles.asMap().isEmpty()).         // close the shard         closeShards(shard).         // delete some random files in the store         List<String> deletedFiles = randomSubsetOf(randomIntBetween(1, storeFiles.size() - 1), storeFiles.asMap().keySet()).         for (String deletedFile : deletedFiles) {             Files.delete(shard.shardPath().resolveIndex().resolve(deletedFile)).         }         // build a new shard using the same store directory as the closed shard         ShardRouting shardRouting = ShardRoutingHelper.initWithSameId(shard.routingEntry(), RecoverySource.ExistingStoreRecoverySource.INSTANCE).         shard = newShard(shardRouting, shard.shardPath(), shard.indexSettings().getIndexMetaData(), null, null, new InternalEngineFactory(), () -> {         }, RetentionLeaseSyncer.EMPTY, EMPTY_EVENT_LISTENER).         // restore the shard         recoverShardFromSnapshot(shard, snapshot, repository).         // check that the shard is not corrupted         TestUtil.checkIndex(shard.store().directory()).         // check that all files have been restored         final Directory directory = shard.store().directory().         final List<String> directoryFiles = Arrays.asList(directory.listAll()).         for (StoreFileMetaData storeFile : storeFiles) {             String fileName = storeFile.name().             assertTrue("File [" + fileName + "] does not exist in store directory", directoryFiles.contains(fileName)).             assertEquals(storeFile.length(), shard.store().directory().fileLength(fileName)).         }     } finally {         if (shard != null && shard.state() != IndexShardState.CLOSED) {             try {                 shard.close("test", false).             } finally {                 IOUtils.close(shard.store()).             }         }     } }
false;public;0;36;;public void testSnapshotWithConflictingName() throws IOException {     final IndexId indexId = new IndexId(randomAlphaOfLength(10), UUIDs.randomBase64UUID()).     final ShardId shardId = new ShardId(indexId.getName(), indexId.getId(), 0).     IndexShard shard = newShard(shardId, true).     try {         // index documents in the shards         final int numDocs = scaledRandomIntBetween(1, 500).         recoverShardFromStore(shard).         for (int i = 0. i < numDocs. i++) {             indexDoc(shard, "_doc", Integer.toString(i)).             if (rarely()) {                 flushShard(shard, false).             }         }         assertDocCount(shard, numDocs).         // snapshot the shard         final Repository repository = createRepository().         final Snapshot snapshot = new Snapshot(repository.getMetadata().name(), new SnapshotId(randomAlphaOfLength(10), "_uuid")).         snapshotShard(shard, snapshot, repository).         final Snapshot snapshotWithSameName = new Snapshot(repository.getMetadata().name(), new SnapshotId(snapshot.getSnapshotId().getName(), "_uuid2")).         IndexShardSnapshotFailedException isfe = expectThrows(IndexShardSnapshotFailedException.class, () -> snapshotShard(shard, snapshotWithSameName, repository)).         assertThat(isfe.getMessage(), containsString("Duplicate snapshot name")).     } finally {         if (shard != null && shard.state() != IndexShardState.CLOSED) {             try {                 shard.close("test", false).             } finally {                 IOUtils.close(shard.store()).             }         }     } }
false;protected;0;4;;@Override protected void assertSnapshotOrGenericThread() { // eliminate thread name check as we create repo manually }
true;private;0;12;/**  * Create a {@link Repository} with a random name *  */ ;/**  * Create a {@link Repository} with a random name *  */ private Repository createRepository() {     Settings settings = Settings.builder().put("location", randomAlphaOfLength(10)).build().     RepositoryMetaData repositoryMetaData = new RepositoryMetaData(randomAlphaOfLength(10), FsRepository.TYPE, settings).     final FsRepository repository = new FsRepository(repositoryMetaData, createEnvironment(), xContentRegistry()) {          @Override         protected void assertSnapshotOrGenericThread() {         // eliminate thread name check as we create repo manually         }     }.     repository.start().     return repository. }
true;private;0;7;/**  * Create a {@link Environment} with random path.home and path.repo *  */ ;/**  * Create a {@link Environment} with random path.home and path.repo *  */ private Environment createEnvironment() {     Path home = createTempDir().     return TestEnvironment.newEnvironment(Settings.builder().put(Environment.PATH_HOME_SETTING.getKey(), home.toAbsolutePath()).put(Environment.PATH_REPO_SETTING.getKey(), home.resolve("repo").toAbsolutePath()).build()). }
