# id;timestamp;commentText;codeText;commentWords;codeWords
BlobStoreRepositoryRestoreTests -> private Repository createRepository();1531729807;Create a {@link Repository} with a random name *;private Repository createRepository() {_        Settings settings = Settings.builder().put("location", randomAlphaOfLength(10)).build()__        RepositoryMetaData repositoryMetaData = new RepositoryMetaData(randomAlphaOfLength(10), FsRepository.TYPE, settings)__        final FsRepository repository = new FsRepository(repositoryMetaData, createEnvironment(), xContentRegistry()) {_            @Override_            protected void assertSnapshotOrGenericThread() {_                _            }_        }__        repository.start()__        return repository__    };create,a,link,repository,with,a,random,name;private,repository,create,repository,settings,settings,settings,builder,put,location,random,alpha,of,length,10,build,repository,meta,data,repository,meta,data,new,repository,meta,data,random,alpha,of,length,10,fs,repository,type,settings,final,fs,repository,repository,new,fs,repository,repository,meta,data,create,environment,x,content,registry,override,protected,void,assert,snapshot,or,generic,thread,repository,start,return,repository
BlobStoreRepositoryRestoreTests -> private Repository createRepository();1532434432;Create a {@link Repository} with a random name *;private Repository createRepository() {_        Settings settings = Settings.builder().put("location", randomAlphaOfLength(10)).build()__        RepositoryMetaData repositoryMetaData = new RepositoryMetaData(randomAlphaOfLength(10), FsRepository.TYPE, settings)__        final FsRepository repository = new FsRepository(repositoryMetaData, createEnvironment(), xContentRegistry()) {_            @Override_            protected void assertSnapshotOrGenericThread() {_                _            }_        }__        repository.start()__        return repository__    };create,a,link,repository,with,a,random,name;private,repository,create,repository,settings,settings,settings,builder,put,location,random,alpha,of,length,10,build,repository,meta,data,repository,meta,data,new,repository,meta,data,random,alpha,of,length,10,fs,repository,type,settings,final,fs,repository,repository,new,fs,repository,repository,meta,data,create,environment,x,content,registry,override,protected,void,assert,snapshot,or,generic,thread,repository,start,return,repository
BlobStoreRepositoryRestoreTests -> private Repository createRepository();1536611444;Create a {@link Repository} with a random name *;private Repository createRepository() {_        Settings settings = Settings.builder().put("location", randomAlphaOfLength(10)).build()__        RepositoryMetaData repositoryMetaData = new RepositoryMetaData(randomAlphaOfLength(10), FsRepository.TYPE, settings)__        final FsRepository repository = new FsRepository(repositoryMetaData, createEnvironment(), xContentRegistry()) {_            @Override_            protected void assertSnapshotOrGenericThread() {_                _            }_        }__        repository.start()__        return repository__    };create,a,link,repository,with,a,random,name;private,repository,create,repository,settings,settings,settings,builder,put,location,random,alpha,of,length,10,build,repository,meta,data,repository,meta,data,new,repository,meta,data,random,alpha,of,length,10,fs,repository,type,settings,final,fs,repository,repository,new,fs,repository,repository,meta,data,create,environment,x,content,registry,override,protected,void,assert,snapshot,or,generic,thread,repository,start,return,repository
BlobStoreRepositoryRestoreTests -> private Repository createRepository();1550668107;Create a {@link Repository} with a random name *;private Repository createRepository() {_        Settings settings = Settings.builder().put("location", randomAlphaOfLength(10)).build()__        RepositoryMetaData repositoryMetaData = new RepositoryMetaData(randomAlphaOfLength(10), FsRepository.TYPE, settings)__        final FsRepository repository = new FsRepository(repositoryMetaData, createEnvironment(), xContentRegistry()) {_            @Override_            protected void assertSnapshotOrGenericThread() {_                _            }_        }__        repository.start()__        return repository__    };create,a,link,repository,with,a,random,name;private,repository,create,repository,settings,settings,settings,builder,put,location,random,alpha,of,length,10,build,repository,meta,data,repository,meta,data,new,repository,meta,data,random,alpha,of,length,10,fs,repository,type,settings,final,fs,repository,repository,new,fs,repository,repository,meta,data,create,environment,x,content,registry,override,protected,void,assert,snapshot,or,generic,thread,repository,start,return,repository
BlobStoreRepositoryRestoreTests -> public void testRestoreSnapshotWithExistingFiles() throws IOException;1524684173;Restoring a snapshot that contains multiple files must succeed even when_some files already exist in the shard's store.;public void testRestoreSnapshotWithExistingFiles() throws IOException {_        final IndexId indexId = new IndexId(randomAlphaOfLength(10), UUIDs.randomBase64UUID())__        final ShardId shardId = new ShardId(indexId.getName(), indexId.getId(), 0)___        IndexShard shard = newShard(shardId, true)__        try {_            _            final int numDocs = scaledRandomIntBetween(1, 500)__            recoverShardFromStore(shard)__            for (int i = 0_ i < numDocs_ i++) {_                indexDoc(shard, "doc", Integer.toString(i))__                if (rarely()) {_                    flushShard(shard, false)__                }_            }_            assertDocCount(shard, numDocs)___            _            final Repository repository = createRepository()__            final Snapshot snapshot = new Snapshot(repository.getMetadata().name(), new SnapshotId(randomAlphaOfLength(10), "_uuid"))__            snapshotShard(shard, snapshot, repository)___            _            final Store.MetadataSnapshot storeFiles = shard.snapshotStoreMetadata()__            assertFalse(storeFiles.asMap().isEmpty())___            _            closeShards(shard)___            _            List<String> deletedFiles = randomSubsetOf(randomIntBetween(1, storeFiles.size() - 1), storeFiles.asMap().keySet())__            for (String deletedFile : deletedFiles) {_                Files.delete(shard.shardPath().resolveIndex().resolve(deletedFile))__            }__            _            ShardRouting shardRouting = ShardRoutingHelper.initWithSameId(shard.routingEntry(), EXISTING_STORE_INSTANCE)__            shard = newShard(shardRouting, shard.shardPath(), shard.indexSettings().getIndexMetaData(), null, null, () -> {},_                EMPTY_EVENT_LISTENER)___            _            recoverShardFromSnapshot(shard, snapshot, repository)___            _            TestUtil.checkIndex(shard.store().directory())___            _            final Directory directory = shard.store().directory()__            final List<String> directoryFiles = Arrays.asList(directory.listAll())___            for (StoreFileMetaData storeFile : storeFiles) {_                String fileName = storeFile.name()__                assertTrue("File [" + fileName + "] does not exist in store directory", directoryFiles.contains(fileName))__                assertEquals(storeFile.length(), shard.store().directory().fileLength(fileName))__            }_        } finally {_            if (shard != null && shard.state() != IndexShardState.CLOSED) {_                try {_                    shard.close("test", false)__                } finally {_                    IOUtils.close(shard.store())__                }_            }_        }_    };restoring,a,snapshot,that,contains,multiple,files,must,succeed,even,when,some,files,already,exist,in,the,shard,s,store;public,void,test,restore,snapshot,with,existing,files,throws,ioexception,final,index,id,index,id,new,index,id,random,alpha,of,length,10,uuids,random,base64uuid,final,shard,id,shard,id,new,shard,id,index,id,get,name,index,id,get,id,0,index,shard,shard,new,shard,shard,id,true,try,final,int,num,docs,scaled,random,int,between,1,500,recover,shard,from,store,shard,for,int,i,0,i,num,docs,i,index,doc,shard,doc,integer,to,string,i,if,rarely,flush,shard,shard,false,assert,doc,count,shard,num,docs,final,repository,repository,create,repository,final,snapshot,snapshot,new,snapshot,repository,get,metadata,name,new,snapshot,id,random,alpha,of,length,10,snapshot,shard,shard,snapshot,repository,final,store,metadata,snapshot,store,files,shard,snapshot,store,metadata,assert,false,store,files,as,map,is,empty,close,shards,shard,list,string,deleted,files,random,subset,of,random,int,between,1,store,files,size,1,store,files,as,map,key,set,for,string,deleted,file,deleted,files,files,delete,shard,shard,path,resolve,index,resolve,deleted,file,shard,routing,shard,routing,shard,routing,helper,init,with,same,id,shard,routing,entry,shard,new,shard,shard,routing,shard,shard,path,shard,index,settings,get,index,meta,data,null,null,recover,shard,from,snapshot,shard,snapshot,repository,test,util,check,index,shard,store,directory,final,directory,directory,shard,store,directory,final,list,string,directory,files,arrays,as,list,directory,list,all,for,store,file,meta,data,store,file,store,files,string,file,name,store,file,name,assert,true,file,file,name,does,not,exist,in,store,directory,directory,files,contains,file,name,assert,equals,store,file,length,shard,store,directory,file,length,file,name,finally,if,shard,null,shard,state,index,shard,state,closed,try,shard,close,test,false,finally,ioutils,close,shard,store
BlobStoreRepositoryRestoreTests -> public void testRestoreSnapshotWithExistingFiles() throws IOException;1525162917;Restoring a snapshot that contains multiple files must succeed even when_some files already exist in the shard's store.;public void testRestoreSnapshotWithExistingFiles() throws IOException {_        final IndexId indexId = new IndexId(randomAlphaOfLength(10), UUIDs.randomBase64UUID())__        final ShardId shardId = new ShardId(indexId.getName(), indexId.getId(), 0)___        IndexShard shard = newShard(shardId, true)__        try {_            _            final int numDocs = scaledRandomIntBetween(1, 500)__            recoverShardFromStore(shard)__            for (int i = 0_ i < numDocs_ i++) {_                indexDoc(shard, "_doc", Integer.toString(i))__                if (rarely()) {_                    flushShard(shard, false)__                }_            }_            assertDocCount(shard, numDocs)___            _            final Repository repository = createRepository()__            final Snapshot snapshot = new Snapshot(repository.getMetadata().name(), new SnapshotId(randomAlphaOfLength(10), "_uuid"))__            snapshotShard(shard, snapshot, repository)___            _            final Store.MetadataSnapshot storeFiles = shard.snapshotStoreMetadata()__            assertFalse(storeFiles.asMap().isEmpty())___            _            closeShards(shard)___            _            List<String> deletedFiles = randomSubsetOf(randomIntBetween(1, storeFiles.size() - 1), storeFiles.asMap().keySet())__            for (String deletedFile : deletedFiles) {_                Files.delete(shard.shardPath().resolveIndex().resolve(deletedFile))__            }__            _            ShardRouting shardRouting = ShardRoutingHelper.initWithSameId(shard.routingEntry(), EXISTING_STORE_INSTANCE)__            shard = newShard(shardRouting, shard.shardPath(), shard.indexSettings().getIndexMetaData(), null, null, () -> {},_                EMPTY_EVENT_LISTENER)___            _            recoverShardFromSnapshot(shard, snapshot, repository)___            _            TestUtil.checkIndex(shard.store().directory())___            _            final Directory directory = shard.store().directory()__            final List<String> directoryFiles = Arrays.asList(directory.listAll())___            for (StoreFileMetaData storeFile : storeFiles) {_                String fileName = storeFile.name()__                assertTrue("File [" + fileName + "] does not exist in store directory", directoryFiles.contains(fileName))__                assertEquals(storeFile.length(), shard.store().directory().fileLength(fileName))__            }_        } finally {_            if (shard != null && shard.state() != IndexShardState.CLOSED) {_                try {_                    shard.close("test", false)__                } finally {_                    IOUtils.close(shard.store())__                }_            }_        }_    };restoring,a,snapshot,that,contains,multiple,files,must,succeed,even,when,some,files,already,exist,in,the,shard,s,store;public,void,test,restore,snapshot,with,existing,files,throws,ioexception,final,index,id,index,id,new,index,id,random,alpha,of,length,10,uuids,random,base64uuid,final,shard,id,shard,id,new,shard,id,index,id,get,name,index,id,get,id,0,index,shard,shard,new,shard,shard,id,true,try,final,int,num,docs,scaled,random,int,between,1,500,recover,shard,from,store,shard,for,int,i,0,i,num,docs,i,index,doc,shard,integer,to,string,i,if,rarely,flush,shard,shard,false,assert,doc,count,shard,num,docs,final,repository,repository,create,repository,final,snapshot,snapshot,new,snapshot,repository,get,metadata,name,new,snapshot,id,random,alpha,of,length,10,snapshot,shard,shard,snapshot,repository,final,store,metadata,snapshot,store,files,shard,snapshot,store,metadata,assert,false,store,files,as,map,is,empty,close,shards,shard,list,string,deleted,files,random,subset,of,random,int,between,1,store,files,size,1,store,files,as,map,key,set,for,string,deleted,file,deleted,files,files,delete,shard,shard,path,resolve,index,resolve,deleted,file,shard,routing,shard,routing,shard,routing,helper,init,with,same,id,shard,routing,entry,shard,new,shard,shard,routing,shard,shard,path,shard,index,settings,get,index,meta,data,null,null,recover,shard,from,snapshot,shard,snapshot,repository,test,util,check,index,shard,store,directory,final,directory,directory,shard,store,directory,final,list,string,directory,files,arrays,as,list,directory,list,all,for,store,file,meta,data,store,file,store,files,string,file,name,store,file,name,assert,true,file,file,name,does,not,exist,in,store,directory,directory,files,contains,file,name,assert,equals,store,file,length,shard,store,directory,file,length,file,name,finally,if,shard,null,shard,state,index,shard,state,closed,try,shard,close,test,false,finally,ioutils,close,shard,store
BlobStoreRepositoryRestoreTests -> public void testRestoreSnapshotWithExistingFiles() throws IOException;1528706846;Restoring a snapshot that contains multiple files must succeed even when_some files already exist in the shard's store.;public void testRestoreSnapshotWithExistingFiles() throws IOException {_        final IndexId indexId = new IndexId(randomAlphaOfLength(10), UUIDs.randomBase64UUID())__        final ShardId shardId = new ShardId(indexId.getName(), indexId.getId(), 0)___        IndexShard shard = newShard(shardId, true)__        try {_            _            final int numDocs = scaledRandomIntBetween(1, 500)__            recoverShardFromStore(shard)__            for (int i = 0_ i < numDocs_ i++) {_                indexDoc(shard, "_doc", Integer.toString(i))__                if (rarely()) {_                    flushShard(shard, false)__                }_            }_            assertDocCount(shard, numDocs)___            _            final Repository repository = createRepository()__            final Snapshot snapshot = new Snapshot(repository.getMetadata().name(), new SnapshotId(randomAlphaOfLength(10), "_uuid"))__            snapshotShard(shard, snapshot, repository)___            _            final Store.MetadataSnapshot storeFiles = shard.snapshotStoreMetadata()__            assertFalse(storeFiles.asMap().isEmpty())___            _            closeShards(shard)___            _            List<String> deletedFiles = randomSubsetOf(randomIntBetween(1, storeFiles.size() - 1), storeFiles.asMap().keySet())__            for (String deletedFile : deletedFiles) {_                Files.delete(shard.shardPath().resolveIndex().resolve(deletedFile))__            }__            _            ShardRouting shardRouting = ShardRoutingHelper.initWithSameId(shard.routingEntry(), EXISTING_STORE_INSTANCE)__            shard = newShard(_                    shardRouting,_                    shard.shardPath(),_                    shard.indexSettings().getIndexMetaData(),_                    null,_                    new InternalEngineFactory(),_                    () -> {},_                    EMPTY_EVENT_LISTENER)___            _            recoverShardFromSnapshot(shard, snapshot, repository)___            _            TestUtil.checkIndex(shard.store().directory())___            _            final Directory directory = shard.store().directory()__            final List<String> directoryFiles = Arrays.asList(directory.listAll())___            for (StoreFileMetaData storeFile : storeFiles) {_                String fileName = storeFile.name()__                assertTrue("File [" + fileName + "] does not exist in store directory", directoryFiles.contains(fileName))__                assertEquals(storeFile.length(), shard.store().directory().fileLength(fileName))__            }_        } finally {_            if (shard != null && shard.state() != IndexShardState.CLOSED) {_                try {_                    shard.close("test", false)__                } finally {_                    IOUtils.close(shard.store())__                }_            }_        }_    };restoring,a,snapshot,that,contains,multiple,files,must,succeed,even,when,some,files,already,exist,in,the,shard,s,store;public,void,test,restore,snapshot,with,existing,files,throws,ioexception,final,index,id,index,id,new,index,id,random,alpha,of,length,10,uuids,random,base64uuid,final,shard,id,shard,id,new,shard,id,index,id,get,name,index,id,get,id,0,index,shard,shard,new,shard,shard,id,true,try,final,int,num,docs,scaled,random,int,between,1,500,recover,shard,from,store,shard,for,int,i,0,i,num,docs,i,index,doc,shard,integer,to,string,i,if,rarely,flush,shard,shard,false,assert,doc,count,shard,num,docs,final,repository,repository,create,repository,final,snapshot,snapshot,new,snapshot,repository,get,metadata,name,new,snapshot,id,random,alpha,of,length,10,snapshot,shard,shard,snapshot,repository,final,store,metadata,snapshot,store,files,shard,snapshot,store,metadata,assert,false,store,files,as,map,is,empty,close,shards,shard,list,string,deleted,files,random,subset,of,random,int,between,1,store,files,size,1,store,files,as,map,key,set,for,string,deleted,file,deleted,files,files,delete,shard,shard,path,resolve,index,resolve,deleted,file,shard,routing,shard,routing,shard,routing,helper,init,with,same,id,shard,routing,entry,shard,new,shard,shard,routing,shard,shard,path,shard,index,settings,get,index,meta,data,null,new,internal,engine,factory,recover,shard,from,snapshot,shard,snapshot,repository,test,util,check,index,shard,store,directory,final,directory,directory,shard,store,directory,final,list,string,directory,files,arrays,as,list,directory,list,all,for,store,file,meta,data,store,file,store,files,string,file,name,store,file,name,assert,true,file,file,name,does,not,exist,in,store,directory,directory,files,contains,file,name,assert,equals,store,file,length,shard,store,directory,file,length,file,name,finally,if,shard,null,shard,state,index,shard,state,closed,try,shard,close,test,false,finally,ioutils,close,shard,store
BlobStoreRepositoryRestoreTests -> public void testRestoreSnapshotWithExistingFiles() throws IOException;1531729807;Restoring a snapshot that contains multiple files must succeed even when_some files already exist in the shard's store.;public void testRestoreSnapshotWithExistingFiles() throws IOException {_        final IndexId indexId = new IndexId(randomAlphaOfLength(10), UUIDs.randomBase64UUID())__        final ShardId shardId = new ShardId(indexId.getName(), indexId.getId(), 0)___        IndexShard shard = newShard(shardId, true)__        try {_            _            final int numDocs = scaledRandomIntBetween(1, 500)__            recoverShardFromStore(shard)__            for (int i = 0_ i < numDocs_ i++) {_                indexDoc(shard, "_doc", Integer.toString(i))__                if (rarely()) {_                    flushShard(shard, false)__                }_            }_            assertDocCount(shard, numDocs)___            _            final Repository repository = createRepository()__            final Snapshot snapshot = new Snapshot(repository.getMetadata().name(), new SnapshotId(randomAlphaOfLength(10), "_uuid"))__            snapshotShard(shard, snapshot, repository)___            _            final Store.MetadataSnapshot storeFiles = shard.snapshotStoreMetadata()__            assertFalse(storeFiles.asMap().isEmpty())___            _            closeShards(shard)___            _            List<String> deletedFiles = randomSubsetOf(randomIntBetween(1, storeFiles.size() - 1), storeFiles.asMap().keySet())__            for (String deletedFile : deletedFiles) {_                Files.delete(shard.shardPath().resolveIndex().resolve(deletedFile))__            }__            _            ShardRouting shardRouting = ShardRoutingHelper.initWithSameId(shard.routingEntry(), EXISTING_STORE_INSTANCE)__            shard = newShard(_                    shardRouting,_                    shard.shardPath(),_                    shard.indexSettings().getIndexMetaData(),_                    null,_                    new InternalEngineFactory(),_                    () -> {},_                    EMPTY_EVENT_LISTENER)___            _            recoverShardFromSnapshot(shard, snapshot, repository)___            _            TestUtil.checkIndex(shard.store().directory())___            _            final Directory directory = shard.store().directory()__            final List<String> directoryFiles = Arrays.asList(directory.listAll())___            for (StoreFileMetaData storeFile : storeFiles) {_                String fileName = storeFile.name()__                assertTrue("File [" + fileName + "] does not exist in store directory", directoryFiles.contains(fileName))__                assertEquals(storeFile.length(), shard.store().directory().fileLength(fileName))__            }_        } finally {_            if (shard != null && shard.state() != IndexShardState.CLOSED) {_                try {_                    shard.close("test", false)__                } finally {_                    IOUtils.close(shard.store())__                }_            }_        }_    };restoring,a,snapshot,that,contains,multiple,files,must,succeed,even,when,some,files,already,exist,in,the,shard,s,store;public,void,test,restore,snapshot,with,existing,files,throws,ioexception,final,index,id,index,id,new,index,id,random,alpha,of,length,10,uuids,random,base64uuid,final,shard,id,shard,id,new,shard,id,index,id,get,name,index,id,get,id,0,index,shard,shard,new,shard,shard,id,true,try,final,int,num,docs,scaled,random,int,between,1,500,recover,shard,from,store,shard,for,int,i,0,i,num,docs,i,index,doc,shard,integer,to,string,i,if,rarely,flush,shard,shard,false,assert,doc,count,shard,num,docs,final,repository,repository,create,repository,final,snapshot,snapshot,new,snapshot,repository,get,metadata,name,new,snapshot,id,random,alpha,of,length,10,snapshot,shard,shard,snapshot,repository,final,store,metadata,snapshot,store,files,shard,snapshot,store,metadata,assert,false,store,files,as,map,is,empty,close,shards,shard,list,string,deleted,files,random,subset,of,random,int,between,1,store,files,size,1,store,files,as,map,key,set,for,string,deleted,file,deleted,files,files,delete,shard,shard,path,resolve,index,resolve,deleted,file,shard,routing,shard,routing,shard,routing,helper,init,with,same,id,shard,routing,entry,shard,new,shard,shard,routing,shard,shard,path,shard,index,settings,get,index,meta,data,null,new,internal,engine,factory,recover,shard,from,snapshot,shard,snapshot,repository,test,util,check,index,shard,store,directory,final,directory,directory,shard,store,directory,final,list,string,directory,files,arrays,as,list,directory,list,all,for,store,file,meta,data,store,file,store,files,string,file,name,store,file,name,assert,true,file,file,name,does,not,exist,in,store,directory,directory,files,contains,file,name,assert,equals,store,file,length,shard,store,directory,file,length,file,name,finally,if,shard,null,shard,state,index,shard,state,closed,try,shard,close,test,false,finally,ioutils,close,shard,store
BlobStoreRepositoryRestoreTests -> public void testRestoreSnapshotWithExistingFiles() throws IOException;1532434432;Restoring a snapshot that contains multiple files must succeed even when_some files already exist in the shard's store.;public void testRestoreSnapshotWithExistingFiles() throws IOException {_        final IndexId indexId = new IndexId(randomAlphaOfLength(10), UUIDs.randomBase64UUID())__        final ShardId shardId = new ShardId(indexId.getName(), indexId.getId(), 0)___        IndexShard shard = newShard(shardId, true)__        try {_            _            final int numDocs = scaledRandomIntBetween(1, 500)__            recoverShardFromStore(shard)__            for (int i = 0_ i < numDocs_ i++) {_                indexDoc(shard, "_doc", Integer.toString(i))__                if (rarely()) {_                    flushShard(shard, false)__                }_            }_            assertDocCount(shard, numDocs)___            _            final Repository repository = createRepository()__            final Snapshot snapshot = new Snapshot(repository.getMetadata().name(), new SnapshotId(randomAlphaOfLength(10), "_uuid"))__            snapshotShard(shard, snapshot, repository)___            _            final Store.MetadataSnapshot storeFiles = shard.snapshotStoreMetadata()__            assertFalse(storeFiles.asMap().isEmpty())___            _            closeShards(shard)___            _            List<String> deletedFiles = randomSubsetOf(randomIntBetween(1, storeFiles.size() - 1), storeFiles.asMap().keySet())__            for (String deletedFile : deletedFiles) {_                Files.delete(shard.shardPath().resolveIndex().resolve(deletedFile))__            }__            _            ShardRouting shardRouting = ShardRoutingHelper.initWithSameId(shard.routingEntry(), EXISTING_STORE_INSTANCE)__            shard = newShard(_                    shardRouting,_                    shard.shardPath(),_                    shard.indexSettings().getIndexMetaData(),_                    null,_                    null,_                    new InternalEngineFactory(),_                    () -> {},_                    EMPTY_EVENT_LISTENER)___            _            recoverShardFromSnapshot(shard, snapshot, repository)___            _            TestUtil.checkIndex(shard.store().directory())___            _            final Directory directory = shard.store().directory()__            final List<String> directoryFiles = Arrays.asList(directory.listAll())___            for (StoreFileMetaData storeFile : storeFiles) {_                String fileName = storeFile.name()__                assertTrue("File [" + fileName + "] does not exist in store directory", directoryFiles.contains(fileName))__                assertEquals(storeFile.length(), shard.store().directory().fileLength(fileName))__            }_        } finally {_            if (shard != null && shard.state() != IndexShardState.CLOSED) {_                try {_                    shard.close("test", false)__                } finally {_                    IOUtils.close(shard.store())__                }_            }_        }_    };restoring,a,snapshot,that,contains,multiple,files,must,succeed,even,when,some,files,already,exist,in,the,shard,s,store;public,void,test,restore,snapshot,with,existing,files,throws,ioexception,final,index,id,index,id,new,index,id,random,alpha,of,length,10,uuids,random,base64uuid,final,shard,id,shard,id,new,shard,id,index,id,get,name,index,id,get,id,0,index,shard,shard,new,shard,shard,id,true,try,final,int,num,docs,scaled,random,int,between,1,500,recover,shard,from,store,shard,for,int,i,0,i,num,docs,i,index,doc,shard,integer,to,string,i,if,rarely,flush,shard,shard,false,assert,doc,count,shard,num,docs,final,repository,repository,create,repository,final,snapshot,snapshot,new,snapshot,repository,get,metadata,name,new,snapshot,id,random,alpha,of,length,10,snapshot,shard,shard,snapshot,repository,final,store,metadata,snapshot,store,files,shard,snapshot,store,metadata,assert,false,store,files,as,map,is,empty,close,shards,shard,list,string,deleted,files,random,subset,of,random,int,between,1,store,files,size,1,store,files,as,map,key,set,for,string,deleted,file,deleted,files,files,delete,shard,shard,path,resolve,index,resolve,deleted,file,shard,routing,shard,routing,shard,routing,helper,init,with,same,id,shard,routing,entry,shard,new,shard,shard,routing,shard,shard,path,shard,index,settings,get,index,meta,data,null,null,new,internal,engine,factory,recover,shard,from,snapshot,shard,snapshot,repository,test,util,check,index,shard,store,directory,final,directory,directory,shard,store,directory,final,list,string,directory,files,arrays,as,list,directory,list,all,for,store,file,meta,data,store,file,store,files,string,file,name,store,file,name,assert,true,file,file,name,does,not,exist,in,store,directory,directory,files,contains,file,name,assert,equals,store,file,length,shard,store,directory,file,length,file,name,finally,if,shard,null,shard,state,index,shard,state,closed,try,shard,close,test,false,finally,ioutils,close,shard,store
BlobStoreRepositoryRestoreTests -> public void testRestoreSnapshotWithExistingFiles() throws IOException;1536611444;Restoring a snapshot that contains multiple files must succeed even when_some files already exist in the shard's store.;public void testRestoreSnapshotWithExistingFiles() throws IOException {_        final IndexId indexId = new IndexId(randomAlphaOfLength(10), UUIDs.randomBase64UUID())__        final ShardId shardId = new ShardId(indexId.getName(), indexId.getId(), 0)___        IndexShard shard = newShard(shardId, true)__        try {_            _            final int numDocs = scaledRandomIntBetween(1, 500)__            recoverShardFromStore(shard)__            for (int i = 0_ i < numDocs_ i++) {_                indexDoc(shard, "_doc", Integer.toString(i))__                if (rarely()) {_                    flushShard(shard, false)__                }_            }_            assertDocCount(shard, numDocs)___            _            final Repository repository = createRepository()__            final Snapshot snapshot = new Snapshot(repository.getMetadata().name(), new SnapshotId(randomAlphaOfLength(10), "_uuid"))__            snapshotShard(shard, snapshot, repository)___            _            final Store.MetadataSnapshot storeFiles = shard.snapshotStoreMetadata()__            assertFalse(storeFiles.asMap().isEmpty())___            _            closeShards(shard)___            _            List<String> deletedFiles = randomSubsetOf(randomIntBetween(1, storeFiles.size() - 1), storeFiles.asMap().keySet())__            for (String deletedFile : deletedFiles) {_                Files.delete(shard.shardPath().resolveIndex().resolve(deletedFile))__            }__            _            ShardRouting shardRouting = ShardRoutingHelper.initWithSameId(shard.routingEntry(),_                RecoverySource.ExistingStoreRecoverySource.INSTANCE)__            shard = newShard(_                    shardRouting,_                    shard.shardPath(),_                    shard.indexSettings().getIndexMetaData(),_                    null,_                    null,_                    new InternalEngineFactory(),_                    () -> {},_                    EMPTY_EVENT_LISTENER)___            _            recoverShardFromSnapshot(shard, snapshot, repository)___            _            TestUtil.checkIndex(shard.store().directory())___            _            final Directory directory = shard.store().directory()__            final List<String> directoryFiles = Arrays.asList(directory.listAll())___            for (StoreFileMetaData storeFile : storeFiles) {_                String fileName = storeFile.name()__                assertTrue("File [" + fileName + "] does not exist in store directory", directoryFiles.contains(fileName))__                assertEquals(storeFile.length(), shard.store().directory().fileLength(fileName))__            }_        } finally {_            if (shard != null && shard.state() != IndexShardState.CLOSED) {_                try {_                    shard.close("test", false)__                } finally {_                    IOUtils.close(shard.store())__                }_            }_        }_    };restoring,a,snapshot,that,contains,multiple,files,must,succeed,even,when,some,files,already,exist,in,the,shard,s,store;public,void,test,restore,snapshot,with,existing,files,throws,ioexception,final,index,id,index,id,new,index,id,random,alpha,of,length,10,uuids,random,base64uuid,final,shard,id,shard,id,new,shard,id,index,id,get,name,index,id,get,id,0,index,shard,shard,new,shard,shard,id,true,try,final,int,num,docs,scaled,random,int,between,1,500,recover,shard,from,store,shard,for,int,i,0,i,num,docs,i,index,doc,shard,integer,to,string,i,if,rarely,flush,shard,shard,false,assert,doc,count,shard,num,docs,final,repository,repository,create,repository,final,snapshot,snapshot,new,snapshot,repository,get,metadata,name,new,snapshot,id,random,alpha,of,length,10,snapshot,shard,shard,snapshot,repository,final,store,metadata,snapshot,store,files,shard,snapshot,store,metadata,assert,false,store,files,as,map,is,empty,close,shards,shard,list,string,deleted,files,random,subset,of,random,int,between,1,store,files,size,1,store,files,as,map,key,set,for,string,deleted,file,deleted,files,files,delete,shard,shard,path,resolve,index,resolve,deleted,file,shard,routing,shard,routing,shard,routing,helper,init,with,same,id,shard,routing,entry,recovery,source,existing,store,recovery,source,instance,shard,new,shard,shard,routing,shard,shard,path,shard,index,settings,get,index,meta,data,null,null,new,internal,engine,factory,recover,shard,from,snapshot,shard,snapshot,repository,test,util,check,index,shard,store,directory,final,directory,directory,shard,store,directory,final,list,string,directory,files,arrays,as,list,directory,list,all,for,store,file,meta,data,store,file,store,files,string,file,name,store,file,name,assert,true,file,file,name,does,not,exist,in,store,directory,directory,files,contains,file,name,assert,equals,store,file,length,shard,store,directory,file,length,file,name,finally,if,shard,null,shard,state,index,shard,state,closed,try,shard,close,test,false,finally,ioutils,close,shard,store
BlobStoreRepositoryRestoreTests -> public void testRestoreSnapshotWithExistingFiles() throws IOException;1550668107;Restoring a snapshot that contains multiple files must succeed even when_some files already exist in the shard's store.;public void testRestoreSnapshotWithExistingFiles() throws IOException {_        final IndexId indexId = new IndexId(randomAlphaOfLength(10), UUIDs.randomBase64UUID())__        final ShardId shardId = new ShardId(indexId.getName(), indexId.getId(), 0)___        IndexShard shard = newShard(shardId, true)__        try {_            _            final int numDocs = scaledRandomIntBetween(1, 500)__            recoverShardFromStore(shard)__            for (int i = 0_ i < numDocs_ i++) {_                indexDoc(shard, "_doc", Integer.toString(i))__                if (rarely()) {_                    flushShard(shard, false)__                }_            }_            assertDocCount(shard, numDocs)___            _            final Repository repository = createRepository()__            final Snapshot snapshot = new Snapshot(repository.getMetadata().name(), new SnapshotId(randomAlphaOfLength(10), "_uuid"))__            snapshotShard(shard, snapshot, repository)___            _            final Store.MetadataSnapshot storeFiles = shard.snapshotStoreMetadata()__            assertFalse(storeFiles.asMap().isEmpty())___            _            closeShards(shard)___            _            List<String> deletedFiles = randomSubsetOf(randomIntBetween(1, storeFiles.size() - 1), storeFiles.asMap().keySet())__            for (String deletedFile : deletedFiles) {_                Files.delete(shard.shardPath().resolveIndex().resolve(deletedFile))__            }__            _            ShardRouting shardRouting = ShardRoutingHelper.initWithSameId(shard.routingEntry(),_                RecoverySource.ExistingStoreRecoverySource.INSTANCE)__            shard = newShard(_                    shardRouting,_                    shard.shardPath(),_                    shard.indexSettings().getIndexMetaData(),_                    null,_                    null,_                    new InternalEngineFactory(),_                    () -> {},_                    RetentionLeaseSyncer.EMPTY,_                    EMPTY_EVENT_LISTENER)___            _            recoverShardFromSnapshot(shard, snapshot, repository)___            _            TestUtil.checkIndex(shard.store().directory())___            _            final Directory directory = shard.store().directory()__            final List<String> directoryFiles = Arrays.asList(directory.listAll())___            for (StoreFileMetaData storeFile : storeFiles) {_                String fileName = storeFile.name()__                assertTrue("File [" + fileName + "] does not exist in store directory", directoryFiles.contains(fileName))__                assertEquals(storeFile.length(), shard.store().directory().fileLength(fileName))__            }_        } finally {_            if (shard != null && shard.state() != IndexShardState.CLOSED) {_                try {_                    shard.close("test", false)__                } finally {_                    IOUtils.close(shard.store())__                }_            }_        }_    };restoring,a,snapshot,that,contains,multiple,files,must,succeed,even,when,some,files,already,exist,in,the,shard,s,store;public,void,test,restore,snapshot,with,existing,files,throws,ioexception,final,index,id,index,id,new,index,id,random,alpha,of,length,10,uuids,random,base64uuid,final,shard,id,shard,id,new,shard,id,index,id,get,name,index,id,get,id,0,index,shard,shard,new,shard,shard,id,true,try,final,int,num,docs,scaled,random,int,between,1,500,recover,shard,from,store,shard,for,int,i,0,i,num,docs,i,index,doc,shard,integer,to,string,i,if,rarely,flush,shard,shard,false,assert,doc,count,shard,num,docs,final,repository,repository,create,repository,final,snapshot,snapshot,new,snapshot,repository,get,metadata,name,new,snapshot,id,random,alpha,of,length,10,snapshot,shard,shard,snapshot,repository,final,store,metadata,snapshot,store,files,shard,snapshot,store,metadata,assert,false,store,files,as,map,is,empty,close,shards,shard,list,string,deleted,files,random,subset,of,random,int,between,1,store,files,size,1,store,files,as,map,key,set,for,string,deleted,file,deleted,files,files,delete,shard,shard,path,resolve,index,resolve,deleted,file,shard,routing,shard,routing,shard,routing,helper,init,with,same,id,shard,routing,entry,recovery,source,existing,store,recovery,source,instance,shard,new,shard,shard,routing,shard,shard,path,shard,index,settings,get,index,meta,data,null,null,new,internal,engine,factory,retention,lease,syncer,empty,recover,shard,from,snapshot,shard,snapshot,repository,test,util,check,index,shard,store,directory,final,directory,directory,shard,store,directory,final,list,string,directory,files,arrays,as,list,directory,list,all,for,store,file,meta,data,store,file,store,files,string,file,name,store,file,name,assert,true,file,file,name,does,not,exist,in,store,directory,directory,files,contains,file,name,assert,equals,store,file,length,shard,store,directory,file,length,file,name,finally,if,shard,null,shard,state,index,shard,state,closed,try,shard,close,test,false,finally,ioutils,close,shard,store
BlobStoreRepositoryRestoreTests -> private Environment createEnvironment();1524684173;Create a {@link Environment} with random path.home and path.repo *;private Environment createEnvironment() {_        Path home = createTempDir()__        return TestEnvironment.newEnvironment(Settings.builder()_                                                      .put(Environment.PATH_HOME_SETTING.getKey(), home.toAbsolutePath())_            .put(Environment.PATH_REPO_SETTING.getKey(), home.resolve("repo").toAbsolutePath())_                                                      .build())__    };create,a,link,environment,with,random,path,home,and,path,repo;private,environment,create,environment,path,home,create,temp,dir,return,test,environment,new,environment,settings,builder,put,environment,get,key,home,to,absolute,path,put,environment,get,key,home,resolve,repo,to,absolute,path,build
BlobStoreRepositoryRestoreTests -> private Environment createEnvironment();1525162917;Create a {@link Environment} with random path.home and path.repo *;private Environment createEnvironment() {_        Path home = createTempDir()__        return TestEnvironment.newEnvironment(Settings.builder()_                                                      .put(Environment.PATH_HOME_SETTING.getKey(), home.toAbsolutePath())_            .put(Environment.PATH_REPO_SETTING.getKey(), home.resolve("repo").toAbsolutePath())_                                                      .build())__    };create,a,link,environment,with,random,path,home,and,path,repo;private,environment,create,environment,path,home,create,temp,dir,return,test,environment,new,environment,settings,builder,put,environment,get,key,home,to,absolute,path,put,environment,get,key,home,resolve,repo,to,absolute,path,build
BlobStoreRepositoryRestoreTests -> private Environment createEnvironment();1528706846;Create a {@link Environment} with random path.home and path.repo *;private Environment createEnvironment() {_        Path home = createTempDir()__        return TestEnvironment.newEnvironment(Settings.builder()_                                                      .put(Environment.PATH_HOME_SETTING.getKey(), home.toAbsolutePath())_            .put(Environment.PATH_REPO_SETTING.getKey(), home.resolve("repo").toAbsolutePath())_                                                      .build())__    };create,a,link,environment,with,random,path,home,and,path,repo;private,environment,create,environment,path,home,create,temp,dir,return,test,environment,new,environment,settings,builder,put,environment,get,key,home,to,absolute,path,put,environment,get,key,home,resolve,repo,to,absolute,path,build
BlobStoreRepositoryRestoreTests -> private Environment createEnvironment();1531729807;Create a {@link Environment} with random path.home and path.repo *;private Environment createEnvironment() {_        Path home = createTempDir()__        return TestEnvironment.newEnvironment(Settings.builder()_                                                      .put(Environment.PATH_HOME_SETTING.getKey(), home.toAbsolutePath())_            .put(Environment.PATH_REPO_SETTING.getKey(), home.resolve("repo").toAbsolutePath())_                                                      .build())__    };create,a,link,environment,with,random,path,home,and,path,repo;private,environment,create,environment,path,home,create,temp,dir,return,test,environment,new,environment,settings,builder,put,environment,get,key,home,to,absolute,path,put,environment,get,key,home,resolve,repo,to,absolute,path,build
BlobStoreRepositoryRestoreTests -> private Environment createEnvironment();1532434432;Create a {@link Environment} with random path.home and path.repo *;private Environment createEnvironment() {_        Path home = createTempDir()__        return TestEnvironment.newEnvironment(Settings.builder()_                                                      .put(Environment.PATH_HOME_SETTING.getKey(), home.toAbsolutePath())_            .put(Environment.PATH_REPO_SETTING.getKey(), home.resolve("repo").toAbsolutePath())_                                                      .build())__    };create,a,link,environment,with,random,path,home,and,path,repo;private,environment,create,environment,path,home,create,temp,dir,return,test,environment,new,environment,settings,builder,put,environment,get,key,home,to,absolute,path,put,environment,get,key,home,resolve,repo,to,absolute,path,build
BlobStoreRepositoryRestoreTests -> private Environment createEnvironment();1536611444;Create a {@link Environment} with random path.home and path.repo *;private Environment createEnvironment() {_        Path home = createTempDir()__        return TestEnvironment.newEnvironment(Settings.builder()_                                                      .put(Environment.PATH_HOME_SETTING.getKey(), home.toAbsolutePath())_            .put(Environment.PATH_REPO_SETTING.getKey(), home.resolve("repo").toAbsolutePath())_                                                      .build())__    };create,a,link,environment,with,random,path,home,and,path,repo;private,environment,create,environment,path,home,create,temp,dir,return,test,environment,new,environment,settings,builder,put,environment,get,key,home,to,absolute,path,put,environment,get,key,home,resolve,repo,to,absolute,path,build
BlobStoreRepositoryRestoreTests -> private Environment createEnvironment();1550668107;Create a {@link Environment} with random path.home and path.repo *;private Environment createEnvironment() {_        Path home = createTempDir()__        return TestEnvironment.newEnvironment(Settings.builder()_                                                      .put(Environment.PATH_HOME_SETTING.getKey(), home.toAbsolutePath())_            .put(Environment.PATH_REPO_SETTING.getKey(), home.resolve("repo").toAbsolutePath())_                                                      .build())__    };create,a,link,environment,with,random,path,home,and,path,repo;private,environment,create,environment,path,home,create,temp,dir,return,test,environment,new,environment,settings,builder,put,environment,get,key,home,to,absolute,path,put,environment,get,key,home,resolve,repo,to,absolute,path,build
BlobStoreRepositoryRestoreTests -> private Repository createRepository() throws IOException;1524684173;Create a {@link Repository} with a random name *;private Repository createRepository() throws IOException {_        Settings settings = Settings.builder().put("location", randomAlphaOfLength(10)).build()__        RepositoryMetaData repositoryMetaData = new RepositoryMetaData(randomAlphaOfLength(10), FsRepository.TYPE, settings)__        return new FsRepository(repositoryMetaData, createEnvironment(), xContentRegistry())__    };create,a,link,repository,with,a,random,name;private,repository,create,repository,throws,ioexception,settings,settings,settings,builder,put,location,random,alpha,of,length,10,build,repository,meta,data,repository,meta,data,new,repository,meta,data,random,alpha,of,length,10,fs,repository,type,settings,return,new,fs,repository,repository,meta,data,create,environment,x,content,registry
BlobStoreRepositoryRestoreTests -> private Repository createRepository() throws IOException;1525162917;Create a {@link Repository} with a random name *;private Repository createRepository() throws IOException {_        Settings settings = Settings.builder().put("location", randomAlphaOfLength(10)).build()__        RepositoryMetaData repositoryMetaData = new RepositoryMetaData(randomAlphaOfLength(10), FsRepository.TYPE, settings)__        return new FsRepository(repositoryMetaData, createEnvironment(), xContentRegistry())__    };create,a,link,repository,with,a,random,name;private,repository,create,repository,throws,ioexception,settings,settings,settings,builder,put,location,random,alpha,of,length,10,build,repository,meta,data,repository,meta,data,new,repository,meta,data,random,alpha,of,length,10,fs,repository,type,settings,return,new,fs,repository,repository,meta,data,create,environment,x,content,registry
BlobStoreRepositoryRestoreTests -> private Repository createRepository() throws IOException;1528706846;Create a {@link Repository} with a random name *;private Repository createRepository() throws IOException {_        Settings settings = Settings.builder().put("location", randomAlphaOfLength(10)).build()__        RepositoryMetaData repositoryMetaData = new RepositoryMetaData(randomAlphaOfLength(10), FsRepository.TYPE, settings)__        return new FsRepository(repositoryMetaData, createEnvironment(), xContentRegistry())__    };create,a,link,repository,with,a,random,name;private,repository,create,repository,throws,ioexception,settings,settings,settings,builder,put,location,random,alpha,of,length,10,build,repository,meta,data,repository,meta,data,new,repository,meta,data,random,alpha,of,length,10,fs,repository,type,settings,return,new,fs,repository,repository,meta,data,create,environment,x,content,registry
