commented;modifiers;parameterAmount;loc;comment;code
false;protected;7;10;;@Override protected InternalTDigestPercentileRanks createTestInstance(String name, List<PipelineAggregator> aggregators, Map<String, Object> metadata, boolean keyed, DocValueFormat format, double[] percents, double[] values) {     final TDigestState state = new TDigestState(100).     Arrays.stream(values).forEach(state::add).     assertEquals(state.centroidCount(), values.length).     return new InternalTDigestPercentileRanks(name, percents, state, keyed, format, aggregators, metadata). }
false;protected;2;22;;@Override protected void assertReduced(InternalTDigestPercentileRanks reduced, List<InternalTDigestPercentileRanks> inputs) {     // it is hard to check the values due to the inaccuracy of the algorithm     // the min/max values should be accurate due to the way the algo works so we can at least test those     double min = Double.POSITIVE_INFINITY.     double max = Double.NEGATIVE_INFINITY.     long totalCount = 0.     for (InternalTDigestPercentileRanks ranks : inputs) {         if (ranks.state.centroidCount() == 0) {             // quantiles would return NaN             continue.         }         totalCount += ranks.state.size().         min = Math.min(ranks.state.quantile(0), min).         max = Math.max(ranks.state.quantile(1), max).     }     assertEquals(totalCount, reduced.state.size()).     if (totalCount > 0) {         assertEquals(reduced.state.quantile(0), min, 0d).         assertEquals(reduced.state.quantile(1), max, 0d).     } }
false;protected;0;4;;@Override protected Reader<InternalTDigestPercentileRanks> instanceReader() {     return InternalTDigestPercentileRanks::new. }
false;protected;0;4;;@Override protected Class<? extends ParsedPercentiles> implementationClass() {     return ParsedTDigestPercentileRanks.class. }
false;protected;1;42;;@Override protected InternalTDigestPercentileRanks mutateInstance(InternalTDigestPercentileRanks instance) {     String name = instance.getName().     double[] percents = instance.keys.     TDigestState state = instance.state.     boolean keyed = instance.keyed.     DocValueFormat formatter = instance.formatter().     List<PipelineAggregator> pipelineAggregators = instance.pipelineAggregators().     Map<String, Object> metaData = instance.getMetaData().     switch(between(0, 4)) {         case 0:             name += randomAlphaOfLength(5).             break.         case 1:             percents = Arrays.copyOf(percents, percents.length + 1).             percents[percents.length - 1] = randomDouble() * 100.             Arrays.sort(percents).             break.         case 2:             TDigestState newState = new TDigestState(state.compression()).             newState.add(state).             for (int i = 0. i < between(10, 100). i++) {                 newState.add(randomDouble()).             }             state = newState.             break.         case 3:             keyed = keyed == false.             break.         case 4:             if (metaData == null) {                 metaData = new HashMap<>(1).             } else {                 metaData = new HashMap<>(instance.getMetaData()).             }             metaData.put(randomAlphaOfLength(15), randomInt()).             break.         default:             throw new AssertionError("Illegal randomisation branch").     }     return new InternalTDigestPercentileRanks(name, percents, state, keyed, formatter, pipelineAggregators, metaData). }
