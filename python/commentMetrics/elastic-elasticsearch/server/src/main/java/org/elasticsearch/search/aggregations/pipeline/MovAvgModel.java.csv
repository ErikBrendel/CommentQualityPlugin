commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Should this model be fit to the data via a cost minimizing algorithm by default?  */ ;/**  * Should this model be fit to the data via a cost minimizing algorithm by default?  */ public boolean minimizeByDefault() {     return false. }
true;public,abstract;0;1;/**  * Returns if the model can be cost minimized.  Not all models have parameters  * which can be tuned / optimized.  */ ;/**  * Returns if the model can be cost minimized.  Not all models have parameters  * which can be tuned / optimized.  */ public abstract boolean canBeMinimized().
true;public,abstract;0;1;/**  * Generates a "neighboring" model, where one of the tunable parameters has been  * randomly mutated within the allowed range.  Used for minimization  */ ;/**  * Generates a "neighboring" model, where one of the tunable parameters has been  * randomly mutated within the allowed range.  Used for minimization  */ public abstract MovAvgModel neighboringModel().
true;public;1;4;/**  * Checks to see this model can produce a new value, without actually running the algo.  * This can be used for models that have certain preconditions that need to be met in order  * to short-circuit execution  *  * @param valuesAvailable Number of values in the current window of values  * @return                Returns `true` if calling next() will produce a value, `false` otherwise  */ ;/**  * Checks to see this model can produce a new value, without actually running the algo.  * This can be used for models that have certain preconditions that need to be met in order  * to short-circuit execution  *  * @param valuesAvailable Number of values in the current window of values  * @return                Returns `true` if calling next() will produce a value, `false` otherwise  */ public boolean hasValue(int valuesAvailable) {     // Default implementation can always provide a next() value     return valuesAvailable > 0. }
true;public,abstract;1;1;/**  * Returns the next value in the series, according to the underlying smoothing model  *  * @param values    Collection of numerics to movingAvg, usually windowed  * @return          Returns a double, since most smoothing methods operate on floating points  */ ;/**  * Returns the next value in the series, according to the underlying smoothing model  *  * @param values    Collection of numerics to movingAvg, usually windowed  * @return          Returns a double, since most smoothing methods operate on floating points  */ public abstract double next(Collection<Double> values).
true;public;2;10;/**  * Predicts the next `n` values in the series.  *  * @param values            Collection of numerics to movingAvg, usually windowed  * @param numPredictions    Number of newly generated predictions to return  * @return                  Returns an array of doubles, since most smoothing methods operate on floating points  */ ;/**  * Predicts the next `n` values in the series.  *  * @param values            Collection of numerics to movingAvg, usually windowed  * @param numPredictions    Number of newly generated predictions to return  * @return                  Returns an array of doubles, since most smoothing methods operate on floating points  */ public double[] predict(Collection<Double> values, int numPredictions) {     assert (numPredictions >= 1).     // If there are no values, we can't do anything.  Return an array of NaNs.     if (values.isEmpty()) {         return emptyPredictions(numPredictions).     }     return doPredict(values, numPredictions). }
true;protected,abstract;2;1;/**  * Calls to the model-specific implementation which actually generates the predictions  *  * @param values            Collection of numerics to movingAvg, usually windowed  * @param numPredictions    Number of newly generated predictions to return  * @return                  Returns an array of doubles, since most smoothing methods operate on floating points  */ ;/**  * Calls to the model-specific implementation which actually generates the predictions  *  * @param values            Collection of numerics to movingAvg, usually windowed  * @param numPredictions    Number of newly generated predictions to return  * @return                  Returns an array of doubles, since most smoothing methods operate on floating points  */ protected abstract double[] doPredict(Collection<Double> values, int numPredictions).
true;protected;1;5;/**  * Returns an empty set of predictions, filled with NaNs  * @param numPredictions Number of empty predictions to generate  */ ;/**  * Returns an empty set of predictions, filled with NaNs  * @param numPredictions Number of empty predictions to generate  */ protected double[] emptyPredictions(int numPredictions) {     double[] predictions = new double[numPredictions].     Arrays.fill(predictions, Double.NaN).     return predictions. }
true;public,abstract;1;2;/**  * Write the model to the output stream  *  * @param out   Output stream  */ ;/**  * Write the model to the output stream  *  * @param out   Output stream  */ @Override public abstract void writeTo(StreamOutput out) throws IOException.
true;public,abstract;0;2;/**  * Clone the model, returning an exact copy  */ ;/**  * Clone the model, returning an exact copy  */ @Override public abstract MovAvgModel clone().
false;public,abstract;0;2;;@Override public abstract int hashCode().
false;public,abstract;1;2;;@Override public abstract boolean equals(Object obj).
true;public,abstract;3;2;/**  * Parse a settings hash that is specific to this model  *  * @param settings           Map of settings, extracted from the request  * @param pipelineName       Name of the parent pipeline agg  * @param windowSize         Size of the window for this moving avg  * @return                   A fully built moving average model  */ ;/**  * Parse a settings hash that is specific to this model  *  * @param settings           Map of settings, extracted from the request  * @param pipelineName       Name of the parent pipeline agg  * @param windowSize         Size of the window for this moving avg  * @return                   A fully built moving average model  */ public abstract MovAvgModel parse(@Nullable Map<String, Object> settings, String pipelineName, int windowSize) throws ParseException.
true;protected;3;22;/**  * Extracts a 0-1 inclusive double from the settings map, otherwise throws an exception  *  * @param settings      Map of settings provided to this model  * @param name          Name of parameter we are attempting to extract  * @param defaultValue  Default value to be used if value does not exist in map  * @return Double value extracted from settings map  */ ;/**  * Extracts a 0-1 inclusive double from the settings map, otherwise throws an exception  *  * @param settings      Map of settings provided to this model  * @param name          Name of parameter we are attempting to extract  * @param defaultValue  Default value to be used if value does not exist in map  * @return Double value extracted from settings map  */ protected double parseDoubleParam(@Nullable Map<String, Object> settings, String name, double defaultValue) throws ParseException {     if (settings == null) {         return defaultValue.     }     Object value = settings.get(name).     if (value == null) {         return defaultValue.     } else if (value instanceof Number) {         double v = ((Number) value).doubleValue().         if (v >= 0 && v <= 1) {             settings.remove(name).             return v.         }         throw new ParseException("Parameter [" + name + "] must be between 0-1 inclusive.  Provided" + "value was [" + v + "]", 0).     }     throw new ParseException("Parameter [" + name + "] must be a double, type `" + value.getClass().getSimpleName() + "` provided instead", 0). }
true;protected;3;16;/**  * Extracts an integer from the settings map, otherwise throws an exception  *  * @param settings      Map of settings provided to this model  * @param name          Name of parameter we are attempting to extract  * @param defaultValue  Default value to be used if value does not exist in map  * @return Integer value extracted from settings map  */ ;/**  * Extracts an integer from the settings map, otherwise throws an exception  *  * @param settings      Map of settings provided to this model  * @param name          Name of parameter we are attempting to extract  * @param defaultValue  Default value to be used if value does not exist in map  * @return Integer value extracted from settings map  */ protected int parseIntegerParam(@Nullable Map<String, Object> settings, String name, int defaultValue) throws ParseException {     if (settings == null) {         return defaultValue.     }     Object value = settings.get(name).     if (value == null) {         return defaultValue.     } else if (value instanceof Number) {         settings.remove(name).         return ((Number) value).intValue().     }     throw new ParseException("Parameter [" + name + "] must be an integer, type `" + value.getClass().getSimpleName() + "` provided instead", 0). }
true;protected;3;16;/**  * Extracts a boolean from the settings map, otherwise throws an exception  *  * @param settings      Map of settings provided to this model  * @param name          Name of parameter we are attempting to extract  * @param defaultValue  Default value to be used if value does not exist in map  * @return Boolean value extracted from settings map  */ ;/**  * Extracts a boolean from the settings map, otherwise throws an exception  *  * @param settings      Map of settings provided to this model  * @param name          Name of parameter we are attempting to extract  * @param defaultValue  Default value to be used if value does not exist in map  * @return Boolean value extracted from settings map  */ protected boolean parseBoolParam(@Nullable Map<String, Object> settings, String name, boolean defaultValue) throws ParseException {     if (settings == null) {         return defaultValue.     }     Object value = settings.get(name).     if (value == null) {         return defaultValue.     } else if (value instanceof Boolean) {         settings.remove(name).         return (Boolean) value.     }     throw new ParseException("Parameter [" + name + "] must be a boolean, type `" + value.getClass().getSimpleName() + "` provided instead", 0). }
false;protected;1;5;;protected void checkUnrecognizedParams(@Nullable Map<String, Object> settings) throws ParseException {     if (settings != null && settings.size() > 0) {         throw new ParseException("Unrecognized parameter(s): [" + settings.keySet() + "]", 0).     } }
