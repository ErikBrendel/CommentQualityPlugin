commented;modifiers;parameterAmount;loc;comment;code
true;public,synchronized;1;6;/**  * Change the interval between runs.  * If a future run is scheduled then this will reschedule it.  * @param interval The new interval between runs.  */ ;/**  * Change the interval between runs.  * If a future run is scheduled then this will reschedule it.  * @param interval The new interval between runs.  */ public synchronized void setInterval(TimeValue interval) {     this.interval = interval.     if (cancellable != null) {         rescheduleIfNecessary().     } }
false;public;0;3;;public TimeValue getInterval() {     return interval. }
true;protected,abstract;0;1;/**  * Test any external conditions that determine whether the task  * should be scheduled.  This method does *not* need to test if  * the task is closed, as being closed automatically prevents  * scheduling.  * @return Should the task be scheduled to run?  */ ;/**  * Test any external conditions that determine whether the task  * should be scheduled.  This method does *not* need to test if  * the task is closed, as being closed automatically prevents  * scheduling.  * @return Should the task be scheduled to run?  */ protected abstract boolean mustReschedule().
true;public,synchronized;0;19;/**  * Schedule the task to run after the configured interval if it  * is not closed and any further conditions imposed by derived  * classes are met.  Any previously scheduled invocation is  * cancelled.  */ ;/**  * Schedule the task to run after the configured interval if it  * is not closed and any further conditions imposed by derived  * classes are met.  Any previously scheduled invocation is  * cancelled.  */ public synchronized void rescheduleIfNecessary() {     if (isClosed()) {         return.     }     if (cancellable != null) {         cancellable.cancel().     }     if (interval.millis() > 0 && mustReschedule()) {         if (logger.isTraceEnabled()) {             logger.trace("scheduling {} every {}", toString(), interval).         }         cancellable = threadPool.schedule(this, interval, getThreadPool()).         isScheduledOrRunning = true.     } else {         logger.trace("scheduled {} disabled", toString()).         cancellable = null.         isScheduledOrRunning = false.     } }
false;public;0;5;;public boolean isScheduled() {     // from this method when a task is repeatedly running and rescheduling itself.     return isScheduledOrRunning. }
true;public,synchronized;0;7;/**  * Cancel any scheduled run, but do not prevent subsequent restarts.  */ ;/**  * Cancel any scheduled run, but do not prevent subsequent restarts.  */ public synchronized void cancel() {     if (cancellable != null) {         cancellable.cancel().         cancellable = null.     }     isScheduledOrRunning = false. }
true;public,synchronized;0;6;/**  * Cancel any scheduled run  */ ;/**  * Cancel any scheduled run  */ @Override public synchronized void close() {     if (closed.compareAndSet(false, true)) {         cancel().     } }
false;public;0;3;;public boolean isClosed() {     return this.closed.get(). }
false;public,final;0;24;;@Override public final void run() {     synchronized (this) {         cancellable = null.         isScheduledOrRunning = autoReschedule.     }     try {         runInternal().     } catch (Exception ex) {         if (lastThrownException == null || sameException(lastThrownException, ex) == false) {             // prevent the annoying fact of logging the same stuff all the time with an interval of 1 sec will spam all your logs             logger.warn(() -> new ParameterizedMessage("failed to run task {} - suppressing re-occurring exceptions unless the exception changes", toString()), ex).             lastThrownException = ex.         }     } finally {         if (autoReschedule) {             rescheduleIfNecessary().         }     } }
false;private,static;2;17;;private static boolean sameException(Exception left, Exception right) {     if (left.getClass() == right.getClass()) {         if (Objects.equals(left.getMessage(), right.getMessage())) {             StackTraceElement[] stackTraceLeft = left.getStackTrace().             StackTraceElement[] stackTraceRight = right.getStackTrace().             if (stackTraceLeft.length == stackTraceRight.length) {                 for (int i = 0. i < stackTraceLeft.length. i++) {                     if (stackTraceLeft[i].equals(stackTraceRight[i]) == false) {                         return false.                     }                 }                 return true.             }         }     }     return false. }
false;protected,abstract;0;1;;protected abstract void runInternal().
true;protected;0;3;/**  * Use the same threadpool by default.  * Derived classes can change this if required.  */ ;/**  * Use the same threadpool by default.  * Derived classes can change this if required.  */ protected String getThreadPool() {     return ThreadPool.Names.SAME. }
