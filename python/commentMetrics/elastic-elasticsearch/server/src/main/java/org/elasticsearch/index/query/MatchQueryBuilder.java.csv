commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;26;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(fieldName).     out.writeGenericValue(value).     if (out.getVersion().before(Version.V_6_0_0_rc1)) {         // deprecated type         MatchQuery.Type.BOOLEAN.writeTo(out).     }     operator.writeTo(out).     if (out.getVersion().before(Version.V_6_0_0_rc1)) {         // deprecated slop         out.writeVInt(MatchQuery.DEFAULT_PHRASE_SLOP).     }     out.writeVInt(prefixLength).     out.writeVInt(maxExpansions).     out.writeBoolean(fuzzyTranspositions).     out.writeBoolean(lenient).     zeroTermsQuery.writeTo(out).     // optional fields     out.writeOptionalString(analyzer).     out.writeOptionalString(minimumShouldMatch).     out.writeOptionalString(fuzzyRewrite).     out.writeOptionalWriteable(fuzziness).     out.writeOptionalFloat(cutoffFrequency).     if (out.getVersion().onOrAfter(Version.V_6_1_0)) {         out.writeBoolean(autoGenerateSynonymsPhraseQuery).     } }
true;public;0;3;/**  * Returns the field name used in this query.  */ ;/**  * Returns the field name used in this query.  */ public String fieldName() {     return this.fieldName. }
true;public;0;3;/**  * Returns the value used in this query.  */ ;/**  * Returns the value used in this query.  */ public Object value() {     return this.value. }
true;public;1;7;/**  * Sets the operator to use when using a boolean query. Defaults to {@code OR}.  */ ;/**  * Sets the operator to use when using a boolean query. Defaults to {@code OR}.  */ public MatchQueryBuilder operator(Operator operator) {     if (operator == null) {         throw new IllegalArgumentException("[" + NAME + "] requires operator to be non-null").     }     this.operator = operator.     return this. }
true;public;0;3;/**  * Returns the operator to use in a boolean query.  */ ;/**  * Returns the operator to use in a boolean query.  */ public Operator operator() {     return this.operator. }
true;public;1;4;/**  * Explicitly set the analyzer to use. Defaults to use explicit mapping config for the field, or, if not  * set, the default search analyzer.  */ ;/**  * Explicitly set the analyzer to use. Defaults to use explicit mapping config for the field, or, if not  * set, the default search analyzer.  */ public MatchQueryBuilder analyzer(String analyzer) {     this.analyzer = analyzer.     return this. }
true;public;0;3;/**  * Get the analyzer to use, if previously set, otherwise {@code null}  */ ;/**  * Get the analyzer to use, if previously set, otherwise {@code null}  */ public String analyzer() {     return this.analyzer. }
true;public;1;4;/**  * Sets the fuzziness used when evaluated to a fuzzy query type. Defaults to "AUTO".  */ ;/**  * Sets the fuzziness used when evaluated to a fuzzy query type. Defaults to "AUTO".  */ public MatchQueryBuilder fuzziness(Object fuzziness) {     this.fuzziness = Fuzziness.build(fuzziness).     return this. }
true;public;0;3;/**  *  Gets the fuzziness used when evaluated to a fuzzy query type.  */ ;/**  *  Gets the fuzziness used when evaluated to a fuzzy query type.  */ public Fuzziness fuzziness() {     return this.fuzziness. }
true;public;1;7;/**  * Sets the length of a length of common (non-fuzzy) prefix for fuzzy match queries  * @param prefixLength non-negative length of prefix  * @throws IllegalArgumentException in case the prefix is negative  */ ;/**  * Sets the length of a length of common (non-fuzzy) prefix for fuzzy match queries  * @param prefixLength non-negative length of prefix  * @throws IllegalArgumentException in case the prefix is negative  */ public MatchQueryBuilder prefixLength(int prefixLength) {     if (prefixLength < 0) {         throw new IllegalArgumentException("[" + NAME + "] requires prefix length to be non-negative.").     }     this.prefixLength = prefixLength.     return this. }
true;public;0;3;/**  * Gets the length of a length of common (non-fuzzy) prefix for fuzzy match queries  */ ;/**  * Gets the length of a length of common (non-fuzzy) prefix for fuzzy match queries  */ public int prefixLength() {     return this.prefixLength. }
true;public;1;7;/**  * When using fuzzy or prefix type query, the number of term expansions to use.  */ ;/**  * When using fuzzy or prefix type query, the number of term expansions to use.  */ public MatchQueryBuilder maxExpansions(int maxExpansions) {     if (maxExpansions <= 0) {         throw new IllegalArgumentException("[" + NAME + "] requires maxExpansions to be positive.").     }     this.maxExpansions = maxExpansions.     return this. }
true;public;0;3;/**  * Get the (optional) number of term expansions when using fuzzy or prefix type query.  */ ;/**  * Get the (optional) number of term expansions when using fuzzy or prefix type query.  */ public int maxExpansions() {     return this.maxExpansions. }
true;public;1;4;/**  * Set a cutoff value in [0..1] (or absolute number &gt.=1) representing the  * maximum threshold of a terms document frequency to be considered a low  * frequency term.  */ ;/**  * Set a cutoff value in [0..1] (or absolute number &gt.=1) representing the  * maximum threshold of a terms document frequency to be considered a low  * frequency term.  */ public MatchQueryBuilder cutoffFrequency(float cutoff) {     this.cutoffFrequency = cutoff.     return this. }
true;public;0;3;/**  * Gets the optional cutoff value, can be {@code null} if not set previously  */ ;/**  * Gets the optional cutoff value, can be {@code null} if not set previously  */ public Float cutoffFrequency() {     return this.cutoffFrequency. }
true;public;1;4;/**  * Sets optional minimumShouldMatch value to apply to the query  */ ;/**  * Sets optional minimumShouldMatch value to apply to the query  */ public MatchQueryBuilder minimumShouldMatch(String minimumShouldMatch) {     this.minimumShouldMatch = minimumShouldMatch.     return this. }
true;public;0;3;/**  * Gets the minimumShouldMatch value  */ ;/**  * Gets the minimumShouldMatch value  */ public String minimumShouldMatch() {     return this.minimumShouldMatch. }
true;public;1;4;/**  * Sets the fuzzy_rewrite parameter controlling how the fuzzy query will get rewritten  */ ;/**  * Sets the fuzzy_rewrite parameter controlling how the fuzzy query will get rewritten  */ public MatchQueryBuilder fuzzyRewrite(String fuzzyRewrite) {     this.fuzzyRewrite = fuzzyRewrite.     return this. }
true;public;0;3;/**  * Get the fuzzy_rewrite parameter  * @see #fuzzyRewrite(String)  */ ;/**  * Get the fuzzy_rewrite parameter  * @see #fuzzyRewrite(String)  */ public String fuzzyRewrite() {     return this.fuzzyRewrite. }
true;public;1;4;/**  * Sets whether transpositions are supported in fuzzy queries.<p>  * The default metric used by fuzzy queries to determine a match is the Damerau-Levenshtein  * distance formula which supports transpositions. Setting transposition to false will  * switch to classic Levenshtein distance.<br>  * If not set, Damerau-Levenshtein distance metric will be used.  */ ;/**  * Sets whether transpositions are supported in fuzzy queries.<p>  * The default metric used by fuzzy queries to determine a match is the Damerau-Levenshtein  * distance formula which supports transpositions. Setting transposition to false will  * switch to classic Levenshtein distance.<br>  * If not set, Damerau-Levenshtein distance metric will be used.  */ public MatchQueryBuilder fuzzyTranspositions(boolean fuzzyTranspositions) {     this.fuzzyTranspositions = fuzzyTranspositions.     return this. }
true;public;0;3;/**  * Gets the fuzzy query transposition setting.  */ ;/**  * Gets the fuzzy query transposition setting.  */ public boolean fuzzyTranspositions() {     return this.fuzzyTranspositions. }
true;public;1;4;/**  * Sets whether format based failures will be ignored.  */ ;/**  * Sets whether format based failures will be ignored.  */ public MatchQueryBuilder lenient(boolean lenient) {     this.lenient = lenient.     return this. }
true;public;0;3;/**  * Gets leniency setting that controls if format based failures will be ignored.  */ ;/**  * Gets leniency setting that controls if format based failures will be ignored.  */ public boolean lenient() {     return this.lenient. }
true;public;1;7;/**  * Sets query to use in case no query terms are available, e.g. after analysis removed them.  * Defaults to {@link MatchQuery.ZeroTermsQuery#NONE}, but can be set to  * {@link MatchQuery.ZeroTermsQuery#ALL} instead.  */ ;/**  * Sets query to use in case no query terms are available, e.g. after analysis removed them.  * Defaults to {@link MatchQuery.ZeroTermsQuery#NONE}, but can be set to  * {@link MatchQuery.ZeroTermsQuery#ALL} instead.  */ public MatchQueryBuilder zeroTermsQuery(MatchQuery.ZeroTermsQuery zeroTermsQuery) {     if (zeroTermsQuery == null) {         throw new IllegalArgumentException("[" + NAME + "] requires zeroTermsQuery to be non-null").     }     this.zeroTermsQuery = zeroTermsQuery.     return this. }
true;public;0;3;/**  * Returns the setting for handling zero terms queries.  */ ;/**  * Returns the setting for handling zero terms queries.  */ public MatchQuery.ZeroTermsQuery zeroTermsQuery() {     return this.zeroTermsQuery. }
false;public;1;4;;public MatchQueryBuilder autoGenerateSynonymsPhraseQuery(boolean enable) {     this.autoGenerateSynonymsPhraseQuery = enable.     return this. }
true;public;0;3;/**  * Whether phrase queries should be automatically generated for multi terms synonyms.  * Defaults to {@code true}.  */ ;/**  * Whether phrase queries should be automatically generated for multi terms synonyms.  * Defaults to {@code true}.  */ public boolean autoGenerateSynonymsPhraseQuery() {     return autoGenerateSynonymsPhraseQuery. }
false;public;2;33;;@Override public void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.startObject(fieldName).     builder.field(QUERY_FIELD.getPreferredName(), value).     builder.field(OPERATOR_FIELD.getPreferredName(), operator.toString()).     if (analyzer != null) {         builder.field(ANALYZER_FIELD.getPreferredName(), analyzer).     }     if (fuzziness != null) {         fuzziness.toXContent(builder, params).     }     builder.field(PREFIX_LENGTH_FIELD.getPreferredName(), prefixLength).     builder.field(MAX_EXPANSIONS_FIELD.getPreferredName(), maxExpansions).     if (minimumShouldMatch != null) {         builder.field(MINIMUM_SHOULD_MATCH_FIELD.getPreferredName(), minimumShouldMatch).     }     if (fuzzyRewrite != null) {         builder.field(FUZZY_REWRITE_FIELD.getPreferredName(), fuzzyRewrite).     }     // LUCENE 4 UPGRADE we need to document this & test this     builder.field(FUZZY_TRANSPOSITIONS_FIELD.getPreferredName(), fuzzyTranspositions).     builder.field(LENIENT_FIELD.getPreferredName(), lenient).     builder.field(ZERO_TERMS_QUERY_FIELD.getPreferredName(), zeroTermsQuery.toString()).     if (cutoffFrequency != null) {         builder.field(CUTOFF_FREQUENCY_FIELD.getPreferredName(), cutoffFrequency).     }     builder.field(GENERATE_SYNONYMS_PHRASE_QUERY.getPreferredName(), autoGenerateSynonymsPhraseQuery).     printBoostAndQueryName(builder).     builder.endObject().     builder.endObject(). }
false;protected;1;25;;@Override protected Query doToQuery(QueryShardContext context) throws IOException {     // validate context specific fields     if (analyzer != null && context.getIndexAnalyzers().get(analyzer) == null) {         throw new QueryShardException(context, "[" + NAME + "] analyzer [" + analyzer + "] not found").     }     MatchQuery matchQuery = new MatchQuery(context).     matchQuery.setOccur(operator.toBooleanClauseOccur()).     if (analyzer != null) {         matchQuery.setAnalyzer(analyzer).     }     matchQuery.setFuzziness(fuzziness).     matchQuery.setFuzzyPrefixLength(prefixLength).     matchQuery.setMaxExpansions(maxExpansions).     matchQuery.setTranspositions(fuzzyTranspositions).     matchQuery.setFuzzyRewriteMethod(QueryParsers.parseRewriteMethod(fuzzyRewrite, null, LoggingDeprecationHandler.INSTANCE)).     matchQuery.setLenient(lenient).     matchQuery.setCommonTermsCutoff(cutoffFrequency).     matchQuery.setZeroTermsQuery(zeroTermsQuery).     matchQuery.setAutoGenerateSynonymsPhraseQuery(autoGenerateSynonymsPhraseQuery).     Query query = matchQuery.parse(MatchQuery.Type.BOOLEAN, fieldName, value).     return Queries.maybeApplyMinimumShouldMatch(query, minimumShouldMatch). }
false;protected;1;17;;@Override protected boolean doEquals(MatchQueryBuilder other) {     return Objects.equals(fieldName, other.fieldName) && Objects.equals(value, other.value) && Objects.equals(operator, other.operator) && Objects.equals(analyzer, other.analyzer) && Objects.equals(fuzziness, other.fuzziness) && Objects.equals(prefixLength, other.prefixLength) && Objects.equals(maxExpansions, other.maxExpansions) && Objects.equals(minimumShouldMatch, other.minimumShouldMatch) && Objects.equals(fuzzyRewrite, other.fuzzyRewrite) && Objects.equals(lenient, other.lenient) && Objects.equals(fuzzyTranspositions, other.fuzzyTranspositions) && Objects.equals(zeroTermsQuery, other.zeroTermsQuery) && Objects.equals(cutoffFrequency, other.cutoffFrequency) && Objects.equals(autoGenerateSynonymsPhraseQuery, other.autoGenerateSynonymsPhraseQuery). }
false;protected;0;6;;@Override protected int doHashCode() {     return Objects.hash(fieldName, value, operator, analyzer, fuzziness, prefixLength, maxExpansions, minimumShouldMatch, fuzzyRewrite, lenient, fuzzyTranspositions, zeroTermsQuery, cutoffFrequency, autoGenerateSynonymsPhraseQuery). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public,static;1;108;;public static MatchQueryBuilder fromXContent(XContentParser parser) throws IOException {     String fieldName = null.     Object value = null.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String minimumShouldMatch = null.     String analyzer = null.     Operator operator = MatchQueryBuilder.DEFAULT_OPERATOR.     Fuzziness fuzziness = null.     int prefixLength = FuzzyQuery.defaultPrefixLength.     int maxExpansion = FuzzyQuery.defaultMaxExpansions.     boolean fuzzyTranspositions = FuzzyQuery.defaultTranspositions.     String fuzzyRewrite = null.     boolean lenient = MatchQuery.DEFAULT_LENIENCY.     Float cutOffFrequency = null.     ZeroTermsQuery zeroTermsQuery = MatchQuery.DEFAULT_ZERO_TERMS_QUERY.     boolean autoGenerateSynonymsPhraseQuery = true.     String queryName = null.     String currentFieldName = null.     XContentParser.Token token.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             throwParsingExceptionOnMultipleFields(NAME, parser.getTokenLocation(), fieldName, currentFieldName).             fieldName = currentFieldName.             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     currentFieldName = parser.currentName().                 } else if (token.isValue()) {                     if (QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         value = parser.objectText().                     } else if (ANALYZER_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         analyzer = parser.text().                     } else if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         boost = parser.floatValue().                     } else if (Fuzziness.FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         fuzziness = Fuzziness.parse(parser).                     } else if (PREFIX_LENGTH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         prefixLength = parser.intValue().                     } else if (MAX_EXPANSIONS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         maxExpansion = parser.intValue().                     } else if (OPERATOR_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         operator = Operator.fromString(parser.text()).                     } else if (MINIMUM_SHOULD_MATCH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         minimumShouldMatch = parser.textOrNull().                     } else if (FUZZY_REWRITE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         fuzzyRewrite = parser.textOrNull().                     } else if (FUZZY_TRANSPOSITIONS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         fuzzyTranspositions = parser.booleanValue().                     } else if (LENIENT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         lenient = parser.booleanValue().                     } else if (CUTOFF_FREQUENCY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         cutOffFrequency = parser.floatValue().                     } else if (ZERO_TERMS_QUERY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         String zeroTermsValue = parser.text().                         if ("none".equalsIgnoreCase(zeroTermsValue)) {                             zeroTermsQuery = MatchQuery.ZeroTermsQuery.NONE.                         } else if ("all".equalsIgnoreCase(zeroTermsValue)) {                             zeroTermsQuery = MatchQuery.ZeroTermsQuery.ALL.                         } else {                             throw new ParsingException(parser.getTokenLocation(), "Unsupported zero_terms_query value [" + zeroTermsValue + "]").                         }                     } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         queryName = parser.text().                     } else if (GENERATE_SYNONYMS_PHRASE_QUERY.match(currentFieldName, parser.getDeprecationHandler())) {                         autoGenerateSynonymsPhraseQuery = parser.booleanValue().                     } else {                         throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] query does not support [" + currentFieldName + "]").                     }                 } else {                     throw new ParsingException(parser.getTokenLocation(), "[" + NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]").                 }             }         } else {             throwParsingExceptionOnMultipleFields(NAME, parser.getTokenLocation(), fieldName, parser.currentName()).             fieldName = parser.currentName().             value = parser.objectText().         }     }     if (value == null) {         throw new ParsingException(parser.getTokenLocation(), "No text specified for text query").     }     MatchQueryBuilder matchQuery = new MatchQueryBuilder(fieldName, value).     matchQuery.operator(operator).     matchQuery.analyzer(analyzer).     matchQuery.minimumShouldMatch(minimumShouldMatch).     if (fuzziness != null) {         matchQuery.fuzziness(fuzziness).     }     matchQuery.fuzzyRewrite(fuzzyRewrite).     matchQuery.prefixLength(prefixLength).     matchQuery.fuzzyTranspositions(fuzzyTranspositions).     matchQuery.maxExpansions(maxExpansion).     matchQuery.lenient(lenient).     if (cutOffFrequency != null) {         matchQuery.cutoffFrequency(cutOffFrequency).     }     matchQuery.zeroTermsQuery(zeroTermsQuery).     matchQuery.autoGenerateSynonymsPhraseQuery(autoGenerateSynonymsPhraseQuery).     matchQuery.queryName(queryName).     matchQuery.boost(boost).     return matchQuery. }
