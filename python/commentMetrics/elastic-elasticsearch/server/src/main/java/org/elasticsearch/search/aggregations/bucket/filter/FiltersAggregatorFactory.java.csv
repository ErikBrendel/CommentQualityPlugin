commented;modifiers;parameterAmount;loc;comment;code
true;public;0;14;/**  * Returns the {@link Weight}s for this filter aggregation, creating it if  * necessary. This is done lazily so that the {@link Weight}s are only  * created if the aggregation collects documents reducing the overhead of  * the aggregation in the case where no documents are collected.  *  * Note that as aggregations are initialsed and executed in a serial manner,  * no concurrency considerations are necessary here.  */ ;/**  * Returns the {@link Weight}s for this filter aggregation, creating it if  * necessary. This is done lazily so that the {@link Weight}s are only  * created if the aggregation collects documents reducing the overhead of  * the aggregation in the case where no documents are collected.  *  * Note that as aggregations are initialsed and executed in a serial manner,  * no concurrency considerations are necessary here.  */ public Weight[] getWeights() {     if (weights == null) {         try {             IndexSearcher contextSearcher = context.searcher().             weights = new Weight[filters.length].             for (int i = 0. i < filters.length. ++i) {                 this.weights[i] = contextSearcher.createWeight(contextSearcher.rewrite(filters[i]), ScoreMode.COMPLETE_NO_SCORES, 1).             }         } catch (IOException e) {             throw new AggregationInitializationException("Failed to initialse filters for aggregation [" + name() + "]", e).         }     }     return weights. }
false;public;4;6;;@Override public Aggregator createInternal(Aggregator parent, boolean collectsFromSingleBucket, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {     return new FiltersAggregator(name, factories, keys, () -> getWeights(), keyed, otherBucket ? otherBucketKey : null, context, parent, pipelineAggregators, metaData). }
