commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;3;/**  * Creates a backoff policy that will not allow any backoff, i.e. an operation will fail after the first attempt.  *  * @return A backoff policy without any backoff period. The returned instance is thread safe.  */ ;/**  * Creates a backoff policy that will not allow any backoff, i.e. an operation will fail after the first attempt.  *  * @return A backoff policy without any backoff period. The returned instance is thread safe.  */ public static BackoffPolicy noBackoff() {     return NO_BACKOFF. }
true;public,static;2;3;/**  * Creates an new constant backoff policy with the provided configuration.  *  * @param delay              The delay defines how long to wait between retry attempts. Must not be null.  *                           Must be &lt.= <code>Integer.MAX_VALUE</code> ms.  * @param maxNumberOfRetries The maximum number of retries. Must be a non-negative number.  * @return A backoff policy with a constant wait time between retries. The returned instance is thread safe but each  * iterator created from it should only be used by a single thread.  */ ;/**  * Creates an new constant backoff policy with the provided configuration.  *  * @param delay              The delay defines how long to wait between retry attempts. Must not be null.  *                           Must be &lt.= <code>Integer.MAX_VALUE</code> ms.  * @param maxNumberOfRetries The maximum number of retries. Must be a non-negative number.  * @return A backoff policy with a constant wait time between retries. The returned instance is thread safe but each  * iterator created from it should only be used by a single thread.  */ public static BackoffPolicy constantBackoff(TimeValue delay, int maxNumberOfRetries) {     return new ConstantBackoff(checkDelay(delay), maxNumberOfRetries). }
true;public,static;0;3;/**  * Creates an new exponential backoff policy with a default configuration of 50 ms initial wait period and 8 retries taking  * roughly 5.1 seconds in total.  *  * @return A backoff policy with an exponential increase in wait time for retries. The returned instance is thread safe but each  * iterator created from it should only be used by a single thread.  */ ;/**  * Creates an new exponential backoff policy with a default configuration of 50 ms initial wait period and 8 retries taking  * roughly 5.1 seconds in total.  *  * @return A backoff policy with an exponential increase in wait time for retries. The returned instance is thread safe but each  * iterator created from it should only be used by a single thread.  */ public static BackoffPolicy exponentialBackoff() {     return exponentialBackoff(TimeValue.timeValueMillis(50), 8). }
true;public,static;2;3;/**  * Creates an new exponential backoff policy with the provided configuration.  *  * @param initialDelay       The initial delay defines how long to wait for the first retry attempt. Must not be null.  *                           Must be &lt.= <code>Integer.MAX_VALUE</code> ms.  * @param maxNumberOfRetries The maximum number of retries. Must be a non-negative number.  * @return A backoff policy with an exponential increase in wait time for retries. The returned instance is thread safe but each  * iterator created from it should only be used by a single thread.  */ ;/**  * Creates an new exponential backoff policy with the provided configuration.  *  * @param initialDelay       The initial delay defines how long to wait for the first retry attempt. Must not be null.  *                           Must be &lt.= <code>Integer.MAX_VALUE</code> ms.  * @param maxNumberOfRetries The maximum number of retries. Must be a non-negative number.  * @return A backoff policy with an exponential increase in wait time for retries. The returned instance is thread safe but each  * iterator created from it should only be used by a single thread.  */ public static BackoffPolicy exponentialBackoff(TimeValue initialDelay, int maxNumberOfRetries) {     return new ExponentialBackoff((int) checkDelay(initialDelay).millis(), maxNumberOfRetries). }
true;public,static;2;3;/**  * Wraps the backoff policy in one that calls a method every time a new backoff is taken from the policy.  */ ;/**  * Wraps the backoff policy in one that calls a method every time a new backoff is taken from the policy.  */ public static BackoffPolicy wrap(BackoffPolicy delegate, Runnable onBackoff) {     return new WrappedBackoffPolicy(delegate, onBackoff). }
false;private,static;1;6;;private static TimeValue checkDelay(TimeValue delay) {     if (delay.millis() > Integer.MAX_VALUE) {         throw new IllegalArgumentException("delay must be <= " + Integer.MAX_VALUE + " ms").     }     return delay. }
false;public;0;4;;@Override public boolean hasNext() {     return false. }
false;public;0;4;;@Override public TimeValue next() {     throw new NoSuchElementException("No backoff"). }
false;public;0;14;;@Override public Iterator<TimeValue> iterator() {     return new Iterator<TimeValue>() {          @Override         public boolean hasNext() {             return false.         }          @Override         public TimeValue next() {             throw new NoSuchElementException("No backoff").         }     }. }
false;public;0;4;;@Override public Iterator<TimeValue> iterator() {     return new ExponentialBackoffIterator(start, numberOfElements). }
false;public;0;4;;@Override public boolean hasNext() {     return currentlyConsumed < numberOfElements. }
false;public;0;9;;@Override public TimeValue next() {     if (!hasNext()) {         throw new NoSuchElementException("Only up to " + numberOfElements + " elements").     }     int result = start + 10 * ((int) Math.exp(0.8d * (currentlyConsumed)) - 1).     currentlyConsumed++.     return TimeValue.timeValueMillis(result). }
false;public;0;4;;@Override public Iterator<TimeValue> iterator() {     return new ConstantBackoffIterator(delay, numberOfElements). }
false;public;0;4;;@Override public boolean hasNext() {     return curr < numberOfElements. }
false;public;0;8;;@Override public TimeValue next() {     if (!hasNext()) {         throw new NoSuchElementException().     }     curr++.     return delay. }
false;public;0;4;;@Override public Iterator<TimeValue> iterator() {     return new WrappedBackoffIterator(delegate.iterator(), onBackoff). }
false;public;0;4;;@Override public boolean hasNext() {     return delegate.hasNext(). }
false;public;0;8;;@Override public TimeValue next() {     if (false == delegate.hasNext()) {         throw new NoSuchElementException().     }     onBackoff.run().     return delegate.next(). }
