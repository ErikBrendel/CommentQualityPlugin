commented;modifiers;parameterAmount;loc;comment;code
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new NestedAggregationBuilder(this, factoriesBuilder, metaData). }
false;protected;1;4;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeString(path). }
true;public;0;3;/**  * Get the path to use for this nested aggregation.  */ ;/**  * Get the path to use for this nested aggregation.  */ public String path() {     return path. }
false;protected;3;20;;@Override protected AggregatorFactory<?> doBuild(SearchContext context, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     ObjectMapper childObjectMapper = context.getObjectMapper(path).     if (childObjectMapper == null) {         // in case the path has been unmapped:         return new NestedAggregatorFactory(name, null, null, context, parent, subFactoriesBuilder, metaData).     }     if (childObjectMapper.nested().isNested() == false) {         throw new AggregationExecutionException("[nested] nested path [" + path + "] is not nested").     }     try {         ObjectMapper parentObjectMapper = context.getQueryShardContext().nestedScope().nextLevel(childObjectMapper).         return new NestedAggregatorFactory(name, parentObjectMapper, childObjectMapper, context, parent, subFactoriesBuilder, metaData).     } finally {         context.getQueryShardContext().nestedScope().previousLevel().     } }
false;protected;2;7;;@Override protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(NestedAggregator.PATH_FIELD.getPreferredName(), path).     builder.endObject().     return builder. }
false;public,static;2;27;;public static NestedAggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     String path = null.     XContentParser.Token token.     String currentFieldName = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.VALUE_STRING) {             if (NestedAggregator.PATH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 path = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + aggregationName + "]: [" + currentFieldName + "].").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "Unexpected token " + token + " in [" + aggregationName + "].").         }     }     if (path == null) {         // "field" doesn't exist, so we fall back to the context of the ancestors         throw new ParsingException(parser.getTokenLocation(), "Missing [path] field for nested aggregation [" + aggregationName + "]").     }     return new NestedAggregationBuilder(aggregationName, path). }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(path). }
false;protected;1;5;;@Override protected boolean doEquals(Object obj) {     NestedAggregationBuilder other = (NestedAggregationBuilder) obj.     return Objects.equals(path, other.path). }
false;public;0;4;;@Override public String getType() {     return NAME. }
