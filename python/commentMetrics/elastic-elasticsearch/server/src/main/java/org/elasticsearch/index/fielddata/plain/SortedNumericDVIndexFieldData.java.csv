commented;modifiers;parameterAmount;loc;comment;code
false;public;4;49;;@Override public SortField sortField(Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse) {     final XFieldComparatorSource source.     switch(numericType) {         case HALF_FLOAT:         case FLOAT:             source = new FloatValuesComparatorSource(this, missingValue, sortMode, nested).             break.         case DOUBLE:             source = new DoubleValuesComparatorSource(this, missingValue, sortMode, nested).             break.         default:             assert !numericType.isFloatingPoint().             source = new LongValuesComparatorSource(this, missingValue, sortMode, nested).             break.     }     /**      * Check if we can use a simple {@link SortedNumericSortField} compatible with index sorting and      * returns a custom sort field otherwise.      */     if (nested != null || (sortMode != MultiValueMode.MAX && sortMode != MultiValueMode.MIN) || numericType == NumericType.HALF_FLOAT) {         return new SortField(fieldName, source, reverse).     }     final SortField sortField.     final SortedNumericSelector.Type selectorType = sortMode == MultiValueMode.MAX ? SortedNumericSelector.Type.MAX : SortedNumericSelector.Type.MIN.     switch(numericType) {         case FLOAT:             sortField = new SortedNumericSortField(fieldName, SortField.Type.FLOAT, reverse, selectorType).             break.         case DOUBLE:             sortField = new SortedNumericSortField(fieldName, SortField.Type.DOUBLE, reverse, selectorType).             break.         default:             assert !numericType.isFloatingPoint().             sortField = new SortedNumericSortField(fieldName, SortField.Type.LONG, reverse, selectorType).             break.     }     sortField.setMissingValue(source.missingObject(missingValue, reverse)).     return sortField. }
false;public;0;4;;@Override public NumericType getNumericType() {     return numericType. }
false;public;1;4;;@Override public AtomicNumericFieldData loadDirect(LeafReaderContext context) throws Exception {     return load(context). }
false;public;1;18;;@Override public AtomicNumericFieldData load(LeafReaderContext context) {     final LeafReader reader = context.reader().     final String field = fieldName.     switch(numericType) {         case HALF_FLOAT:             return new SortedNumericHalfFloatFieldData(reader, field).         case FLOAT:             return new SortedNumericFloatFieldData(reader, field).         case DOUBLE:             return new SortedNumericDoubleFieldData(reader, field).         case DATE_NANOSECONDS:             return new NanoSecondFieldData(reader, field, numericType).         default:             return new SortedNumericLongFieldData(reader, field, numericType).     } }
false;public;1;4;;@Override public boolean advanceExact(int target) throws IOException {     return dv.advanceExact(target). }
false;public;0;4;;@Override public long nextValue() throws IOException {     return DateUtils.toMilliSeconds(dv.nextValue()). }
false;public;0;4;;@Override public int docValueCount() {     return dv.docValueCount(). }
false;public;0;4;;@Override public int nextDoc() throws IOException {     return dv.nextDoc(). }
false;public;0;26;;@Override public SortedNumericDocValues getLongValues() {     final SortedNumericDocValues dv = getLongValuesAsNanos().     return new AbstractSortedNumericDocValues() {          @Override         public boolean advanceExact(int target) throws IOException {             return dv.advanceExact(target).         }          @Override         public long nextValue() throws IOException {             return DateUtils.toMilliSeconds(dv.nextValue()).         }          @Override         public int docValueCount() {             return dv.docValueCount().         }          @Override         public int nextDoc() throws IOException {             return dv.nextDoc().         }     }. }
false;public;0;7;;public SortedNumericDocValues getLongValuesAsNanos() {     try {         return DocValues.getSortedNumeric(reader, fieldName).     } catch (IOException e) {         throw new IllegalStateException("Cannot load doc values", e).     } }
false;public;0;8;;@Override public SortedNumericDocValues getLongValues() {     try {         return DocValues.getSortedNumeric(reader, field).     } catch (IOException e) {         throw new IllegalStateException("Cannot load doc values", e).     } }
false;public;0;4;;@Override public Collection<Accountable> getChildResources() {     return Collections.emptyList(). }
false;public;0;15;;@Override public SortedNumericDoubleValues getDoubleValues() {     try {         SortedNumericDocValues raw = DocValues.getSortedNumeric(reader, field).         NumericDocValues single = DocValues.unwrapSingleton(raw).         if (single != null) {             return FieldData.singleton(new SingleHalfFloatValues(single)).         } else {             return new MultiHalfFloatValues(raw).         }     } catch (IOException e) {         throw new IllegalStateException("Cannot load doc values", e).     } }
false;public;0;4;;@Override public Collection<Accountable> getChildResources() {     return Collections.emptyList(). }
false;public;0;4;;@Override public double doubleValue() throws IOException {     return HalfFloatPoint.sortableShortToHalfFloat((short) in.longValue()). }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return in.advanceExact(doc). }
false;public;1;4;;@Override public boolean advanceExact(int target) throws IOException {     return in.advanceExact(target). }
false;public;0;4;;@Override public double nextValue() throws IOException {     return HalfFloatPoint.sortableShortToHalfFloat((short) in.nextValue()). }
false;public;0;4;;@Override public int docValueCount() {     return in.docValueCount(). }
false;public;0;15;;@Override public SortedNumericDoubleValues getDoubleValues() {     try {         SortedNumericDocValues raw = DocValues.getSortedNumeric(reader, field).         NumericDocValues single = DocValues.unwrapSingleton(raw).         if (single != null) {             return FieldData.singleton(new SingleFloatValues(single)).         } else {             return new MultiFloatValues(raw).         }     } catch (IOException e) {         throw new IllegalStateException("Cannot load doc values", e).     } }
false;public;0;4;;@Override public Collection<Accountable> getChildResources() {     return Collections.emptyList(). }
false;public;0;4;;@Override public double doubleValue() throws IOException {     return NumericUtils.sortableIntToFloat((int) in.longValue()). }
false;public;1;4;;@Override public boolean advanceExact(int doc) throws IOException {     return in.advanceExact(doc). }
false;public;1;4;;@Override public boolean advanceExact(int target) throws IOException {     return in.advanceExact(target). }
false;public;0;4;;@Override public double nextValue() throws IOException {     return NumericUtils.sortableIntToFloat((int) in.nextValue()). }
false;public;0;4;;@Override public int docValueCount() {     return in.docValueCount(). }
false;public;0;9;;@Override public SortedNumericDoubleValues getDoubleValues() {     try {         SortedNumericDocValues raw = DocValues.getSortedNumeric(reader, field).         return FieldData.sortableLongBitsToDoubles(raw).     } catch (IOException e) {         throw new IllegalStateException("Cannot load doc values", e).     } }
false;public;0;4;;@Override public Collection<Accountable> getChildResources() {     return Collections.emptyList(). }
