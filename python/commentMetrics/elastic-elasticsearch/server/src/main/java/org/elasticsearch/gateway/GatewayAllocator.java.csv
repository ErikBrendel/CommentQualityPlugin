commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;public void cleanCaches() {     Releasables.close(asyncFetchStarted.values()).     asyncFetchStarted.clear().     Releasables.close(asyncFetchStore.values()).     asyncFetchStore.clear(). }
false;public;0;10;;public int getNumberOfInFlightFetch() {     int count = 0.     for (AsyncShardFetch<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> fetch : asyncFetchStarted.values()) {         count += fetch.getNumberOfInFlightFetches().     }     for (AsyncShardFetch<TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData> fetch : asyncFetchStore.values()) {         count += fetch.getNumberOfInFlightFetches().     }     return count. }
false;public;2;6;;public void applyStartedShards(final RoutingAllocation allocation, final List<ShardRouting> startedShards) {     for (ShardRouting startedShard : startedShards) {         Releasables.close(asyncFetchStarted.remove(startedShard.shardId())).         Releasables.close(asyncFetchStore.remove(startedShard.shardId())).     } }
false;public;2;6;;public void applyFailedShards(final RoutingAllocation allocation, final List<FailedShard> failedShards) {     for (FailedShard failedShard : failedShards) {         Releasables.close(asyncFetchStarted.remove(failedShard.getRoutingEntry().shardId())).         Releasables.close(asyncFetchStore.remove(failedShard.getRoutingEntry().shardId())).     } }
false;public;1;3;;public void allocateUnassigned(final RoutingAllocation allocation) {     innerAllocatedUnassigned(allocation, primaryShardAllocator, replicaShardAllocator). }
true;protected,static;3;10;// allow for testing infra to change shard allocators implementation ;// allow for testing infra to change shard allocators implementation protected static void innerAllocatedUnassigned(RoutingAllocation allocation, PrimaryShardAllocator primaryShardAllocator, ReplicaShardAllocator replicaShardAllocator) {     RoutingNodes.UnassignedShards unassigned = allocation.routingNodes().unassigned().     // sort for priority ordering     unassigned.sort(PriorityComparator.getAllocationComparator(allocation)).     primaryShardAllocator.allocateUnassigned(allocation).     replicaShardAllocator.processExistingRecoveries(allocation).     replicaShardAllocator.allocateUnassigned(allocation). }
true;public;2;7;/**  * Computes and returns the design for allocating a single unassigned shard.  If called on an assigned shard,  * {@link AllocateUnassignedDecision#NOT_TAKEN} is returned.  */ ;/**  * Computes and returns the design for allocating a single unassigned shard.  If called on an assigned shard,  * {@link AllocateUnassignedDecision#NOT_TAKEN} is returned.  */ public AllocateUnassignedDecision decideUnassignedShardAllocation(ShardRouting unassignedShard, RoutingAllocation routingAllocation) {     if (unassignedShard.primary()) {         return primaryShardAllocator.makeAllocationDecision(unassignedShard, routingAllocation, logger).     } else {         return replicaShardAllocator.makeAllocationDecision(unassignedShard, routingAllocation, logger).     } }
false;protected;2;5;;@Override protected void reroute(ShardId shardId, String reason) {     logger.trace("{} scheduling reroute for {}", shardId, reason).     routingService.reroute("async_shard_fetch"). }
false;protected;2;14;;@Override protected AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> fetchData(ShardRouting shard, RoutingAllocation allocation) {     AsyncShardFetch<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> fetch = asyncFetchStarted.computeIfAbsent(shard.shardId(), shardId -> new InternalAsyncFetch<>(logger, "shard_started", shardId, startedAction)).     AsyncShardFetch.FetchResult<TransportNodesListGatewayStartedShards.NodeGatewayStartedShards> shardState = fetch.fetchData(allocation.nodes(), allocation.getIgnoreNodes(shard.shardId())).     if (shardState.hasData()) {         shardState.processAllocation(allocation).     }     return shardState. }
false;protected;2;13;;@Override protected AsyncShardFetch.FetchResult<TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData> fetchData(ShardRouting shard, RoutingAllocation allocation) {     AsyncShardFetch<TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData> fetch = asyncFetchStore.computeIfAbsent(shard.shardId(), shardId -> new InternalAsyncFetch<>(logger, "shard_store", shard.shardId(), storeAction)).     AsyncShardFetch.FetchResult<TransportNodesListShardStoreMetaData.NodeStoreFilesMetaData> shardStores = fetch.fetchData(allocation.nodes(), allocation.getIgnoreNodes(shard.shardId())).     if (shardStores.hasData()) {         shardStores.processAllocation(allocation).     }     return shardStores. }
false;protected;1;4;;@Override protected boolean hasInitiatedFetching(ShardRouting shard) {     return asyncFetchStore.get(shard.shardId()) != null. }
