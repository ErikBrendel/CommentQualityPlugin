commented;modifiers;parameterAmount;loc;comment;code
true;public,static;0;3;/**  * This method returns a listenable future. The listeners will be called on completion of the future.  * The listeners will be executed by the same thread that completes the future.  *  * @param <T> the result of the future  * @return a listenable future  */ ;/**  * This method returns a listenable future. The listeners will be called on completion of the future.  * The listeners will be executed by the same thread that completes the future.  *  * @param <T> the result of the future  * @return a listenable future  */ public static <T> PlainListenableActionFuture<T> newListenableFuture() {     return new PlainListenableActionFuture<>(). }
true;public,static;1;3;/**  * This method returns a listenable future. The listeners will be called on completion of the future.  * The listeners will be executed on the LISTENER thread pool.  * @param threadPool the thread pool used to execute listeners  * @param <T> the result of the future  * @return a listenable future  */ ;/**  * This method returns a listenable future. The listeners will be called on completion of the future.  * The listeners will be executed on the LISTENER thread pool.  * @param threadPool the thread pool used to execute listeners  * @param <T> the result of the future  * @return a listenable future  */ public static <T> PlainListenableActionFuture<T> newDispatchingListenableFuture(ThreadPool threadPool) {     return new DispatchingListenableActionFuture<>(threadPool). }
false;public;1;4;;@Override public void addListener(final ActionListener<T> listener) {     internalAddListener(listener). }
false;protected;0;18;;@Override protected void done() {     super.done().     synchronized (this) {         executedListeners = true.     }     Object listeners = this.listeners.     if (listeners != null) {         if (listeners instanceof List) {             List list = (List) listeners.             for (Object listener : list) {                 executeListener((ActionListener<T>) listener).             }         } else {             executeListener((ActionListener<T>) listeners).         }     } }
false;protected;1;4;;@Override protected T convert(T listenerResponse) {     return listenerResponse. }
false;private;1;24;;private void internalAddListener(ActionListener<T> listener) {     boolean executeImmediate = false.     synchronized (this) {         if (executedListeners) {             executeImmediate = true.         } else {             Object listeners = this.listeners.             if (listeners == null) {                 listeners = listener.             } else if (listeners instanceof List) {                 ((List) this.listeners).add(listener).             } else {                 Object orig = listeners.                 listeners = new ArrayList<>(2).                 ((List) listeners).add(orig).                 ((List) listeners).add(listener).             }             this.listeners = listeners.         }     }     if (executeImmediate) {         executeListener(listener).     } }
false;private;1;9;;private void executeListener(final ActionListener<T> listener) {     try {         // we use a timeout of 0 to by pass assertion forbidding to call actionGet() (blocking) on a network thread.         // here we know we will never block         listener.onResponse(actionGet(0)).     } catch (Exception e) {         listener.onFailure(e).     } }
false;public;1;4;;@Override public void addListener(final ActionListener<T> listener) {     super.addListener(new ThreadedActionListener<>(logger, threadPool, ThreadPool.Names.LISTENER, listener, false)). }
