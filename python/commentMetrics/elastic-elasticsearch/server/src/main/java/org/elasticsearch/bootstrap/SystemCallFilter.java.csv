commented;modifiers;parameterAmount;loc;comment;code
true;;5;1;/**  * maps to prctl(2)  */ ;/**  * maps to prctl(2)  */ int prctl(int option, NativeLong arg2, NativeLong arg3, NativeLong arg4, NativeLong arg5).
true;;2;1;/**  * used to call seccomp(2), its too new...  * this is the only way, DON'T use it on some other architecture unless you know wtf you are doing  */ ;/**  * used to call seccomp(2), its too new...  * this is the only way, DON'T use it on some other architecture unless you know wtf you are doing  */ NativeLong syscall(NativeLong number, Object... args).
false;protected;0;4;;@Override protected List<String> getFieldOrder() {     return Arrays.asList("len", "filter"). }
false;static;2;3;;static SockFilter BPF_STMT(int code, int k) {     return new SockFilter((short) code, (byte) 0, (byte) 0, k). }
false;static;4;3;;static SockFilter BPF_JUMP(int code, int k, int jt, int jf) {     return new SockFilter((short) code, (byte) jt, (byte) jf, k). }
true;private,static;5;3;/**  * invokes prctl() from linux libc library  */ ;/**  * invokes prctl() from linux libc library  */ private static int linux_prctl(int option, long arg2, long arg3, long arg4, long arg5) {     return linux_libc.prctl(option, new NativeLong(arg2), new NativeLong(arg3), new NativeLong(arg4), new NativeLong(arg5)). }
true;private,static;2;3;/**  * invokes syscall() from linux libc library  */ ;/**  * invokes syscall() from linux libc library  */ private static long linux_syscall(long number, Object... args) {     return linux_libc.syscall(new NativeLong(number), args).longValue(). }
true;private,static;0;155;/**  * try to install our BPF filters via seccomp() or prctl() to block execution  */ ;/**  * try to install our BPF filters via seccomp() or prctl() to block execution  */ private static int linuxImpl() {     // first be defensive: we can give nice errors this way, at the very least.     // also, some of these security features get backported to old versions, checking kernel version here is a big no-no!     final Arch arch = ARCHITECTURES.get(Constants.OS_ARCH).     boolean supported = Constants.LINUX && arch != null.     if (supported == false) {         throw new UnsupportedOperationException("seccomp unavailable: '" + Constants.OS_ARCH + "' architecture unsupported").     }     // we couldn't link methods, could be some really ancient kernel (e.g. < 2.1.57) or some bug     if (linux_libc == null) {         throw new UnsupportedOperationException("seccomp unavailable: could not link methods. requires kernel 3.5+ " + "with CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER compiled in").     }     // try to check system calls really are who they claim     // you never know (e.g. https://chromium.googlesource.com/chromium/src.git/+/master/sandbox/linux/seccomp-bpf/sandbox_bpf.cc#57)     final int bogusArg = 0xf7a46a5c.     // test seccomp(BOGUS)     long ret = linux_syscall(arch.seccomp, bogusArg).     if (ret != -1) {         throw new UnsupportedOperationException("seccomp unavailable: seccomp(BOGUS_OPERATION) returned " + ret).     } else {         int errno = Native.getLastError().         switch(errno) {             // ok             case ENOSYS:                 break.             // ok             case EINVAL:                 break.             default:                 throw new UnsupportedOperationException("seccomp(BOGUS_OPERATION): " + JNACLibrary.strerror(errno)).         }     }     // test seccomp(VALID, BOGUS)     ret = linux_syscall(arch.seccomp, SECCOMP_SET_MODE_FILTER, bogusArg).     if (ret != -1) {         throw new UnsupportedOperationException("seccomp unavailable: seccomp(SECCOMP_SET_MODE_FILTER, BOGUS_FLAG) returned " + ret).     } else {         int errno = Native.getLastError().         switch(errno) {             // ok             case ENOSYS:                 break.             // ok             case EINVAL:                 break.             default:                 throw new UnsupportedOperationException("seccomp(SECCOMP_SET_MODE_FILTER, BOGUS_FLAG): " + JNACLibrary.strerror(errno)).         }     }     // test prctl(BOGUS)     ret = linux_prctl(bogusArg, 0, 0, 0, 0).     if (ret != -1) {         throw new UnsupportedOperationException("seccomp unavailable: prctl(BOGUS_OPTION) returned " + ret).     } else {         int errno = Native.getLastError().         switch(errno) {             // ok             case ENOSYS:                 break.             // ok             case EINVAL:                 break.             default:                 throw new UnsupportedOperationException("prctl(BOGUS_OPTION): " + JNACLibrary.strerror(errno)).         }     }     // check for GET_NO_NEW_PRIVS     switch(linux_prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0)) {         // not yet set         case 0:             break.         // already set by caller         case 1:             break.         default:             int errno = Native.getLastError().             if (errno == EINVAL) {                 // friendly error, this will be the typical case for an old kernel                 throw new UnsupportedOperationException("seccomp unavailable: requires kernel 3.5+ with" + " CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER compiled in").             } else {                 throw new UnsupportedOperationException("prctl(PR_GET_NO_NEW_PRIVS): " + JNACLibrary.strerror(errno)).             }     }     // check for SECCOMP     switch(linux_prctl(PR_GET_SECCOMP, 0, 0, 0, 0)) {         // not yet set         case 0:             break.         // already in filter mode by caller         case 2:             break.         default:             int errno = Native.getLastError().             if (errno == EINVAL) {                 throw new UnsupportedOperationException("seccomp unavailable: CONFIG_SECCOMP not compiled into kernel," + " CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER are needed").             } else {                 throw new UnsupportedOperationException("prctl(PR_GET_SECCOMP): " + JNACLibrary.strerror(errno)).             }     }     // check for SECCOMP_MODE_FILTER     if (linux_prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, 0, 0, 0) != 0) {         int errno = Native.getLastError().         switch(errno) {             // available             case EFAULT:                 break.             case EINVAL:                 throw new UnsupportedOperationException("seccomp unavailable: CONFIG_SECCOMP_FILTER not" + " compiled into kernel, CONFIG_SECCOMP and CONFIG_SECCOMP_FILTER are needed").             default:                 throw new UnsupportedOperationException("prctl(PR_SET_SECCOMP): " + JNACLibrary.strerror(errno)).         }     }     // ok, now set PR_SET_NO_NEW_PRIVS, needed to be able to set a seccomp filter as ordinary user     if (linux_prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) != 0) {         throw new UnsupportedOperationException("prctl(PR_SET_NO_NEW_PRIVS): " + JNACLibrary.strerror(Native.getLastError())).     }     // check it worked     if (linux_prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {         throw new UnsupportedOperationException("seccomp filter did not really succeed: prctl(PR_GET_NO_NEW_PRIVS): " + JNACLibrary.strerror(Native.getLastError())).     }     // BPF installed to check arch, limit, then syscall.     // See https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt for details.     SockFilter[] insns = { //      BPF_STMT(BPF_LD + BPF_W + BPF_ABS, SECCOMP_DATA_ARCH_OFFSET), // if (arch != audit) goto fail.     BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch.audit, 0, 7), //      BPF_STMT(BPF_LD + BPF_W + BPF_ABS, SECCOMP_DATA_NR_OFFSET), // if (syscall > LIMIT) goto fail.     BPF_JUMP(BPF_JMP + BPF_JGT + BPF_K, arch.limit, 5, 0), // if (syscall == FORK) goto fail.     BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch.fork, 4, 0), // if (syscall == VFORK) goto fail.     BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch.vfork, 3, 0), // if (syscall == EXECVE) goto fail.     BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch.execve, 2, 0), // if (syscall == EXECVEAT) goto fail.     BPF_JUMP(BPF_JMP + BPF_JEQ + BPF_K, arch.execveat, 1, 0), // pass: return OK.     BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ALLOW), // fail: return EACCES.     BPF_STMT(BPF_RET + BPF_K, SECCOMP_RET_ERRNO | (EACCES & SECCOMP_RET_DATA)) }.     // seccomp takes a long, so we pass it one explicitly to keep the JNA simple     SockFProg prog = new SockFProg(insns).     prog.write().     long pointer = Pointer.nativeValue(prog.getPointer()).     int method = 1.     // first try it with seccomp(SECCOMP_SET_MODE_FILTER), falling back to prctl()     if (linux_syscall(arch.seccomp, SECCOMP_SET_MODE_FILTER, SECCOMP_FILTER_FLAG_TSYNC, new NativeLong(pointer)) != 0) {         method = 0.         int errno1 = Native.getLastError().         if (logger.isDebugEnabled()) {             logger.debug("seccomp(SECCOMP_SET_MODE_FILTER): {}, falling back to prctl(PR_SET_SECCOMP)...", JNACLibrary.strerror(errno1)).         }         if (linux_prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, pointer, 0, 0) != 0) {             int errno2 = Native.getLastError().             throw new UnsupportedOperationException("seccomp(SECCOMP_SET_MODE_FILTER): " + JNACLibrary.strerror(errno1) + ", prctl(PR_SET_SECCOMP): " + JNACLibrary.strerror(errno2)).         }     }     // now check that the filter was really installed, we should be in filter mode.     if (linux_prctl(PR_GET_SECCOMP, 0, 0, 0, 0) != 2) {         throw new UnsupportedOperationException("seccomp filter installation did not really succeed. seccomp(PR_GET_SECCOMP): " + JNACLibrary.strerror(Native.getLastError())).     }     logger.debug("Linux seccomp filter installation successful, threads: [{}]", method == 1 ? "all" : "app").     return method. }
true;;3;1;/**  * maps to sandbox_init(3), since Leopard  */ ;/**  * maps to sandbox_init(3), since Leopard  */ int sandbox_init(String profile, long flags, PointerByReference errorbuf).
true;;1;1;/**  * releases memory when an error occurs during initialization (e.g. syntax bug)  */ ;/**  * releases memory when an error occurs during initialization (e.g. syntax bug)  */ void sandbox_free_error(Pointer errorbuf).
true;private,static;1;37;/**  * try to install our custom rule profile into sandbox_init() to block execution  */ ;/**  * try to install our custom rule profile into sandbox_init() to block execution  */ private static void macImpl(Path tmpFile) throws IOException {     // first be defensive: we can give nice errors this way, at the very least.     boolean supported = Constants.MAC_OS_X.     if (supported == false) {         throw new IllegalStateException("bug: should not be trying to initialize seatbelt for an unsupported OS").     }     // we couldn't link methods, could be some really ancient OS X (< Leopard) or some bug     if (libc_mac == null) {         throw new UnsupportedOperationException("seatbelt unavailable: could not link methods. requires Leopard or above.").     }     // write rules to a temporary file, which will be passed to sandbox_init()     Path rules = Files.createTempFile(tmpFile, "es", "sb").     Files.write(rules, Collections.singleton(SANDBOX_RULES)).     boolean success = false.     try {         PointerByReference errorRef = new PointerByReference().         int ret = libc_mac.sandbox_init(rules.toAbsolutePath().toString(), SANDBOX_NAMED, errorRef).         // if sandbox_init() fails, add the message from the OS (e.g. syntax error) and free the buffer         if (ret != 0) {             Pointer errorBuf = errorRef.getValue().             RuntimeException e = new UnsupportedOperationException("sandbox_init(): " + errorBuf.getString(0)).             libc_mac.sandbox_free_error(errorBuf).             throw e.         }         logger.debug("OS X seatbelt initialization successful").         success = true.     } finally {         if (success) {             Files.delete(rules).         } else {             IOUtils.deleteFilesIgnoringExceptions(rules).         }     } }
true;;3;1;/**  * see priv_set(3C), a convenience method for setppriv(2).  */ ;/**  * see priv_set(3C), a convenience method for setppriv(2).  */ int priv_set(int op, String which, String... privs).
false;static;0;19;;static void solarisImpl() {     // first be defensive: we can give nice errors this way, at the very least.     boolean supported = Constants.SUN_OS.     if (supported == false) {         throw new IllegalStateException("bug: should not be trying to initialize priv_set for an unsupported OS").     }     // we couldn't link methods, could be some really ancient Solaris or some bug     if (libc_solaris == null) {         throw new UnsupportedOperationException("priv_set unavailable: could not link methods. requires Solaris 10+").     }     // drop a null-terminated list of privileges     if (libc_solaris.priv_set(PRIV_OFF, PRIV_ALLSETS, PRIV_PROC_FORK, PRIV_PROC_EXEC, null) != 0) {         throw new UnsupportedOperationException("priv_set unavailable: priv_set(): " + JNACLibrary.strerror(Native.getLastError())).     }     logger.debug("Solaris priv_set initialization successful"). }
false;static;0;15;;static void bsdImpl() {     boolean supported = Constants.FREE_BSD || OPENBSD || Constants.MAC_OS_X.     if (supported == false) {         throw new IllegalStateException("bug: should not be trying to initialize RLIMIT_NPROC for an unsupported OS").     }     JNACLibrary.Rlimit limit = new JNACLibrary.Rlimit().     limit.rlim_cur.setValue(0).     limit.rlim_max.setValue(0).     if (JNACLibrary.setrlimit(RLIMIT_NPROC, limit) != 0) {         throw new UnsupportedOperationException("RLIMIT_NPROC unavailable: " + JNACLibrary.strerror(Native.getLastError())).     }     logger.debug("BSD RLIMIT_NPROC initialization successful"). }
false;static;0;39;;// windows impl via job ActiveProcessLimit static void windowsImpl() {     if (!Constants.WINDOWS) {         throw new IllegalStateException("bug: should not be trying to initialize ActiveProcessLimit for an unsupported OS").     }     JNAKernel32Library lib = JNAKernel32Library.getInstance().     // create a new Job     Pointer job = lib.CreateJobObjectW(null, null).     if (job == null) {         throw new UnsupportedOperationException("CreateJobObject: " + Native.getLastError()).     }     try {         // retrieve the current basic limits of the job         int clazz = JNAKernel32Library.JOBOBJECT_BASIC_LIMIT_INFORMATION_CLASS.         JNAKernel32Library.JOBOBJECT_BASIC_LIMIT_INFORMATION limits = new JNAKernel32Library.JOBOBJECT_BASIC_LIMIT_INFORMATION().         limits.write().         if (!lib.QueryInformationJobObject(job, clazz, limits.getPointer(), limits.size(), null)) {             throw new UnsupportedOperationException("QueryInformationJobObject: " + Native.getLastError()).         }         limits.read().         // modify the number of active processes to be 1 (exactly the one process we will add to the job).         limits.ActiveProcessLimit = 1.         limits.LimitFlags = JNAKernel32Library.JOB_OBJECT_LIMIT_ACTIVE_PROCESS.         limits.write().         if (!lib.SetInformationJobObject(job, clazz, limits.getPointer(), limits.size())) {             throw new UnsupportedOperationException("SetInformationJobObject: " + Native.getLastError()).         }         // assign ourselves to the job         if (!lib.AssignProcessToJobObject(job, lib.GetCurrentProcess())) {             throw new UnsupportedOperationException("AssignProcessToJobObject: " + Native.getLastError()).         }     } finally {         lib.CloseHandle(job).     }     logger.debug("Windows ActiveProcessLimit initialization successful"). }
true;static;1;21;/**  * Attempt to drop the capability to execute for the process.  * <p>  * This is best effort and OS and architecture dependent. It may throw any Throwable.  * @return 0 if we can do this for application threads, 1 for the entire process  */ ;/**  * Attempt to drop the capability to execute for the process.  * <p>  * This is best effort and OS and architecture dependent. It may throw any Throwable.  * @return 0 if we can do this for application threads, 1 for the entire process  */ static int init(Path tmpFile) throws Exception {     if (Constants.LINUX) {         return linuxImpl().     } else if (Constants.MAC_OS_X) {         // try to enable both mechanisms if possible         bsdImpl().         macImpl(tmpFile).         return 1.     } else if (Constants.SUN_OS) {         solarisImpl().         return 1.     } else if (Constants.FREE_BSD || OPENBSD) {         bsdImpl().         return 1.     } else if (Constants.WINDOWS) {         windowsImpl().         return 1.     } else {         throw new UnsupportedOperationException("syscall filtering not supported for OS: '" + Constants.OS_NAME + "'").     } }
