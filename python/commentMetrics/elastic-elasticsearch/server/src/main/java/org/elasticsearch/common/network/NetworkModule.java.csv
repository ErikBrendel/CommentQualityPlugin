commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public boolean isTransportClient() {     return transportClient. }
true;private;2;5;/**  * Adds a transport implementation that can be selected by setting {@link #TRANSPORT_TYPE_KEY}.  */ ;/**  * Adds a transport implementation that can be selected by setting {@link #TRANSPORT_TYPE_KEY}.  */ private void registerTransport(String key, Supplier<Transport> factory) {     if (transportFactories.putIfAbsent(key, factory) != null) {         throw new IllegalArgumentException("transport for name: " + key + " is already registered").     } }
true;private;2;8;// TODO: we need another name than "http transport"....so confusing with transportClient... ;/**  * Adds an http transport implementation that can be selected by setting {@link #HTTP_TYPE_KEY}.  */ // TODO: we need another name than "http transport"....so confusing with transportClient... private void registerHttpTransport(String key, Supplier<HttpServerTransport> factory) {     if (transportClient) {         throw new IllegalArgumentException("Cannot register http transport " + key + " for transport client").     }     if (transportHttpFactories.putIfAbsent(key, factory) != null) {         throw new IllegalArgumentException("transport for name: " + key + " is already registered").     } }
true;private,static;3;5;/**  * Register an allocation command.  * <p>  * This lives here instead of the more aptly named ClusterModule because the Transport client needs these to be registered.  * </p>  * @param reader the reader to read it from a stream  * @param parser the parser to read it from XContent  * @param commandName the names under which the command should be parsed. The {@link ParseField#getPreferredName()} is special because  *        it is the name under which the command's reader is registered.  */ ;/**  * Register an allocation command.  * <p>  * This lives here instead of the more aptly named ClusterModule because the Transport client needs these to be registered.  * </p>  * @param reader the reader to read it from a stream  * @param parser the parser to read it from XContent  * @param commandName the names under which the command should be parsed. The {@link ParseField#getPreferredName()} is special because  *        it is the name under which the command's reader is registered.  */ private static <T extends AllocationCommand> void registerAllocationCommand(Writeable.Reader<T> reader, CheckedFunction<XContentParser, T, IOException> parser, ParseField commandName) {     namedXContents.add(new NamedXContentRegistry.Entry(AllocationCommand.class, commandName, parser)).     namedWriteables.add(new NamedWriteableRegistry.Entry(AllocationCommand.class, commandName.getPreferredName(), reader)). }
false;public,static;0;3;;public static List<NamedWriteableRegistry.Entry> getNamedWriteables() {     return Collections.unmodifiableList(namedWriteables). }
false;public,static;0;3;;public static List<NamedXContentRegistry.Entry> getNamedXContents() {     return Collections.unmodifiableList(namedXContents). }
false;public;0;13;;public Supplier<HttpServerTransport> getHttpServerTransportSupplier() {     final String name.     if (HTTP_TYPE_SETTING.exists(settings)) {         name = HTTP_TYPE_SETTING.get(settings).     } else {         name = HTTP_DEFAULT_TYPE_SETTING.get(settings).     }     final Supplier<HttpServerTransport> factory = transportHttpFactories.get(name).     if (factory == null) {         throw new IllegalStateException("Unsupported http.type [" + name + "]").     }     return factory. }
false;public;0;13;;public Supplier<Transport> getTransportSupplier() {     final String name.     if (TRANSPORT_TYPE_SETTING.exists(settings)) {         name = TRANSPORT_TYPE_SETTING.get(settings).     } else {         name = TRANSPORT_DEFAULT_TYPE_SETTING.get(settings).     }     final Supplier<Transport> factory = transportFactories.get(name).     if (factory == null) {         throw new IllegalStateException("Unsupported transport.type [" + name + "]").     }     return factory. }
true;private;1;3;/**  * Registers a new {@link TransportInterceptor}  */ ;/**  * Registers a new {@link TransportInterceptor}  */ private void registerTransportInterceptor(TransportInterceptor interceptor) {     this.transportIntercetors.add(Objects.requireNonNull(interceptor, "interceptor must not be null")). }
true;public;0;3;/**  * Returns a composite {@link TransportInterceptor} containing all registered interceptors  * @see #registerTransportInterceptor(TransportInterceptor)  */ ;/**  * Returns a composite {@link TransportInterceptor} containing all registered interceptors  * @see #registerTransportInterceptor(TransportInterceptor)  */ public TransportInterceptor getTransportInterceptor() {     return new CompositeTransportInterceptor(this.transportIntercetors). }
false;public;4;9;;@Override public <T extends TransportRequest> TransportRequestHandler<T> interceptHandler(String action, String executor, boolean forceExecution, TransportRequestHandler<T> actualHandler) {     for (TransportInterceptor interceptor : this.transportInterceptors) {         actualHandler = interceptor.interceptHandler(action, executor, forceExecution, actualHandler).     }     return actualHandler. }
false;public;1;7;;@Override public AsyncSender interceptSender(AsyncSender sender) {     for (TransportInterceptor interceptor : this.transportInterceptors) {         sender = interceptor.interceptSender(sender).     }     return sender. }
