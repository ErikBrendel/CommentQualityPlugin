# id;timestamp;commentText;codeText;commentWords;codeWords
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1524684173;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1525334055;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1528706846;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1528762805;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1529916081;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1532685069;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1534848846;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1535046779;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1536828374;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1538579488;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1539615817;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1539723533;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1540486836;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1541008027;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1542609384;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1542646292;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1542899326;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1543236161;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1543277112;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1546434630;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1546462872;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1547520324;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1547625930;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1548593396;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1548834350;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1548872440;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1548953505;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1549822589;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1550216671;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1550342051;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings);1550483271;Returns <code>ShardDeletionCheckResult</code> signaling whether the shards content for the given shard can be deleted.__@param shardId the shard to delete._@param indexSettings the shards's relevant {@link IndexSettings}. This is required to access the indexes settings etc.;public ShardDeletionCheckResult canDeleteShardContent(ShardId shardId, IndexSettings indexSettings) {_        assert shardId.getIndex().equals(indexSettings.getIndex())__        final IndexService indexService = indexService(shardId.getIndex())__        if (nodeEnv.hasNodeFile()) {_            final boolean isAllocated = indexService != null && indexService.hasShard(shardId.id())__            if (isAllocated) {_                return ShardDeletionCheckResult.STILL_ALLOCATED_ _            } else if (indexSettings.hasCustomDataPath()) {_                _                _                return Files.exists(nodeEnv.resolveCustomLocation(indexSettings, shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            } else {_                _                _                return FileSystemUtils.exists(nodeEnv.availableShardPaths(shardId)) ?_                        ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE :_                        ShardDeletionCheckResult.NO_FOLDER_FOUND__            }_        } else {_            return ShardDeletionCheckResult.NO_LOCAL_STORAGE__        }_    };returns,code,shard,deletion,check,result,code,signaling,whether,the,shards,content,for,the,given,shard,can,be,deleted,param,shard,id,the,shard,to,delete,param,index,settings,the,shards,s,relevant,link,index,settings,this,is,required,to,access,the,indexes,settings,etc;public,shard,deletion,check,result,can,delete,shard,content,shard,id,shard,id,index,settings,index,settings,assert,shard,id,get,index,equals,index,settings,get,index,final,index,service,index,service,index,service,shard,id,get,index,if,node,env,has,node,file,final,boolean,is,allocated,index,service,null,index,service,has,shard,shard,id,id,if,is,allocated,return,shard,deletion,check,result,else,if,index,settings,has,custom,data,path,return,files,exists,node,env,resolve,custom,location,index,settings,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,file,system,utils,exists,node,env,available,shard,paths,shard,id,shard,deletion,check,result,shard,deletion,check,result,else,return,shard,deletion,check,result
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1524684173;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1525334055;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1528706846;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1528762805;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1529916081;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1532685069;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1534848846;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1535046779;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1536828374;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1538579488;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), () -> {_            return "Shard: " + request.shardId() + "\nSource:\n" + request.source()__        }, out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,return,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1539615817;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), () -> {_            return "Shard: " + request.shardId() + "\nSource:\n" + request.source()__        }, out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,return,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1539723533;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), () -> {_            return "Shard: " + request.shardId() + "\nSource:\n" + request.source()__        }, out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,return,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1540486836;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), () -> {_            return "Shard: " + request.shardId() + "\nSource:\n" + request.source()__        }, out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,return,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1541008027;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), () -> {_            return "Shard: " + request.shardId() + "\nSource:\n" + request.source()__        }, out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,return,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1542609384;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), () -> {_            return "Shard: " + request.shardId() + "\nSource:\n" + request.source()__        }, out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,return,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1542646292;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), () -> {_            return "Shard: " + request.shardId() + "\nSource:\n" + request.source()__        }, out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,return,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1542899326;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(), () -> {_            return "Shard: " + request.shardId() + "\nSource:\n" + request.source()__        }, out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,return,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1543236161;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1543277112;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1546434630;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1546462872;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1547520324;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1547625930;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1548593396;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1548834350;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1548872440;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1548953505;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1549822589;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1550216671;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1550342051;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception;1550483271;Loads the cache result, computing it if needed by executing the query phase and otherwise deserializing the cached_value into the {@link SearchContext#queryResult() context's query result}. The combination of load + compute allows_to have a single load operation that will cause other requests with the same key to wait till its loaded an reuse_the same cache.;public void loadIntoContext(ShardSearchRequest request, SearchContext context, QueryPhase queryPhase) throws Exception {_        assert canCache(request, context)__        final DirectoryReader directoryReader = context.searcher().getDirectoryReader()___        boolean[] loadedFromCache = new boolean[] { true }__        BytesReference bytesReference = cacheShardLevelResult(context.indexShard(), directoryReader, request.cacheKey(),_            () -> "Shard: " + request.shardId() + "\nSource:\n" + request.source(),_            out -> {_            queryPhase.execute(context)__            try {_                context.queryResult().writeToNoId(out)___            } catch (IOException e) {_                throw new AssertionError("Could not serialize response", e)__            }_            loadedFromCache[0] = false__        })___        if (loadedFromCache[0]) {_            _            final QuerySearchResult result = context.queryResult()__            StreamInput in = new NamedWriteableAwareStreamInput(bytesReference.streamInput(), namedWriteableRegistry)__            result.readFromWithId(context.id(), in)__            result.setSearchShardTarget(context.shardTarget())__        } else if (context.queryResult().searchTimedOut()) {_            _            _            _            _            _            _            _            indicesRequestCache.invalidate(new IndexShardCacheEntity(context.indexShard()), directoryReader, request.cacheKey())__            if (logger.isTraceEnabled()) {_                logger.trace("Query timed out, invalidating cache entry for request on shard [{}]:\n {}", request.shardId(),_                        request.source())__            }_        }_    };loads,the,cache,result,computing,it,if,needed,by,executing,the,query,phase,and,otherwise,deserializing,the,cached,value,into,the,link,search,context,query,result,context,s,query,result,the,combination,of,load,compute,allows,to,have,a,single,load,operation,that,will,cause,other,requests,with,the,same,key,to,wait,till,its,loaded,an,reuse,the,same,cache;public,void,load,into,context,shard,search,request,request,search,context,context,query,phase,query,phase,throws,exception,assert,can,cache,request,context,final,directory,reader,directory,reader,context,searcher,get,directory,reader,boolean,loaded,from,cache,new,boolean,true,bytes,reference,bytes,reference,cache,shard,level,result,context,index,shard,directory,reader,request,cache,key,shard,request,shard,id,n,source,n,request,source,out,query,phase,execute,context,try,context,query,result,write,to,no,id,out,catch,ioexception,e,throw,new,assertion,error,could,not,serialize,response,e,loaded,from,cache,0,false,if,loaded,from,cache,0,final,query,search,result,result,context,query,result,stream,input,in,new,named,writeable,aware,stream,input,bytes,reference,stream,input,named,writeable,registry,result,read,from,with,id,context,id,in,result,set,search,shard,target,context,shard,target,else,if,context,query,result,search,timed,out,indices,request,cache,invalidate,new,index,shard,cache,entity,context,index,shard,directory,reader,request,cache,key,if,logger,is,trace,enabled,logger,trace,query,timed,out,invalidating,cache,entry,for,request,on,shard,n,request,shard,id,request,source
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1524684173;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1525334055;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1528706846;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1528762805;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1529916081;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1532685069;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1534848846;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1535046779;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1536828374;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1538579488;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1539615817;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1539723533;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1540486836;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1541008027;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1542609384;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1542646292;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1542899326;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1543236161;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1543277112;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1546434630;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1546462872;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1547520324;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1547625930;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1548593396;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1548834350;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1548872440;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1548953505;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1549822589;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1550216671;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1550342051;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void addPendingDelete(ShardId shardId, IndexSettings settings);1550483271;Adds a pending delete for the given index shard.;@Override_    public void addPendingDelete(ShardId shardId, IndexSettings settings) {_        if (shardId == null) {_            throw new IllegalArgumentException("shardId must not be null")__        }_        if (settings == null) {_            throw new IllegalArgumentException("settings must not be null")__        }_        PendingDelete pendingDelete = new PendingDelete(shardId, settings)__        addPendingDelete(shardId.getIndex(), pendingDelete)__    };adds,a,pending,delete,for,the,given,index,shard;override,public,void,add,pending,delete,shard,id,shard,id,index,settings,settings,if,shard,id,null,throw,new,illegal,argument,exception,shard,id,must,not,be,null,if,settings,null,throw,new,illegal,argument,exception,settings,must,not,be,null,pending,delete,pending,delete,new,pending,delete,shard,id,settings,add,pending,delete,shard,id,get,index,pending,delete
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1524684173;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1525334055;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1528706846;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1528762805;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1529916081;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1532685069;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1534848846;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1535046779;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1536828374;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1538579488;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1539615817;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1539723533;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1540486836;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1541008027;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1542609384;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1542646292;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1542899326;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1543236161;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1543277112;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1546434630;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1546462872;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1547520324;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1547625930;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1548593396;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1548834350;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1548872440;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1548953505;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1549822589;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1550216671;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1550342051;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)             throws IOException, InterruptedException, ShardLockObtainFailedException;1550483271;Processes all pending deletes for the given index. This method will acquire all locks for the given index and will_process all pending deletes for this index. Pending deletes might occur if the OS doesn't allow deletion of files because_they are used by a different process ie. on Windows where files might still be open by a virus scanner. On a shared_filesystem a replica might not have been closed when the primary is deleted causing problems on delete calls so we_schedule there deletes later._@param index the index to process the pending deletes for_@param timeout the timeout used for processing pending deletes;@Override_    public void processPendingDeletes(Index index, IndexSettings indexSettings, TimeValue timeout)_            throws IOException, InterruptedException, ShardLockObtainFailedException {_        logger.debug("{} processing pending deletes", index)__        final long startTimeNS = System.nanoTime()__        final List<ShardLock> shardLocks = nodeEnv.lockAllForIndex(index, indexSettings, timeout.millis())__        int numRemoved = 0__        try {_            Map<ShardId, ShardLock> locks = new HashMap<>()__            for (ShardLock lock : shardLocks) {_                locks.put(lock.getShardId(), lock)__            }_            final List<PendingDelete> remove__            synchronized (pendingDeletes) {_                 remove = pendingDeletes.remove(index)__            }_            if (remove != null && remove.isEmpty() == false) {_                numRemoved = remove.size()__                CollectionUtil.timSort(remove)_ _                final long maxSleepTimeMs = 10 * 1000_ _                long sleepTime = 10__                do {_                    if (remove.isEmpty()) {_                        break__                    }_                    Iterator<PendingDelete> iterator = remove.iterator()__                    while (iterator.hasNext()) {_                        PendingDelete delete = iterator.next()___                        if (delete.deleteIndex) {_                            assert delete.shardId == -1__                            logger.debug("{} deleting index store reason [{}]", index, "pending delete")__                            try {_                                nodeEnv.deleteIndexDirectoryUnderLock(index, indexSettings)__                                iterator.remove()__                            } catch (IOException ex) {_                                logger.debug(() -> new ParameterizedMessage("{} retry pending delete", index), ex)__                            }_                        } else {_                            assert delete.shardId != -1__                            ShardLock shardLock = locks.get(new ShardId(delete.index, delete.shardId))__                            if (shardLock != null) {_                                try {_                                    deleteShardStore("pending delete", shardLock, delete.settings)__                                    iterator.remove()__                                } catch (IOException ex) {_                                    logger.debug(() -> new ParameterizedMessage("{} retry pending delete", shardLock.getShardId()), ex)__                                }_                            } else {_                                logger.warn("{} no shard lock for pending delete", delete.shardId)__                                iterator.remove()__                            }_                        }_                    }_                    if (remove.isEmpty() == false) {_                        logger.warn("{} still pending deletes present for shards {} - retrying", index, remove.toString())__                        Thread.sleep(sleepTime)__                        sleepTime = Math.min(maxSleepTimeMs, sleepTime * 2)_ _                        logger.debug("{} schedule pending delete retry after {} ms", index, sleepTime)__                    }_                } while ((System.nanoTime() - startTimeNS) < timeout.nanos())__            }_        } finally {_            IOUtils.close(shardLocks)__            if (numRemoved > 0) {_                int remainingUncompletedDeletes = numUncompletedDeletes.addAndGet(-numRemoved)__                assert remainingUncompletedDeletes >= 0__            }_        }_    };processes,all,pending,deletes,for,the,given,index,this,method,will,acquire,all,locks,for,the,given,index,and,will,process,all,pending,deletes,for,this,index,pending,deletes,might,occur,if,the,os,doesn,t,allow,deletion,of,files,because,they,are,used,by,a,different,process,ie,on,windows,where,files,might,still,be,open,by,a,virus,scanner,on,a,shared,filesystem,a,replica,might,not,have,been,closed,when,the,primary,is,deleted,causing,problems,on,delete,calls,so,we,schedule,there,deletes,later,param,index,the,index,to,process,the,pending,deletes,for,param,timeout,the,timeout,used,for,processing,pending,deletes;override,public,void,process,pending,deletes,index,index,index,settings,index,settings,time,value,timeout,throws,ioexception,interrupted,exception,shard,lock,obtain,failed,exception,logger,debug,processing,pending,deletes,index,final,long,start,time,ns,system,nano,time,final,list,shard,lock,shard,locks,node,env,lock,all,for,index,index,index,settings,timeout,millis,int,num,removed,0,try,map,shard,id,shard,lock,locks,new,hash,map,for,shard,lock,lock,shard,locks,locks,put,lock,get,shard,id,lock,final,list,pending,delete,remove,synchronized,pending,deletes,remove,pending,deletes,remove,index,if,remove,null,remove,is,empty,false,num,removed,remove,size,collection,util,tim,sort,remove,final,long,max,sleep,time,ms,10,1000,long,sleep,time,10,do,if,remove,is,empty,break,iterator,pending,delete,iterator,remove,iterator,while,iterator,has,next,pending,delete,delete,iterator,next,if,delete,delete,index,assert,delete,shard,id,1,logger,debug,deleting,index,store,reason,index,pending,delete,try,node,env,delete,index,directory,under,lock,index,index,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,index,ex,else,assert,delete,shard,id,1,shard,lock,shard,lock,locks,get,new,shard,id,delete,index,delete,shard,id,if,shard,lock,null,try,delete,shard,store,pending,delete,shard,lock,delete,settings,iterator,remove,catch,ioexception,ex,logger,debug,new,parameterized,message,retry,pending,delete,shard,lock,get,shard,id,ex,else,logger,warn,no,shard,lock,for,pending,delete,delete,shard,id,iterator,remove,if,remove,is,empty,false,logger,warn,still,pending,deletes,present,for,shards,retrying,index,remove,to,string,thread,sleep,sleep,time,sleep,time,math,min,max,sleep,time,ms,sleep,time,2,logger,debug,schedule,pending,delete,retry,after,ms,index,sleep,time,while,system,nano,time,start,time,ns,timeout,nanos,finally,ioutils,close,shard,locks,if,num,removed,0,int,remaining,uncompleted,deletes,num,uncompleted,deletes,add,and,get,num,removed,assert,remaining,uncompleted,deletes,0
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1524684173;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1525334055;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1528706846;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1528762805;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1529916081;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1532685069;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1534848846;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1535046779;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1536828374;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1538579488;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1539615817;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1539723533;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1540486836;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1541008027;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])", metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1542609384;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1542646292;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1542899326;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1543236161;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1543277112;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1546434630;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1546462872;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1547520324;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1547625930;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1548593396;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1548834350;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1548872440;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1548953505;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1549822589;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1550216671;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1550342051;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> @Override     public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState);1550483271;Deletes an index that is not assigned to this node. This method cleans up all disk folders relating to the index_but does not deal with in-memory structures. For those call {@link #removeIndex(Index, IndexRemovalReason, String)};@Override_    public void deleteUnassignedIndex(String reason, IndexMetaData metaData, ClusterState clusterState) {_        if (nodeEnv.hasNodeFile()) {_            String indexName = metaData.getIndex().getName()__            try {_                if (clusterState.metaData().hasIndex(indexName)) {_                    final IndexMetaData index = clusterState.metaData().index(indexName)__                    throw new IllegalStateException("Can't delete unassigned index store for [" + indexName + "] - it's still part of " +_                                                    "the cluster state [" + index.getIndexUUID() + "] [" + metaData.getIndexUUID() + "]")__                }_                deleteIndexStore(reason, metaData, clusterState)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete unassigned index (reason [{}])",_                    metaData.getIndex(), reason), e)__            }_        }_    };deletes,an,index,that,is,not,assigned,to,this,node,this,method,cleans,up,all,disk,folders,relating,to,the,index,but,does,not,deal,with,in,memory,structures,for,those,call,link,remove,index,index,index,removal,reason,string;override,public,void,delete,unassigned,index,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,if,node,env,has,node,file,string,index,name,meta,data,get,index,get,name,try,if,cluster,state,meta,data,has,index,index,name,final,index,meta,data,index,cluster,state,meta,data,index,index,name,throw,new,illegal,state,exception,can,t,delete,unassigned,index,store,for,index,name,it,s,still,part,of,the,cluster,state,index,get,index,uuid,meta,data,get,index,uuid,delete,index,store,reason,meta,data,cluster,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,unassigned,index,reason,meta,data,get,index,reason,e
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger);1540486836;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@param deprecationLogger The logger to use for deprecation warnings_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            if (ENFORCE_MAX_SHARDS_PER_NODE) {_                return Optional.of(errorMessage)__            } else {_                deprecationLogger.deprecated("In a future major version, this request will fail because {}. Before upgrading, " +_                        "reduce the number of shards in your cluster or adjust the cluster setting [{}].",_                    errorMessage, MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.getKey())__            }_        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,for,deprecation,warnings,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,deprecation,logger,deprecation,logger,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,if,return,optional,of,error,message,else,deprecation,logger,deprecated,in,a,future,major,version,this,request,will,fail,because,before,upgrading,reduce,the,number,of,shards,in,your,cluster,or,adjust,the,cluster,setting,error,message,meta,data,get,key,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger);1541008027;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@param deprecationLogger The logger to use for deprecation warnings_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            if (ENFORCE_MAX_SHARDS_PER_NODE) {_                return Optional.of(errorMessage)__            } else {_                deprecationLogger.deprecated("In a future major version, this request will fail because {}. Before upgrading, " +_                        "reduce the number of shards in your cluster or adjust the cluster setting [{}].",_                    errorMessage, MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.getKey())__            }_        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,for,deprecation,warnings,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,deprecation,logger,deprecation,logger,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,if,return,optional,of,error,message,else,deprecation,logger,deprecated,in,a,future,major,version,this,request,will,fail,because,before,upgrading,reduce,the,number,of,shards,in,your,cluster,or,adjust,the,cluster,setting,error,message,meta,data,get,key,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger);1542609384;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@param deprecationLogger The logger to use for deprecation warnings_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            if (ENFORCE_MAX_SHARDS_PER_NODE) {_                return Optional.of(errorMessage)__            } else {_                deprecationLogger.deprecated("In a future major version, this request will fail because {}. Before upgrading, " +_                        "reduce the number of shards in your cluster or adjust the cluster setting [{}].",_                    errorMessage, MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.getKey())__            }_        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,for,deprecation,warnings,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,deprecation,logger,deprecation,logger,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,if,return,optional,of,error,message,else,deprecation,logger,deprecated,in,a,future,major,version,this,request,will,fail,because,before,upgrading,reduce,the,number,of,shards,in,your,cluster,or,adjust,the,cluster,setting,error,message,meta,data,get,key,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger);1542646292;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@param deprecationLogger The logger to use for deprecation warnings_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            if (ENFORCE_MAX_SHARDS_PER_NODE) {_                return Optional.of(errorMessage)__            } else {_                deprecationLogger.deprecated("In a future major version, this request will fail because {}. Before upgrading, " +_                        "reduce the number of shards in your cluster or adjust the cluster setting [{}].",_                    errorMessage, MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.getKey())__            }_        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,for,deprecation,warnings,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,deprecation,logger,deprecation,logger,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,if,return,optional,of,error,message,else,deprecation,logger,deprecated,in,a,future,major,version,this,request,will,fail,because,before,upgrading,reduce,the,number,of,shards,in,your,cluster,or,adjust,the,cluster,setting,error,message,meta,data,get,key,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger);1542899326;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@param deprecationLogger The logger to use for deprecation warnings_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            if (ENFORCE_MAX_SHARDS_PER_NODE) {_                return Optional.of(errorMessage)__            } else {_                deprecationLogger.deprecated("In a future major version, this request will fail because {}. Before upgrading, " +_                        "reduce the number of shards in your cluster or adjust the cluster setting [{}].",_                    errorMessage, MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.getKey())__            }_        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,for,deprecation,warnings,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,deprecation,logger,deprecation,logger,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,if,return,optional,of,error,message,else,deprecation,logger,deprecated,in,a,future,major,version,this,request,will,fail,because,before,upgrading,reduce,the,number,of,shards,in,your,cluster,or,adjust,the,cluster,setting,error,message,meta,data,get,key,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger);1543236161;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@param deprecationLogger The logger to use for deprecation warnings_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state, DeprecationLogger deprecationLogger) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            if (ENFORCE_MAX_SHARDS_PER_NODE) {_                return Optional.of(errorMessage)__            } else {_                deprecationLogger.deprecated("In a future major version, this request will fail because {}. Before upgrading, " +_                        "reduce the number of shards in your cluster or adjust the cluster setting [{}].",_                    errorMessage, MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.getKey())__            }_        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,param,deprecation,logger,the,logger,to,use,for,deprecation,warnings,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,deprecation,logger,deprecation,logger,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,if,return,optional,of,error,message,else,deprecation,logger,deprecated,in,a,future,major,version,this,request,will,fail,because,before,upgrading,reduce,the,number,of,shards,in,your,cluster,or,adjust,the,cluster,setting,error,message,meta,data,get,key,return,optional,empty
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1524684173;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1525334055;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1528706846;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1528762805;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1529916081;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1532685069;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1534848846;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1535046779;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1536828374;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1538579488;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1539615817;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1539723533;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1540486836;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1541008027;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1542609384;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1542646292;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1542899326;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1543236161;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1543277112;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1546434630;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1546462872;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1547520324;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1547625930;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1548593396;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1548834350;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1548872440;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1548953505;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1549822589;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1550216671;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1550342051;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> PendingDelete -> PendingDelete(Index index, IndexSettings settings);1550483271;Creates a new pending delete of a shard;PendingDelete(Index index, IndexSettings settings) {_            this.index = index__            this.shardId = -1__            this.settings = settings__            this.deleteIndex = true__        };creates,a,new,pending,delete,of,a,shard;pending,delete,index,index,index,settings,settings,this,index,index,this,shard,id,1,this,settings,settings,this,delete,index,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1524684173;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        if ((context.searcher().getIndexReader() instanceof DirectoryReader) == false) {_            return false__        }_        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,if,context,searcher,get,index,reader,instanceof,directory,reader,false,return,false,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1525334055;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        if ((context.searcher().getIndexReader() instanceof DirectoryReader) == false) {_            return false__        }_        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,if,context,searcher,get,index,reader,instanceof,directory,reader,false,return,false,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1528706846;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        if ((context.searcher().getIndexReader() instanceof DirectoryReader) == false) {_            return false__        }_        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,if,context,searcher,get,index,reader,instanceof,directory,reader,false,return,false,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1528762805;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        if ((context.searcher().getIndexReader() instanceof DirectoryReader) == false) {_            return false__        }_        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,if,context,searcher,get,index,reader,instanceof,directory,reader,false,return,false,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1529916081;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        if ((context.searcher().getIndexReader() instanceof DirectoryReader) == false) {_            return false__        }_        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,if,context,searcher,get,index,reader,instanceof,directory,reader,false,return,false,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1532685069;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        if ((context.searcher().getIndexReader() instanceof DirectoryReader) == false) {_            return false__        }_        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,if,context,searcher,get,index,reader,instanceof,directory,reader,false,return,false,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1534848846;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        if ((context.searcher().getIndexReader() instanceof DirectoryReader) == false) {_            return false__        }_        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,if,context,searcher,get,index,reader,instanceof,directory,reader,false,return,false,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1535046779;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        if ((context.searcher().getIndexReader() instanceof DirectoryReader) == false) {_            return false__        }_        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,if,context,searcher,get,index,reader,instanceof,directory,reader,false,return,false,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1536828374;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        if ((context.searcher().getIndexReader() instanceof DirectoryReader) == false) {_            return false__        }_        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,if,context,searcher,get,index,reader,instanceof,directory,reader,false,return,false,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1538579488;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        if ((context.searcher().getIndexReader() instanceof DirectoryReader) == false) {_            return false__        }_        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,if,context,searcher,get,index,reader,instanceof,directory,reader,false,return,false,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1539615817;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1539723533;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1540486836;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1541008027;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1542609384;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1542646292;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1542899326;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1543236161;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1543277112;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCachable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cachable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1546434630;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1546462872;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1547520324;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1547625930;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1548593396;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1548834350;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1548872440;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1548953505;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1549822589;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1550216671;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1550342051;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public boolean canCache(ShardSearchRequest request, SearchContext context);1550483271;Can the shard request be cached at all?;public boolean canCache(ShardSearchRequest request, SearchContext context) {_        _        _        _        if (request.scroll() != null) {_            return false__        }__        _        _        _        _        if (SearchType.QUERY_THEN_FETCH != context.searchType()) {_            return false__        }__        IndexSettings settings = context.indexShard().indexSettings()__        _        if (request.requestCache() == null) {_            if (settings.getValue(IndicesRequestCache.INDEX_CACHE_REQUEST_ENABLED_SETTING) == false) {_                return false__            } else if (context.size() != 0) {_                _                _                return false__            }_        } else if (request.requestCache() == false) {_            return false__        }_        _        assert context.searcher().getIndexReader().getReaderCacheHelper() != null___        _        _        if (context.getQueryShardContext().isCacheable() == false) {_            return false__        }_        return true___    };can,the,shard,request,be,cached,at,all;public,boolean,can,cache,shard,search,request,request,search,context,context,if,request,scroll,null,return,false,if,search,type,context,search,type,return,false,index,settings,settings,context,index,shard,index,settings,if,request,request,cache,null,if,settings,get,value,indices,request,cache,false,return,false,else,if,context,size,0,return,false,else,if,request,request,cache,false,return,false,assert,context,searcher,get,index,reader,get,reader,cache,helper,null,if,context,get,query,shard,context,is,cacheable,false,return,false,return,true
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1524684173;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1525334055;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1528706846;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1528762805;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1529916081;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1532685069;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1534848846;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1535046779;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1536828374;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1538579488;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1539615817;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1539723533;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1540486836;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1541008027;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        if (clusterState.nodes().getLocalNode().isMasterNode() == false && _                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1542609384;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1542646292;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1542899326;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1543236161;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1543277112;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1546434630;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1546462872;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1547520324;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1547625930;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1548593396;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1548834350;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1548872440;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1548953505;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1549822589;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1550216671;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1550342051;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)             throws IOException, ShardLockObtainFailedException;1550483271;This method deletes the shard contents on disk for the given shard ID. This method will fail if the shard deleting_is prevented by {@link #canDeleteShardContent(ShardId, IndexSettings)}_of if the shards lock can not be acquired.__On data nodes, if the deleted shard is the last shard folder in its index, the method will attempt to remove_the index folder as well.__@param reason the reason for the shard deletion_@param shardId the shards ID to delete_@param clusterState . This is required to access the indexes settings etc._@throws IOException if an IOException occurs;public void deleteShardStore(String reason, ShardId shardId, ClusterState clusterState)_            throws IOException, ShardLockObtainFailedException {_        final IndexMetaData metaData = clusterState.getMetaData().indices().get(shardId.getIndexName())___        final IndexSettings indexSettings = buildIndexSettings(metaData)__        ShardDeletionCheckResult shardDeletionCheckResult = canDeleteShardContent(shardId, indexSettings)__        if (shardDeletionCheckResult != ShardDeletionCheckResult.FOLDER_FOUND_CAN_DELETE) {_            throw new IllegalStateException("Can't delete shard " + shardId + " (cause: " + shardDeletionCheckResult + ")")__        }_        nodeEnv.deleteShardDirectorySafe(shardId, indexSettings)__        logger.debug("{} deleted shard reason [{}]", shardId, reason)___        _        if (clusterState.nodes().getLocalNode().isMasterNode() == false &&_                canDeleteIndexContents(shardId.getIndex(), indexSettings)) {_            if (nodeEnv.findAllShardIds(shardId.getIndex()).isEmpty()) {_                try {_                    _                    deleteIndexStore("no longer used", metaData, clusterState)__                } catch (Exception e) {_                    _                    throw new ElasticsearchException("failed to delete unused index after deleting its last shard (" + shardId + ")", e)__                }_            } else {_                logger.trace("[{}] still has shard stores, leaving as is", shardId.getIndex())__            }_        }_    };this,method,deletes,the,shard,contents,on,disk,for,the,given,shard,id,this,method,will,fail,if,the,shard,deleting,is,prevented,by,link,can,delete,shard,content,shard,id,index,settings,of,if,the,shards,lock,can,not,be,acquired,on,data,nodes,if,the,deleted,shard,is,the,last,shard,folder,in,its,index,the,method,will,attempt,to,remove,the,index,folder,as,well,param,reason,the,reason,for,the,shard,deletion,param,shard,id,the,shards,id,to,delete,param,cluster,state,this,is,required,to,access,the,indexes,settings,etc,throws,ioexception,if,an,ioexception,occurs;public,void,delete,shard,store,string,reason,shard,id,shard,id,cluster,state,cluster,state,throws,ioexception,shard,lock,obtain,failed,exception,final,index,meta,data,meta,data,cluster,state,get,meta,data,indices,get,shard,id,get,index,name,final,index,settings,index,settings,build,index,settings,meta,data,shard,deletion,check,result,shard,deletion,check,result,can,delete,shard,content,shard,id,index,settings,if,shard,deletion,check,result,shard,deletion,check,result,throw,new,illegal,state,exception,can,t,delete,shard,shard,id,cause,shard,deletion,check,result,node,env,delete,shard,directory,safe,shard,id,index,settings,logger,debug,deleted,shard,reason,shard,id,reason,if,cluster,state,nodes,get,local,node,is,master,node,false,can,delete,index,contents,shard,id,get,index,index,settings,if,node,env,find,all,shard,ids,shard,id,get,index,is,empty,try,delete,index,store,no,longer,used,meta,data,cluster,state,catch,exception,e,throw,new,elasticsearch,exception,failed,to,delete,unused,index,after,deleting,its,last,shard,shard,id,e,else,logger,trace,still,has,shard,stores,leaving,as,is,shard,id,get,index
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1524684173;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1525334055;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1528706846;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1528762805;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1529916081;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1532685069;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1534848846;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1535046779;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1536828374;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1538579488;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1539615817;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1539723533;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1540486836;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1541008027;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1542609384;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1542646292;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1542899326;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1543236161;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1543277112;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1546434630;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1546462872;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1547520324;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1547625930;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1548593396;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1548834350;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1548872440;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1548953505;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1549822589;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1550216671;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1550342051;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings);1550483271;This method returns true if the current node is allowed to delete the given index._This is the case if the index is deleted in the metadata or there is no allocation_on the local node and the index isn't on a shared file system._@param index {@code Index} to check whether deletion is allowed_@param indexSettings {@code IndexSettings} for the given index_@return true if the index can be deleted on this node;public boolean canDeleteIndexContents(Index index, IndexSettings indexSettings) {_        _        _        final IndexService indexService = indexService(index)__        if (indexService == null && nodeEnv.hasNodeFile()) {_            return true__        }_        return false__    };this,method,returns,true,if,the,current,node,is,allowed,to,delete,the,given,index,this,is,the,case,if,the,index,is,deleted,in,the,metadata,or,there,is,no,allocation,on,the,local,node,and,the,index,isn,t,on,a,shared,file,system,param,index,code,index,to,check,whether,deletion,is,allowed,param,index,settings,code,index,settings,for,the,given,index,return,true,if,the,index,can,be,deleted,on,this,node;public,boolean,can,delete,index,contents,index,index,index,settings,index,settings,final,index,service,index,service,index,service,index,if,index,service,null,node,env,has,node,file,return,true,return,false
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1524684173;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1525334055;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1528706846;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1528762805;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1529916081;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1532685069;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1534848846;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1535046779;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1536828374;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1538579488;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1539615817;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1539723533;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1540486836;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1541008027;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1542609384;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1542646292;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1542899326;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1543236161;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1543277112;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1546434630;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1546462872;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1547520324;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1547625930;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1548593396;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1548834350;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1548872440;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1548953505;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1549822589;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1550216671;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1550342051;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> @Override     @Nullable     public IndexService indexService(Index index);1550483271;Returns an IndexService for the specified index if exists otherwise returns <code>null</code>.;@Override_    @Nullable_    public IndexService indexService(Index index) {_        return indices.get(index.getUUID())__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,returns,code,null,code;override,nullable,public,index,service,index,service,index,index,return,indices,get,index,get,uuid
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1524684173;Returns the node stats indices stats. The <tt>includePrevious</tt> flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,tt,include,previous,tt,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1525334055;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1528706846;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1528762805;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1529916081;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1532685069;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1534848846;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1535046779;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1536828374;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1538579488;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1539615817;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1539723533;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1540486836;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1541008027;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1542609384;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1542646292;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1542899326;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1543236161;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1543277112;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1546434630;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1546462872;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1547520324;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1547625930;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1548593396;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1548834350;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1548872440;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1548953505;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1549822589;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1550216671;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1550342051;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> public NodeIndicesStats stats(boolean includePrevious);1550483271;Returns the node stats indices stats. The {@code includePrevious} flag controls_if old shards stats will be aggregated as well (only for relevant stats, such as_refresh and indexing, not for docs/store).;public NodeIndicesStats stats(boolean includePrevious) {_        return stats(includePrevious, new CommonStatsFlags().all())__    };returns,the,node,stats,indices,stats,the,code,include,previous,flag,controls,if,old,shards,stats,will,be,aggregated,as,well,only,for,relevant,stats,such,as,refresh,and,indexing,not,for,docs,store;public,node,indices,stats,stats,boolean,include,previous,return,stats,include,previous,new,common,stats,flags,all
IndicesService -> private void ensureChangesAllowed();1524684173;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1525334055;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1528706846;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1528762805;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1529916081;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1532685069;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1534848846;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1535046779;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1536828374;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1538579488;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1539615817;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1539723533;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1540486836;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1541008027;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1542609384;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1542646292;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1542899326;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1543236161;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1543277112;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1546434630;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1546462872;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1547520324;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1547625930;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1548593396;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1548834350;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1548872440;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1548953505;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1549822589;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1550216671;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1550342051;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> private void ensureChangesAllowed();1550483271;Checks if changes (adding / removing) indices, shards and so on are allowed.__@throws IllegalStateException if no changes allowed.;private void ensureChangesAllowed() {_        if (lifecycle.started() == false) {_            throw new IllegalStateException("Can't make changes to indices service, node is closed")__        }_    };checks,if,changes,adding,removing,indices,shards,and,so,on,are,allowed,throws,illegal,state,exception,if,no,changes,allowed;private,void,ensure,changes,allowed,if,lifecycle,started,false,throw,new,illegal,state,exception,can,t,make,changes,to,indices,service,node,is,closed
IndicesService -> public boolean hasUncompletedPendingDeletes();1524684173;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1525334055;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1528706846;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1528762805;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1529916081;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1532685069;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1534848846;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1535046779;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1536828374;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1538579488;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1539615817;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1539723533;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1540486836;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1541008027;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents while deletion still ongoing._The reason is that, on Windows, browsing the directory contents can interfere with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1542609384;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1542646292;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1542899326;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1543236161;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1543277112;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1546434630;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1546462872;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1547520324;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1547625930;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1548593396;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1548834350;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1548872440;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1548953505;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1549822589;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1550216671;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1550342051;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public boolean hasUncompletedPendingDeletes();1550483271;Checks if all pending deletes have completed. Used by tests to ensure we don't check directory contents_while deletion still ongoing. * The reason is that, on Windows, browsing the directory contents can interfere_with the deletion process and delay it unnecessarily.;public boolean hasUncompletedPendingDeletes() {_        return numUncompletedDeletes.get() > 0__    };checks,if,all,pending,deletes,have,completed,used,by,tests,to,ensure,we,don,t,check,directory,contents,while,deletion,still,ongoing,the,reason,is,that,on,windows,browsing,the,directory,contents,can,interfere,with,the,deletion,process,and,delay,it,unnecessarily;public,boolean,has,uncompleted,pending,deletes,return,num,uncompleted,deletes,get,0
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1524684173;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1525334055;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1528706846;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings))__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1528762805;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings))__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1529916081;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings))__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1532685069;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1534848846;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1535046779;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1536828374;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1538579488;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1539615817;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1539723533;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1540486836;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1541008027;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1542609384;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1542646292;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1542899326;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1543236161;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1543277112;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1546434630;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1546462872;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1547520324;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1547625930;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1548593396;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1548834350;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1548872440;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1548953505;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1549822589;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1550216671;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1550342051;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException;1550483271;creates a new mapper service for the given index, in order to do administrative work like mapping updates._This *should not* be used for document parsing. Doing so will result in an exception.__Note: the returned {@link MapperService} should be closed when unneeded.;public synchronized MapperService createIndexMapperService(IndexMetaData indexMetaData) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        pluginsService.onIndexModule(indexModule)__        return indexModule.newIndexMapperService(xContentRegistry, mapperRegistry, scriptService)__    };creates,a,new,mapper,service,for,the,given,index,in,order,to,do,administrative,work,like,mapping,updates,this,should,not,be,used,for,document,parsing,doing,so,will,result,in,an,exception,note,the,returned,link,mapper,service,should,be,closed,when,unneeded;public,synchronized,mapper,service,create,index,mapper,service,index,meta,data,index,meta,data,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,plugins,service,on,index,module,index,module,return,index,module,new,index,mapper,service,x,content,registry,mapper,registry,script,service
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1524684173;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1525334055;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1528706846;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1528762805;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1529916081;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1532685069;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1534848846;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1535046779;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1536828374;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1538579488;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1539615817;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1539723533;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1540486836;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1541008027;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1542609384;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1542646292;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1542899326;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1543236161;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1543277112;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1546434630;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1546462872;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1547520324;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1547625930;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1548593396;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1548834350;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1548872440;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1548953505;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1549822589;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1550216671;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1550342051;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException;1550483271;Deletes the shard with an already acquired shard lock._@param reason the reason for the shard deletion_@param lock the lock of the shard to delete_@param indexSettings the shards index settings._@throws IOException if an IOException occurs;@Override_    public void deleteShardStore(String reason, ShardLock lock, IndexSettings indexSettings) throws IOException {_        ShardId shardId = lock.getShardId()__        logger.trace("{} deleting shard reason [{}]", shardId, reason)__        nodeEnv.deleteShardDirectoryUnderLock(lock, indexSettings)__    };deletes,the,shard,with,an,already,acquired,shard,lock,param,reason,the,reason,for,the,shard,deletion,param,lock,the,lock,of,the,shard,to,delete,param,index,settings,the,shards,index,settings,throws,ioexception,if,an,ioexception,occurs;override,public,void,delete,shard,store,string,reason,shard,lock,lock,index,settings,index,settings,throws,ioexception,shard,id,shard,id,lock,get,shard,id,logger,trace,deleting,shard,reason,shard,id,reason,node,env,delete,shard,directory,under,lock,lock,index,settings
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1524684173;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1525334055;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1528706846;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1528762805;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1529916081;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1532685069;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1534848846;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1535046779;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1536828374;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1538579488;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1539615817;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1539723533;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1540486836;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1541008027;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1542609384;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1542646292;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1542899326;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1543236161;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1543277112;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1546434630;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1546462872;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1547520324;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1547625930;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1548593396;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1548834350;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1548872440;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1548953505;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1549822589;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1550216671;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__                if (metaData == null) {_                    return null__                }_            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,if,meta,data,null,return,null,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1550342051;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__                if (metaData == null) {_                    return null__                }_            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,if,meta,data,null,return,null,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> @Override     @Nullable     public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState);1550483271;Verify that the contents on disk for the given index is deleted_ if not, delete the contents._This method assumes that an index is already deleted in the cluster state and/or explicitly_through index tombstones._@param index {@code Index} to make sure its deleted from disk_@param clusterState {@code ClusterState} to ensure the index is not part of it_@return IndexMetaData for the index loaded from disk;@Override_    @Nullable_    public IndexMetaData verifyIndexIsDeleted(final Index index, final ClusterState clusterState) {_        _        if (clusterState.metaData().index(index) != null) {_            throw new IllegalStateException("Cannot delete index [" + index + "], it is still part of the cluster state.")__        }_        if (nodeEnv.hasNodeFile() && FileSystemUtils.exists(nodeEnv.indexPaths(index))) {_            final IndexMetaData metaData__            try {_                metaData = metaStateService.loadIndexState(index)__                if (metaData == null) {_                    return null__                }_            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to load state file from a stale deleted index, " +_                    "folders will be left on disk", index), e)__                return null__            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            try {_                deleteIndexStoreIfDeletionAllowed("stale deleted index", index, indexSettings, ALWAYS_TRUE)__            } catch (Exception e) {_                _                _                logger.warn(() -> new ParameterizedMessage("[{}] failed to delete index on disk", metaData.getIndex()), e)__            }_            return metaData__        }_        return null__    };verify,that,the,contents,on,disk,for,the,given,index,is,deleted,if,not,delete,the,contents,this,method,assumes,that,an,index,is,already,deleted,in,the,cluster,state,and,or,explicitly,through,index,tombstones,param,index,code,index,to,make,sure,its,deleted,from,disk,param,cluster,state,code,cluster,state,to,ensure,the,index,is,not,part,of,it,return,index,meta,data,for,the,index,loaded,from,disk;override,nullable,public,index,meta,data,verify,index,is,deleted,final,index,index,final,cluster,state,cluster,state,if,cluster,state,meta,data,index,index,null,throw,new,illegal,state,exception,cannot,delete,index,index,it,is,still,part,of,the,cluster,state,if,node,env,has,node,file,file,system,utils,exists,node,env,index,paths,index,final,index,meta,data,meta,data,try,meta,data,meta,state,service,load,index,state,index,if,meta,data,null,return,null,catch,exception,e,logger,warn,new,parameterized,message,failed,to,load,state,file,from,a,stale,deleted,index,folders,will,be,left,on,disk,index,e,return,null,final,index,settings,index,settings,build,index,settings,meta,data,try,delete,index,store,if,deletion,allowed,stale,deleted,index,index,index,settings,catch,exception,e,logger,warn,new,parameterized,message,failed,to,delete,index,on,disk,meta,data,get,index,e,return,meta,data,return,null
IndicesService -> public IndexService indexServiceSafe(Index index);1524684173;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1525334055;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1528706846;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1528762805;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1529916081;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1532685069;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1534848846;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1535046779;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1536828374;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1538579488;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1539615817;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1539723533;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1540486836;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1541008027;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() + " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1542609384;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1542646292;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1542899326;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1543236161;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1543277112;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1546434630;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1546462872;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1547520324;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1547625930;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1548593396;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1548834350;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1548872440;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1548953505;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1549822589;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1550216671;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1550342051;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public IndexService indexServiceSafe(Index index);1550483271;Returns an IndexService for the specified index if exists otherwise a {@link IndexNotFoundException} is thrown.;public IndexService indexServiceSafe(Index index) {_        IndexService indexService = indices.get(index.getUUID())__        if (indexService == null) {_            throw new IndexNotFoundException(index)__        }_        assert indexService.indexUUID().equals(index.getUUID()) : "uuid mismatch local: " + indexService.indexUUID() +_            " incoming: " + index.getUUID()__        return indexService__    };returns,an,index,service,for,the,specified,index,if,exists,otherwise,a,link,index,not,found,exception,is,thrown;public,index,service,index,service,safe,index,index,index,service,index,service,indices,get,index,get,uuid,if,index,service,null,throw,new,index,not,found,exception,index,assert,index,service,index,uuid,equals,index,get,uuid,uuid,mismatch,local,index,service,index,uuid,incoming,index,get,uuid,return,index,service
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1524684173;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1525334055;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1528706846;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1528762805;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1529916081;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1532685069;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1534848846;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1535046779;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1536828374;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1538579488;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1539615817;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1539723533;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1540486836;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1541008027;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1542609384;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1542646292;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1542899326;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1543236161;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1543277112;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1546434630;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1546462872;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1547520324;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1547625930;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1548593396;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1548834350;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1548872440;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1548953505;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1549822589;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1550216671;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1550342051;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> public void addPendingDelete(Index index, IndexSettings settings);1550483271;Adds a pending delete for the given index.;public void addPendingDelete(Index index, IndexSettings settings) {_        PendingDelete pendingDelete = new PendingDelete(index, settings)__        addPendingDelete(index, pendingDelete)__    };adds,a,pending,delete,for,the,given,index;public,void,add,pending,delete,index,index,index,settings,settings,pending,delete,pending,delete,new,pending,delete,index,settings,add,pending,delete,index,pending,delete
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1524684173;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1525334055;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1528706846;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1528762805;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1529916081;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1532685069;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1534848846;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1535046779;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1536828374;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1538579488;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1539615817;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1539723533;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1540486836;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1541008027;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1542609384;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1542646292;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1542899326;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1543236161;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1543277112;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1546434630;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1546462872;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1547520324;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1547625930;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1548593396;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1548834350;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1548872440;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1548953505;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1549822589;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1550216671;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1550342051;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> PendingDelete -> PendingDelete(ShardId shardId, IndexSettings settings);1550483271;Creates a new pending delete of an index;PendingDelete(ShardId shardId, IndexSettings settings) {_            this.index = shardId.getIndex()__            this.shardId = shardId.getId()__            this.settings = settings__            this.deleteIndex = false__        };creates,a,new,pending,delete,of,an,index;pending,delete,shard,id,shard,id,index,settings,settings,this,index,shard,id,get,index,this,shard,id,shard,id,get,id,this,settings,settings,this,delete,index,false
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1524684173;Returns a new {@link QueryRewriteContext} with the given <tt>now</tt> provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,tt,now,tt,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1525334055;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1528706846;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1528762805;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1529916081;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1532685069;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1534848846;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1535046779;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1536828374;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1538579488;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1539615817;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1539723533;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1540486836;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1541008027;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1542609384;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1542646292;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1542899326;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1543236161;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1543277112;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1546434630;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1546462872;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1547520324;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1547625930;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1548593396;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1548834350;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1548872440;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1548953505;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1549822589;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1550216671;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1550342051;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis);1550483271;Returns a new {@link QueryRewriteContext} with the given {@code now} provider;public QueryRewriteContext getRewriteContext(LongSupplier nowInMillis) {_        return new QueryRewriteContext(xContentRegistry, namedWriteableRegistry, client, nowInMillis)__    };returns,a,new,link,query,rewrite,context,with,the,given,code,now,provider;public,query,rewrite,context,get,rewrite,context,long,supplier,now,in,millis,return,new,query,rewrite,context,x,content,registry,named,writeable,registry,client,now,in,millis
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1543277112;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1546434630;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1546462872;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1547520324;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1547625930;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1548593396;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1548834350;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1548872440;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1548953505;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1549822589;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1550216671;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1550342051;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> public static Optional<String> checkShardLimit(int newShards, ClusterState state);1550483271;Checks to see if an operation can be performed without taking the cluster over the cluster-wide shard limit. Adds a deprecation_warning or returns an error message as appropriate__@param newShards         The number of shards to be added by this operation_@param state             The current cluster state_@return If present, an error message to be given as the reason for failing_an operation. If empty, a sign that the operation is valid.;public static Optional<String> checkShardLimit(int newShards, ClusterState state) {_        Settings theseSettings = state.metaData().settings()__        int nodeCount = state.getNodes().getDataNodes().size()___        _        _        if (nodeCount == 0 || newShards < 0) {_            return Optional.empty()__        }_        int maxShardsPerNode = MetaData.SETTING_CLUSTER_MAX_SHARDS_PER_NODE.get(theseSettings)__        int maxShardsInCluster = maxShardsPerNode * nodeCount__        int currentOpenShards = state.getMetaData().getTotalOpenIndexShards()___        if ((currentOpenShards + newShards) > maxShardsInCluster) {_            String errorMessage = "this action would add [" + newShards + "] total shards, but this cluster currently has [" +_                currentOpenShards + "]/[" + maxShardsInCluster + "] maximum shards open"__            return Optional.of(errorMessage)__        }_        return Optional.empty()__    };checks,to,see,if,an,operation,can,be,performed,without,taking,the,cluster,over,the,cluster,wide,shard,limit,adds,a,deprecation,warning,or,returns,an,error,message,as,appropriate,param,new,shards,the,number,of,shards,to,be,added,by,this,operation,param,state,the,current,cluster,state,return,if,present,an,error,message,to,be,given,as,the,reason,for,failing,an,operation,if,empty,a,sign,that,the,operation,is,valid;public,static,optional,string,check,shard,limit,int,new,shards,cluster,state,state,settings,these,settings,state,meta,data,settings,int,node,count,state,get,nodes,get,data,nodes,size,if,node,count,0,new,shards,0,return,optional,empty,int,max,shards,per,node,meta,data,get,these,settings,int,max,shards,in,cluster,max,shards,per,node,node,count,int,current,open,shards,state,get,meta,data,get,total,open,index,shards,if,current,open,shards,new,shards,max,shards,in,cluster,string,error,message,this,action,would,add,new,shards,total,shards,but,this,cluster,currently,has,current,open,shards,max,shards,in,cluster,maximum,shards,open,return,optional,of,error,message,return,optional,empty
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1524684173;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1525334055;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1528706846;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1528762805;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1529916081;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1532685069;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1534848846;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1535046779;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1536828374;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1538579488;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1539615817;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1539723533;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1540486836;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1541008027;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1542609384;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1542646292;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1542899326;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1543236161;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1543277112;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1546434630;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1546462872;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1547520324;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1547625930;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1548593396;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1548834350;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1548872440;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1548953505;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1549822589;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1550216671;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1550342051;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException;1550483271;Deletes the index store trying to acquire all shards locks for this index._This method will delete the metadata for the index even if the actual shards can't be locked.__Package private for testing;void deleteIndexStore(String reason, IndexMetaData metaData, ClusterState clusterState) throws IOException {_        if (nodeEnv.hasNodeFile()) {_            synchronized (this) {_                Index index = metaData.getIndex()__                if (hasIndex(index)) {_                    String localUUid = indexService(index).indexUUID()__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() +_                        "] - it's still part of the indices service [" + localUUid + "] [" + metaData.getIndexUUID() + "]")__                }__                if (clusterState.metaData().hasIndex(index.getName()) && (clusterState.nodes().getLocalNode().isMasterNode() == true)) {_                    _                    _                    final IndexMetaData idxMeta = clusterState.metaData().index(index.getName())__                    throw new IllegalStateException("Can't delete index store for [" + index.getName() + "] - it's still part of the " +_                                                    "cluster state [" + idxMeta.getIndexUUID() + "] [" + metaData.getIndexUUID() + "], " +_                                                    "we are master eligible, so will keep the index metadata even if no shards are left.")__                }_            }_            final IndexSettings indexSettings = buildIndexSettings(metaData)__            deleteIndexStore(reason, indexSettings.getIndex(), indexSettings)__        }_    };deletes,the,index,store,trying,to,acquire,all,shards,locks,for,this,index,this,method,will,delete,the,metadata,for,the,index,even,if,the,actual,shards,can,t,be,locked,package,private,for,testing;void,delete,index,store,string,reason,index,meta,data,meta,data,cluster,state,cluster,state,throws,ioexception,if,node,env,has,node,file,synchronized,this,index,index,meta,data,get,index,if,has,index,index,string,local,uuid,index,service,index,index,uuid,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,indices,service,local,uuid,meta,data,get,index,uuid,if,cluster,state,meta,data,has,index,index,get,name,cluster,state,nodes,get,local,node,is,master,node,true,final,index,meta,data,idx,meta,cluster,state,meta,data,index,index,get,name,throw,new,illegal,state,exception,can,t,delete,index,store,for,index,get,name,it,s,still,part,of,the,cluster,state,idx,meta,get,index,uuid,meta,data,get,index,uuid,we,are,master,eligible,so,will,keep,the,index,metadata,even,if,no,shards,are,left,final,index,settings,index,settings,build,index,settings,meta,data,delete,index,store,reason,index,settings,get,index,index,settings
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1524684173;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1525334055;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1528706846;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1528762805;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1529916081;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1532685069;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1534848846;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1535046779;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1536828374;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1538579488;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1539615817;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1539723533;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1540486836;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1541008027;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1542609384;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1542646292;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1542899326;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1543236161;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1543277112;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1546434630;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1546462872;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1547520324;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1547625930;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1548593396;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1548834350;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1548872440;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1548953505;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1549822589;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1550216671;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1550342051;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> public Function<String, Predicate<String>> getFieldFilter();1550483271;Returns a function which given an index name, returns a predicate which fields must match in order to be returned by get mappings,_get index, get field mappings and field capabilities API. Useful to filter the fields that such API return._The predicate receives the field name as input argument. In case multiple plugins register a field filter through_{@link org.elasticsearch.plugins.MapperPlugin#getFieldFilter()}, only fields that match all the registered filters will be_returned by get mappings, get index, get field mappings and field capabilities API.;public Function<String, Predicate<String>> getFieldFilter() {_        return mapperRegistry.getFieldFilter()__    };returns,a,function,which,given,an,index,name,returns,a,predicate,which,fields,must,match,in,order,to,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api,useful,to,filter,the,fields,that,such,api,return,the,predicate,receives,the,field,name,as,input,argument,in,case,multiple,plugins,register,a,field,filter,through,link,org,elasticsearch,plugins,mapper,plugin,get,field,filter,only,fields,that,match,all,the,registered,filters,will,be,returned,by,get,mappings,get,index,get,field,mappings,and,field,capabilities,api;public,function,string,predicate,string,get,field,filter,return,mapper,registry,get,field,filter
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)             throws Exception;1524684173;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)_            throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)             throws Exception;1525334055;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)_            throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)             throws Exception;1528706846;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)_            throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)             throws Exception;1528762805;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)_            throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)             throws Exception;1529916081;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)_            throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)             throws Exception;1532685069;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)_            throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)             throws Exception;1534848846;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)_            throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)             throws Exception;1535046779;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)_            throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)             throws Exception;1536828374;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey, Consumer<StreamOutput> loader)_            throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1538579488;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1539615817;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1539723533;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1540486836;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1541008027;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1542609384;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1542646292;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1542899326;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1543236161;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1543277112;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1546434630;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1546462872;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1547520324;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1547625930;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1548593396;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1548834350;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1548872440;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1548953505;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1549822589;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1550216671;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1550342051;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,             Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception;1550483271;Cache something calculated at the shard level._@param shard the shard this item is part of_@param reader a reader for this shard. Used to invalidate the cache when there are changes._@param cacheKey key for the thing being cached within this shard_@param loader loads the data into the cache if needed_@return the contents of the cache or the result of calling the loader;private BytesReference cacheShardLevelResult(IndexShard shard, DirectoryReader reader, BytesReference cacheKey,_            Supplier<String> cacheKeyRenderer, Consumer<StreamOutput> loader) throws Exception {_        IndexShardCacheEntity cacheEntity = new IndexShardCacheEntity(shard)__        Supplier<BytesReference> supplier = () -> {_            _            final int expectedSizeInBytes = 512__            try (BytesStreamOutput out = new BytesStreamOutput(expectedSizeInBytes)) {_                loader.accept(out)__                _                _                return out.bytes()__            }_        }__        return indicesRequestCache.getOrCompute(cacheEntity, supplier, reader, cacheKey, cacheKeyRenderer)__    };cache,something,calculated,at,the,shard,level,param,shard,the,shard,this,item,is,part,of,param,reader,a,reader,for,this,shard,used,to,invalidate,the,cache,when,there,are,changes,param,cache,key,key,for,the,thing,being,cached,within,this,shard,param,loader,loads,the,data,into,the,cache,if,needed,return,the,contents,of,the,cache,or,the,result,of,calling,the,loader;private,bytes,reference,cache,shard,level,result,index,shard,shard,directory,reader,reader,bytes,reference,cache,key,supplier,string,cache,key,renderer,consumer,stream,output,loader,throws,exception,index,shard,cache,entity,cache,entity,new,index,shard,cache,entity,shard,supplier,bytes,reference,supplier,final,int,expected,size,in,bytes,512,try,bytes,stream,output,out,new,bytes,stream,output,expected,size,in,bytes,loader,accept,out,return,out,bytes,return,indices,request,cache,get,or,compute,cache,entity,supplier,reader,cache,key,cache,key,renderer
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1524684173;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1525334055;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1528706846;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings))__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1528762805;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings))__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1529916081;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings))__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1532685069;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1534848846;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1535046779;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1536828374;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1538579488;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1539615817;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1539723533;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1540486836;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, this.settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,this,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1541008027;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1542609384;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1542646292;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1542899326;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1543236161;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1543277112;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1546434630;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1546462872;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1547520324;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1547625930;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1548593396;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1548834350;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1548872440;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1548953505;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1549822589;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        if (idxSettings.getIndexVersionCreated().onOrAfter(Version.V_7_0_0)_            && EngineConfig.INDEX_OPTIMIZE_AUTO_GENERATED_IDS.exists(idxSettings.getSettings())) {_            throw new IllegalArgumentException(_                "Setting [" + EngineConfig.INDEX_OPTIMIZE_AUTO_GENERATED_IDS.getKey() + "] was removed in version 7.0.0")__        }_        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,if,idx,settings,get,index,version,created,on,or,after,version,engine,config,exists,idx,settings,get,settings,throw,new,illegal,argument,exception,setting,engine,config,get,key,was,removed,in,version,7,0,0,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1550216671;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        if (idxSettings.getIndexVersionCreated().onOrAfter(Version.V_7_0_0)_            && EngineConfig.INDEX_OPTIMIZE_AUTO_GENERATED_IDS.exists(idxSettings.getSettings())) {_            throw new IllegalArgumentException(_                "Setting [" + EngineConfig.INDEX_OPTIMIZE_AUTO_GENERATED_IDS.getKey() + "] was removed in version 7.0.0")__        }_        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,if,idx,settings,get,index,version,created,on,or,after,version,engine,config,exists,idx,settings,get,settings,throw,new,illegal,argument,exception,setting,engine,config,get,key,was,removed,in,version,7,0,0,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1550342051;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> private synchronized IndexService createIndexService(final String reason,                                                          IndexMetaData indexMetaData,                                                          IndicesQueryCache indicesQueryCache,                                                          IndicesFieldDataCache indicesFieldDataCache,                                                          List<IndexEventListener> builtInListeners,                                                          IndexingOperationListener... indexingOperationListeners) throws IOException;1550483271;This creates a new IndexService without registering it;private synchronized IndexService createIndexService(final String reason,_                                                         IndexMetaData indexMetaData,_                                                         IndicesQueryCache indicesQueryCache,_                                                         IndicesFieldDataCache indicesFieldDataCache,_                                                         List<IndexEventListener> builtInListeners,_                                                         IndexingOperationListener... indexingOperationListeners) throws IOException {_        final IndexSettings idxSettings = new IndexSettings(indexMetaData, settings, indexScopedSettings)__        _        indexScopedSettings.validate(indexMetaData.getSettings(), true, true, true)__        logger.debug("creating Index [{}], shards [{}]/[{}] - reason [{}]",_            indexMetaData.getIndex(),_            idxSettings.getNumberOfShards(),_            idxSettings.getNumberOfReplicas(),_            reason)___        final IndexModule indexModule = new IndexModule(idxSettings, analysisRegistry, getEngineFactory(idxSettings), indexStoreFactories)__        for (IndexingOperationListener operationListener : indexingOperationListeners) {_            indexModule.addIndexOperationListener(operationListener)__        }_        pluginsService.onIndexModule(indexModule)__        for (IndexEventListener listener : builtInListeners) {_            indexModule.addIndexEventListener(listener)__        }_        return indexModule.newIndexService(_                nodeEnv,_                xContentRegistry,_                this,_                circuitBreakerService,_                bigArrays,_                threadPool,_                scriptService,_                client,_                indicesQueryCache,_                mapperRegistry,_                indicesFieldDataCache,_                namedWriteableRegistry_        )__    };this,creates,a,new,index,service,without,registering,it;private,synchronized,index,service,create,index,service,final,string,reason,index,meta,data,index,meta,data,indices,query,cache,indices,query,cache,indices,field,data,cache,indices,field,data,cache,list,index,event,listener,built,in,listeners,indexing,operation,listener,indexing,operation,listeners,throws,ioexception,final,index,settings,idx,settings,new,index,settings,index,meta,data,settings,index,scoped,settings,index,scoped,settings,validate,index,meta,data,get,settings,true,true,true,logger,debug,creating,index,shards,reason,index,meta,data,get,index,idx,settings,get,number,of,shards,idx,settings,get,number,of,replicas,reason,final,index,module,index,module,new,index,module,idx,settings,analysis,registry,get,engine,factory,idx,settings,index,store,factories,for,indexing,operation,listener,operation,listener,indexing,operation,listeners,index,module,add,index,operation,listener,operation,listener,plugins,service,on,index,module,index,module,for,index,event,listener,listener,built,in,listeners,index,module,add,index,event,listener,listener,return,index,module,new,index,service,node,env,x,content,registry,this,circuit,breaker,service,big,arrays,thread,pool,script,service,client,indices,query,cache,mapper,registry,indices,field,data,cache,named,writeable,registry
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1524684173;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1525334055;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1528706846;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1528762805;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1529916081;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1532685069;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1534848846;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1535046779;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1536828374;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1538579488;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1539615817;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1539723533;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1540486836;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1541008027;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1542609384;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1542646292;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1542899326;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1543236161;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1543277112;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1546434630;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1546462872;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1547520324;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1547625930;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1548593396;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1548834350;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1548872440;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1548953505;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1549822589;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1550216671;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1550342051;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,                                      String...fields);1550483271;Clears the caches for the given shard id if the shard is still allocated on this node;public void clearIndexShardCache(ShardId shardId, boolean queryCache, boolean fieldDataCache, boolean requestCache,_                                     String...fields) {_        final IndexService service = indexService(shardId.getIndex())__        if (service != null) {_            IndexShard shard = service.getShardOrNull(shardId.id())__            final boolean clearedAtLeastOne = service.clearCaches(queryCache, fieldDataCache, fields)__            if ((requestCache || (clearedAtLeastOne == false && fields.length == 0)) && shard != null) {_                indicesRequestCache.clear(new IndexShardCacheEntity(shard))__            }_        }_    };clears,the,caches,for,the,given,shard,id,if,the,shard,is,still,allocated,on,this,node;public,void,clear,index,shard,cache,shard,id,shard,id,boolean,query,cache,boolean,field,data,cache,boolean,request,cache,string,fields,final,index,service,service,index,service,shard,id,get,index,if,service,null,index,shard,shard,service,get,shard,or,null,shard,id,id,final,boolean,cleared,at,least,one,service,clear,caches,query,cache,field,data,cache,fields,if,request,cache,cleared,at,least,one,false,fields,length,0,shard,null,indices,request,cache,clear,new,index,shard,cache,entity,shard
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1524684173;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1525334055;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1528706846;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1528762805;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1529916081;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1532685069;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1534848846;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1535046779;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1536828374;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1538579488;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1539615817;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1539723533;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1540486836;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1541008027;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate} is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1542609384;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1542646292;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1542899326;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1543236161;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1543277112;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1546434630;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1546462872;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1547520324;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1547625930;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1548593396;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1548834350;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1548872440;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1548953505;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1549822589;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1550216671;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1550342051;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException;1550483271;This method verifies that the given {@code metaData} holds sane values to create an {@link IndexService}._This method tries to update the meta data of the created {@link IndexService} if the given {@code metaDataUpdate}_is different from the given {@code metaData}._This method will throw an exception if the creation or the update fails._The created {@link IndexService} will not be registered and will be closed immediately.;public synchronized void verifyIndexMetadata(IndexMetaData metaData, IndexMetaData metaDataUpdate) throws IOException {_        final List<Closeable> closeables = new ArrayList<>()__        try {_            IndicesFieldDataCache indicesFieldDataCache = new IndicesFieldDataCache(settings, new IndexFieldDataCache.Listener() {})__            closeables.add(indicesFieldDataCache)__            IndicesQueryCache indicesQueryCache = new IndicesQueryCache(settings)__            closeables.add(indicesQueryCache)__            _            final IndexService service =_                createIndexService("metadata verification", metaData, indicesQueryCache, indicesFieldDataCache, emptyList())__            closeables.add(() -> service.close("metadata verification", false))__            service.mapperService().merge(metaData, MapperService.MergeReason.MAPPING_RECOVERY)__            if (metaData.equals(metaDataUpdate) == false) {_                service.updateMetaData(metaData, metaDataUpdate)__            }_        } finally {_            IOUtils.close(closeables)__        }_    };this,method,verifies,that,the,given,code,meta,data,holds,sane,values,to,create,an,link,index,service,this,method,tries,to,update,the,meta,data,of,the,created,link,index,service,if,the,given,code,meta,data,update,is,different,from,the,given,code,meta,data,this,method,will,throw,an,exception,if,the,creation,or,the,update,fails,the,created,link,index,service,will,not,be,registered,and,will,be,closed,immediately;public,synchronized,void,verify,index,metadata,index,meta,data,meta,data,index,meta,data,meta,data,update,throws,ioexception,final,list,closeable,closeables,new,array,list,try,indices,field,data,cache,indices,field,data,cache,new,indices,field,data,cache,settings,new,index,field,data,cache,listener,closeables,add,indices,field,data,cache,indices,query,cache,indices,query,cache,new,indices,query,cache,settings,closeables,add,indices,query,cache,final,index,service,service,create,index,service,metadata,verification,meta,data,indices,query,cache,indices,field,data,cache,empty,list,closeables,add,service,close,metadata,verification,false,service,mapper,service,merge,meta,data,mapper,service,merge,reason,if,meta,data,equals,meta,data,update,false,service,update,meta,data,meta,data,meta,data,update,finally,ioutils,close,closeables
IndicesService -> public boolean isMetaDataField(String field);1524684173;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1525334055;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1528706846;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1528762805;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1529916081;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1532685069;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1534848846;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1535046779;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1536828374;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1538579488;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1539615817;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1539723533;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1540486836;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1541008027;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1542609384;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1542646292;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1542899326;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1543236161;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1543277112;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1546434630;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1546462872;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1547520324;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1547625930;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> public boolean isMetaDataField(String field);1548593396;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(String field) {_        return mapperRegistry.isMetaDataField(field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,string,field,return,mapper,registry,is,meta,data,field,field
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1524684173;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1525334055;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1528706846;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1528762805;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1529916081;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1532685069;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1534848846;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1535046779;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1536828374;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1538579488;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1539615817;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1539723533;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1540486836;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1541008027;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1542609384;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1542646292;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1542899326;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1543236161;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1543277112;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1546434630;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1546462872;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1547520324;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1547625930;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1548593396;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1548834350;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1548872440;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1548953505;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1549822589;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1550216671;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1550342051;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreClosed(ShardId shardId) {_                indicesQueryCache.onClose(shardId)__            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,closed,shard,id,shard,id,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> @Override     public synchronized IndexService createIndex(             final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException;1550483271;Creates a new {@link IndexService} for the given metadata.__@param indexMetaData          the index metadata to create the index for_@param builtInListeners       a list of built-in lifecycle {@link IndexEventListener} that should should be used along side with the_per-index listeners_@throws ResourceAlreadyExistsException if the index already exists.;@Override_    public synchronized IndexService createIndex(_            final IndexMetaData indexMetaData, final List<IndexEventListener> builtInListeners) throws IOException {_        ensureChangesAllowed()__        if (indexMetaData.getIndexUUID().equals(IndexMetaData.INDEX_UUID_NA_VALUE)) {_            throw new IllegalArgumentException("index must have a real UUID found value: [" + indexMetaData.getIndexUUID() + "]")__        }_        final Index index = indexMetaData.getIndex()__        if (hasIndex(index)) {_            throw new ResourceAlreadyExistsException(index)__        }_        List<IndexEventListener> finalListeners = new ArrayList<>(builtInListeners)__        final IndexEventListener onStoreClose = new IndexEventListener() {_            @Override_            public void onStoreCreated(ShardId shardId) {_                indicesRefCount.incRef()__            }_            @Override_            public void onStoreClosed(ShardId shardId) {_                try {_                    indicesRefCount.decRef()__                } finally {_                    indicesQueryCache.onClose(shardId)__                }_            }_        }__        finalListeners.add(onStoreClose)__        finalListeners.add(oldShardsStats)__        final IndexService indexService =_                createIndexService(_                        "create index",_                        indexMetaData,_                        indicesQueryCache,_                        indicesFieldDataCache,_                        finalListeners,_                        indexingMemoryController)__        boolean success = false__        try {_            indexService.getIndexEventListener().afterIndexCreated(indexService)__            indices = newMapBuilder(indices).put(index.getUUID(), indexService).immutableMap()__            success = true__            return indexService__        } finally {_            if (success == false) {_                indexService.close("plugins_failed", true)__            }_        }_    };creates,a,new,link,index,service,for,the,given,metadata,param,index,meta,data,the,index,metadata,to,create,the,index,for,param,built,in,listeners,a,list,of,built,in,lifecycle,link,index,event,listener,that,should,should,be,used,along,side,with,the,per,index,listeners,throws,resource,already,exists,exception,if,the,index,already,exists;override,public,synchronized,index,service,create,index,final,index,meta,data,index,meta,data,final,list,index,event,listener,built,in,listeners,throws,ioexception,ensure,changes,allowed,if,index,meta,data,get,index,uuid,equals,index,meta,data,throw,new,illegal,argument,exception,index,must,have,a,real,uuid,found,value,index,meta,data,get,index,uuid,final,index,index,index,meta,data,get,index,if,has,index,index,throw,new,resource,already,exists,exception,index,list,index,event,listener,final,listeners,new,array,list,built,in,listeners,final,index,event,listener,on,store,close,new,index,event,listener,override,public,void,on,store,created,shard,id,shard,id,indices,ref,count,inc,ref,override,public,void,on,store,closed,shard,id,shard,id,try,indices,ref,count,dec,ref,finally,indices,query,cache,on,close,shard,id,final,listeners,add,on,store,close,final,listeners,add,old,shards,stats,final,index,service,index,service,create,index,service,create,index,index,meta,data,indices,query,cache,indices,field,data,cache,final,listeners,indexing,memory,controller,boolean,success,false,try,index,service,get,index,event,listener,after,index,created,index,service,indices,new,map,builder,indices,put,index,get,uuid,index,service,immutable,map,success,true,return,index,service,finally,if,success,false,index,service,close,true
IndicesService -> public boolean isMetaDataField(Version indexCreatedVersion, String field);1548834350;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(Version indexCreatedVersion, String field) {_        return mapperRegistry.isMetaDataField(indexCreatedVersion, field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,version,index,created,version,string,field,return,mapper,registry,is,meta,data,field,index,created,version,field
IndicesService -> public boolean isMetaDataField(Version indexCreatedVersion, String field);1548872440;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(Version indexCreatedVersion, String field) {_        return mapperRegistry.isMetaDataField(indexCreatedVersion, field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,version,index,created,version,string,field,return,mapper,registry,is,meta,data,field,index,created,version,field
IndicesService -> public boolean isMetaDataField(Version indexCreatedVersion, String field);1548953505;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(Version indexCreatedVersion, String field) {_        return mapperRegistry.isMetaDataField(indexCreatedVersion, field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,version,index,created,version,string,field,return,mapper,registry,is,meta,data,field,index,created,version,field
IndicesService -> public boolean isMetaDataField(Version indexCreatedVersion, String field);1549822589;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(Version indexCreatedVersion, String field) {_        return mapperRegistry.isMetaDataField(indexCreatedVersion, field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,version,index,created,version,string,field,return,mapper,registry,is,meta,data,field,index,created,version,field
IndicesService -> public boolean isMetaDataField(Version indexCreatedVersion, String field);1550216671;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(Version indexCreatedVersion, String field) {_        return mapperRegistry.isMetaDataField(indexCreatedVersion, field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,version,index,created,version,string,field,return,mapper,registry,is,meta,data,field,index,created,version,field
IndicesService -> public boolean isMetaDataField(Version indexCreatedVersion, String field);1550342051;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(Version indexCreatedVersion, String field) {_        return mapperRegistry.isMetaDataField(indexCreatedVersion, field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,version,index,created,version,string,field,return,mapper,registry,is,meta,data,field,index,created,version,field
IndicesService -> public boolean isMetaDataField(Version indexCreatedVersion, String field);1550483271;Returns true if the provided field is a registered metadata field (including ones registered via plugins), false otherwise.;public boolean isMetaDataField(Version indexCreatedVersion, String field) {_        return mapperRegistry.isMetaDataField(indexCreatedVersion, field)__    };returns,true,if,the,provided,field,is,a,registered,metadata,field,including,ones,registered,via,plugins,false,otherwise;public,boolean,is,meta,data,field,version,index,created,version,string,field,return,mapper,registry,is,meta,data,field,index,created,version,field
