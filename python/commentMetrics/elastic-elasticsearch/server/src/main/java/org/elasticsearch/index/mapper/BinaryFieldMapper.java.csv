commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public BinaryFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new BinaryFieldMapper(name, fieldType, defaultFieldType, context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;3;7;;@Override public BinaryFieldMapper.Builder parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     BinaryFieldMapper.Builder builder = new BinaryFieldMapper.Builder(name).     parseField(builder, name, node, parserContext).     return builder. }
false;public;0;4;;@Override public MappedFieldType clone() {     return new BinaryFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;2;4;;@Override public DocValueFormat docValueFormat(String format, ZoneId timeZone) {     return DocValueFormat.BINARY. }
false;public;1;18;;@Override public BytesReference valueForDisplay(Object value) {     if (value == null) {         return null.     }     BytesReference bytes.     if (value instanceof BytesRef) {         bytes = new BytesArray((BytesRef) value).     } else if (value instanceof BytesReference) {         bytes = (BytesReference) value.     } else if (value instanceof byte[]) {         bytes = new BytesArray((byte[]) value).     } else {         bytes = new BytesArray(Base64.getDecoder().decode(value.toString())).     }     return bytes. }
false;public;1;5;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     failIfNoDocValues().     return new BytesBinaryDVIndexFieldData.Builder(). }
false;public;1;8;;@Override public Query existsQuery(QueryShardContext context) {     if (hasDocValues()) {         return new DocValuesFieldExistsQuery(name()).     } else {         return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())).     } }
false;public;2;4;;@Override public Query termQuery(Object value, QueryShardContext context) {     throw new QueryShardException(context, "Binary fields do not support searching"). }
false;protected;2;36;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     if (!fieldType().stored() && !fieldType().hasDocValues()) {         return.     }     byte[] value = context.parseExternalValue(byte[].class).     if (value == null) {         if (context.parser().currentToken() == XContentParser.Token.VALUE_NULL) {             return.         } else {             value = context.parser().binaryValue().         }     }     if (value == null) {         return.     }     if (fieldType().stored()) {         fields.add(new Field(fieldType().name(), value, fieldType())).     }     if (fieldType().hasDocValues()) {         CustomBinaryDocValuesField field = (CustomBinaryDocValuesField) context.doc().getByKey(fieldType().name()).         if (field == null) {             field = new CustomBinaryDocValuesField(fieldType().name(), value).             context.doc().addWithKey(fieldType().name(), field).         } else {             field.add(value).         }     } else {         // Only add an entry to the field names field if the field is stored         // but has no doc values so exists query will work on a field with         // no doc values         createFieldNamesField(context, fields).     } }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;public;1;4;;public void add(byte[] bytes) {     bytesList.add(bytes).     totalSize += bytes.length. }
false;public;0;20;;@Override public BytesRef binaryValue() {     try {         CollectionUtils.sortAndDedup(bytesList).         int size = bytesList.size().         final byte[] bytes = new byte[totalSize + (size + 1) * 5].         ByteArrayDataOutput out = new ByteArrayDataOutput(bytes).         // write total number of values         out.writeVInt(size).         for (int i = 0. i < size. i++) {             final byte[] value = bytesList.get(i).             int valueLength = value.length.             out.writeVInt(valueLength).             out.writeBytes(value, 0, valueLength).         }         return new BytesRef(bytes, 0, out.getPosition()).     } catch (IOException e) {         throw new ElasticsearchException("Failed to get binary value", e).     } }
