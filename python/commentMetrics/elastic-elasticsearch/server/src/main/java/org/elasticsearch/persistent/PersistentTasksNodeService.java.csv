commented;modifiers;parameterAmount;loc;comment;code
false;public;1;72;;@Override public void clusterChanged(ClusterChangedEvent event) {     if (event.state().blocks().hasGlobalBlock(GatewayService.STATE_NOT_RECOVERED_BLOCK)) {         // we start cancelling all local tasks before cluster has a chance to recover.         return.     }     PersistentTasksCustomMetaData tasks = event.state().getMetaData().custom(PersistentTasksCustomMetaData.TYPE).     PersistentTasksCustomMetaData previousTasks = event.previousState().getMetaData().custom(PersistentTasksCustomMetaData.TYPE).     if (Objects.equals(tasks, previousTasks) == false || event.nodesChanged()) {         // We have some changes let's check if they are related to our node         String localNodeId = event.state().getNodes().getLocalNodeId().         Set<Long> notVisitedTasks = new HashSet<>(runningTasks.keySet()).         if (tasks != null) {             for (PersistentTask<?> taskInProgress : tasks.tasks()) {                 if (localNodeId.equals(taskInProgress.getExecutorNode())) {                     Long allocationId = taskInProgress.getAllocationId().                     AllocatedPersistentTask persistentTask = runningTasks.get(allocationId).                     if (persistentTask == null) {                         // New task - let's start it                         startTask(taskInProgress).                     } else {                         // The task is still running                         notVisitedTasks.remove(allocationId).                     }                 }             }         }         for (Long id : notVisitedTasks) {             AllocatedPersistentTask task = runningTasks.get(id).             if (task.isCompleted()) {                 // Result was sent to the caller and the caller acknowledged acceptance of the result                 logger.trace("Found completed persistent task [{}] with id [{}] and allocation id [{}] - removing", task.getAction(), task.getPersistentTaskId(), task.getAllocationId()).                 runningTasks.remove(id).             } else {                 // task is running locally, but master doesn't know about it - that means that the persistent task was removed                 // cancel the task without notifying master                 logger.trace("Found unregistered persistent task [{}] with id [{}] and allocation id [{}] - cancelling", task.getAction(), task.getPersistentTaskId(), task.getAllocationId()).                 cancelTask(id).             }         }     } }
false;public;1;4;;@Override public void setParentTask(TaskId taskId) {     throw new UnsupportedOperationException("parent task if for persistent tasks shouldn't change"). }
false;public;0;4;;@Override public TaskId getParentTask() {     return parentTaskId. }
false;public;5;4;;@Override public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {     return executor.createTask(id, type, action, parentTaskId, taskInProgress, headers). }
false;private;1;46;;private <Params extends PersistentTaskParams> void startTask(PersistentTask<Params> taskInProgress) {     PersistentTasksExecutor<Params> executor = persistentTasksExecutorRegistry.getPersistentTaskExecutorSafe(taskInProgress.getTaskName()).     TaskAwareRequest request = new TaskAwareRequest() {          TaskId parentTaskId = new TaskId("cluster", taskInProgress.getAllocationId()).          @Override         public void setParentTask(TaskId taskId) {             throw new UnsupportedOperationException("parent task if for persistent tasks shouldn't change").         }          @Override         public TaskId getParentTask() {             return parentTaskId.         }          @Override         public Task createTask(long id, String type, String action, TaskId parentTaskId, Map<String, String> headers) {             return executor.createTask(id, type, action, parentTaskId, taskInProgress, headers).         }     }.     AllocatedPersistentTask task = (AllocatedPersistentTask) taskManager.register("persistent", taskInProgress.getTaskName() + "[c]", request).     boolean processed = false.     try {         task.init(persistentTasksService, taskManager, logger, taskInProgress.getId(), taskInProgress.getAllocationId()).         logger.trace("Persistent task [{}] with id [{}] and allocation id [{}] was created", task.getAction(), task.getPersistentTaskId(), task.getAllocationId()).         try {             runningTasks.put(taskInProgress.getAllocationId(), task).             nodePersistentTasksExecutor.executeTask(taskInProgress.getParams(), taskInProgress.getState(), task, executor).         } catch (Exception e) {             // Submit task failure             task.markAsFailed(e).         }         processed = true.     } finally {         if (processed == false) {             // something went wrong - unregistering task             logger.warn("Persistent task [{}] with id [{}] and allocation id [{}] failed to create", task.getAction(), task.getPersistentTaskId(), task.getAllocationId()).             taskManager.unregister(task).         }     } }
false;public;1;5;;@Override public void onResponse(CancelTasksResponse cancelTasksResponse) {     logger.trace("Persistent task [{}] with id [{}] and allocation id [{}] was cancelled", task.getAction(), task.getPersistentTaskId(), task.getAllocationId()). }
false;public;1;7;;@Override public void onFailure(Exception e) {     // There is really nothing we can do in case of failure here     logger.warn(() -> new ParameterizedMessage("failed to cancel task [{}] with id [{}] and allocation id [{}]", task.getAction(), task.getPersistentTaskId(), task.getAllocationId()), e). }
true;private;1;22;/**  * Unregisters and then cancels the locally running task using the task manager. No notification to master will be send upon  * cancellation.  */ ;/**  * Unregisters and then cancels the locally running task using the task manager. No notification to master will be send upon  * cancellation.  */ private void cancelTask(Long allocationId) {     AllocatedPersistentTask task = runningTasks.remove(allocationId).     if (task.markAsCancelled()) {         // Cancel the local task using the task manager         String reason = "task has been removed, cancelling locally".         persistentTasksService.sendCancelRequest(task.getId(), reason, new ActionListener<CancelTasksResponse>() {              @Override             public void onResponse(CancelTasksResponse cancelTasksResponse) {                 logger.trace("Persistent task [{}] with id [{}] and allocation id [{}] was cancelled", task.getAction(), task.getPersistentTaskId(), task.getAllocationId()).             }              @Override             public void onFailure(Exception e) {                 // There is really nothing we can do in case of failure here                 logger.warn(() -> new ParameterizedMessage("failed to cancel task [{}] with id [{}] and allocation id [{}]", task.getAction(), task.getPersistentTaskId(), task.getAllocationId()), e).             }         }).     } }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field("state", state.toString()).     builder.endObject().     return builder. }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(state.toString()). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
false;public;0;4;;@Override public boolean isFragment() {     return false. }
false;public;1;7;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Status status = (Status) o.     return state == status.state. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(state). }
