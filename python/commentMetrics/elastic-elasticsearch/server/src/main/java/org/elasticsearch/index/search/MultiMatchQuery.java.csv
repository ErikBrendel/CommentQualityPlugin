commented;modifiers;parameterAmount;loc;comment;code
false;public;1;3;;public void setTieBreaker(float tieBreaker) {     this.groupTieBreaker = tieBreaker. }
false;public;4;21;;public Query parse(MultiMatchQueryBuilder.Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch) throws IOException {     final float tieBreaker = groupTieBreaker == null ? type.tieBreaker() : groupTieBreaker.     final List<Query> queries.     switch(type) {         case PHRASE:         case PHRASE_PREFIX:         case BEST_FIELDS:         case MOST_FIELDS:             queries = buildFieldQueries(type, fieldNames, value, minimumShouldMatch).             break.         case CROSS_FIELDS:             queries = buildCrossFieldQuery(type, fieldNames, value, minimumShouldMatch, tieBreaker).             break.         default:             throw new IllegalStateException("No such type: " + type).     }     return combineGrouped(queries, tieBreaker). }
false;private;2;9;;private Query combineGrouped(List<Query> groupQuery, float tieBreaker) {     if (groupQuery.isEmpty()) {         return zeroTermsQuery().     }     if (groupQuery.size() == 1) {         return groupQuery.get(0).     }     return new DisjunctionMaxQuery(groupQuery, tieBreaker). }
false;private;4;22;;private List<Query> buildFieldQueries(MultiMatchQueryBuilder.Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch) throws IOException {     List<Query> queries = new ArrayList<>().     for (String fieldName : fieldNames.keySet()) {         if (context.fieldMapper(fieldName) == null) {             // ignore unmapped fields             continue.         }         float boostValue = fieldNames.getOrDefault(fieldName, 1.0f).         Query query = parse(type.matchQueryType(), fieldName, value).         query = Queries.maybeApplyMinimumShouldMatch(query, minimumShouldMatch).         if (query != null && boostValue != AbstractQueryBuilder.DEFAULT_BOOST && query instanceof MatchNoDocsQuery == false) {             query = new BoostQuery(query, boostValue).         }         if (query != null) {             queries.add(query).         }     }     return queries. }
false;private;5;46;;private List<Query> buildCrossFieldQuery(MultiMatchQueryBuilder.Type type, Map<String, Float> fieldNames, Object value, String minimumShouldMatch, float tieBreaker) throws IOException {     Map<Analyzer, List<FieldAndBoost>> groups = new HashMap<>().     List<Query> queries = new ArrayList<>().     for (Map.Entry<String, Float> entry : fieldNames.entrySet()) {         String name = entry.getKey().         MappedFieldType fieldType = context.fieldMapper(name).         if (fieldType != null) {             Analyzer actualAnalyzer = getAnalyzer(fieldType, type == MultiMatchQueryBuilder.Type.PHRASE).             if (!groups.containsKey(actualAnalyzer)) {                 groups.put(actualAnalyzer, new ArrayList<>()).             }             float boost = entry.getValue() == null ? 1.0f : entry.getValue().             groups.get(actualAnalyzer).add(new FieldAndBoost(fieldType, boost)).         }     }     for (Map.Entry<Analyzer, List<FieldAndBoost>> group : groups.entrySet()) {         final MatchQueryBuilder builder.         if (group.getValue().size() == 1) {             builder = new MatchQueryBuilder(group.getKey(), group.getValue().get(0).fieldType).         } else {             builder = new BlendedQueryBuilder(group.getKey(), group.getValue(), tieBreaker).         }         /*              * We have to pick some field to pass through the superclass so              * we just pick the first field. It shouldn't matter because              * fields are already grouped by their analyzers/types.              */         String representativeField = group.getValue().get(0).fieldType.name().         Query query = parseInternal(type.matchQueryType(), representativeField, builder, value).         query = Queries.maybeApplyMinimumShouldMatch(query, minimumShouldMatch).         if (query != null) {             if (group.getValue().size() == 1) {                 // apply the field boost to groups that contain a single field                 float boost = group.getValue().get(0).boost.                 if (boost != AbstractQueryBuilder.DEFAULT_BOOST) {                     query = new BoostQuery(query, boost).                 }             }             queries.add(query).         }     }     return queries. }
false;protected;1;8;;@Override protected Query newSynonymQuery(Term[] terms) {     BytesRef[] values = new BytesRef[terms.length].     for (int i = 0. i < terms.length. i++) {         values[i] = terms[i].bytes().     }     return blendTerms(context, values, commonTermsCutoff, tieBreaker, lenient, blendedFields). }
false;public;1;4;;@Override public Query newTermQuery(Term term) {     return blendTerm(context, term.bytes(), commonTermsCutoff, tieBreaker, lenient, blendedFields). }
false;protected;3;12;;@Override protected Query analyzePhrase(String field, TokenStream stream, int slop) throws IOException {     List<Query> disjunctions = new ArrayList<>().     for (FieldAndBoost fieldType : blendedFields) {         Query query = fieldType.fieldType.phraseQuery(stream, slop, enablePositionIncrements).         if (fieldType.boost != 1f) {             query = new BoostQuery(query, fieldType.boost).         }         disjunctions.add(query).     }     return new DisjunctionMaxQuery(disjunctions, tieBreaker). }
false;protected;3;12;;@Override protected Query analyzeMultiPhrase(String field, TokenStream stream, int slop) throws IOException {     List<Query> disjunctions = new ArrayList<>().     for (FieldAndBoost fieldType : blendedFields) {         Query query = fieldType.fieldType.multiPhraseQuery(stream, slop, enablePositionIncrements).         if (fieldType.boost != 1f) {             query = new BoostQuery(query, fieldType.boost).         }         disjunctions.add(query).     }     return new DisjunctionMaxQuery(disjunctions, tieBreaker). }
false;static;6;5;;static Query blendTerm(QueryShardContext context, BytesRef value, Float commonTermsCutoff, float tieBreaker, boolean lenient, List<FieldAndBoost> blendedFields) {     return blendTerms(context, new BytesRef[] { value }, commonTermsCutoff, tieBreaker, lenient, blendedFields). }
false;static;6;55;;static Query blendTerms(QueryShardContext context, BytesRef[] values, Float commonTermsCutoff, float tieBreaker, boolean lenient, List<FieldAndBoost> blendedFields) {     List<Query> queries = new ArrayList<>().     Term[] terms = new Term[blendedFields.size() * values.length].     float[] blendedBoost = new float[blendedFields.size() * values.length].     int i = 0.     for (FieldAndBoost ft : blendedFields) {         for (BytesRef term : values) {             Query query.             try {                 query = ft.fieldType.termQuery(term, context).             } catch (RuntimeException e) {                 if (lenient) {                     query = newLenientFieldQuery(ft.fieldType.name(), e).                 } else {                     throw e.                 }             }             float boost = ft.boost.             while (query instanceof BoostQuery) {                 BoostQuery bq = (BoostQuery) query.                 query = bq.getQuery().                 boost *= bq.getBoost().             }             if (query.getClass() == TermQuery.class) {                 terms[i] = ((TermQuery) query).getTerm().                 blendedBoost[i] = boost.                 i++.             } else {                 if (boost != 1f && query instanceof MatchNoDocsQuery == false) {                     query = new BoostQuery(query, boost).                 }                 queries.add(query).             }         }     }     if (i > 0) {         terms = Arrays.copyOf(terms, i).         blendedBoost = Arrays.copyOf(blendedBoost, i).         if (commonTermsCutoff != null) {             queries.add(BlendedTermQuery.commonTermsBlendedQuery(terms, blendedBoost, commonTermsCutoff)).         } else {             queries.add(BlendedTermQuery.dismaxBlendedQuery(terms, blendedBoost, tieBreaker)).         }     }     if (queries.size() == 1) {         return queries.get(0).     } else {         // TODO: can we improve this?         return new DisjunctionMaxQuery(queries, tieBreaker).     } }
