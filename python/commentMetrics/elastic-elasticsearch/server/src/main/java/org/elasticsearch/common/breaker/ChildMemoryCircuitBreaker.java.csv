commented;modifiers;parameterAmount;loc;comment;code
true;public;2;10;/**  * Method used to trip the breaker, delegates to the parent to determine  * whether to trip the breaker or not  */ ;/**  * Method used to trip the breaker, delegates to the parent to determine  * whether to trip the breaker or not  */ @Override public void circuitBreak(String fieldName, long bytesNeeded) {     this.trippedCount.incrementAndGet().     final String message = "[" + this.name + "] Data too large, data for [" + fieldName + "]" + " would be [" + bytesNeeded + "/" + new ByteSizeValue(bytesNeeded) + "]" + ", which is larger than the limit of [" + memoryBytesLimit + "/" + new ByteSizeValue(memoryBytesLimit) + "]".     logger.debug("{}", message).     throw new CircuitBreakingException(message, bytesNeeded, memoryBytesLimit, durability). }
true;public;2;29;/**  * Add a number of bytes, tripping the circuit breaker if the aggregated  * estimates are above the limit. Automatically trips the breaker if the  * memory limit is set to 0. Will never trip the breaker if the limit is  * set &lt. 0, but can still be used to aggregate estimations.  * @param bytes number of bytes to add to the breaker  * @return number of "used" bytes so far  */ ;/**  * Add a number of bytes, tripping the circuit breaker if the aggregated  * estimates are above the limit. Automatically trips the breaker if the  * memory limit is set to 0. Will never trip the breaker if the limit is  * set &lt. 0, but can still be used to aggregate estimations.  * @param bytes number of bytes to add to the breaker  * @return number of "used" bytes so far  */ @Override public double addEstimateBytesAndMaybeBreak(long bytes, String label) throws CircuitBreakingException {     // short-circuit on no data allowed, immediately throwing an exception     if (memoryBytesLimit == 0) {         circuitBreak(label, bytes).     }     long newUsed.     // limit), which makes the RamAccountingTermsEnum case faster.     if (this.memoryBytesLimit == -1) {         newUsed = noLimit(bytes, label).     } else {         newUsed = limit(bytes, label).     }     // Additionally, we need to check that we haven't exceeded the parent's limit     try {         parent.checkParentLimit((long) (bytes * overheadConstant), label).     } catch (CircuitBreakingException e) {         // If the parent breaker is tripped, this breaker has to be         // adjusted back down because the allocation is "blocked" but the         // breaker has already been incremented         this.addWithoutBreaking(-bytes).         throw e.     }     return newUsed. }
false;private;2;9;;private long noLimit(long bytes, String label) {     long newUsed.     newUsed = this.used.addAndGet(bytes).     if (logger.isTraceEnabled()) {         logger.trace("[{}] Adding [{}][{}] to used bytes [new used: [{}], limit: [-1b]]", this.name, new ByteSizeValue(bytes), label, new ByteSizeValue(newUsed)).     }     return newUsed. }
false;private;2;28;;private long limit(long bytes, String label) {     // Otherwise, check the addition and commit the addition, looping if     long newUsed.     // there are conflicts. May result in additional logging, but it's     // trace logging and shouldn't be counted on for additions.     long currentUsed.     do {         currentUsed = this.used.get().         newUsed = currentUsed + bytes.         long newUsedWithOverhead = (long) (newUsed * overheadConstant).         if (logger.isTraceEnabled()) {             logger.trace("[{}] Adding [{}][{}] to used bytes [new used: [{}], limit: {} [{}], estimate: {} [{}]]", this.name, new ByteSizeValue(bytes), label, new ByteSizeValue(newUsed), memoryBytesLimit, new ByteSizeValue(memoryBytesLimit), newUsedWithOverhead, new ByteSizeValue(newUsedWithOverhead)).         }         if (memoryBytesLimit > 0 && newUsedWithOverhead > memoryBytesLimit) {             logger.warn("[{}] New used memory {} [{}] for data of [{}] would be larger than configured breaker: {} [{}], breaking", this.name, newUsedWithOverhead, new ByteSizeValue(newUsedWithOverhead), label, memoryBytesLimit, new ByteSizeValue(memoryBytesLimit)).             circuitBreak(label, newUsedWithOverhead).         }     // Attempt to set the new used value, but make sure it hasn't changed     // underneath us, if it has, keep trying until we are able to set it     } while (!this.used.compareAndSet(currentUsed, newUsed)).     return newUsed. }
true;public;1;9;/**  * Add an <b>exact</b> number of bytes, not checking for tripping the  * circuit breaker. This bypasses the overheadConstant multiplication.  *  * Also does not check with the parent breaker to see if the parent limit  * has been exceeded.  *  * @param bytes number of bytes to add to the breaker  * @return number of "used" bytes so far  */ ;/**  * Add an <b>exact</b> number of bytes, not checking for tripping the  * circuit breaker. This bypasses the overheadConstant multiplication.  *  * Also does not check with the parent breaker to see if the parent limit  * has been exceeded.  *  * @param bytes number of bytes to add to the breaker  * @return number of "used" bytes so far  */ @Override public long addWithoutBreaking(long bytes) {     long u = used.addAndGet(bytes).     if (logger.isTraceEnabled()) {         logger.trace("[{}] Adjusted breaker by [{}] bytes, now [{}]", this.name, bytes, u).     }     assert u >= 0 : "Used bytes: [" + u + "] must be >= 0".     return u. }
true;public;0;4;/**  * @return the number of aggregated "used" bytes so far  */ ;/**  * @return the number of aggregated "used" bytes so far  */ @Override public long getUsed() {     return this.used.get(). }
true;public;0;4;/**  * @return the number of bytes that can be added before the breaker trips  */ ;/**  * @return the number of bytes that can be added before the breaker trips  */ @Override public long getLimit() {     return this.memoryBytesLimit. }
true;public;0;4;/**  * @return the constant multiplier the breaker uses for aggregations  */ ;/**  * @return the constant multiplier the breaker uses for aggregations  */ @Override public double getOverhead() {     return this.overheadConstant. }
true;public;0;4;/**  * @return the number of times the breaker has been tripped  */ ;/**  * @return the number of times the breaker has been tripped  */ @Override public long getTrippedCount() {     return this.trippedCount.get(). }
true;public;0;4;/**  * @return the name of the breaker  */ ;/**  * @return the name of the breaker  */ @Override public String getName() {     return this.name. }
true;public;0;4;/**  * @return whether a tripped circuit breaker will reset itself (transient) or requires manual intervention (permanent).  */ ;/**  * @return whether a tripped circuit breaker will reset itself (transient) or requires manual intervention (permanent).  */ @Override public Durability getDurability() {     return this.durability. }
