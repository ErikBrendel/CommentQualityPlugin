commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public DfsSearchResult maxDoc(int maxDoc) {     this.maxDoc = maxDoc.     return this. }
false;public;0;3;;public int maxDoc() {     return maxDoc. }
false;public;2;5;;public DfsSearchResult termsStatistics(Term[] terms, TermStatistics[] termStatistics) {     this.terms = terms.     this.termStatistics = termStatistics.     return this. }
false;public;1;4;;public DfsSearchResult fieldStatistics(ObjectObjectHashMap<String, CollectionStatistics> fieldStatistics) {     this.fieldStatistics = fieldStatistics.     return this. }
false;public;0;3;;public Term[] terms() {     return terms. }
false;public;0;3;;public TermStatistics[] termStatistics() {     return termStatistics. }
false;public;0;3;;public ObjectObjectHashMap<String, CollectionStatistics> fieldStatistics() {     return fieldStatistics. }
false;public;1;19;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     requestId = in.readLong().     int termsSize = in.readVInt().     if (termsSize == 0) {         terms = EMPTY_TERMS.     } else {         terms = new Term[termsSize].         for (int i = 0. i < terms.length. i++) {             terms[i] = new Term(in.readString(), in.readBytesRef()).         }     }     this.termStatistics = readTermStats(in, terms).     readFieldStats(in, fieldStatistics).     maxDoc = in.readVInt(). }
false;public;1;13;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeLong(requestId).     out.writeVInt(terms.length).     for (Term term : terms) {         out.writeString(term.field()).         out.writeBytesRef(term.bytes()).     }     writeTermStats(out, termStatistics).     writeFieldStats(out, fieldStatistics).     out.writeVInt(maxDoc). }
false;public,static;2;21;;public static void writeFieldStats(StreamOutput out, ObjectObjectHashMap<String, CollectionStatistics> fieldStatistics) throws IOException {     out.writeVInt(fieldStatistics.size()).     for (ObjectObjectCursor<String, CollectionStatistics> c : fieldStatistics) {         out.writeString(c.key).         CollectionStatistics statistics = c.value.         assert statistics.maxDoc() >= 0.         out.writeVLong(statistics.maxDoc()).         if (out.getVersion().onOrAfter(Version.V_7_0_0)) {             // stats are always positive numbers             out.writeVLong(statistics.docCount()).             out.writeVLong(statistics.sumTotalTermFreq()).             out.writeVLong(statistics.sumDocFreq()).         } else {             out.writeVLong(addOne(statistics.docCount())).             out.writeVLong(addOne(statistics.sumTotalTermFreq())).             out.writeVLong(addOne(statistics.sumDocFreq())).         }     } }
false;public,static;2;6;;public static void writeTermStats(StreamOutput out, TermStatistics[] termStatistics) throws IOException {     out.writeVInt(termStatistics.length).     for (TermStatistics termStatistic : termStatistics) {         writeSingleTermStats(out, termStatistic).     } }
false;public,static;2;10;;public static void writeSingleTermStats(StreamOutput out, TermStatistics termStatistic) throws IOException {     if (termStatistic != null) {         assert termStatistic.docFreq() > 0.         out.writeVLong(termStatistic.docFreq()).         out.writeVLong(addOne(termStatistic.totalTermFreq())).     } else {         out.writeVLong(0).         out.writeVLong(0).     } }
false;public,static;1;3;;public static ObjectObjectHashMap<String, CollectionStatistics> readFieldStats(StreamInput in) throws IOException {     return readFieldStats(in, null). }
false;public,static;2;28;;public static ObjectObjectHashMap<String, CollectionStatistics> readFieldStats(StreamInput in, ObjectObjectHashMap<String, CollectionStatistics> fieldStatistics) throws IOException {     final int numFieldStatistics = in.readVInt().     if (fieldStatistics == null) {         fieldStatistics = HppcMaps.newNoNullKeysMap(numFieldStatistics).     }     for (int i = 0. i < numFieldStatistics. i++) {         final String field = in.readString().         assert field != null.         final long maxDoc = in.readVLong().         final long docCount.         final long sumTotalTermFreq.         final long sumDocFreq.         if (in.getVersion().onOrAfter(Version.V_7_0_0)) {             // stats are always positive numbers             docCount = in.readVLong().             sumTotalTermFreq = in.readVLong().             sumDocFreq = in.readVLong().         } else {             docCount = subOne(in.readVLong()).             sumTotalTermFreq = subOne(in.readVLong()).             sumDocFreq = subOne(in.readVLong()).         }         CollectionStatistics stats = new CollectionStatistics(field, maxDoc, docCount, sumTotalTermFreq, sumDocFreq).         fieldStatistics.put(field, stats).     }     return fieldStatistics. }
false;public,static;2;21;;public static TermStatistics[] readTermStats(StreamInput in, Term[] terms) throws IOException {     int termsStatsSize = in.readVInt().     final TermStatistics[] termStatistics.     if (termsStatsSize == 0) {         termStatistics = EMPTY_TERM_STATS.     } else {         termStatistics = new TermStatistics[termsStatsSize].         assert terms.length == termsStatsSize.         for (int i = 0. i < termStatistics.length. i++) {             BytesRef term = terms[i].bytes().             final long docFreq = in.readVLong().             assert docFreq >= 0.             final long totalTermFreq = subOne(in.readVLong()).             if (docFreq == 0) {                 continue.             }             termStatistics[i] = new TermStatistics(term, docFreq, totalTermFreq).         }     }     return termStatistics. }
true;public,static;1;4;/*      * optional statistics are set to -1 in lucene by default.      * Since we are using var longs to encode values we add one to each value      * to ensure we don't waste space and don't add negative values.      */ ;/*      * optional statistics are set to -1 in lucene by default.      * Since we are using var longs to encode values we add one to each value      * to ensure we don't waste space and don't add negative values.      */ public static long addOne(long value) {     assert value + 1 >= 0.     return value + 1. }
true;public,static;1;4;/*      * See #addOne this just subtracting one and asserts that the actual value      * is positive.      */ ;/*      * See #addOne this just subtracting one and asserts that the actual value      * is positive.      */ public static long subOne(long value) {     assert value >= 0.     return value - 1. }
