commented;modifiers;parameterAmount;loc;comment;code
false;public;0;27;;@Override public boolean matches() throws IOException {     BytesRef encodedRanges = values.binaryValue().     in.reset(encodedRanges.bytes, encodedRanges.offset, encodedRanges.length).     int numRanges = in.readVInt().     final byte[] bytes = encodedRanges.bytes.     otherFrom.bytes = bytes.     otherTo.bytes = bytes.     int offset = in.getPosition().     for (int i = 0. i < numRanges. i++) {         int length = lengthType.readLength(bytes, offset).         otherFrom.offset = offset.         otherFrom.length = length.         offset += length.         length = lengthType.readLength(bytes, offset).         otherTo.offset = offset.         otherTo.length = length.         offset += length.         if (queryType.matches(from, to, otherFrom, otherTo)) {             return true.         }     }     assert offset == encodedRanges.offset + encodedRanges.length.     return false. }
false;public;0;4;;@Override public float matchCost() {     // at most 4 comparisons     return 4. }
false;public;1;48;;@Override public Scorer scorer(LeafReaderContext context) throws IOException {     final BinaryDocValues values = context.reader().getBinaryDocValues(fieldName).     if (values == null) {         return null.     }     final TwoPhaseIterator iterator = new TwoPhaseIterator(values) {          ByteArrayDataInput in = new ByteArrayDataInput().          BytesRef otherFrom = new BytesRef().          BytesRef otherTo = new BytesRef().          @Override         public boolean matches() throws IOException {             BytesRef encodedRanges = values.binaryValue().             in.reset(encodedRanges.bytes, encodedRanges.offset, encodedRanges.length).             int numRanges = in.readVInt().             final byte[] bytes = encodedRanges.bytes.             otherFrom.bytes = bytes.             otherTo.bytes = bytes.             int offset = in.getPosition().             for (int i = 0. i < numRanges. i++) {                 int length = lengthType.readLength(bytes, offset).                 otherFrom.offset = offset.                 otherFrom.length = length.                 offset += length.                 length = lengthType.readLength(bytes, offset).                 otherTo.offset = offset.                 otherTo.length = length.                 offset += length.                 if (queryType.matches(from, to, otherFrom, otherTo)) {                     return true.                 }             }             assert offset == encodedRanges.offset + encodedRanges.length.             return false.         }          @Override         public float matchCost() {             // at most 4 comparisons             return 4.         }     }.     return new ConstantScoreScorer(this, score(), scoreMode, iterator). }
false;public;1;4;;@Override public boolean isCacheable(LeafReaderContext ctx) {     return DocValues.isCacheable(ctx, fieldName). }
false;public;3;59;;@Override public Weight createWeight(IndexSearcher searcher, ScoreMode scoreMode, float boost) throws IOException {     return new ConstantScoreWeight(this, boost) {          @Override         public Scorer scorer(LeafReaderContext context) throws IOException {             final BinaryDocValues values = context.reader().getBinaryDocValues(fieldName).             if (values == null) {                 return null.             }             final TwoPhaseIterator iterator = new TwoPhaseIterator(values) {                  ByteArrayDataInput in = new ByteArrayDataInput().                  BytesRef otherFrom = new BytesRef().                  BytesRef otherTo = new BytesRef().                  @Override                 public boolean matches() throws IOException {                     BytesRef encodedRanges = values.binaryValue().                     in.reset(encodedRanges.bytes, encodedRanges.offset, encodedRanges.length).                     int numRanges = in.readVInt().                     final byte[] bytes = encodedRanges.bytes.                     otherFrom.bytes = bytes.                     otherTo.bytes = bytes.                     int offset = in.getPosition().                     for (int i = 0. i < numRanges. i++) {                         int length = lengthType.readLength(bytes, offset).                         otherFrom.offset = offset.                         otherFrom.length = length.                         offset += length.                         length = lengthType.readLength(bytes, offset).                         otherTo.offset = offset.                         otherTo.length = length.                         offset += length.                         if (queryType.matches(from, to, otherFrom, otherTo)) {                             return true.                         }                     }                     assert offset == encodedRanges.offset + encodedRanges.length.                     return false.                 }                  @Override                 public float matchCost() {                     // at most 4 comparisons                     return 4.                 }             }.             return new ConstantScoreScorer(this, score(), scoreMode, iterator).         }          @Override         public boolean isCacheable(LeafReaderContext ctx) {             return DocValues.isCacheable(ctx, fieldName).         }     }. }
false;public;1;4;;@Override public String toString(String field) {     return "BinaryDocValuesRangeQuery(fieldName=" + field + ",from=" + originalFrom + ",to=" + originalTo + ")". }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     BinaryDocValuesRangeQuery that = (BinaryDocValuesRangeQuery) o.     return Objects.equals(fieldName, that.fieldName) && queryType == that.queryType && lengthType == that.lengthType && Objects.equals(from, that.from) && Objects.equals(to, that.to). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(getClass(), fieldName, queryType, lengthType, from, to). }
false;;4;7;;@Override boolean matches(BytesRef from, BytesRef to, BytesRef otherFrom, BytesRef otherTo) {     // other:               |------|     return from.compareTo(otherTo) <= 0 && to.compareTo(otherFrom) >= 0. }
false;;4;7;;@Override boolean matches(BytesRef from, BytesRef to, BytesRef otherFrom, BytesRef otherTo) {     // other:       |------|     return from.compareTo(otherFrom) <= 0 && to.compareTo(otherTo) >= 0. }
false;;4;7;;@Override boolean matches(BytesRef from, BytesRef to, BytesRef otherFrom, BytesRef otherTo) {     // other:    |---------------|     return from.compareTo(otherFrom) >= 0 && to.compareTo(otherTo) <= 0. }
false;;4;6;;@Override boolean matches(BytesRef from, BytesRef to, BytesRef otherFrom, BytesRef otherTo) {     // does not disjoint AND not within:     return (from.compareTo(otherTo) > 0 || to.compareTo(otherFrom) < 0) == false && (from.compareTo(otherFrom) <= 0 && to.compareTo(otherTo) >= 0) == false. }
false;abstract;4;1;;abstract boolean matches(BytesRef from, BytesRef to, BytesRef otherFrom, BytesRef otherTo).
false;;2;4;;@Override int readLength(byte[] bytes, int offset) {     return 4. }
false;;2;4;;@Override int readLength(byte[] bytes, int offset) {     return 8. }
false;;2;4;;@Override int readLength(byte[] bytes, int offset) {     return 16. }
false;;2;11;;@Override int readLength(byte[] bytes, int offset) {     // the first bit encodes the sign and the next 4 bits encode the number     // of additional bytes     int token = Byte.toUnsignedInt(bytes[offset]).     int length = (token >>> 3) & 0x0f.     if ((token & 0x80) == 0) {         length = 0x0f - length.     }     return 1 + length. }
true;abstract;2;1;/**  * Return the length of the value that starts at {@code offset} in {@code bytes}.  */ ;/**  * Return the length of the value that starts at {@code offset} in {@code bytes}.  */ abstract int readLength(byte[] bytes, int offset).
