commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;3;;public static Query newMatchAllQuery() {     return new MatchAllDocsQuery(). }
true;public,static;1;3;/**  * Return a query that matches no document.  */ ;/**  * Return a query that matches no document.  */ public static Query newMatchNoDocsQuery(String reason) {     return new MatchNoDocsQuery(reason). }
false;public,static;1;3;;public static Query newUnmappedFieldQuery(String field) {     return Queries.newMatchNoDocsQuery("unmapped field [" + (field != null ? field : "null") + "]"). }
false;public,static;2;4;;public static Query newLenientFieldQuery(String field, RuntimeException e) {     String message = ElasticsearchException.getExceptionName(e) + ":[" + e.getMessage() + "]".     return Queries.newMatchNoDocsQuery("failed [" + field + "] query, caused by " + message). }
false;public,static;0;3;;public static Query newNestedFilter() {     return new PrefixQuery(new Term(TypeFieldMapper.NAME, new BytesRef("__"))). }
true;public,static;1;10;/**  * Creates a new non-nested docs query  * @param indexVersionCreated the index version created since newer indices can identify a parent field more efficiently  */ ;/**  * Creates a new non-nested docs query  * @param indexVersionCreated the index version created since newer indices can identify a parent field more efficiently  */ public static Query newNonNestedFilter(Version indexVersionCreated) {     if (indexVersionCreated.onOrAfter(Version.V_6_1_0)) {         return new DocValuesFieldExistsQuery(SeqNoFieldMapper.PRIMARY_TERM_NAME).     } else {         return new BooleanQuery.Builder().add(new MatchAllDocsQuery(), Occur.FILTER).add(newNestedFilter(), Occur.MUST_NOT).build().     } }
false;public,static;2;10;;public static BooleanQuery filtered(@Nullable Query query, @Nullable Query filter) {     BooleanQuery.Builder builder = new BooleanQuery.Builder().     if (query != null) {         builder.add(new BooleanClause(query, Occur.MUST)).     }     if (filter != null) {         builder.add(new BooleanClause(filter, Occur.FILTER)).     }     return builder.build(). }
true;public,static;1;6;/**  * Return a query that matches all documents but those that match the given query.  */ ;/**  * Return a query that matches all documents but those that match the given query.  */ public static Query not(Query q) {     return new BooleanQuery.Builder().add(new MatchAllDocsQuery(), Occur.MUST).add(q, Occur.MUST_NOT).build(). }
false;static;1;8;;static boolean isNegativeQuery(Query q) {     if (!(q instanceof BooleanQuery)) {         return false.     }     List<BooleanClause> clauses = ((BooleanQuery) q).clauses().     return clauses.isEmpty() == false && clauses.stream().allMatch(BooleanClause::isProhibited). }
false;public,static;1;12;;public static Query fixNegativeQueryIfNeeded(Query q) {     if (isNegativeQuery(q)) {         BooleanQuery bq = (BooleanQuery) q.         BooleanQuery.Builder builder = new BooleanQuery.Builder().         for (BooleanClause clause : bq) {             builder.add(clause).         }         builder.add(newMatchAllQuery(), BooleanClause.Occur.FILTER).         return builder.build().     }     return q. }
false;public,static;2;23;;public static Query applyMinimumShouldMatch(BooleanQuery query, @Nullable String minimumShouldMatch) {     if (minimumShouldMatch == null) {         return query.     }     int optionalClauses = 0.     for (BooleanClause c : query.clauses()) {         if (c.getOccur() == BooleanClause.Occur.SHOULD) {             optionalClauses++.         }     }     int msm = calculateMinShouldMatch(optionalClauses, minimumShouldMatch).     if (0 < msm) {         BooleanQuery.Builder builder = new BooleanQuery.Builder().         for (BooleanClause clause : query) {             builder.add(clause).         }         builder.setMinimumNumberShouldMatch(msm).         return builder.build().     } else {         return query.     } }
true;public,static;2;8;/**  * Potentially apply minimum should match value if we have a query that it can be applied to,  * otherwise return the original query.  */ ;/**  * Potentially apply minimum should match value if we have a query that it can be applied to,  * otherwise return the original query.  */ public static Query maybeApplyMinimumShouldMatch(Query query, @Nullable String minimumShouldMatch) {     if (query instanceof BooleanQuery) {         return applyMinimumShouldMatch((BooleanQuery) query, minimumShouldMatch).     } else if (query instanceof ExtendedCommonTermsQuery) {         ((ExtendedCommonTermsQuery) query).setLowFreqMinimumNumberShouldMatch(minimumShouldMatch).     }     return query. }
false;public,static;2;35;;public static int calculateMinShouldMatch(int optionalClauseCount, String spec) {     int result = optionalClauseCount.     spec = spec.trim().     if (-1 < spec.indexOf("<")) {         /* we have conditional spec(s) */         spec = spaceAroundLessThanPattern.matcher(spec).replaceAll("<").         for (String s : spacePattern.split(spec)) {             String[] parts = lessThanPattern.split(s, 0).             int upperBound = Integer.parseInt(parts[0]).             if (optionalClauseCount <= upperBound) {                 return result.             } else {                 result = calculateMinShouldMatch(optionalClauseCount, parts[1]).             }         }         return result.     }     if (-1 < spec.indexOf('%')) {         /* percentage - assume the % was the last char.  If not, let Integer.parseInt fail. */         spec = spec.substring(0, spec.length() - 1).         int percent = Integer.parseInt(spec).         float calc = (result * percent) * (1 / 100f).         result = calc < 0 ? result + (int) calc : (int) calc.     } else {         int calc = Integer.parseInt(spec).         result = calc < 0 ? result + calc : calc.     }     return result < 0 ? 0 : result. }
