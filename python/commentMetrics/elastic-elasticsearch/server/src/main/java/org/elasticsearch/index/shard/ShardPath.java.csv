commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Path resolveTranslog() {     return path.resolve(TRANSLOG_FOLDER_NAME). }
false;public;0;3;;public Path resolveIndex() {     return path.resolve(INDEX_FOLDER_NAME). }
false;public;0;3;;public Path getDataPath() {     return path. }
false;public;0;3;;public boolean exists() {     return Files.exists(path). }
false;public;0;3;;public ShardId getShardId() {     return shardId. }
false;public;0;3;;public Path getShardStatePath() {     return shardStatePath. }
true;public;0;4;/**  * Returns the data-path root for this shard. The root is a parent of {@link #getDataPath()} without the index name  * and the shard ID.  */ ;/**  * Returns the data-path root for this shard. The root is a parent of {@link #getDataPath()} without the index name  * and the shard ID.  */ public Path getRootDataPath() {     Path noIndexShardId = getDataPath().getParent().getParent().     // also strip the indices folder     return isCustomDataPath ? noIndexShardId : noIndexShardId.getParent(). }
true;public;0;3;/**  * Returns the state-path root for this shard. The root is a parent of {@link #getRootStatePath()} ()} without the index name  * and the shard ID.  */ ;/**  * Returns the state-path root for this shard. The root is a parent of {@link #getRootStatePath()} ()} without the index name  * and the shard ID.  */ public Path getRootStatePath() {     // also strip the indices folder     return getShardStatePath().getParent().getParent().getParent(). }
true;public;0;3;/**  * Returns <code>true</code> iff the data location is a custom data location and therefore outside of the nodes configured data paths.  */ ;/**  * Returns <code>true</code> iff the data location is a custom data location and therefore outside of the nodes configured data paths.  */ public boolean isCustomDataPath() {     return isCustomDataPath. }
true;public,static;4;7;/**  * This method walks through the nodes shard paths to find the data and state path for the given shard. If multiple  * directories with a valid shard state exist the one with the highest version will be used.  * <b>Note:</b> this method resolves custom data locations for the shard.  */ ;/**  * This method walks through the nodes shard paths to find the data and state path for the given shard. If multiple  * directories with a valid shard state exist the one with the highest version will be used.  * <b>Note:</b> this method resolves custom data locations for the shard.  */ public static ShardPath loadShardPath(Logger logger, NodeEnvironment env, ShardId shardId, IndexSettings indexSettings) throws IOException {     final Path[] paths = env.availableShardPaths(shardId).     final int nodeLockId = env.getNodeLockId().     final Path sharedDataPath = env.sharedDataPath().     return loadShardPath(logger, shardId, indexSettings, paths, nodeLockId, sharedDataPath). }
true;public,static;6;37;/**  * This method walks through the nodes shard paths to find the data and state path for the given shard. If multiple  * directories with a valid shard state exist the one with the highest version will be used.  * <b>Note:</b> this method resolves custom data locations for the shard.  */ ;/**  * This method walks through the nodes shard paths to find the data and state path for the given shard. If multiple  * directories with a valid shard state exist the one with the highest version will be used.  * <b>Note:</b> this method resolves custom data locations for the shard.  */ public static ShardPath loadShardPath(Logger logger, ShardId shardId, IndexSettings indexSettings, Path[] availableShardPaths, int nodeLockId, Path sharedDataPath) throws IOException {     final String indexUUID = indexSettings.getUUID().     Path loadedPath = null.     for (Path path : availableShardPaths) {         // EMPTY is safe here because we never call namedObject         ShardStateMetaData load = ShardStateMetaData.FORMAT.loadLatestState(logger, NamedXContentRegistry.EMPTY, path).         if (load != null) {             if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) {                 logger.warn("{} found shard on path: [{}] with a different index UUID - this " + "shard seems to be leftover from a different index with the same name. " + "Remove the leftover shard in order to reuse the path with the current index", shardId, path).                 throw new IllegalStateException(shardId + " index UUID in shard state was: " + load.indexUUID + " expected: " + indexUUID + " on shard path: " + path).             }             if (loadedPath == null) {                 loadedPath = path.             } else {                 throw new IllegalStateException(shardId + " more than one shard state found").             }         }     }     if (loadedPath == null) {         return null.     } else {         final Path dataPath.         final Path statePath = loadedPath.         if (indexSettings.hasCustomDataPath()) {             dataPath = NodeEnvironment.resolveCustomLocation(indexSettings, shardId, sharedDataPath, nodeLockId).         } else {             dataPath = statePath.         }         logger.debug("{} loaded data path [{}], state path [{}]", shardId, dataPath, statePath).         return new ShardPath(indexSettings.hasCustomDataPath(), dataPath, statePath, shardId).     } }
true;public,static;4;17;/**  * This method tries to delete left-over shards where the index name has been reused but the UUID is different  * to allow the new shard to be allocated.  */ ;/**  * This method tries to delete left-over shards where the index name has been reused but the UUID is different  * to allow the new shard to be allocated.  */ public static void deleteLeftoverShardDirectory(Logger logger, NodeEnvironment env, ShardLock lock, IndexSettings indexSettings) throws IOException {     final String indexUUID = indexSettings.getUUID().     final Path[] paths = env.availableShardPaths(lock.getShardId()).     for (Path path : paths) {         // EMPTY is safe here because we never call namedObject         ShardStateMetaData load = ShardStateMetaData.FORMAT.loadLatestState(logger, NamedXContentRegistry.EMPTY, path).         if (load != null) {             if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) {                 logger.warn("{} deleting leftover shard on path: [{}] with a different index UUID", lock.getShardId(), path).                 assert Files.isDirectory(path) : path + " is not a directory".                 NodeEnvironment.acquireFSLockForPaths(indexSettings, paths).                 IOUtils.rm(path).             }         }     } }
false;public,static;5;68;;public static ShardPath selectNewPathForShard(NodeEnvironment env, ShardId shardId, IndexSettings indexSettings, long avgShardSizeInBytes, Map<Path, Integer> dataPathToShardCount) throws IOException {     final Path dataPath.     final Path statePath.     if (indexSettings.hasCustomDataPath()) {         dataPath = env.resolveCustomLocation(indexSettings, shardId).         statePath = env.nodePaths()[0].resolve(shardId).     } else {         BigInteger totFreeSpace = BigInteger.ZERO.         for (NodeEnvironment.NodePath nodePath : env.nodePaths()) {             totFreeSpace = totFreeSpace.add(BigInteger.valueOf(nodePath.fileStore.getUsableSpace())).         }         // TODO: this is a hack!!  We should instead keep track of incoming (relocated) shards since we know         // how large they will be once they're done copying, instead of a silly guess for such cases:         // Very rough heuristic of how much disk space we expect the shard will use over its lifetime, the max of current average         // shard size across the cluster and 5% of the total available free space on this node:         BigInteger estShardSizeInBytes = BigInteger.valueOf(avgShardSizeInBytes).max(totFreeSpace.divide(BigInteger.valueOf(20))).         // TODO - do we need something more extensible? Yet, this does the job for now...         final NodeEnvironment.NodePath[] paths = env.nodePaths().         // If no better path is chosen, use the one with the most space by default         NodeEnvironment.NodePath bestPath = getPathWithMostFreeSpace(env).         if (paths.length != 1) {             Map<NodeEnvironment.NodePath, Long> pathToShardCount = env.shardCountPerPath(shardId.getIndex()).             // Compute how much space there is on each path             final Map<NodeEnvironment.NodePath, BigInteger> pathsToSpace = new HashMap<>(paths.length).             for (NodeEnvironment.NodePath nodePath : paths) {                 FileStore fileStore = nodePath.fileStore.                 BigInteger usableBytes = BigInteger.valueOf(fileStore.getUsableSpace()).                 pathsToSpace.put(nodePath, usableBytes).             }             bestPath = Arrays.stream(paths).filter((path) -> pathsToSpace.get(path).subtract(estShardSizeInBytes).compareTo(BigInteger.ZERO) > 0).sorted((p1, p2) -> {                 int cmp = Long.compare(pathToShardCount.getOrDefault(p1, 0L), pathToShardCount.getOrDefault(p2, 0L)).                 if (cmp == 0) {                     // if the number of shards is equal, tie-break with the number of total shards                     cmp = Integer.compare(dataPathToShardCount.getOrDefault(p1.path, 0), dataPathToShardCount.getOrDefault(p2.path, 0)).                     if (cmp == 0) {                         // if the number of shards is equal, tie-break with the usable bytes                         cmp = pathsToSpace.get(p2).compareTo(pathsToSpace.get(p1)).                     }                 }                 return cmp.             }).findFirst().orElse(bestPath).         }         statePath = bestPath.resolve(shardId).         dataPath = statePath.     }     return new ShardPath(indexSettings.hasCustomDataPath(), dataPath, statePath, shardId). }
false;static;1;17;;static NodeEnvironment.NodePath getPathWithMostFreeSpace(NodeEnvironment env) throws IOException {     final NodeEnvironment.NodePath[] paths = env.nodePaths().     NodeEnvironment.NodePath bestPath = null.     long maxUsableBytes = Long.MIN_VALUE.     for (NodeEnvironment.NodePath nodePath : paths) {         FileStore fileStore = nodePath.fileStore.         long usableBytes = fileStore.getUsableSpace().         assert usableBytes >= 0 : "usable bytes must be >= 0, got: " + usableBytes.         if (bestPath == null || usableBytes > maxUsableBytes) {             // This path has been determined to be "better" based on the usable bytes             maxUsableBytes = usableBytes.             bestPath = nodePath.         }     }     return bestPath. }
false;public;1;18;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     final ShardPath shardPath = (ShardPath) o.     if (shardId != null ? !shardId.equals(shardPath.shardId) : shardPath.shardId != null) {         return false.     }     if (path != null ? !path.equals(shardPath.path) : shardPath.path != null) {         return false.     }     return true. }
false;public;0;6;;@Override public int hashCode() {     int result = path != null ? path.hashCode() : 0.     result = 31 * result + (shardId != null ? shardId.hashCode() : 0).     return result. }
false;public;0;7;;@Override public String toString() {     return "ShardPath{" + "path=" + path + ", shard=" + shardId + '}'. }
