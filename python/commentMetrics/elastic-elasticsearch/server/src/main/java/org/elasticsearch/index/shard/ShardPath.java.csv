# id;timestamp;commentText;codeText;commentWords;codeWords
ShardPath -> public static ShardPath loadShardPath(Logger logger, ShardId shardId, IndexSettings indexSettings, Path[] availableShardPaths,                                            int nodeLockId, Path sharedDataPath) throws IOException;1537371806;This method walks through the nodes shard paths to find the data and state path for the given shard. If multiple_directories with a valid shard state exist the one with the highest version will be used._<b>Note:</b> this method resolves custom data locations for the shard.;public static ShardPath loadShardPath(Logger logger, ShardId shardId, IndexSettings indexSettings, Path[] availableShardPaths,_                                           int nodeLockId, Path sharedDataPath) throws IOException {_        final String indexUUID = indexSettings.getUUID()__        Path loadedPath = null__        for (Path path : availableShardPaths) {_            _            ShardStateMetaData load = ShardStateMetaData.FORMAT.loadLatestState(logger, NamedXContentRegistry.EMPTY, path)__            if (load != null) {_                if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) {_                    logger.warn("{} found shard on path: [{}] with a different index UUID - this "_                        + "shard seems to be leftover from a different index with the same name. "_                        + "Remove the leftover shard in order to reuse the path with the current index", shardId, path)__                    throw new IllegalStateException(shardId + " index UUID in shard state was: " + load.indexUUID_                        + " expected: " + indexUUID + " on shard path: " + path)__                }_                if (loadedPath == null) {_                    loadedPath = path__                } else{_                    throw new IllegalStateException(shardId + " more than one shard state found")__                }_            }__        }_        if (loadedPath == null) {_            return null__        } else {_            final Path dataPath__            final Path statePath = loadedPath__            if (indexSettings.hasCustomDataPath()) {_                dataPath = NodeEnvironment.resolveCustomLocation(indexSettings, shardId, sharedDataPath, nodeLockId)__            } else {_                dataPath = statePath__            }_            logger.debug("{} loaded data path [{}], state path [{}]", shardId, dataPath, statePath)__            return new ShardPath(indexSettings.hasCustomDataPath(), dataPath, statePath, shardId)__        }_    };this,method,walks,through,the,nodes,shard,paths,to,find,the,data,and,state,path,for,the,given,shard,if,multiple,directories,with,a,valid,shard,state,exist,the,one,with,the,highest,version,will,be,used,b,note,b,this,method,resolves,custom,data,locations,for,the,shard;public,static,shard,path,load,shard,path,logger,logger,shard,id,shard,id,index,settings,index,settings,path,available,shard,paths,int,node,lock,id,path,shared,data,path,throws,ioexception,final,string,index,uuid,index,settings,get,uuid,path,loaded,path,null,for,path,path,available,shard,paths,shard,state,meta,data,load,shard,state,meta,data,format,load,latest,state,logger,named,xcontent,registry,empty,path,if,load,null,if,load,index,uuid,equals,index,uuid,false,index,meta,data,equals,load,index,uuid,false,logger,warn,found,shard,on,path,with,a,different,index,uuid,this,shard,seems,to,be,leftover,from,a,different,index,with,the,same,name,remove,the,leftover,shard,in,order,to,reuse,the,path,with,the,current,index,shard,id,path,throw,new,illegal,state,exception,shard,id,index,uuid,in,shard,state,was,load,index,uuid,expected,index,uuid,on,shard,path,path,if,loaded,path,null,loaded,path,path,else,throw,new,illegal,state,exception,shard,id,more,than,one,shard,state,found,if,loaded,path,null,return,null,else,final,path,data,path,final,path,state,path,loaded,path,if,index,settings,has,custom,data,path,data,path,node,environment,resolve,custom,location,index,settings,shard,id,shared,data,path,node,lock,id,else,data,path,state,path,logger,debug,loaded,data,path,state,path,shard,id,data,path,state,path,return,new,shard,path,index,settings,has,custom,data,path,data,path,state,path,shard,id
ShardPath -> public static ShardPath loadShardPath(Logger logger, ShardId shardId, IndexSettings indexSettings, Path[] availableShardPaths,                                            int nodeLockId, Path sharedDataPath) throws IOException;1542697754;This method walks through the nodes shard paths to find the data and state path for the given shard. If multiple_directories with a valid shard state exist the one with the highest version will be used._<b>Note:</b> this method resolves custom data locations for the shard.;public static ShardPath loadShardPath(Logger logger, ShardId shardId, IndexSettings indexSettings, Path[] availableShardPaths,_                                           int nodeLockId, Path sharedDataPath) throws IOException {_        final String indexUUID = indexSettings.getUUID()__        Path loadedPath = null__        for (Path path : availableShardPaths) {_            _            ShardStateMetaData load = ShardStateMetaData.FORMAT.loadLatestState(logger, NamedXContentRegistry.EMPTY, path)__            if (load != null) {_                if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) {_                    logger.warn("{} found shard on path: [{}] with a different index UUID - this "_                        + "shard seems to be leftover from a different index with the same name. "_                        + "Remove the leftover shard in order to reuse the path with the current index", shardId, path)__                    throw new IllegalStateException(shardId + " index UUID in shard state was: " + load.indexUUID_                        + " expected: " + indexUUID + " on shard path: " + path)__                }_                if (loadedPath == null) {_                    loadedPath = path__                } else{_                    throw new IllegalStateException(shardId + " more than one shard state found")__                }_            }__        }_        if (loadedPath == null) {_            return null__        } else {_            final Path dataPath__            final Path statePath = loadedPath__            if (indexSettings.hasCustomDataPath()) {_                dataPath = NodeEnvironment.resolveCustomLocation(indexSettings, shardId, sharedDataPath, nodeLockId)__            } else {_                dataPath = statePath__            }_            logger.debug("{} loaded data path [{}], state path [{}]", shardId, dataPath, statePath)__            return new ShardPath(indexSettings.hasCustomDataPath(), dataPath, statePath, shardId)__        }_    };this,method,walks,through,the,nodes,shard,paths,to,find,the,data,and,state,path,for,the,given,shard,if,multiple,directories,with,a,valid,shard,state,exist,the,one,with,the,highest,version,will,be,used,b,note,b,this,method,resolves,custom,data,locations,for,the,shard;public,static,shard,path,load,shard,path,logger,logger,shard,id,shard,id,index,settings,index,settings,path,available,shard,paths,int,node,lock,id,path,shared,data,path,throws,ioexception,final,string,index,uuid,index,settings,get,uuid,path,loaded,path,null,for,path,path,available,shard,paths,shard,state,meta,data,load,shard,state,meta,data,format,load,latest,state,logger,named,xcontent,registry,empty,path,if,load,null,if,load,index,uuid,equals,index,uuid,false,index,meta,data,equals,load,index,uuid,false,logger,warn,found,shard,on,path,with,a,different,index,uuid,this,shard,seems,to,be,leftover,from,a,different,index,with,the,same,name,remove,the,leftover,shard,in,order,to,reuse,the,path,with,the,current,index,shard,id,path,throw,new,illegal,state,exception,shard,id,index,uuid,in,shard,state,was,load,index,uuid,expected,index,uuid,on,shard,path,path,if,loaded,path,null,loaded,path,path,else,throw,new,illegal,state,exception,shard,id,more,than,one,shard,state,found,if,loaded,path,null,return,null,else,final,path,data,path,final,path,state,path,loaded,path,if,index,settings,has,custom,data,path,data,path,node,environment,resolve,custom,location,index,settings,shard,id,shared,data,path,node,lock,id,else,data,path,state,path,logger,debug,loaded,data,path,state,path,shard,id,data,path,state,path,return,new,shard,path,index,settings,has,custom,data,path,data,path,state,path,shard,id
ShardPath -> public static void deleteLeftoverShardDirectory(Logger logger, NodeEnvironment env, ShardLock lock, IndexSettings indexSettings) throws IOException;1524684173;This method tries to delete left-over shards where the index name has been reused but the UUID is different_to allow the new shard to be allocated.;public static void deleteLeftoverShardDirectory(Logger logger, NodeEnvironment env, ShardLock lock, IndexSettings indexSettings) throws IOException {_        final String indexUUID = indexSettings.getUUID()__        final Path[] paths = env.availableShardPaths(lock.getShardId())__        for (Path path : paths) {_            _            ShardStateMetaData load = ShardStateMetaData.FORMAT.loadLatestState(logger, NamedXContentRegistry.EMPTY, path)__            if (load != null) {_                if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) {_                    logger.warn("{} deleting leftover shard on path: [{}] with a different index UUID", lock.getShardId(), path)__                    assert Files.isDirectory(path) : path + " is not a directory"__                    NodeEnvironment.acquireFSLockForPaths(indexSettings, paths)__                    IOUtils.rm(path)__                }_            }_        }_    };this,method,tries,to,delete,left,over,shards,where,the,index,name,has,been,reused,but,the,uuid,is,different,to,allow,the,new,shard,to,be,allocated;public,static,void,delete,leftover,shard,directory,logger,logger,node,environment,env,shard,lock,lock,index,settings,index,settings,throws,ioexception,final,string,index,uuid,index,settings,get,uuid,final,path,paths,env,available,shard,paths,lock,get,shard,id,for,path,path,paths,shard,state,meta,data,load,shard,state,meta,data,format,load,latest,state,logger,named,xcontent,registry,empty,path,if,load,null,if,load,index,uuid,equals,index,uuid,false,index,meta,data,equals,load,index,uuid,false,logger,warn,deleting,leftover,shard,on,path,with,a,different,index,uuid,lock,get,shard,id,path,assert,files,is,directory,path,path,is,not,a,directory,node,environment,acquire,fslock,for,paths,index,settings,paths,ioutils,rm,path
ShardPath -> public static void deleteLeftoverShardDirectory(Logger logger, NodeEnvironment env, ShardLock lock, IndexSettings indexSettings) throws IOException;1537371806;This method tries to delete left-over shards where the index name has been reused but the UUID is different_to allow the new shard to be allocated.;public static void deleteLeftoverShardDirectory(Logger logger, NodeEnvironment env, ShardLock lock, IndexSettings indexSettings) throws IOException {_        final String indexUUID = indexSettings.getUUID()__        final Path[] paths = env.availableShardPaths(lock.getShardId())__        for (Path path : paths) {_            _            ShardStateMetaData load = ShardStateMetaData.FORMAT.loadLatestState(logger, NamedXContentRegistry.EMPTY, path)__            if (load != null) {_                if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) {_                    logger.warn("{} deleting leftover shard on path: [{}] with a different index UUID", lock.getShardId(), path)__                    assert Files.isDirectory(path) : path + " is not a directory"__                    NodeEnvironment.acquireFSLockForPaths(indexSettings, paths)__                    IOUtils.rm(path)__                }_            }_        }_    };this,method,tries,to,delete,left,over,shards,where,the,index,name,has,been,reused,but,the,uuid,is,different,to,allow,the,new,shard,to,be,allocated;public,static,void,delete,leftover,shard,directory,logger,logger,node,environment,env,shard,lock,lock,index,settings,index,settings,throws,ioexception,final,string,index,uuid,index,settings,get,uuid,final,path,paths,env,available,shard,paths,lock,get,shard,id,for,path,path,paths,shard,state,meta,data,load,shard,state,meta,data,format,load,latest,state,logger,named,xcontent,registry,empty,path,if,load,null,if,load,index,uuid,equals,index,uuid,false,index,meta,data,equals,load,index,uuid,false,logger,warn,deleting,leftover,shard,on,path,with,a,different,index,uuid,lock,get,shard,id,path,assert,files,is,directory,path,path,is,not,a,directory,node,environment,acquire,fslock,for,paths,index,settings,paths,ioutils,rm,path
ShardPath -> public static ShardPath loadShardPath(Logger logger, NodeEnvironment env, ShardId shardId, IndexSettings indexSettings) throws IOException;1524684173;This method walks through the nodes shard paths to find the data and state path for the given shard. If multiple_directories with a valid shard state exist the one with the highest version will be used._<b>Note:</b> this method resolves custom data locations for the shard.;public static ShardPath loadShardPath(Logger logger, NodeEnvironment env, ShardId shardId, IndexSettings indexSettings) throws IOException {_        final String indexUUID = indexSettings.getUUID()__        final Path[] paths = env.availableShardPaths(shardId)__        Path loadedPath = null__        for (Path path : paths) {_            _            ShardStateMetaData load = ShardStateMetaData.FORMAT.loadLatestState(logger, NamedXContentRegistry.EMPTY, path)__            if (load != null) {_                if (load.indexUUID.equals(indexUUID) == false && IndexMetaData.INDEX_UUID_NA_VALUE.equals(load.indexUUID) == false) {_                    logger.warn("{} found shard on path: [{}] with a different index UUID - this shard seems to be leftover from a different index with the same name. Remove the leftover shard in order to reuse the path with the current index", shardId, path)__                    throw new IllegalStateException(shardId + " index UUID in shard state was: " + load.indexUUID + " expected: " + indexUUID + " on shard path: " + path)__                }_                if (loadedPath == null) {_                    loadedPath = path__                } else{_                    throw new IllegalStateException(shardId + " more than one shard state found")__                }_            }__        }_        if (loadedPath == null) {_            return null__        } else {_            final Path dataPath__            final Path statePath = loadedPath__            if (indexSettings.hasCustomDataPath()) {_                dataPath = env.resolveCustomLocation(indexSettings, shardId)__            } else {_                dataPath = statePath__            }_            logger.debug("{} loaded data path [{}], state path [{}]", shardId, dataPath, statePath)__            return new ShardPath(indexSettings.hasCustomDataPath(), dataPath, statePath, shardId)__        }_    };this,method,walks,through,the,nodes,shard,paths,to,find,the,data,and,state,path,for,the,given,shard,if,multiple,directories,with,a,valid,shard,state,exist,the,one,with,the,highest,version,will,be,used,b,note,b,this,method,resolves,custom,data,locations,for,the,shard;public,static,shard,path,load,shard,path,logger,logger,node,environment,env,shard,id,shard,id,index,settings,index,settings,throws,ioexception,final,string,index,uuid,index,settings,get,uuid,final,path,paths,env,available,shard,paths,shard,id,path,loaded,path,null,for,path,path,paths,shard,state,meta,data,load,shard,state,meta,data,format,load,latest,state,logger,named,xcontent,registry,empty,path,if,load,null,if,load,index,uuid,equals,index,uuid,false,index,meta,data,equals,load,index,uuid,false,logger,warn,found,shard,on,path,with,a,different,index,uuid,this,shard,seems,to,be,leftover,from,a,different,index,with,the,same,name,remove,the,leftover,shard,in,order,to,reuse,the,path,with,the,current,index,shard,id,path,throw,new,illegal,state,exception,shard,id,index,uuid,in,shard,state,was,load,index,uuid,expected,index,uuid,on,shard,path,path,if,loaded,path,null,loaded,path,path,else,throw,new,illegal,state,exception,shard,id,more,than,one,shard,state,found,if,loaded,path,null,return,null,else,final,path,data,path,final,path,state,path,loaded,path,if,index,settings,has,custom,data,path,data,path,env,resolve,custom,location,index,settings,shard,id,else,data,path,state,path,logger,debug,loaded,data,path,state,path,shard,id,data,path,state,path,return,new,shard,path,index,settings,has,custom,data,path,data,path,state,path,shard,id
ShardPath -> public static ShardPath loadShardPath(Logger logger, NodeEnvironment env, ShardId shardId, IndexSettings indexSettings) throws IOException;1537371806;This method walks through the nodes shard paths to find the data and state path for the given shard. If multiple_directories with a valid shard state exist the one with the highest version will be used._<b>Note:</b> this method resolves custom data locations for the shard.;public static ShardPath loadShardPath(Logger logger, NodeEnvironment env, ShardId shardId, IndexSettings indexSettings) throws IOException {_        final Path[] paths = env.availableShardPaths(shardId)__        final int nodeLockId = env.getNodeLockId()__        final Path sharedDataPath = env.sharedDataPath()__        return loadShardPath(logger, shardId, indexSettings, paths, nodeLockId, sharedDataPath)__    };this,method,walks,through,the,nodes,shard,paths,to,find,the,data,and,state,path,for,the,given,shard,if,multiple,directories,with,a,valid,shard,state,exist,the,one,with,the,highest,version,will,be,used,b,note,b,this,method,resolves,custom,data,locations,for,the,shard;public,static,shard,path,load,shard,path,logger,logger,node,environment,env,shard,id,shard,id,index,settings,index,settings,throws,ioexception,final,path,paths,env,available,shard,paths,shard,id,final,int,node,lock,id,env,get,node,lock,id,final,path,shared,data,path,env,shared,data,path,return,load,shard,path,logger,shard,id,index,settings,paths,node,lock,id,shared,data,path
ShardPath -> public Path getRootStatePath();1524684173;Returns the state-path root for this shard. The root is a parent of {@link #getRootStatePath()} ()} without the index name_and the shard ID.;public Path getRootStatePath() {_        return getShardStatePath().getParent().getParent().getParent()_ _    };returns,the,state,path,root,for,this,shard,the,root,is,a,parent,of,link,get,root,state,path,without,the,index,name,and,the,shard,id;public,path,get,root,state,path,return,get,shard,state,path,get,parent,get,parent,get,parent
ShardPath -> public Path getRootStatePath();1537371806;Returns the state-path root for this shard. The root is a parent of {@link #getRootStatePath()} ()} without the index name_and the shard ID.;public Path getRootStatePath() {_        return getShardStatePath().getParent().getParent().getParent()_ _    };returns,the,state,path,root,for,this,shard,the,root,is,a,parent,of,link,get,root,state,path,without,the,index,name,and,the,shard,id;public,path,get,root,state,path,return,get,shard,state,path,get,parent,get,parent,get,parent
ShardPath -> public Path getRootStatePath();1542697754;Returns the state-path root for this shard. The root is a parent of {@link #getRootStatePath()} ()} without the index name_and the shard ID.;public Path getRootStatePath() {_        return getShardStatePath().getParent().getParent().getParent()_ _    };returns,the,state,path,root,for,this,shard,the,root,is,a,parent,of,link,get,root,state,path,without,the,index,name,and,the,shard,id;public,path,get,root,state,path,return,get,shard,state,path,get,parent,get,parent,get,parent
ShardPath -> public Path getRootDataPath();1524684173;Returns the data-path root for this shard. The root is a parent of {@link #getDataPath()} without the index name_and the shard ID.;public Path getRootDataPath() {_        Path noIndexShardId = getDataPath().getParent().getParent()__        return isCustomDataPath ? noIndexShardId : noIndexShardId.getParent()_ _    };returns,the,data,path,root,for,this,shard,the,root,is,a,parent,of,link,get,data,path,without,the,index,name,and,the,shard,id;public,path,get,root,data,path,path,no,index,shard,id,get,data,path,get,parent,get,parent,return,is,custom,data,path,no,index,shard,id,no,index,shard,id,get,parent
ShardPath -> public Path getRootDataPath();1537371806;Returns the data-path root for this shard. The root is a parent of {@link #getDataPath()} without the index name_and the shard ID.;public Path getRootDataPath() {_        Path noIndexShardId = getDataPath().getParent().getParent()__        return isCustomDataPath ? noIndexShardId : noIndexShardId.getParent()_ _    };returns,the,data,path,root,for,this,shard,the,root,is,a,parent,of,link,get,data,path,without,the,index,name,and,the,shard,id;public,path,get,root,data,path,path,no,index,shard,id,get,data,path,get,parent,get,parent,return,is,custom,data,path,no,index,shard,id,no,index,shard,id,get,parent
ShardPath -> public Path getRootDataPath();1542697754;Returns the data-path root for this shard. The root is a parent of {@link #getDataPath()} without the index name_and the shard ID.;public Path getRootDataPath() {_        Path noIndexShardId = getDataPath().getParent().getParent()__        return isCustomDataPath ? noIndexShardId : noIndexShardId.getParent()_ _    };returns,the,data,path,root,for,this,shard,the,root,is,a,parent,of,link,get,data,path,without,the,index,name,and,the,shard,id;public,path,get,root,data,path,path,no,index,shard,id,get,data,path,get,parent,get,parent,return,is,custom,data,path,no,index,shard,id,no,index,shard,id,get,parent
ShardPath -> public boolean isCustomDataPath();1524684173;Returns <code>true</code> iff the data location is a custom data location and therefore outside of the nodes configured data paths.;public boolean isCustomDataPath() {_        return isCustomDataPath__    };returns,code,true,code,iff,the,data,location,is,a,custom,data,location,and,therefore,outside,of,the,nodes,configured,data,paths;public,boolean,is,custom,data,path,return,is,custom,data,path
ShardPath -> public boolean isCustomDataPath();1537371806;Returns <code>true</code> iff the data location is a custom data location and therefore outside of the nodes configured data paths.;public boolean isCustomDataPath() {_        return isCustomDataPath__    };returns,code,true,code,iff,the,data,location,is,a,custom,data,location,and,therefore,outside,of,the,nodes,configured,data,paths;public,boolean,is,custom,data,path,return,is,custom,data,path
ShardPath -> public boolean isCustomDataPath();1542697754;Returns <code>true</code> iff the data location is a custom data location and therefore outside of the nodes configured data paths.;public boolean isCustomDataPath() {_        return isCustomDataPath__    };returns,code,true,code,iff,the,data,location,is,a,custom,data,location,and,therefore,outside,of,the,nodes,configured,data,paths;public,boolean,is,custom,data,path,return,is,custom,data,path
