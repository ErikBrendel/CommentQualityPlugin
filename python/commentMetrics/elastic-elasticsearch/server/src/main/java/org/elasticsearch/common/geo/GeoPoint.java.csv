commented;modifiers;parameterAmount;loc;comment;code
false;public;2;5;;public GeoPoint reset(double lat, double lon) {     this.lat = lat.     this.lon = lon.     return this. }
false;public;1;4;;public GeoPoint resetLat(double lat) {     this.lat = lat.     return this. }
false;public;1;4;;public GeoPoint resetLon(double lon) {     this.lon = lon.     return this. }
false;public;1;3;;public GeoPoint resetFromString(String value) {     return resetFromString(value, false). }
false;public;2;6;;public GeoPoint resetFromString(String value, final boolean ignoreZValue) {     if (value.contains(",")) {         return resetFromCoordinates(value, ignoreZValue).     }     return resetFromGeoHash(value). }
false;public;2;23;;public GeoPoint resetFromCoordinates(String value, final boolean ignoreZValue) {     String[] vals = value.split(",").     if (vals.length > 3) {         throw new ElasticsearchParseException("failed to parse [{}], expected 2 or 3 coordinates " + "but found: [{}]", vals.length).     }     final double lat.     final double lon.     try {         lat = Double.parseDouble(vals[0].trim()).     } catch (NumberFormatException ex) {         throw new ElasticsearchParseException("latitude must be a number").     }     try {         lon = Double.parseDouble(vals[1].trim()).     } catch (NumberFormatException ex) {         throw new ElasticsearchParseException("longitude must be a number").     }     if (vals.length > 2) {         GeoPoint.assertZValue(ignoreZValue, Double.parseDouble(vals[2].trim())).     }     return reset(lat, lon). }
false;public;1;5;;public GeoPoint resetFromIndexHash(long hash) {     lon = GeoHashUtils.decodeLongitude(hash).     lat = GeoHashUtils.decodeLatitude(hash).     return this. }
true;public;1;15;// todo remove with next release of lucene ;// todo this is a crutch because LatLonPoint doesn't have a helper for returning .stringValue() // todo remove with next release of lucene public GeoPoint resetFromIndexableField(IndexableField field) {     if (field instanceof LatLonPoint) {         BytesRef br = field.binaryValue().         byte[] bytes = Arrays.copyOfRange(br.bytes, br.offset, br.length).         return this.reset(GeoEncodingUtils.decodeLatitude(bytes, 0), GeoEncodingUtils.decodeLongitude(bytes, Integer.BYTES)).     } else if (field instanceof LatLonDocValuesField) {         long encoded = (long) (field.numericValue()).         return this.reset(GeoEncodingUtils.decodeLatitude((int) (encoded >>> 32)), GeoEncodingUtils.decodeLongitude((int) encoded)).     }     return resetFromIndexHash(Long.parseLong(field.stringValue())). }
false;public;1;9;;public GeoPoint resetFromGeoHash(String geohash) {     final long hash.     try {         hash = mortonEncode(geohash).     } catch (IllegalArgumentException ex) {         throw new ElasticsearchParseException(ex.getMessage(), ex).     }     return this.reset(GeoHashUtils.decodeLatitude(hash), GeoHashUtils.decodeLongitude(hash)). }
false;public;1;4;;public GeoPoint resetFromGeoHash(long geohashLong) {     final int level = (int) (12 - (geohashLong & 15)).     return this.resetFromIndexHash(BitUtil.flipFlop((geohashLong >>> 4) << ((level * 5) + 2))). }
false;public;0;3;;public double lat() {     return this.lat. }
false;public;0;3;;public double getLat() {     return this.lat. }
false;public;0;3;;public double lon() {     return this.lon. }
false;public;0;3;;public double getLon() {     return this.lon. }
false;public;0;3;;public String geohash() {     return stringEncode(lon, lat). }
false;public;0;3;;public String getGeohash() {     return stringEncode(lon, lat). }
false;public;1;12;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     GeoPoint geoPoint = (GeoPoint) o.     if (Double.compare(geoPoint.lat, lat) != 0)         return false.     if (Double.compare(geoPoint.lon, lon) != 0)         return false.     return true. }
false;public;0;10;;@Override public int hashCode() {     int result.     long temp.     temp = lat != +0.0d ? Double.doubleToLongBits(lat) : 0L.     result = Long.hashCode(temp).     temp = lon != +0.0d ? Double.doubleToLongBits(lon) : 0L.     result = 31 * result + Long.hashCode(temp).     return result. }
false;public;0;4;;@Override public String toString() {     return lat + ", " + lon. }
false;public,static;1;4;;public static GeoPoint parseFromLatLon(String latLon) {     GeoPoint point = new GeoPoint(latLon).     return point. }
false;public,static;1;3;;public static GeoPoint fromGeohash(String geohash) {     return new GeoPoint().resetFromGeoHash(geohash). }
false;public,static;1;3;;public static GeoPoint fromGeohash(long geohashLong) {     return new GeoPoint().resetFromGeoHash(geohashLong). }
false;public;2;4;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     return builder.latlon(lat, lon). }
false;public,static;2;7;;public static double assertZValue(final boolean ignoreZValue, double zValue) {     if (ignoreZValue == false) {         throw new ElasticsearchParseException("Exception parsing coordinates: found Z value [{}] but [{}] " + "parameter is [{}]", zValue, IGNORE_Z_VALUE, ignoreZValue).     }     return zValue. }
