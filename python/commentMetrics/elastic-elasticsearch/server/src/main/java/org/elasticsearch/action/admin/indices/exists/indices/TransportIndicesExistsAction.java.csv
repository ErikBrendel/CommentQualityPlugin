commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected String executor() {     // lightweight in memory check     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected IndicesExistsResponse newResponse() {     return new IndicesExistsResponse(). }
false;protected;2;8;;@Override protected ClusterBlockException checkBlock(IndicesExistsRequest request, ClusterState state) {     // make sure through indices options that the concrete indices call never throws IndexMissingException     IndicesOptions indicesOptions = IndicesOptions.fromOptions(true, true, request.indicesOptions().expandWildcardsOpen(), request.indicesOptions().expandWildcardsClosed()).     return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_READ, indexNameExpressionResolver.concreteIndexNames(state, indicesOptions, request.indices())). }
false;protected;3;13;;@Override protected void masterOperation(final IndicesExistsRequest request, final ClusterState state, final ActionListener<IndicesExistsResponse> listener) {     boolean exists.     try {         // Similar as the previous behaviour, but now also aliases and wildcards are supported.         indexNameExpressionResolver.concreteIndexNames(state, request).         exists = true.     } catch (IndexNotFoundException e) {         exists = false.     }     listener.onResponse(new IndicesExistsResponse(exists)). }
