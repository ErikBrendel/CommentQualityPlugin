commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public String[] indices() {     return indices. }
false;public;0;3;;public String[] getIndices() {     return indices(). }
false;public;0;3;;public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings() {     return mappings. }
false;public;0;3;;public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> getMappings() {     return mappings(). }
false;public;0;3;;public ImmutableOpenMap<String, List<AliasMetaData>> aliases() {     return aliases. }
false;public;0;3;;public ImmutableOpenMap<String, List<AliasMetaData>> getAliases() {     return aliases(). }
false;public;0;3;;public ImmutableOpenMap<String, Settings> settings() {     return settings. }
true;public;0;3;/**  * If the originating {@link GetIndexRequest} object was configured to include  * defaults, this will contain a mapping of index name to {@link Settings} objects.  * The returned {@link Settings} objects will contain only those settings taking  * effect as defaults.  Any settings explicitly set on the index will be available  * via {@link #settings()}.  * See also {@link GetIndexRequest#includeDefaults(boolean)}  */ ;/**  * If the originating {@link GetIndexRequest} object was configured to include  * defaults, this will contain a mapping of index name to {@link Settings} objects.  * The returned {@link Settings} objects will contain only those settings taking  * effect as defaults.  Any settings explicitly set on the index will be available  * via {@link #settings()}.  * See also {@link GetIndexRequest#includeDefaults(boolean)}  */ public ImmutableOpenMap<String, Settings> defaultSettings() {     return defaultSettings. }
false;public;0;3;;public ImmutableOpenMap<String, Settings> getSettings() {     return settings(). }
true;public;2;17;/**  * Returns the string value for the specified index and setting.  If the includeDefaults flag was not set or set to  * false on the {@link GetIndexRequest}, this method will only return a value where the setting was explicitly set  * on the index.  If the includeDefaults flag was set to true on the {@link GetIndexRequest}, this method will fall  * back to return the default value if the setting was not explicitly set.  */ ;/**  * Returns the string value for the specified index and setting.  If the includeDefaults flag was not set or set to  * false on the {@link GetIndexRequest}, this method will only return a value where the setting was explicitly set  * on the index.  If the includeDefaults flag was set to true on the {@link GetIndexRequest}, this method will fall  * back to return the default value if the setting was not explicitly set.  */ public String getSetting(String index, String setting) {     Settings indexSettings = settings.get(index).     if (setting != null) {         if (indexSettings != null && indexSettings.hasValue(setting)) {             return indexSettings.get(setting).         } else {             Settings defaultIndexSettings = defaultSettings.get(index).             if (defaultIndexSettings != null) {                 return defaultIndexSettings.get(setting).             } else {                 return null.             }         }     } else {         return null.     } }
false;public;1;48;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     this.indices = in.readStringArray().     int mappingsSize = in.readVInt().     ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> mappingsMapBuilder = ImmutableOpenMap.builder().     for (int i = 0. i < mappingsSize. i++) {         String key = in.readString().         int valueSize = in.readVInt().         ImmutableOpenMap.Builder<String, MappingMetaData> mappingEntryBuilder = ImmutableOpenMap.builder().         for (int j = 0. j < valueSize. j++) {             mappingEntryBuilder.put(in.readString(), new MappingMetaData(in)).         }         mappingsMapBuilder.put(key, mappingEntryBuilder.build()).     }     mappings = mappingsMapBuilder.build().     int aliasesSize = in.readVInt().     ImmutableOpenMap.Builder<String, List<AliasMetaData>> aliasesMapBuilder = ImmutableOpenMap.builder().     for (int i = 0. i < aliasesSize. i++) {         String key = in.readString().         int valueSize = in.readVInt().         List<AliasMetaData> aliasEntryBuilder = new ArrayList<>(valueSize).         for (int j = 0. j < valueSize. j++) {             aliasEntryBuilder.add(new AliasMetaData(in)).         }         aliasesMapBuilder.put(key, Collections.unmodifiableList(aliasEntryBuilder)).     }     aliases = aliasesMapBuilder.build().     int settingsSize = in.readVInt().     ImmutableOpenMap.Builder<String, Settings> settingsMapBuilder = ImmutableOpenMap.builder().     for (int i = 0. i < settingsSize. i++) {         String key = in.readString().         settingsMapBuilder.put(key, Settings.readSettingsFromStream(in)).     }     settings = settingsMapBuilder.build().     ImmutableOpenMap.Builder<String, Settings> defaultSettingsMapBuilder = ImmutableOpenMap.builder().     if (in.getVersion().onOrAfter(Version.V_6_4_0)) {         int defaultSettingsSize = in.readVInt().         for (int i = 0. i < defaultSettingsSize. i++) {             defaultSettingsMapBuilder.put(in.readString(), Settings.readSettingsFromStream(in)).         }     }     defaultSettings = defaultSettingsMapBuilder.build(). }
false;public;1;34;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeStringArray(indices).     out.writeVInt(mappings.size()).     for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexEntry : mappings) {         out.writeString(indexEntry.key).         out.writeVInt(indexEntry.value.size()).         for (ObjectObjectCursor<String, MappingMetaData> mappingEntry : indexEntry.value) {             out.writeString(mappingEntry.key).             mappingEntry.value.writeTo(out).         }     }     out.writeVInt(aliases.size()).     for (ObjectObjectCursor<String, List<AliasMetaData>> indexEntry : aliases) {         out.writeString(indexEntry.key).         out.writeVInt(indexEntry.value.size()).         for (AliasMetaData aliasEntry : indexEntry.value) {             aliasEntry.writeTo(out).         }     }     out.writeVInt(settings.size()).     for (ObjectObjectCursor<String, Settings> indexEntry : settings) {         out.writeString(indexEntry.key).         Settings.writeSettingsToStream(indexEntry.value, out).     }     if (out.getVersion().onOrAfter(Version.V_6_4_0)) {         out.writeVInt(defaultSettings.size()).         for (ObjectObjectCursor<String, Settings> indexEntry : defaultSettings) {             out.writeString(indexEntry.key).             Settings.writeSettingsToStream(indexEntry.value, out).         }     } }
false;public;2;64;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     {         for (final String index : indices) {             builder.startObject(index).             {                 builder.startObject("aliases").                 List<AliasMetaData> indexAliases = aliases.get(index).                 if (indexAliases != null) {                     for (final AliasMetaData alias : indexAliases) {                         AliasMetaData.Builder.toXContent(alias, builder, params).                     }                 }                 builder.endObject().                 ImmutableOpenMap<String, MappingMetaData> indexMappings = mappings.get(index).                 boolean includeTypeName = params.paramAsBoolean(INCLUDE_TYPE_NAME_PARAMETER, DEFAULT_INCLUDE_TYPE_NAME_POLICY).                 if (includeTypeName) {                     builder.startObject("mappings").                     if (indexMappings != null) {                         for (final ObjectObjectCursor<String, MappingMetaData> typeEntry : indexMappings) {                             builder.field(typeEntry.key).                             builder.map(typeEntry.value.sourceAsMap()).                         }                     }                     builder.endObject().                 } else {                     MappingMetaData mappings = null.                     for (final ObjectObjectCursor<String, MappingMetaData> typeEntry : indexMappings) {                         if (typeEntry.key.equals(MapperService.DEFAULT_MAPPING) == false) {                             assert mappings == null.                             mappings = typeEntry.value.                         }                     }                     if (mappings == null) {                         // no mappings yet                         builder.startObject("mappings").endObject().                     } else {                         builder.field("mappings", mappings.sourceAsMap()).                     }                 }                 builder.startObject("settings").                 Settings indexSettings = settings.get(index).                 if (indexSettings != null) {                     indexSettings.toXContent(builder, params).                 }                 builder.endObject().                 Settings defaultIndexSettings = defaultSettings.get(index).                 if (defaultIndexSettings != null && defaultIndexSettings.isEmpty() == false) {                     builder.startObject("defaults").                     defaultIndexSettings.toXContent(builder, params).                     builder.endObject().                 }             }             builder.endObject().         }     }     builder.endObject().     return builder. }
false;private,static;1;9;;private static List<AliasMetaData> parseAliases(XContentParser parser) throws IOException {     List<AliasMetaData> indexAliases = new ArrayList<>().     // We start at START_OBJECT since parseIndexEntry ensures that     while (parser.nextToken() != Token.END_OBJECT) {         ensureExpectedToken(Token.FIELD_NAME, parser.currentToken(), parser::getTokenLocation).         indexAliases.add(AliasMetaData.Builder.fromXContent(parser)).     }     return indexAliases. }
false;private,static;1;15;;private static ImmutableOpenMap<String, MappingMetaData> parseMappings(XContentParser parser) throws IOException {     ImmutableOpenMap.Builder<String, MappingMetaData> indexMappings = ImmutableOpenMap.builder().     // We start at START_OBJECT since parseIndexEntry ensures that     while (parser.nextToken() != Token.END_OBJECT) {         ensureExpectedToken(Token.FIELD_NAME, parser.currentToken(), parser::getTokenLocation).         parser.nextToken().         if (parser.currentToken() == Token.START_OBJECT) {             String mappingType = parser.currentName().             indexMappings.put(mappingType, new MappingMetaData(mappingType, parser.map())).         } else if (parser.currentToken() == Token.START_ARRAY) {             parser.skipChildren().         }     }     return indexMappings.build(). }
false;private,static;1;32;;private static IndexEntry parseIndexEntry(XContentParser parser) throws IOException {     List<AliasMetaData> indexAliases = null.     ImmutableOpenMap<String, MappingMetaData> indexMappings = null.     Settings indexSettings = null.     Settings indexDefaultSettings = null.     // We start at START_OBJECT since fromXContent ensures that     while (parser.nextToken() != Token.END_OBJECT) {         ensureExpectedToken(Token.FIELD_NAME, parser.currentToken(), parser::getTokenLocation).         parser.nextToken().         if (parser.currentToken() == Token.START_OBJECT) {             switch(parser.currentName()) {                 case "aliases":                     indexAliases = parseAliases(parser).                     break.                 case "mappings":                     indexMappings = parseMappings(parser).                     break.                 case "settings":                     indexSettings = Settings.fromXContent(parser).                     break.                 case "defaults":                     indexDefaultSettings = Settings.fromXContent(parser).                     break.                 default:                     parser.skipChildren().             }         } else if (parser.currentToken() == Token.START_ARRAY) {             parser.skipChildren().         }     }     return new IndexEntry(indexAliases, indexMappings, indexSettings, indexDefaultSettings). }
false;public,static;1;39;;public static GetIndexResponse fromXContent(XContentParser parser) throws IOException {     ImmutableOpenMap.Builder<String, List<AliasMetaData>> aliases = ImmutableOpenMap.builder().     ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> mappings = ImmutableOpenMap.builder().     ImmutableOpenMap.Builder<String, Settings> settings = ImmutableOpenMap.builder().     ImmutableOpenMap.Builder<String, Settings> defaultSettings = ImmutableOpenMap.builder().     List<String> indices = new ArrayList<>().     if (parser.currentToken() == null) {         parser.nextToken().     }     ensureExpectedToken(Token.START_OBJECT, parser.currentToken(), parser::getTokenLocation).     parser.nextToken().     while (!parser.isClosed()) {         if (parser.currentToken() == Token.START_OBJECT) {             // we assume this is an index entry             String indexName = parser.currentName().             indices.add(indexName).             IndexEntry indexEntry = parseIndexEntry(parser).             // make the order deterministic             CollectionUtil.timSort(indexEntry.indexAliases, Comparator.comparing(AliasMetaData::alias)).             aliases.put(indexName, Collections.unmodifiableList(indexEntry.indexAliases)).             mappings.put(indexName, indexEntry.indexMappings).             settings.put(indexName, indexEntry.indexSettings).             if (indexEntry.indexDefaultSettings.isEmpty() == false) {                 defaultSettings.put(indexName, indexEntry.indexDefaultSettings).             }         } else if (parser.currentToken() == Token.START_ARRAY) {             parser.skipChildren().         } else {             parser.nextToken().         }     }     return new GetIndexResponse(indices.toArray(new String[0]), mappings.build(), aliases.build(), settings.build(), defaultSettings.build()). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     GetIndexResponse that = (GetIndexResponse) o.     return Arrays.equals(indices, that.indices) && Objects.equals(aliases, that.aliases) && Objects.equals(mappings, that.mappings) && Objects.equals(settings, that.settings) && Objects.equals(defaultSettings, that.defaultSettings). }
false;public;0;11;;@Override public int hashCode() {     return Objects.hash(Arrays.hashCode(indices), aliases, mappings, settings, defaultSettings). }
