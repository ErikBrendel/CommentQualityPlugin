commented;modifiers;parameterAmount;loc;comment;code
true;static;2;24;/**  * Sorts an address by preference. This way code like publishing can just pick the first one  */ ;/**  * Sorts an address by preference. This way code like publishing can just pick the first one  */ static int sortKey(InetAddress address, boolean prefer_v6) {     int key = address.getAddress().length.     if (prefer_v6) {         key = -key.     }     if (address.isAnyLocalAddress()) {         key += 5.     }     if (address.isMulticastAddress()) {         key += 4.     }     if (address.isLoopbackAddress()) {         key += 3.     }     if (address.isLinkLocalAddress()) {         key += 2.     }     if (address.isSiteLocalAddress()) {         key += 1.     }     return key. }
false;public;2;8;;@Override public int compare(InetAddress left, InetAddress right) {     int cmp = Integer.compare(sortKey(left, PREFER_V6), sortKey(right, PREFER_V6)).     if (cmp == 0) {         cmp = new BytesRef(left.getAddress()).compareTo(new BytesRef(right.getAddress())).     }     return cmp. }
true;public,static;1;14;/**  * Sorts addresses by order of preference. This is used to pick the first one for publishing  * @deprecated remove this when multihoming is really correct  */ ;/**  * Sorts addresses by order of preference. This is used to pick the first one for publishing  * @deprecated remove this when multihoming is really correct  */ @Deprecated public static // only public because of silly multicast void sortAddresses(List<InetAddress> list) {     Collections.sort(list, new Comparator<InetAddress>() {          @Override         public int compare(InetAddress left, InetAddress right) {             int cmp = Integer.compare(sortKey(left, PREFER_V6), sortKey(right, PREFER_V6)).             if (cmp == 0) {                 cmp = new BytesRef(left.getAddress()).compareTo(new BytesRef(right.getAddress())).             }             return cmp.         }     }). }
false;public;2;4;;@Override public int compare(NetworkInterface left, NetworkInterface right) {     return Integer.compare(left.getIndex(), right.getIndex()). }
true;static;0;11;/**  * Return all interfaces (and subinterfaces) on the system  */ ;/**  * Return all interfaces (and subinterfaces) on the system  */ static List<NetworkInterface> getInterfaces() throws SocketException {     List<NetworkInterface> all = new ArrayList<>().     addAllInterfaces(all, Collections.list(NetworkInterface.getNetworkInterfaces())).     Collections.sort(all, new Comparator<NetworkInterface>() {          @Override         public int compare(NetworkInterface left, NetworkInterface right) {             return Integer.compare(left.getIndex(), right.getIndex()).         }     }).     return all. }
true;private,static;2;8;/**  * Helper for getInterfaces, recursively adds subinterfaces to {@code target}  */ ;/**  * Helper for getInterfaces, recursively adds subinterfaces to {@code target}  */ private static void addAllInterfaces(List<NetworkInterface> target, List<NetworkInterface> level) {     if (!level.isEmpty()) {         target.addAll(level).         for (NetworkInterface intf : level) {             addAllInterfaces(target, Collections.list(intf.getSubInterfaces())).         }     } }
true;public,static;0;3;/**  * Returns system default for SO_REUSEADDR  */ ;/**  * Returns system default for SO_REUSEADDR  */ public static boolean defaultReuseAddress() {     return Constants.WINDOWS ? false : true. }
true;static;0;16;/**  * Returns all interface-local scope (loopback) addresses for interfaces that are up.  */ ;/**  * Returns all interface-local scope (loopback) addresses for interfaces that are up.  */ static InetAddress[] getLoopbackAddresses() throws SocketException {     List<InetAddress> list = new ArrayList<>().     for (NetworkInterface intf : getInterfaces()) {         if (intf.isUp()) {             for (InetAddress address : Collections.list(intf.getInetAddresses())) {                 if (address.isLoopbackAddress()) {                     list.add(address).                 }             }         }     }     if (list.isEmpty()) {         throw new IllegalArgumentException("No up-and-running loopback addresses found, got " + getInterfaces()).     }     return list.toArray(new InetAddress[list.size()]). }
true;static;0;16;/**  * Returns all site-local scope (private) addresses for interfaces that are up.  */ ;/**  * Returns all site-local scope (private) addresses for interfaces that are up.  */ static InetAddress[] getSiteLocalAddresses() throws SocketException {     List<InetAddress> list = new ArrayList<>().     for (NetworkInterface intf : getInterfaces()) {         if (intf.isUp()) {             for (InetAddress address : Collections.list(intf.getInetAddresses())) {                 if (address.isSiteLocalAddress()) {                     list.add(address).                 }             }         }     }     if (list.isEmpty()) {         throw new IllegalArgumentException("No up-and-running site-local (private) addresses found, got " + getInterfaces()).     }     return list.toArray(new InetAddress[list.size()]). }
true;static;0;18;/**  * Returns all global scope addresses for interfaces that are up.  */ ;/**  * Returns all global scope addresses for interfaces that are up.  */ static InetAddress[] getGlobalAddresses() throws SocketException {     List<InetAddress> list = new ArrayList<>().     for (NetworkInterface intf : getInterfaces()) {         if (intf.isUp()) {             for (InetAddress address : Collections.list(intf.getInetAddresses())) {                 if (address.isLoopbackAddress() == false && address.isSiteLocalAddress() == false && address.isLinkLocalAddress() == false) {                     list.add(address).                 }             }         }     }     if (list.isEmpty()) {         throw new IllegalArgumentException("No up-and-running global-scope (public) addresses found, got " + getInterfaces()).     }     return list.toArray(new InetAddress[list.size()]). }
true;static;0;14;/**  * Returns all addresses (any scope) for interfaces that are up.  *  This is only used to pick a publish address, when the user set network.host to a wildcard  */ ;/**  * Returns all addresses (any scope) for interfaces that are up.  *  This is only used to pick a publish address, when the user set network.host to a wildcard  */ static InetAddress[] getAllAddresses() throws SocketException {     List<InetAddress> list = new ArrayList<>().     for (NetworkInterface intf : getInterfaces()) {         if (intf.isUp()) {             for (InetAddress address : Collections.list(intf.getInetAddresses())) {                 list.add(address).             }         }     }     if (list.isEmpty()) {         throw new IllegalArgumentException("No up-and-running addresses found, got " + getInterfaces()).     }     return list.toArray(new InetAddress[list.size()]). }
true;static;1;15;/**  * Returns addresses for the given interface (it must be marked up)  */ ;/**  * Returns addresses for the given interface (it must be marked up)  */ static InetAddress[] getAddressesForInterface(String name) throws SocketException {     Optional<NetworkInterface> networkInterface = getInterfaces().stream().filter((netIf) -> name.equals(netIf.getName())).findFirst().     if (networkInterface.isPresent() == false) {         throw new IllegalArgumentException("No interface named '" + name + "' found, got " + getInterfaces()).     }     if (!networkInterface.get().isUp()) {         throw new IllegalArgumentException("Interface '" + name + "' is not up and running").     }     List<InetAddress> list = Collections.list(networkInterface.get().getInetAddresses()).     if (list.isEmpty()) {         throw new IllegalArgumentException("Interface '" + name + "' has no internet addresses").     }     return list.toArray(new InetAddress[list.size()]). }
true;static;1;12;/**  * Returns only the IPV4 addresses in {@code addresses}  */ ;/**  * Returns only the IPV4 addresses in {@code addresses}  */ static InetAddress[] filterIPV4(InetAddress[] addresses) {     List<InetAddress> list = new ArrayList<>().     for (InetAddress address : addresses) {         if (address instanceof Inet4Address) {             list.add(address).         }     }     if (list.isEmpty()) {         throw new IllegalArgumentException("No ipv4 addresses found in " + Arrays.toString(addresses)).     }     return list.toArray(new InetAddress[list.size()]). }
true;static;1;12;/**  * Returns only the IPV6 addresses in {@code addresses}  */ ;/**  * Returns only the IPV6 addresses in {@code addresses}  */ static InetAddress[] filterIPV6(InetAddress[] addresses) {     List<InetAddress> list = new ArrayList<>().     for (InetAddress address : addresses) {         if (address instanceof Inet6Address) {             list.add(address).         }     }     if (list.isEmpty()) {         throw new IllegalArgumentException("No ipv6 addresses found in " + Arrays.toString(addresses)).     }     return list.toArray(new InetAddress[list.size()]). }
