commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Override public int hashCode() {     return Objects.hash(classHash(), boostTerms, boostTermsFactor, Arrays.hashCode(likeText), maxDocFreq, maxQueryTerms, maxWordLen, minDocFreq, minTermFrequency, minWordLen, Arrays.hashCode(moreLikeFields), minimumShouldMatch, stopWords). }
false;public;1;42;;@Override public boolean equals(Object obj) {     if (sameClassAs(obj) == false) {         return false.     }     MoreLikeThisQuery other = (MoreLikeThisQuery) obj.     if (!analyzer.equals(other.analyzer))         return false.     if (boostTerms != other.boostTerms)         return false.     if (boostTermsFactor != other.boostTermsFactor)         return false.     if (!(Arrays.equals(likeText, other.likeText)))         return false.     if (maxDocFreq != other.maxDocFreq)         return false.     if (maxQueryTerms != other.maxQueryTerms)         return false.     if (maxWordLen != other.maxWordLen)         return false.     if (minDocFreq != other.minDocFreq)         return false.     if (minTermFrequency != other.minTermFrequency)         return false.     if (minWordLen != other.minWordLen)         return false.     if (!Arrays.equals(moreLikeFields, other.moreLikeFields))         return false.     if (!minimumShouldMatch.equals(other.minimumShouldMatch))         return false.     if (similarity == null) {         if (other.similarity != null)             return false.     } else if (!similarity.equals(other.similarity))         return false.     if (stopWords == null) {         if (other.stopWords != null)             return false.     } else if (!stopWords.equals(other.stopWords))         return false.     return true. }
false;public;1;26;;@Override public Query rewrite(IndexReader reader) throws IOException {     Query rewritten = super.rewrite(reader).     if (rewritten != this) {         return rewritten.     }     XMoreLikeThis mlt = new XMoreLikeThis(reader, similarity == null ? new ClassicSimilarity() : similarity).     mlt.setFieldNames(moreLikeFields).     mlt.setAnalyzer(analyzer).     mlt.setMinTermFreq(minTermFrequency).     mlt.setMinDocFreq(minDocFreq).     mlt.setMaxDocFreq(maxDocFreq).     mlt.setMaxQueryTerms(maxQueryTerms).     mlt.setMinWordLen(minWordLen).     mlt.setMaxWordLen(maxWordLen).     mlt.setStopWords(stopWords).     mlt.setBoost(boostTerms).     mlt.setBoostFactor(boostTermsFactor).     if (this.unlikeText != null || this.unlikeFields != null) {         handleUnlike(mlt, this.unlikeText, this.unlikeFields).     }     return createQuery(mlt). }
false;private;1;19;;private Query createQuery(XMoreLikeThis mlt) throws IOException {     BooleanQuery.Builder bqBuilder = new BooleanQuery.Builder().     if (this.likeFields != null) {         Query mltQuery = mlt.like(this.likeFields).         mltQuery = Queries.applyMinimumShouldMatch((BooleanQuery) mltQuery, minimumShouldMatch).         bqBuilder.add(mltQuery, BooleanClause.Occur.SHOULD).     }     if (this.likeText != null) {         Reader[] readers = new Reader[likeText.length].         for (int i = 0. i < readers.length. i++) {             readers[i] = new StringReader(likeText[i]).         }         // LUCENE 4 UPGRADE this mapps the 3.6 behavior (only use the first field)         Query mltQuery = mlt.like(moreLikeFields[0], readers).         mltQuery = Queries.applyMinimumShouldMatch((BooleanQuery) mltQuery, minimumShouldMatch).         bqBuilder.add(mltQuery, BooleanClause.Occur.SHOULD).     }     return bqBuilder.build(). }
false;private;3;34;;private void handleUnlike(XMoreLikeThis mlt, String[] unlikeText, Fields[] unlikeFields) throws IOException {     Set<Term> skipTerms = new HashSet<>().     // handle like text     if (unlikeText != null) {         for (String text : unlikeText) {             // only use the first field to be consistent             String fieldName = moreLikeFields[0].             try (TokenStream ts = analyzer.tokenStream(fieldName, text)) {                 CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class).                 ts.reset().                 while (ts.incrementToken()) {                     skipTerms.add(new Term(fieldName, termAtt.toString())).                 }                 ts.end().             }         }     }     // handle like fields     if (unlikeFields != null) {         for (Fields fields : unlikeFields) {             for (String fieldName : fields) {                 Terms terms = fields.terms(fieldName).                 final TermsEnum termsEnum = terms.iterator().                 BytesRef text.                 while ((text = termsEnum.next()) != null) {                     skipTerms.add(new Term(fieldName, text.utf8ToString())).                 }             }         }     }     if (!skipTerms.isEmpty()) {         mlt.setSkipTerms(skipTerms).     } }
false;public;1;4;;@Override public String toString(String field) {     return "like:" + Arrays.toString(likeText). }
false;public;0;3;;public String getLikeText() {     return (likeText == null ? null : likeText[0]). }
false;public;0;3;;public String[] getLikeTexts() {     return likeText. }
false;public;1;3;;public void setLikeText(String... likeText) {     this.likeText = likeText. }
false;public;0;3;;public Fields[] getLikeFields() {     return likeFields. }
false;public;1;3;;public void setLikeFields(Fields... likeFields) {     this.likeFields = likeFields. }
false;public;1;3;;public void setLikeText(List<String> likeText) {     setLikeText(likeText.toArray(Strings.EMPTY_ARRAY)). }
false;public;1;3;;public void setUnlikeFields(Fields... unlikeFields) {     this.unlikeFields = unlikeFields. }
false;public;1;3;;public void setUnlikeText(String[] unlikeText) {     this.unlikeText = unlikeText. }
false;public;0;3;;public String[] getMoreLikeFields() {     return moreLikeFields. }
false;public;1;3;;public void setMoreLikeFields(String[] moreLikeFields) {     this.moreLikeFields = moreLikeFields. }
false;public;0;3;;public Similarity getSimilarity() {     return similarity. }
false;public;1;6;;public void setSimilarity(Similarity similarity) {     if (similarity == null || similarity instanceof TFIDFSimilarity) {         // LUCENE 4 UPGRADE we need TFIDF similarity here so I only set it if it is an instance of it         this.similarity = (TFIDFSimilarity) similarity.     } }
false;public;0;3;;public Analyzer getAnalyzer() {     return analyzer. }
false;public;1;3;;public void setAnalyzer(Analyzer analyzer) {     this.analyzer = analyzer. }
true;public;0;3;/**  * Number of terms that must match the generated query expressed in the  * common syntax for minimum should match.  *  * @see    org.elasticsearch.common.lucene.search.Queries#calculateMinShouldMatch(int, String)  */ ;/**  * Number of terms that must match the generated query expressed in the  * common syntax for minimum should match.  *  * @see    org.elasticsearch.common.lucene.search.Queries#calculateMinShouldMatch(int, String)  */ public String getMinimumShouldMatch() {     return minimumShouldMatch. }
true;public;1;3;/**  * Number of terms that must match the generated query expressed in the  * common syntax for minimum should match. Defaults to {@code 30%}.  *  * @see    org.elasticsearch.common.lucene.search.Queries#calculateMinShouldMatch(int, String)  */ ;/**  * Number of terms that must match the generated query expressed in the  * common syntax for minimum should match. Defaults to {@code 30%}.  *  * @see    org.elasticsearch.common.lucene.search.Queries#calculateMinShouldMatch(int, String)  */ public void setMinimumShouldMatch(String minimumShouldMatch) {     this.minimumShouldMatch = minimumShouldMatch. }
false;public;0;3;;public int getMinTermFrequency() {     return minTermFrequency. }
false;public;1;3;;public void setMinTermFrequency(int minTermFrequency) {     this.minTermFrequency = minTermFrequency. }
false;public;0;3;;public int getMaxQueryTerms() {     return maxQueryTerms. }
false;public;1;3;;public void setMaxQueryTerms(int maxQueryTerms) {     this.maxQueryTerms = maxQueryTerms. }
false;public;0;3;;public Set<?> getStopWords() {     return stopWords. }
false;public;1;3;;public void setStopWords(Set<?> stopWords) {     this.stopWords = stopWords. }
false;public;0;3;;public int getMinDocFreq() {     return minDocFreq. }
false;public;1;3;;public void setMinDocFreq(int minDocFreq) {     this.minDocFreq = minDocFreq. }
false;public;0;3;;public int getMaxDocFreq() {     return maxDocFreq. }
false;public;1;3;;public void setMaxDocFreq(int maxDocFreq) {     this.maxDocFreq = maxDocFreq. }
false;public;0;3;;public int getMinWordLen() {     return minWordLen. }
false;public;1;3;;public void setMinWordLen(int minWordLen) {     this.minWordLen = minWordLen. }
false;public;0;3;;public int getMaxWordLen() {     return maxWordLen. }
false;public;1;3;;public void setMaxWordLen(int maxWordLen) {     this.maxWordLen = maxWordLen. }
false;public;0;3;;public boolean isBoostTerms() {     return boostTerms. }
false;public;1;3;;public void setBoostTerms(boolean boostTerms) {     this.boostTerms = boostTerms. }
false;public;0;3;;public float getBoostTermsFactor() {     return boostTermsFactor. }
false;public;1;3;;public void setBoostTermsFactor(float boostTermsFactor) {     this.boostTermsFactor = boostTermsFactor. }
