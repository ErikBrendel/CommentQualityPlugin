commented;modifiers;parameterAmount;loc;comment;code
true;public;1;23;/**  * Allocate unassigned shards to nodes (if any) where valid copies of the shard already exist.  * It is up to the individual implementations of {@link #makeAllocationDecision(ShardRouting, RoutingAllocation, Logger)}  * to make decisions on assigning shards to nodes.  *  * @param allocation the allocation state container object  */ ;/**  * Allocate unassigned shards to nodes (if any) where valid copies of the shard already exist.  * It is up to the individual implementations of {@link #makeAllocationDecision(ShardRouting, RoutingAllocation, Logger)}  * to make decisions on assigning shards to nodes.  *  * @param allocation the allocation state container object  */ public void allocateUnassigned(RoutingAllocation allocation) {     final RoutingNodes routingNodes = allocation.routingNodes().     final RoutingNodes.UnassignedShards.UnassignedIterator unassignedIterator = routingNodes.unassigned().iterator().     while (unassignedIterator.hasNext()) {         final ShardRouting shard = unassignedIterator.next().         final AllocateUnassignedDecision allocateUnassignedDecision = makeAllocationDecision(shard, allocation, logger).         if (allocateUnassignedDecision.isDecisionTaken() == false) {             // no decision was taken by this allocator             continue.         }         if (allocateUnassignedDecision.getAllocationDecision() == AllocationDecision.YES) {             unassignedIterator.initialize(allocateUnassignedDecision.getTargetNode().getId(), allocateUnassignedDecision.getAllocationId(), shard.primary() ? ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE : allocation.clusterInfo().getShardSize(shard, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes()).         } else {             unassignedIterator.removeAndIgnore(allocateUnassignedDecision.getAllocationStatus(), allocation.changes()).         }     } }
true;public,abstract;3;3;/**  * Make a decision on the allocation of an unassigned shard.  This method is used by  * {@link #allocateUnassigned(RoutingAllocation)} to make decisions about whether or not  * the shard can be allocated by this allocator and if so, to which node it will be allocated.  *  * @param unassignedShard  the unassigned shard to allocate  * @param allocation       the current routing state  * @param logger           the logger  * @return an {@link AllocateUnassignedDecision} with the final decision of whether to allocate and details of the decision  */ ;/**  * Make a decision on the allocation of an unassigned shard.  This method is used by  * {@link #allocateUnassigned(RoutingAllocation)} to make decisions about whether or not  * the shard can be allocated by this allocator and if so, to which node it will be allocated.  *  * @param unassignedShard  the unassigned shard to allocate  * @param allocation       the current routing state  * @param logger           the logger  * @return an {@link AllocateUnassignedDecision} with the final decision of whether to allocate and details of the decision  */ public abstract AllocateUnassignedDecision makeAllocationDecision(ShardRouting unassignedShard, RoutingAllocation allocation, Logger logger).
true;protected;2;8;/**  * Builds decisions for all nodes in the cluster, so that the explain API can provide information on  * allocation decisions for each node, while still waiting to allocate the shard (e.g. due to fetching shard data).  */ ;/**  * Builds decisions for all nodes in the cluster, so that the explain API can provide information on  * allocation decisions for each node, while still waiting to allocate the shard (e.g. due to fetching shard data).  */ protected List<NodeAllocationResult> buildDecisionsForAllNodes(ShardRouting shard, RoutingAllocation allocation) {     List<NodeAllocationResult> results = new ArrayList<>().     for (RoutingNode node : allocation.routingNodes()) {         Decision decision = allocation.deciders().canAllocate(shard, node, allocation).         results.add(new NodeAllocationResult(node.node(), null, decision)).     }     return results. }
