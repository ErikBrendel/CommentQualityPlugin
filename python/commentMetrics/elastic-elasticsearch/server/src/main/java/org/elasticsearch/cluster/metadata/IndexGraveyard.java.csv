commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return Version.CURRENT.minimumCompatibilityVersion(). }
false;public;0;4;;@Override public EnumSet<MetaData.XContentContext> context() {     return MetaData.API_AND_GATEWAY. }
false;public;1;4;;@Override public boolean equals(Object obj) {     return (obj instanceof IndexGraveyard) && Objects.equals(tombstones, ((IndexGraveyard) obj).tombstones). }
false;public;0;4;;@Override public int hashCode() {     return tombstones.hashCode(). }
true;public;0;3;/**  * Get the current unmodifiable index tombstone list.  */ ;/**  * Get the current unmodifiable index tombstone list.  */ public List<Tombstone> getTombstones() {     return tombstones. }
true;public;1;8;/**  * Returns true if the graveyard contains a tombstone for the given index.  */ ;/**  * Returns true if the graveyard contains a tombstone for the given index.  */ public boolean containsIndex(final Index index) {     for (Tombstone tombstone : tombstones) {         if (tombstone.getIndex().equals(index)) {             return true.         }     }     return false. }
false;public;2;8;;@Override public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {     builder.startArray(TOMBSTONES_FIELD.getPreferredName()).     for (Tombstone tombstone : tombstones) {         tombstone.toXContent(builder, params).     }     return builder.endArray(). }
false;public,static;1;3;;public static IndexGraveyard fromXContent(final XContentParser parser) throws IOException {     return new IndexGraveyard(GRAVEYARD_PARSER.parse(parser, null)). }
false;public;0;4;;@Override public String toString() {     return "IndexGraveyard[" + tombstones + "]". }
false;public;1;7;;@Override public void writeTo(final StreamOutput out) throws IOException {     out.writeVInt(tombstones.size()).     for (Tombstone tombstone : tombstones) {         tombstone.writeTo(out).     } }
false;public;1;4;;@Override public Diff<MetaData.Custom> diff(final MetaData.Custom previous) {     return new IndexGraveyardDiff((IndexGraveyard) previous, this). }
false;public,static;1;3;;public static NamedDiff<MetaData.Custom> readDiffFrom(final StreamInput in) throws IOException {     return new IndexGraveyardDiff(in). }
false;public,static;0;3;;public static IndexGraveyard.Builder builder() {     return new IndexGraveyard.Builder(). }
false;public,static;1;3;;public static IndexGraveyard.Builder builder(final IndexGraveyard graveyard) {     return new IndexGraveyard.Builder(graveyard). }
true;public;0;3;/**  * A copy of the current tombstones in the builder.  */ ;/**  * A copy of the current tombstones in the builder.  */ public List<Tombstone> tombstones() {     return Collections.unmodifiableList(tombstones). }
true;public;1;4;/**  * Add a deleted index to the list of tombstones in the cluster state.  */ ;/**  * Add a deleted index to the list of tombstones in the cluster state.  */ public Builder addTombstone(final Index index) {     tombstones.add(new Tombstone(index, currentTime)).     return this. }
true;public;1;6;/**  * Add a set of deleted indexes to the list of tombstones in the cluster state.  */ ;/**  * Add a set of deleted indexes to the list of tombstones in the cluster state.  */ public Builder addTombstones(final Collection<Index> indices) {     for (Index index : indices) {         addTombstone(index).     }     return this. }
true;;1;4;/**  * Add a list of tombstones to the graveyard.  */ ;/**  * Add a list of tombstones to the graveyard.  */ Builder addBuiltTombstones(final List<Tombstone> tombstones) {     this.tombstones.addAll(tombstones).     return this. }
true;public;0;4;/**  * Get the number of tombstones that were purged.  This should *only* be called  * after build() has been called.  */ ;/**  * Get the number of tombstones that were purged.  This should *only* be called  * after build() has been called.  */ public int getNumPurged() {     assert numPurged != -1.     return numPurged. }
true;private;1;8;/**  * Purge tombstone entries.  Returns the number of entries that were purged.  *  * Tombstones are purged if the number of tombstones in the list  * is greater than the input parameter of maximum allowed tombstones.  * Tombstones are purged until the list is equal to the maximum allowed.  */ ;/**  * Purge tombstone entries.  Returns the number of entries that were purged.  *  * Tombstones are purged if the number of tombstones in the list  * is greater than the input parameter of maximum allowed tombstones.  * Tombstones are purged until the list is equal to the maximum allowed.  */ private int purge(final int maxTombstones) {     int count = tombstones().size() - maxTombstones.     if (count <= 0) {         return 0.     }     tombstones = tombstones.subList(count, tombstones.size()).     return count. }
false;public;0;3;;public IndexGraveyard build() {     return build(Settings.EMPTY). }
false;public;1;5;;public IndexGraveyard build(final Settings settings) {     // first, purge the necessary amount of entries     numPurged = purge(SETTING_MAX_TOMBSTONES.get(settings)).     return new IndexGraveyard(tombstones). }
false;public;1;5;;@Override public void writeTo(final StreamOutput out) throws IOException {     out.writeList(added).     out.writeVInt(removedCount). }
false;public;1;13;;@Override public IndexGraveyard apply(final MetaData.Custom previous) {     final IndexGraveyard old = (IndexGraveyard) previous.     if (removedCount > old.tombstones.size()) {         throw new IllegalStateException("IndexGraveyardDiff cannot remove [" + removedCount + "] entries from [" + old.tombstones.size() + "] tombstones.").     }     final List<Tombstone> newTombstones = new ArrayList<>(old.tombstones.subList(removedCount, old.tombstones.size())).     for (Tombstone tombstone : added) {         newTombstones.add(tombstone).     }     return new IndexGraveyard.Builder().addBuiltTombstones(newTombstones).build(). }
true;public;0;3;/**  * The index tombstones that were added between two states  */ ;/**  * The index tombstones that were added between two states  */ public List<Tombstone> getAdded() {     return added. }
true;public;0;3;/**  * The number of index tombstones that were removed between two states  */ ;/**  * The number of index tombstones that were removed between two states  */ public int getRemovedCount() {     return removedCount. }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;static;0;3;;static ContextParser<Void, Tombstone> getParser() {     return (parser, context) -> TOMBSTONE_PARSER.apply(parser, null).build(). }
true;public;0;3;/**  * The deleted index.  */ ;/**  * The deleted index.  */ public Index getIndex() {     return index. }
true;public;0;3;/**  * The date in milliseconds that the index deletion event occurred, used for logging/debugging.  */ ;/**  * The date in milliseconds that the index deletion event occurred, used for logging/debugging.  */ public long getDeleteDateInMillis() {     return deleteDateInMillis. }
false;public;1;5;;@Override public void writeTo(final StreamOutput out) throws IOException {     index.writeTo(out).     out.writeLong(deleteDateInMillis). }
false;public;1;11;;@Override public boolean equals(final Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     Tombstone that = (Tombstone) other.     return index.equals(that.index) && deleteDateInMillis == that.deleteDateInMillis. }
false;public;0;6;;@Override public int hashCode() {     int result = index.hashCode().     result = 31 * result + Long.hashCode(deleteDateInMillis).     return result. }
false;public;0;5;;@Override public String toString() {     String date = FORMATTER.format(Instant.ofEpochMilli(deleteDateInMillis)).     return "[index=" + index + ", deleteDate=" + date + "]". }
false;public;2;8;;@Override public XContentBuilder toXContent(final XContentBuilder builder, final Params params) throws IOException {     builder.startObject().     builder.field(INDEX_KEY).     index.toXContent(builder, params).     builder.timeField(DELETE_DATE_IN_MILLIS_KEY, DELETE_DATE_KEY, deleteDateInMillis).     return builder.endObject(). }
false;public;1;3;;public void index(final Index index) {     this.index = index. }
false;public;1;3;;public void deleteDateInMillis(final long deleteDate) {     this.deleteDateInMillis = deleteDate. }
false;public;0;5;;public Tombstone build() {     assert index != null.     assert deleteDateInMillis > -1L.     return new Tombstone(index, deleteDateInMillis). }
