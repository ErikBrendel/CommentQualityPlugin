commented;modifiers;parameterAmount;loc;comment;code
false;abstract;0;1;;abstract Writeable.Reader<B> getBucketReader().
false;protected;1;5;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     writeSize(requiredSize, out).     out.writeList(buckets). }
false;abstract;5;2;;abstract InternalGeoGrid create(String name, int requiredSize, List<InternalGeoGridBucket> buckets, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData).
false;public;0;4;;@Override public List<InternalGeoGridBucket> getBuckets() {     return unmodifiableList(buckets). }
false;public;2;37;;@Override public InternalGeoGrid doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {     LongObjectPagedHashMap<List<B>> buckets = null.     for (InternalAggregation aggregation : aggregations) {         InternalGeoGrid grid = (InternalGeoGrid) aggregation.         if (buckets == null) {             buckets = new LongObjectPagedHashMap<>(grid.buckets.size(), reduceContext.bigArrays()).         }         for (Object obj : grid.buckets) {             B bucket = (B) obj.             List<B> existingBuckets = buckets.get(bucket.hashAsLong()).             if (existingBuckets == null) {                 existingBuckets = new ArrayList<>(aggregations.size()).                 buckets.put(bucket.hashAsLong(), existingBuckets).             }             existingBuckets.add(bucket).         }     }     final int size = Math.toIntExact(reduceContext.isFinalReduce() == false ? buckets.size() : Math.min(requiredSize, buckets.size())).     BucketPriorityQueue<InternalGeoGridBucket> ordered = new BucketPriorityQueue<>(size).     for (LongObjectPagedHashMap.Cursor<List<B>> cursor : buckets) {         List<B> sameCellBuckets = cursor.value.         InternalGeoGridBucket removed = ordered.insertWithOverflow(sameCellBuckets.get(0).reduce(sameCellBuckets, reduceContext)).         if (removed != null) {             reduceContext.consumeBucketsAndMaybeBreak(-countInnerBucket(removed)).         } else {             reduceContext.consumeBucketsAndMaybeBreak(1).         }     }     buckets.close().     InternalGeoGridBucket[] list = new InternalGeoGridBucket[ordered.size()].     for (int i = ordered.size() - 1. i >= 0. i--) {         list[i] = ordered.pop().     }     return create(getName(), requiredSize, Arrays.asList(list), pipelineAggregators(), getMetaData()). }
false;public;2;9;;@Override public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     builder.startArray(CommonFields.BUCKETS.getPreferredName()).     for (InternalGeoGridBucket bucket : buckets) {         bucket.toXContent(builder, params).     }     builder.endArray().     return builder. }
true;;0;3;// package protected for testing ;// package protected for testing int getRequiredSize() {     return requiredSize. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(requiredSize, buckets). }
false;protected;1;6;;@Override protected boolean doEquals(Object obj) {     InternalGeoGrid other = (InternalGeoGrid) obj.     return Objects.equals(requiredSize, other.requiredSize) && Objects.equals(buckets, other.buckets). }
