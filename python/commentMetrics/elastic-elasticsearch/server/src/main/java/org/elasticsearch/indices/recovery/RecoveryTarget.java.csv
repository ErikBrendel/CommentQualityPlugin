# id;timestamp;commentText;codeText;commentWords;codeWords
RecoveryTarget -> public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException;1524684173;Creates an {@link org.apache.lucene.store.IndexOutput} for the given file name. Note that the_IndexOutput actually point at a temporary file._<p>_Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput_at a later stage;public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {_        ensureRefCount()__        String tempFileName = getTempNameForFile(fileName)__        if (tempFileNames.containsKey(tempFileName)) {_            throw new IllegalStateException("output for file [" + fileName + "] has already been created")__        }_        _        tempFileNames.put(tempFileName, fileName)__        IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT)__        openIndexOutputs.put(fileName, indexOutput)__        return indexOutput__    };creates,an,link,org,apache,lucene,store,index,output,for,the,given,file,name,note,that,the,index,output,actually,point,at,a,temporary,file,p,note,you,can,use,link,get,open,index,output,string,with,the,same,filename,to,retrieve,the,same,index,output,at,a,later,stage;public,index,output,open,and,put,index,output,string,file,name,store,file,meta,data,meta,data,store,store,throws,ioexception,ensure,ref,count,string,temp,file,name,get,temp,name,for,file,file,name,if,temp,file,names,contains,key,temp,file,name,throw,new,illegal,state,exception,output,for,file,file,name,has,already,been,created,temp,file,names,put,temp,file,name,file,name,index,output,index,output,store,create,verifying,output,temp,file,name,meta,data,iocontext,default,open,index,outputs,put,file,name,index,output,return,index,output
RecoveryTarget -> public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException;1525162917;Creates an {@link org.apache.lucene.store.IndexOutput} for the given file name. Note that the_IndexOutput actually point at a temporary file._<p>_Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput_at a later stage;public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {_        ensureRefCount()__        String tempFileName = getTempNameForFile(fileName)__        if (tempFileNames.containsKey(tempFileName)) {_            throw new IllegalStateException("output for file [" + fileName + "] has already been created")__        }_        _        tempFileNames.put(tempFileName, fileName)__        IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT)__        openIndexOutputs.put(fileName, indexOutput)__        return indexOutput__    };creates,an,link,org,apache,lucene,store,index,output,for,the,given,file,name,note,that,the,index,output,actually,point,at,a,temporary,file,p,note,you,can,use,link,get,open,index,output,string,with,the,same,filename,to,retrieve,the,same,index,output,at,a,later,stage;public,index,output,open,and,put,index,output,string,file,name,store,file,meta,data,meta,data,store,store,throws,ioexception,ensure,ref,count,string,temp,file,name,get,temp,name,for,file,file,name,if,temp,file,names,contains,key,temp,file,name,throw,new,illegal,state,exception,output,for,file,file,name,has,already,been,created,temp,file,names,put,temp,file,name,file,name,index,output,index,output,store,create,verifying,output,temp,file,name,meta,data,iocontext,default,open,index,outputs,put,file,name,index,output,return,index,output
RecoveryTarget -> public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException;1533295538;Creates an {@link org.apache.lucene.store.IndexOutput} for the given file name. Note that the_IndexOutput actually point at a temporary file._<p>_Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput_at a later stage;public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {_        ensureRefCount()__        String tempFileName = getTempNameForFile(fileName)__        if (tempFileNames.containsKey(tempFileName)) {_            throw new IllegalStateException("output for file [" + fileName + "] has already been created")__        }_        _        tempFileNames.put(tempFileName, fileName)__        IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT)__        openIndexOutputs.put(fileName, indexOutput)__        return indexOutput__    };creates,an,link,org,apache,lucene,store,index,output,for,the,given,file,name,note,that,the,index,output,actually,point,at,a,temporary,file,p,note,you,can,use,link,get,open,index,output,string,with,the,same,filename,to,retrieve,the,same,index,output,at,a,later,stage;public,index,output,open,and,put,index,output,string,file,name,store,file,meta,data,meta,data,store,store,throws,ioexception,ensure,ref,count,string,temp,file,name,get,temp,name,for,file,file,name,if,temp,file,names,contains,key,temp,file,name,throw,new,illegal,state,exception,output,for,file,file,name,has,already,been,created,temp,file,names,put,temp,file,name,file,name,index,output,index,output,store,create,verifying,output,temp,file,name,meta,data,iocontext,default,open,index,outputs,put,file,name,index,output,return,index,output
RecoveryTarget -> public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException;1535965276;Creates an {@link org.apache.lucene.store.IndexOutput} for the given file name. Note that the_IndexOutput actually point at a temporary file._<p>_Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput_at a later stage;public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {_        ensureRefCount()__        String tempFileName = getTempNameForFile(fileName)__        if (tempFileNames.containsKey(tempFileName)) {_            throw new IllegalStateException("output for file [" + fileName + "] has already been created")__        }_        _        tempFileNames.put(tempFileName, fileName)__        IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT)__        openIndexOutputs.put(fileName, indexOutput)__        return indexOutput__    };creates,an,link,org,apache,lucene,store,index,output,for,the,given,file,name,note,that,the,index,output,actually,point,at,a,temporary,file,p,note,you,can,use,link,get,open,index,output,string,with,the,same,filename,to,retrieve,the,same,index,output,at,a,later,stage;public,index,output,open,and,put,index,output,string,file,name,store,file,meta,data,meta,data,store,store,throws,ioexception,ensure,ref,count,string,temp,file,name,get,temp,name,for,file,file,name,if,temp,file,names,contains,key,temp,file,name,throw,new,illegal,state,exception,output,for,file,file,name,has,already,been,created,temp,file,names,put,temp,file,name,file,name,index,output,index,output,store,create,verifying,output,temp,file,name,meta,data,iocontext,default,open,index,outputs,put,file,name,index,output,return,index,output
RecoveryTarget -> public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException;1537806831;Creates an {@link org.apache.lucene.store.IndexOutput} for the given file name. Note that the_IndexOutput actually point at a temporary file._<p>_Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput_at a later stage;public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {_        ensureRefCount()__        String tempFileName = getTempNameForFile(fileName)__        if (tempFileNames.containsKey(tempFileName)) {_            throw new IllegalStateException("output for file [" + fileName + "] has already been created")__        }_        _        tempFileNames.put(tempFileName, fileName)__        IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT)__        openIndexOutputs.put(fileName, indexOutput)__        return indexOutput__    };creates,an,link,org,apache,lucene,store,index,output,for,the,given,file,name,note,that,the,index,output,actually,point,at,a,temporary,file,p,note,you,can,use,link,get,open,index,output,string,with,the,same,filename,to,retrieve,the,same,index,output,at,a,later,stage;public,index,output,open,and,put,index,output,string,file,name,store,file,meta,data,meta,data,store,store,throws,ioexception,ensure,ref,count,string,temp,file,name,get,temp,name,for,file,file,name,if,temp,file,names,contains,key,temp,file,name,throw,new,illegal,state,exception,output,for,file,file,name,has,already,been,created,temp,file,names,put,temp,file,name,file,name,index,output,index,output,store,create,verifying,output,temp,file,name,meta,data,iocontext,default,open,index,outputs,put,file,name,index,output,return,index,output
RecoveryTarget -> public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException;1538067637;Creates an {@link org.apache.lucene.store.IndexOutput} for the given file name. Note that the_IndexOutput actually point at a temporary file._<p>_Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput_at a later stage;public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {_        ensureRefCount()__        String tempFileName = getTempNameForFile(fileName)__        if (tempFileNames.containsKey(tempFileName)) {_            throw new IllegalStateException("output for file [" + fileName + "] has already been created")__        }_        _        tempFileNames.put(tempFileName, fileName)__        IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT)__        openIndexOutputs.put(fileName, indexOutput)__        return indexOutput__    };creates,an,link,org,apache,lucene,store,index,output,for,the,given,file,name,note,that,the,index,output,actually,point,at,a,temporary,file,p,note,you,can,use,link,get,open,index,output,string,with,the,same,filename,to,retrieve,the,same,index,output,at,a,later,stage;public,index,output,open,and,put,index,output,string,file,name,store,file,meta,data,meta,data,store,store,throws,ioexception,ensure,ref,count,string,temp,file,name,get,temp,name,for,file,file,name,if,temp,file,names,contains,key,temp,file,name,throw,new,illegal,state,exception,output,for,file,file,name,has,already,been,created,temp,file,names,put,temp,file,name,file,name,index,output,index,output,store,create,verifying,output,temp,file,name,meta,data,iocontext,default,open,index,outputs,put,file,name,index,output,return,index,output
RecoveryTarget -> public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException;1547496886;Creates an {@link org.apache.lucene.store.IndexOutput} for the given file name. Note that the_IndexOutput actually point at a temporary file._<p>_Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput_at a later stage;public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {_        ensureRefCount()__        String tempFileName = getTempNameForFile(fileName)__        if (tempFileNames.containsKey(tempFileName)) {_            throw new IllegalStateException("output for file [" + fileName + "] has already been created")__        }_        _        tempFileNames.put(tempFileName, fileName)__        IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT)__        openIndexOutputs.put(fileName, indexOutput)__        return indexOutput__    };creates,an,link,org,apache,lucene,store,index,output,for,the,given,file,name,note,that,the,index,output,actually,point,at,a,temporary,file,p,note,you,can,use,link,get,open,index,output,string,with,the,same,filename,to,retrieve,the,same,index,output,at,a,later,stage;public,index,output,open,and,put,index,output,string,file,name,store,file,meta,data,meta,data,store,store,throws,ioexception,ensure,ref,count,string,temp,file,name,get,temp,name,for,file,file,name,if,temp,file,names,contains,key,temp,file,name,throw,new,illegal,state,exception,output,for,file,file,name,has,already,been,created,temp,file,names,put,temp,file,name,file,name,index,output,index,output,store,create,verifying,output,temp,file,name,meta,data,iocontext,default,open,index,outputs,put,file,name,index,output,return,index,output
RecoveryTarget -> public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException;1547508054;Creates an {@link org.apache.lucene.store.IndexOutput} for the given file name. Note that the_IndexOutput actually point at a temporary file._<p>_Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput_at a later stage;public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {_        ensureRefCount()__        String tempFileName = getTempNameForFile(fileName)__        if (tempFileNames.containsKey(tempFileName)) {_            throw new IllegalStateException("output for file [" + fileName + "] has already been created")__        }_        _        tempFileNames.put(tempFileName, fileName)__        IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT)__        openIndexOutputs.put(fileName, indexOutput)__        return indexOutput__    };creates,an,link,org,apache,lucene,store,index,output,for,the,given,file,name,note,that,the,index,output,actually,point,at,a,temporary,file,p,note,you,can,use,link,get,open,index,output,string,with,the,same,filename,to,retrieve,the,same,index,output,at,a,later,stage;public,index,output,open,and,put,index,output,string,file,name,store,file,meta,data,meta,data,store,store,throws,ioexception,ensure,ref,count,string,temp,file,name,get,temp,name,for,file,file,name,if,temp,file,names,contains,key,temp,file,name,throw,new,illegal,state,exception,output,for,file,file,name,has,already,been,created,temp,file,names,put,temp,file,name,file,name,index,output,index,output,store,create,verifying,output,temp,file,name,meta,data,iocontext,default,open,index,outputs,put,file,name,index,output,return,index,output
RecoveryTarget -> public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException;1547576245;Creates an {@link org.apache.lucene.store.IndexOutput} for the given file name. Note that the_IndexOutput actually point at a temporary file._<p>_Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput_at a later stage;public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {_        ensureRefCount()__        String tempFileName = getTempNameForFile(fileName)__        if (tempFileNames.containsKey(tempFileName)) {_            throw new IllegalStateException("output for file [" + fileName + "] has already been created")__        }_        _        tempFileNames.put(tempFileName, fileName)__        IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT)__        openIndexOutputs.put(fileName, indexOutput)__        return indexOutput__    };creates,an,link,org,apache,lucene,store,index,output,for,the,given,file,name,note,that,the,index,output,actually,point,at,a,temporary,file,p,note,you,can,use,link,get,open,index,output,string,with,the,same,filename,to,retrieve,the,same,index,output,at,a,later,stage;public,index,output,open,and,put,index,output,string,file,name,store,file,meta,data,meta,data,store,store,throws,ioexception,ensure,ref,count,string,temp,file,name,get,temp,name,for,file,file,name,if,temp,file,names,contains,key,temp,file,name,throw,new,illegal,state,exception,output,for,file,file,name,has,already,been,created,temp,file,names,put,temp,file,name,file,name,index,output,index,output,store,create,verifying,output,temp,file,name,meta,data,iocontext,default,open,index,outputs,put,file,name,index,output,return,index,output
RecoveryTarget -> public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException;1548124510;Creates an {@link org.apache.lucene.store.IndexOutput} for the given file name. Note that the_IndexOutput actually point at a temporary file._<p>_Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput_at a later stage;public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {_        ensureRefCount()__        String tempFileName = getTempNameForFile(fileName)__        if (tempFileNames.containsKey(tempFileName)) {_            throw new IllegalStateException("output for file [" + fileName + "] has already been created")__        }_        _        tempFileNames.put(tempFileName, fileName)__        IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT)__        openIndexOutputs.put(fileName, indexOutput)__        return indexOutput__    };creates,an,link,org,apache,lucene,store,index,output,for,the,given,file,name,note,that,the,index,output,actually,point,at,a,temporary,file,p,note,you,can,use,link,get,open,index,output,string,with,the,same,filename,to,retrieve,the,same,index,output,at,a,later,stage;public,index,output,open,and,put,index,output,string,file,name,store,file,meta,data,meta,data,store,store,throws,ioexception,ensure,ref,count,string,temp,file,name,get,temp,name,for,file,file,name,if,temp,file,names,contains,key,temp,file,name,throw,new,illegal,state,exception,output,for,file,file,name,has,already,been,created,temp,file,names,put,temp,file,name,file,name,index,output,index,output,store,create,verifying,output,temp,file,name,meta,data,iocontext,default,open,index,outputs,put,file,name,index,output,return,index,output
RecoveryTarget -> public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException;1549406621;Creates an {@link org.apache.lucene.store.IndexOutput} for the given file name. Note that the_IndexOutput actually point at a temporary file._<p>_Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput_at a later stage;public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {_        ensureRefCount()__        String tempFileName = getTempNameForFile(fileName)__        if (tempFileNames.containsKey(tempFileName)) {_            throw new IllegalStateException("output for file [" + fileName + "] has already been created")__        }_        _        tempFileNames.put(tempFileName, fileName)__        IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT)__        openIndexOutputs.put(fileName, indexOutput)__        return indexOutput__    };creates,an,link,org,apache,lucene,store,index,output,for,the,given,file,name,note,that,the,index,output,actually,point,at,a,temporary,file,p,note,you,can,use,link,get,open,index,output,string,with,the,same,filename,to,retrieve,the,same,index,output,at,a,later,stage;public,index,output,open,and,put,index,output,string,file,name,store,file,meta,data,meta,data,store,store,throws,ioexception,ensure,ref,count,string,temp,file,name,get,temp,name,for,file,file,name,if,temp,file,names,contains,key,temp,file,name,throw,new,illegal,state,exception,output,for,file,file,name,has,already,been,created,temp,file,names,put,temp,file,name,file,name,index,output,index,output,store,create,verifying,output,temp,file,name,meta,data,iocontext,default,open,index,outputs,put,file,name,index,output,return,index,output
RecoveryTarget -> public void renameAllTempFiles() throws IOException;1524684173;renames all temporary files to their true name, potentially overriding existing files;public void renameAllTempFiles() throws IOException {_        ensureRefCount()__        store.renameTempFilesSafe(tempFileNames)__    };renames,all,temporary,files,to,their,true,name,potentially,overriding,existing,files;public,void,rename,all,temp,files,throws,ioexception,ensure,ref,count,store,rename,temp,files,safe,temp,file,names
RecoveryTarget -> public void renameAllTempFiles() throws IOException;1525162917;renames all temporary files to their true name, potentially overriding existing files;public void renameAllTempFiles() throws IOException {_        ensureRefCount()__        store.renameTempFilesSafe(tempFileNames)__    };renames,all,temporary,files,to,their,true,name,potentially,overriding,existing,files;public,void,rename,all,temp,files,throws,ioexception,ensure,ref,count,store,rename,temp,files,safe,temp,file,names
RecoveryTarget -> public void renameAllTempFiles() throws IOException;1533295538;renames all temporary files to their true name, potentially overriding existing files;public void renameAllTempFiles() throws IOException {_        ensureRefCount()__        store.renameTempFilesSafe(tempFileNames)__    };renames,all,temporary,files,to,their,true,name,potentially,overriding,existing,files;public,void,rename,all,temp,files,throws,ioexception,ensure,ref,count,store,rename,temp,files,safe,temp,file,names
RecoveryTarget -> public void renameAllTempFiles() throws IOException;1535965276;renames all temporary files to their true name, potentially overriding existing files;public void renameAllTempFiles() throws IOException {_        ensureRefCount()__        store.renameTempFilesSafe(tempFileNames)__    };renames,all,temporary,files,to,their,true,name,potentially,overriding,existing,files;public,void,rename,all,temp,files,throws,ioexception,ensure,ref,count,store,rename,temp,files,safe,temp,file,names
RecoveryTarget -> public void renameAllTempFiles() throws IOException;1537806831;renames all temporary files to their true name, potentially overriding existing files;public void renameAllTempFiles() throws IOException {_        ensureRefCount()__        store.renameTempFilesSafe(tempFileNames)__    };renames,all,temporary,files,to,their,true,name,potentially,overriding,existing,files;public,void,rename,all,temp,files,throws,ioexception,ensure,ref,count,store,rename,temp,files,safe,temp,file,names
RecoveryTarget -> public void renameAllTempFiles() throws IOException;1538067637;renames all temporary files to their true name, potentially overriding existing files;public void renameAllTempFiles() throws IOException {_        ensureRefCount()__        store.renameTempFilesSafe(tempFileNames)__    };renames,all,temporary,files,to,their,true,name,potentially,overriding,existing,files;public,void,rename,all,temp,files,throws,ioexception,ensure,ref,count,store,rename,temp,files,safe,temp,file,names
RecoveryTarget -> public void renameAllTempFiles() throws IOException;1547496886;renames all temporary files to their true name, potentially overriding existing files;public void renameAllTempFiles() throws IOException {_        ensureRefCount()__        store.renameTempFilesSafe(tempFileNames)__    };renames,all,temporary,files,to,their,true,name,potentially,overriding,existing,files;public,void,rename,all,temp,files,throws,ioexception,ensure,ref,count,store,rename,temp,files,safe,temp,file,names
RecoveryTarget -> public void renameAllTempFiles() throws IOException;1547508054;renames all temporary files to their true name, potentially overriding existing files;public void renameAllTempFiles() throws IOException {_        ensureRefCount()__        store.renameTempFilesSafe(tempFileNames)__    };renames,all,temporary,files,to,their,true,name,potentially,overriding,existing,files;public,void,rename,all,temp,files,throws,ioexception,ensure,ref,count,store,rename,temp,files,safe,temp,file,names
RecoveryTarget -> public void renameAllTempFiles() throws IOException;1547576245;renames all temporary files to their true name, potentially overriding existing files;public void renameAllTempFiles() throws IOException {_        ensureRefCount()__        store.renameTempFilesSafe(tempFileNames)__    };renames,all,temporary,files,to,their,true,name,potentially,overriding,existing,files;public,void,rename,all,temp,files,throws,ioexception,ensure,ref,count,store,rename,temp,files,safe,temp,file,names
RecoveryTarget -> public void renameAllTempFiles() throws IOException;1548124510;renames all temporary files to their true name, potentially overriding existing files;public void renameAllTempFiles() throws IOException {_        ensureRefCount()__        store.renameTempFilesSafe(tempFileNames)__    };renames,all,temporary,files,to,their,true,name,potentially,overriding,existing,files;public,void,rename,all,temp,files,throws,ioexception,ensure,ref,count,store,rename,temp,files,safe,temp,file,names
RecoveryTarget -> public void renameAllTempFiles() throws IOException;1549406621;renames all temporary files to their true name, potentially overriding existing files;public void renameAllTempFiles() throws IOException {_        ensureRefCount()__        store.renameTempFilesSafe(tempFileNames)__    };renames,all,temporary,files,to,their,true,name,potentially,overriding,existing,files;public,void,rename,all,temp,files,throws,ioexception,ensure,ref,count,store,rename,temp,files,safe,temp,file,names
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener);1548124510;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener) {_        ActionListener.completeWith(listener, () -> {_            state().getTranslog().totalOperations(totalTranslogOps)__            indexShard().openEngineAndSkipTranslogRecovery()__            return null__        })__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,action,listener,void,listener,action,listener,complete,with,listener,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery,return,null
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener);1549406621;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener) {_        ActionListener.completeWith(listener, () -> {_            state().getTranslog().totalOperations(totalTranslogOps)__            indexShard().openEngineAndSkipTranslogRecovery()__            return null__        })__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,action,listener,void,listener,action,listener,complete,with,listener,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery,return,null
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener);1549663373;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener) {_        ActionListener.completeWith(listener, () -> {_            state().getTranslog().totalOperations(totalTranslogOps)__            indexShard().openEngineAndSkipTranslogRecovery()__            return null__        })__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,action,listener,void,listener,action,listener,complete,with,listener,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery,return,null
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener);1550526771;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener) {_        ActionListener.completeWith(listener, () -> {_            state().getTranslog().totalOperations(totalTranslogOps)__            indexShard().openEngineAndSkipTranslogRecovery()__            return null__        })__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,action,listener,void,listener,action,listener,complete,with,listener,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery,return,null
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener);1550943583;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps, ActionListener<Void> listener) {_        ActionListener.completeWith(listener, () -> {_            state().getTranslog().totalOperations(totalTranslogOps)__            indexShard().openEngineAndSkipTranslogRecovery()__            return null__        })__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,action,listener,void,listener,action,listener,complete,with,listener,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery,return,null
RecoveryTarget -> public String getTempNameForFile(String origFile);1524684173;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return tempFilePrefix + origFile__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,temp,file,prefix,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1525162917;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return tempFilePrefix + origFile__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,temp,file,prefix,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1533295538;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return tempFilePrefix + origFile__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,temp,file,prefix,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1535965276;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return tempFilePrefix + origFile__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,temp,file,prefix,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1537806831;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return tempFilePrefix + origFile__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,temp,file,prefix,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1538067637;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return tempFilePrefix + origFile__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,temp,file,prefix,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1547496886;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return tempFilePrefix + origFile__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,temp,file,prefix,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1547508054;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return tempFilePrefix + origFile__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,temp,file,prefix,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1547576245;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return tempFilePrefix + origFile__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,temp,file,prefix,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1548124510;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return tempFilePrefix + origFile__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,temp,file,prefix,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1549406621;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return tempFilePrefix + origFile__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,temp,file,prefix,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1549663373;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return multiFileWriter.getTempNameForFile(origFile)__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,multi,file,writer,get,temp,name,for,file,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1550526771;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return multiFileWriter.getTempNameForFile(origFile)__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,multi,file,writer,get,temp,name,for,file,orig,file
RecoveryTarget -> public String getTempNameForFile(String origFile);1550943583;Get a temporary name for the provided file name.;public String getTempNameForFile(String origFile) {_        return multiFileWriter.getTempNameForFile(origFile)__    };get,a,temporary,name,for,the,provided,file,name;public,string,get,temp,name,for,file,string,orig,file,return,multi,file,writer,get,temp,name,for,file,orig,file
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1524684173;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.indexSettings().getSettings(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        this.tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,index,settings,get,settings,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,this,temp,file,prefix,uuids,random,base64uuid,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1525162917;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.indexSettings().getSettings(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        this.tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,index,settings,get,settings,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,this,temp,file,prefix,uuids,random,base64uuid,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1533295538;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.indexSettings().getSettings(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        this.tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,index,settings,get,settings,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,this,temp,file,prefix,uuids,random,base64uuid,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1535965276;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        this.tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,this,temp,file,prefix,uuids,random,base64uuid,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1537806831;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        this.tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,this,temp,file,prefix,uuids,random,base64uuid,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1538067637;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        this.tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,this,temp,file,prefix,uuids,random,base64uuid,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1547496886;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        this.tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,this,temp,file,prefix,uuids,random,base64uuid,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1547508054;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        this.tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,this,temp,file,prefix,uuids,random,base64uuid,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1547576245;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        this.tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,this,temp,file,prefix,uuids,random,base64uuid,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1548124510;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        this.tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,this,temp,file,prefix,uuids,random,base64uuid,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1549406621;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        this.tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,this,temp,file,prefix,uuids,random,base64uuid,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1549663373;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        final String tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.multiFileWriter = new MultiFileWriter(indexShard.store(), indexShard.recoveryState().getIndex(), tempFilePrefix, logger,_            this::ensureRefCount)__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,final,string,temp,file,prefix,uuids,random,base64uuid,this,multi,file,writer,new,multi,file,writer,index,shard,store,index,shard,recovery,state,get,index,temp,file,prefix,logger,this,ensure,ref,count,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1550526771;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        final String tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.multiFileWriter = new MultiFileWriter(indexShard.store(), indexShard.recoveryState().getIndex(), tempFilePrefix, logger,_            this::ensureRefCount)__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,final,string,temp,file,prefix,uuids,random,base64uuid,this,multi,file,writer,new,multi,file,writer,index,shard,store,index,shard,recovery,state,get,index,temp,file,prefix,logger,this,ensure,ref,count,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> public RecoveryTarget(final IndexShard indexShard,                    final DiscoveryNode sourceNode,                    final PeerRecoveryTargetService.RecoveryListener listener,                    final LongConsumer ensureClusterStateVersionCallback);1550943583;Creates a new recovery target object that represents a recovery to the provided shard.__@param indexShard                        local shard where we want to recover to_@param sourceNode                        source node of the recovery where we recover from_@param listener                          called when recovery is completed/failed_@param ensureClusterStateVersionCallback callback to ensure that the current node is at least on a cluster state with the provided_version_ necessary for primary relocation so that new primary knows about all other ongoing_replica recoveries when replicating documents (see {@link RecoverySourceHandler});public RecoveryTarget(final IndexShard indexShard,_                   final DiscoveryNode sourceNode,_                   final PeerRecoveryTargetService.RecoveryListener listener,_                   final LongConsumer ensureClusterStateVersionCallback) {_        super("recovery_status")__        this.cancellableThreads = new CancellableThreads()__        this.recoveryId = idGenerator.incrementAndGet()__        this.listener = listener__        this.logger = Loggers.getLogger(getClass(), indexShard.shardId())__        this.indexShard = indexShard__        this.sourceNode = sourceNode__        this.shardId = indexShard.shardId()__        final String tempFilePrefix = RECOVERY_PREFIX + UUIDs.randomBase64UUID() + "."__        this.multiFileWriter = new MultiFileWriter(indexShard.store(), indexShard.recoveryState().getIndex(), tempFilePrefix, logger,_            this::ensureRefCount)__        this.store = indexShard.store()__        this.ensureClusterStateVersionCallback = ensureClusterStateVersionCallback__        _        store.incRef()__        indexShard.recoveryStats().incCurrentAsTarget()__    };creates,a,new,recovery,target,object,that,represents,a,recovery,to,the,provided,shard,param,index,shard,local,shard,where,we,want,to,recover,to,param,source,node,source,node,of,the,recovery,where,we,recover,from,param,listener,called,when,recovery,is,completed,failed,param,ensure,cluster,state,version,callback,callback,to,ensure,that,the,current,node,is,at,least,on,a,cluster,state,with,the,provided,version,necessary,for,primary,relocation,so,that,new,primary,knows,about,all,other,ongoing,replica,recoveries,when,replicating,documents,see,link,recovery,source,handler;public,recovery,target,final,index,shard,index,shard,final,discovery,node,source,node,final,peer,recovery,target,service,recovery,listener,listener,final,long,consumer,ensure,cluster,state,version,callback,super,this,cancellable,threads,new,cancellable,threads,this,recovery,id,id,generator,increment,and,get,this,listener,listener,this,logger,loggers,get,logger,get,class,index,shard,shard,id,this,index,shard,index,shard,this,source,node,source,node,this,shard,id,index,shard,shard,id,final,string,temp,file,prefix,uuids,random,base64uuid,this,multi,file,writer,new,multi,file,writer,index,shard,store,index,shard,recovery,state,get,index,temp,file,prefix,logger,this,ensure,ref,count,this,store,index,shard,store,this,ensure,cluster,state,version,callback,ensure,cluster,state,version,callback,store,inc,ref,index,shard,recovery,stats,inc,current,as,target
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1524684173;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1525162917;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1533295538;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1535965276;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1537806831;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1538067637;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1547496886;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1547508054;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1547576245;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1548124510;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1549406621;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1549663373;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1550526771;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException;1550943583;Closes the current recovery target and waits up to a certain timeout for resources to be freed._Returns true if resetting the recovery was successful, false if the recovery target is already cancelled / failed or marked as done.;boolean resetRecovery(CancellableThreads newTargetCancellableThreads) throws IOException {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("reset of recovery with shard {} and id [{}]", shardId, recoveryId)__            } finally {_                _                decRef()__            }_            try {_                newTargetCancellableThreads.execute(closedLatch::await)__            } catch (CancellableThreads.ExecutionCancelledException e) {_                logger.trace("new recovery target cancelled for shard {} while waiting on old recovery target with id [{}] to close",_                    shardId, recoveryId)__                return false__            }_            RecoveryState.Stage stage = indexShard.recoveryState().getStage()__            if (indexShard.recoveryState().getPrimary() && (stage == RecoveryState.Stage.FINALIZE || stage == RecoveryState.Stage.DONE)) {_                _                _                _                _                assert stage != RecoveryState.Stage.DONE : "recovery should not have completed when it's being reset"__                throw new IllegalStateException("cannot reset recovery as previous attempt made it past finalization step")__            }_            indexShard.performRecoveryRestart()__            return true__        }_        return false__    };closes,the,current,recovery,target,and,waits,up,to,a,certain,timeout,for,resources,to,be,freed,returns,true,if,resetting,the,recovery,was,successful,false,if,the,recovery,target,is,already,cancelled,failed,or,marked,as,done;boolean,reset,recovery,cancellable,threads,new,target,cancellable,threads,throws,ioexception,if,finished,compare,and,set,false,true,try,logger,debug,reset,of,recovery,with,shard,and,id,shard,id,recovery,id,finally,dec,ref,try,new,target,cancellable,threads,execute,closed,latch,await,catch,cancellable,threads,execution,cancelled,exception,e,logger,trace,new,recovery,target,cancelled,for,shard,while,waiting,on,old,recovery,target,with,id,to,close,shard,id,recovery,id,return,false,recovery,state,stage,stage,index,shard,recovery,state,get,stage,if,index,shard,recovery,state,get,primary,stage,recovery,state,stage,finalize,stage,recovery,state,stage,done,assert,stage,recovery,state,stage,done,recovery,should,not,have,completed,when,it,s,being,reset,throw,new,illegal,state,exception,cannot,reset,recovery,as,previous,attempt,made,it,past,finalization,step,index,shard,perform,recovery,restart,return,true,return,false
RecoveryTarget -> public void cancel(String reason);1524684173;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1525162917;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1533295538;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1535965276;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1537806831;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1538067637;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1547496886;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1547508054;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1547576245;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1548124510;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1549406621;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1549663373;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1550526771;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public void cancel(String reason);1550943583;cancel the recovery. calling this method will clean temporary files and release the store_unless this object is in use (in which case it will be cleaned once all ongoing users call_{@link #decRef()}_<p>_if {@link #cancellableThreads()} was used, the threads will be interrupted.;public void cancel(String reason) {_        if (finished.compareAndSet(false, true)) {_            try {_                logger.debug("recovery canceled (reason: [{}])", reason)__                cancellableThreads.cancel(reason)__            } finally {_                _                decRef()__            }_        }_    };cancel,the,recovery,calling,this,method,will,clean,temporary,files,and,release,the,store,unless,this,object,is,in,use,in,which,case,it,will,be,cleaned,once,all,ongoing,users,call,link,dec,ref,p,if,link,cancellable,threads,was,used,the,threads,will,be,interrupted;public,void,cancel,string,reason,if,finished,compare,and,set,false,true,try,logger,debug,recovery,canceled,reason,reason,cancellable,threads,cancel,reason,finally,dec,ref
RecoveryTarget -> public RecoveryTarget retryCopy();1524684173;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1525162917;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1533295538;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1535965276;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1537806831;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1538067637;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1547496886;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1547508054;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1547576245;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1548124510;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1549406621;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1549663373;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1550526771;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public RecoveryTarget retryCopy();1550943583;Returns a fresh recovery target to retry recovery from the same source node onto the same shard and using the same listener.__@return a copy of this recovery target;public RecoveryTarget retryCopy() {_        return new RecoveryTarget(indexShard, sourceNode, listener, ensureClusterStateVersionCallback)__    };returns,a,fresh,recovery,target,to,retry,recovery,from,the,same,source,node,onto,the,same,shard,and,using,the,same,listener,return,a,copy,of,this,recovery,target;public,recovery,target,retry,copy,return,new,recovery,target,index,shard,source,node,listener,ensure,cluster,state,version,callback
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1524684173;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1525162917;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1533295538;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1535965276;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1537806831;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1538067637;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1547496886;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1547508054;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1547576245;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1548124510;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1549406621;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1549663373;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1550526771;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void fail(RecoveryFailedException e, boolean sendShardFailure);1550943583;fail the recovery and call listener__@param e                exception that encapsulating the failure_@param sendShardFailure indicates whether to notify the master of the shard failure;public void fail(RecoveryFailedException e, boolean sendShardFailure) {_        if (finished.compareAndSet(false, true)) {_            try {_                notifyListener(e, sendShardFailure)__            } finally {_                try {_                    cancellableThreads.cancel("failed recovery [" + ExceptionsHelper.stackTrace(e) + "]")__                } finally {_                    _                    decRef()__                }_            }_        }_    };fail,the,recovery,and,call,listener,param,e,exception,that,encapsulating,the,failure,param,send,shard,failure,indicates,whether,to,notify,the,master,of,the,shard,failure;public,void,fail,recovery,failed,exception,e,boolean,send,shard,failure,if,finished,compare,and,set,false,true,try,notify,listener,e,send,shard,failure,finally,try,cancellable,threads,cancel,failed,recovery,exceptions,helper,stack,trace,e,finally,dec,ref
RecoveryTarget -> public void markAsDone();1524684173;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1525162917;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1533295538;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1535965276;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1537806831;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1538067637;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1547496886;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1547508054;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1547576245;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1548124510;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1549406621;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1549663373;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert multiFileWriter.tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,multi,file,writer,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1550526771;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert multiFileWriter.tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,multi,file,writer,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void markAsDone();1550943583;mark the current recovery as done;public void markAsDone() {_        if (finished.compareAndSet(false, true)) {_            assert multiFileWriter.tempFileNames.isEmpty() : "not all temporary files are renamed"__            try {_                _                _                indexShard.postRecovery("peer recovery done")__            } finally {_                _                decRef()__            }_            listener.onRecoveryDone(state())__        }_    };mark,the,current,recovery,as,done;public,void,mark,as,done,if,finished,compare,and,set,false,true,assert,multi,file,writer,temp,file,names,is,empty,not,all,temporary,files,are,renamed,try,index,shard,post,recovery,peer,recovery,done,finally,dec,ref,listener,on,recovery,done,state
RecoveryTarget -> public void setLastAccessTime();1524684173;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1525162917;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1533295538;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1535965276;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1537806831;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1538067637;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1547496886;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1547508054;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1547576245;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1548124510;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1549406621;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1549663373;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1550526771;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> public void setLastAccessTime();1550943583;sets the lasAccessTime flag to now;public void setLastAccessTime() {_        lastAccessTime = System.nanoTime()__    };sets,the,las,access,time,flag,to,now;public,void,set,last,access,time,last,access,time,system,nano,time
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException;1524684173;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException {_        state().getTranslog().totalOperations(totalTranslogOps)__        indexShard().openEngineAndSkipTranslogRecovery()__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,throws,ioexception,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException;1525162917;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException {_        state().getTranslog().totalOperations(totalTranslogOps)__        indexShard().openEngineAndSkipTranslogRecovery()__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,throws,ioexception,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException;1533295538;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException {_        state().getTranslog().totalOperations(totalTranslogOps)__        indexShard().openEngineAndSkipTranslogRecovery()__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,throws,ioexception,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException;1535965276;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException {_        state().getTranslog().totalOperations(totalTranslogOps)__        indexShard().openEngineAndSkipTranslogRecovery()__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,throws,ioexception,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException;1537806831;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException {_        state().getTranslog().totalOperations(totalTranslogOps)__        indexShard().openEngineAndSkipTranslogRecovery()__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,throws,ioexception,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException;1538067637;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException {_        state().getTranslog().totalOperations(totalTranslogOps)__        indexShard().openEngineAndSkipTranslogRecovery()__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,throws,ioexception,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException;1547496886;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException {_        state().getTranslog().totalOperations(totalTranslogOps)__        indexShard().openEngineAndSkipTranslogRecovery()__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,throws,ioexception,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException;1547508054;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException {_        state().getTranslog().totalOperations(totalTranslogOps)__        indexShard().openEngineAndSkipTranslogRecovery()__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,throws,ioexception,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery
RecoveryTarget -> @Override     public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException;1547576245;* Implementation of {@link RecoveryTargetHandler };@Override_    public void prepareForTranslogOperations(boolean fileBasedRecovery, int totalTranslogOps) throws IOException {_        state().getTranslog().totalOperations(totalTranslogOps)__        indexShard().openEngineAndSkipTranslogRecovery()__    };implementation,of,link,recovery,target,handler;override,public,void,prepare,for,translog,operations,boolean,file,based,recovery,int,total,translog,ops,throws,ioexception,state,get,translog,total,operations,total,translog,ops,index,shard,open,engine,and,skip,translog,recovery
RecoveryTarget -> public IndexOutput removeOpenIndexOutputs(String name);1524684173;remove and {@link org.apache.lucene.store.IndexOutput} for a given file. It is the caller's responsibility to close it;public IndexOutput removeOpenIndexOutputs(String name) {_        ensureRefCount()__        return openIndexOutputs.remove(name)__    };remove,and,link,org,apache,lucene,store,index,output,for,a,given,file,it,is,the,caller,s,responsibility,to,close,it;public,index,output,remove,open,index,outputs,string,name,ensure,ref,count,return,open,index,outputs,remove,name
RecoveryTarget -> public IndexOutput removeOpenIndexOutputs(String name);1525162917;remove and {@link org.apache.lucene.store.IndexOutput} for a given file. It is the caller's responsibility to close it;public IndexOutput removeOpenIndexOutputs(String name) {_        ensureRefCount()__        return openIndexOutputs.remove(name)__    };remove,and,link,org,apache,lucene,store,index,output,for,a,given,file,it,is,the,caller,s,responsibility,to,close,it;public,index,output,remove,open,index,outputs,string,name,ensure,ref,count,return,open,index,outputs,remove,name
RecoveryTarget -> public IndexOutput removeOpenIndexOutputs(String name);1533295538;remove and {@link org.apache.lucene.store.IndexOutput} for a given file. It is the caller's responsibility to close it;public IndexOutput removeOpenIndexOutputs(String name) {_        ensureRefCount()__        return openIndexOutputs.remove(name)__    };remove,and,link,org,apache,lucene,store,index,output,for,a,given,file,it,is,the,caller,s,responsibility,to,close,it;public,index,output,remove,open,index,outputs,string,name,ensure,ref,count,return,open,index,outputs,remove,name
RecoveryTarget -> public IndexOutput removeOpenIndexOutputs(String name);1535965276;remove and {@link org.apache.lucene.store.IndexOutput} for a given file. It is the caller's responsibility to close it;public IndexOutput removeOpenIndexOutputs(String name) {_        ensureRefCount()__        return openIndexOutputs.remove(name)__    };remove,and,link,org,apache,lucene,store,index,output,for,a,given,file,it,is,the,caller,s,responsibility,to,close,it;public,index,output,remove,open,index,outputs,string,name,ensure,ref,count,return,open,index,outputs,remove,name
RecoveryTarget -> public IndexOutput removeOpenIndexOutputs(String name);1537806831;remove and {@link org.apache.lucene.store.IndexOutput} for a given file. It is the caller's responsibility to close it;public IndexOutput removeOpenIndexOutputs(String name) {_        ensureRefCount()__        return openIndexOutputs.remove(name)__    };remove,and,link,org,apache,lucene,store,index,output,for,a,given,file,it,is,the,caller,s,responsibility,to,close,it;public,index,output,remove,open,index,outputs,string,name,ensure,ref,count,return,open,index,outputs,remove,name
RecoveryTarget -> public IndexOutput removeOpenIndexOutputs(String name);1538067637;remove and {@link org.apache.lucene.store.IndexOutput} for a given file. It is the caller's responsibility to close it;public IndexOutput removeOpenIndexOutputs(String name) {_        ensureRefCount()__        return openIndexOutputs.remove(name)__    };remove,and,link,org,apache,lucene,store,index,output,for,a,given,file,it,is,the,caller,s,responsibility,to,close,it;public,index,output,remove,open,index,outputs,string,name,ensure,ref,count,return,open,index,outputs,remove,name
RecoveryTarget -> public IndexOutput removeOpenIndexOutputs(String name);1547496886;remove and {@link org.apache.lucene.store.IndexOutput} for a given file. It is the caller's responsibility to close it;public IndexOutput removeOpenIndexOutputs(String name) {_        ensureRefCount()__        return openIndexOutputs.remove(name)__    };remove,and,link,org,apache,lucene,store,index,output,for,a,given,file,it,is,the,caller,s,responsibility,to,close,it;public,index,output,remove,open,index,outputs,string,name,ensure,ref,count,return,open,index,outputs,remove,name
RecoveryTarget -> public IndexOutput removeOpenIndexOutputs(String name);1547508054;remove and {@link org.apache.lucene.store.IndexOutput} for a given file. It is the caller's responsibility to close it;public IndexOutput removeOpenIndexOutputs(String name) {_        ensureRefCount()__        return openIndexOutputs.remove(name)__    };remove,and,link,org,apache,lucene,store,index,output,for,a,given,file,it,is,the,caller,s,responsibility,to,close,it;public,index,output,remove,open,index,outputs,string,name,ensure,ref,count,return,open,index,outputs,remove,name
RecoveryTarget -> public IndexOutput removeOpenIndexOutputs(String name);1547576245;remove and {@link org.apache.lucene.store.IndexOutput} for a given file. It is the caller's responsibility to close it;public IndexOutput removeOpenIndexOutputs(String name) {_        ensureRefCount()__        return openIndexOutputs.remove(name)__    };remove,and,link,org,apache,lucene,store,index,output,for,a,given,file,it,is,the,caller,s,responsibility,to,close,it;public,index,output,remove,open,index,outputs,string,name,ensure,ref,count,return,open,index,outputs,remove,name
RecoveryTarget -> public IndexOutput removeOpenIndexOutputs(String name);1548124510;remove and {@link org.apache.lucene.store.IndexOutput} for a given file. It is the caller's responsibility to close it;public IndexOutput removeOpenIndexOutputs(String name) {_        ensureRefCount()__        return openIndexOutputs.remove(name)__    };remove,and,link,org,apache,lucene,store,index,output,for,a,given,file,it,is,the,caller,s,responsibility,to,close,it;public,index,output,remove,open,index,outputs,string,name,ensure,ref,count,return,open,index,outputs,remove,name
RecoveryTarget -> public IndexOutput removeOpenIndexOutputs(String name);1549406621;remove and {@link org.apache.lucene.store.IndexOutput} for a given file. It is the caller's responsibility to close it;public IndexOutput removeOpenIndexOutputs(String name) {_        ensureRefCount()__        return openIndexOutputs.remove(name)__    };remove,and,link,org,apache,lucene,store,index,output,for,a,given,file,it,is,the,caller,s,responsibility,to,close,it;public,index,output,remove,open,index,outputs,string,name,ensure,ref,count,return,open,index,outputs,remove,name
RecoveryTarget -> public long lastAccessTime();1524684173;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1525162917;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1533295538;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1535965276;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1537806831;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1538067637;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1547496886;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1547508054;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1547576245;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1548124510;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1549406621;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1549663373;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1550526771;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
RecoveryTarget -> public long lastAccessTime();1550943583;return the last time this RecoveryStatus was used (based on System.nanoTime();public long lastAccessTime() {_        return lastAccessTime__    };return,the,last,time,this,recovery,status,was,used,based,on,system,nano,time;public,long,last,access,time,return,last,access,time
