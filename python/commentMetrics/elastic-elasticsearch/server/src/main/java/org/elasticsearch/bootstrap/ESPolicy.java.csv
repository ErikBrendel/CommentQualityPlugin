commented;modifiers;parameterAmount;loc;comment;code
false;public;2;40;;@Override @SuppressForbidden(reason = "fast equals check is desired") public boolean implies(ProtectionDomain domain, Permission permission) {     CodeSource codeSource = domain.getCodeSource().     // codesource can be null when reducing privileges via doPrivileged()     if (codeSource == null) {         return false.     }     URL location = codeSource.getLocation().     // https://bugs.openjdk.java.net/browse/JDK-8129972     if (location != null) {         // run scripts with limited permissions         if (BootstrapInfo.UNTRUSTED_CODEBASE.equals(location.getFile())) {             return untrusted.implies(domain, permission).         }         // check for an additional plugin permission: plugin policy is         // only consulted for its codesources.         Policy plugin = plugins.get(location.getFile()).         if (plugin != null && plugin.implies(domain, permission)) {             return true.         }     }     // yeah right, REMOVE THIS when hadoop is fixed     if (permission instanceof FilePermission && "<<ALL FILES>>".equals(permission.getName())) {         for (StackTraceElement element : Thread.currentThread().getStackTrace()) {             if ("org.apache.hadoop.util.Shell".equals(element.getClassName()) && "runCommand".equals(element.getMethodName())) {                 // we found the horrible method: the hack begins!                 // force the hadoop code to back down, by throwing an exception that it catches.                 rethrow(new IOException("no hadoop, you cannot do this.")).             }         }     }     // otherwise defer to template + dynamic file permissions     return template.implies(domain, permission) || dynamic.implies(permission) || system.implies(domain, permission). }
false;private;1;3;;private void rethrow(Throwable t) throws T {     throw (T) t. }
true;private;1;3;/**  * Rethrows <code>t</code> (identical object).  */ ;/**  * Rethrows <code>t</code> (identical object).  */ private void rethrow(Throwable t) {     new Rethrower<Error>().rethrow(t). }
false;public;1;14;;@Override public PermissionCollection getPermissions(CodeSource codesource) {     // return them a new empty permissions object so jvisualvm etc work     for (StackTraceElement element : Thread.currentThread().getStackTrace()) {         if ("sun.rmi.server.LoaderHandler".equals(element.getClassName()) && "loadClass".equals(element.getMethodName())) {             return new Permissions().         }     }     // return UNSUPPORTED_EMPTY_COLLECTION since it is safe.     return super.getPermissions(codesource). }
false;public,final;1;4;;@Override public final boolean implies(Permission permission) {     return preImplies.test(permission) && badDefaultPermission.implies(permission). }
false;public,final;1;4;;@Override public final boolean equals(Object obj) {     return badDefaultPermission.equals(obj). }
false;public;0;4;;@Override public int hashCode() {     return badDefaultPermission.hashCode(). }
false;public;0;4;;@Override public String getActions() {     return badDefaultPermission.getActions(). }
false;public;2;7;;@Override public boolean implies(ProtectionDomain domain, Permission permission) {     if (BAD_DEFAULT_NUMBER_ONE.implies(permission) || BAD_DEFAULT_NUMBER_TWO.implies(permission)) {         return false.     }     return delegate.implies(domain, permission). }
