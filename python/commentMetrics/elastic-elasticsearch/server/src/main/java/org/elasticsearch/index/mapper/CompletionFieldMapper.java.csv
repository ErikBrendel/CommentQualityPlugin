commented;modifiers;parameterAmount;loc;comment;code
false;public;3;49;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     CompletionFieldMapper.Builder builder = new CompletionFieldMapper.Builder(name).     NamedAnalyzer indexAnalyzer = null.     NamedAnalyzer searchAnalyzer = null.     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String fieldName = entry.getKey().         Object fieldNode = entry.getValue().         if (fieldName.equals("type")) {             continue.         }         if (Fields.ANALYZER.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {             indexAnalyzer = getNamedAnalyzer(parserContext, fieldNode.toString()).             iterator.remove().         } else if (Fields.SEARCH_ANALYZER.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {             searchAnalyzer = getNamedAnalyzer(parserContext, fieldNode.toString()).             iterator.remove().         } else if (Fields.PRESERVE_SEPARATORS.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {             builder.preserveSeparators(Boolean.parseBoolean(fieldNode.toString())).             iterator.remove().         } else if (Fields.PRESERVE_POSITION_INCREMENTS.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {             builder.preservePositionIncrements(Boolean.parseBoolean(fieldNode.toString())).             iterator.remove().         } else if (Fields.MAX_INPUT_LENGTH.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {             builder.maxInputLength(Integer.parseInt(fieldNode.toString())).             iterator.remove().         } else if (Fields.CONTEXTS.match(fieldName, LoggingDeprecationHandler.INSTANCE)) {             builder.contextMappings(ContextMappings.load(fieldNode, parserContext.indexVersionCreated())).             iterator.remove().         } else if (parseMultiField(builder, name, parserContext, fieldName, fieldNode)) {             iterator.remove().         }     }     if (indexAnalyzer == null) {         if (searchAnalyzer != null) {             throw new MapperParsingException("analyzer on completion field [" + name + "] must be set when search_analyzer is set").         }         indexAnalyzer = searchAnalyzer = parserContext.getIndexAnalyzers().get("simple").     } else if (searchAnalyzer == null) {         searchAnalyzer = indexAnalyzer.     }     builder.indexAnalyzer(indexAnalyzer).     builder.searchAnalyzer(searchAnalyzer).     return builder. }
false;private;2;7;;private NamedAnalyzer getNamedAnalyzer(ParserContext parserContext, String name) {     NamedAnalyzer analyzer = parserContext.getIndexAnalyzers().get(name).     if (analyzer == null) {         throw new IllegalArgumentException("Can't find default or mapped analyzer with name [" + name + "]").     }     return analyzer. }
false;public;1;4;;public void setPreserveSep(boolean preserveSep) {     checkIfFrozen().     this.preserveSep = preserveSep. }
false;public;1;4;;public void setPreservePositionIncrements(boolean preservePositionIncrements) {     checkIfFrozen().     this.preservePositionIncrements = preservePositionIncrements. }
false;public;1;4;;public void setContextMappings(ContextMappings contextMappings) {     checkIfFrozen().     this.contextMappings = contextMappings. }
false;public;0;10;;@Override public NamedAnalyzer indexAnalyzer() {     final NamedAnalyzer indexAnalyzer = super.indexAnalyzer().     if (indexAnalyzer != null && !(indexAnalyzer.analyzer() instanceof CompletionAnalyzer)) {         return new NamedAnalyzer(indexAnalyzer.name(), AnalyzerScope.INDEX, new CompletionAnalyzer(indexAnalyzer, preserveSep, preservePositionIncrements)).     }     return indexAnalyzer. }
false;public;0;9;;@Override public NamedAnalyzer searchAnalyzer() {     final NamedAnalyzer searchAnalyzer = super.searchAnalyzer().     if (searchAnalyzer != null && !(searchAnalyzer.analyzer() instanceof CompletionAnalyzer)) {         return new NamedAnalyzer(searchAnalyzer.name(), AnalyzerScope.INDEX, new CompletionAnalyzer(searchAnalyzer, preserveSep, preservePositionIncrements)).     }     return searchAnalyzer. }
true;public;0;3;/**  * @return true if there are one or more context mappings defined  * for this field type  */ ;/**  * @return true if there are one or more context mappings defined  * for this field type  */ public boolean hasContextMappings() {     return contextMappings != null. }
true;public;0;3;/**  * @return associated context mappings for this field type  */ ;/**  * @return associated context mappings for this field type  */ public ContextMappings getContextMappings() {     return contextMappings. }
false;public;0;3;;public boolean preserveSep() {     return preserveSep. }
false;public;0;3;;public boolean preservePositionIncrements() {     return preservePositionIncrements. }
true;public,static,synchronized;0;6;/**  * @return postings format to use for this field-type  */ ;/**  * @return postings format to use for this field-type  */ public static synchronized PostingsFormat postingsFormat() {     if (postingsFormat == null) {         postingsFormat = new Completion50PostingsFormat().     }     return postingsFormat. }
false;public;1;4;;@Override public Query existsQuery(QueryShardContext context) {     return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())). }
true;public;1;3;/**  * Completion prefix query  */ ;/**  * Completion prefix query  */ public CompletionQuery prefixQuery(Object value) {     return new PrefixCompletionQuery(searchAnalyzer().analyzer(), new Term(name(), indexedValueForSearch(value))). }
true;public;3;3;/**  * Completion prefix regular expression query  */ ;/**  * Completion prefix regular expression query  */ public CompletionQuery regexpQuery(Object value, int flags, int maxDeterminizedStates) {     return new RegexCompletionQuery(new Term(name(), indexedValueForSearch(value)), flags, maxDeterminizedStates). }
true;public;7;7;/**  * Completion prefix fuzzy query  */ ;/**  * Completion prefix fuzzy query  */ public CompletionQuery fuzzyQuery(String value, Fuzziness fuzziness, int nonFuzzyPrefixLength, int minFuzzyPrefixLength, int maxExpansions, boolean transpositions, boolean unicodeAware) {     return new FuzzyCompletionQuery(searchAnalyzer().analyzer(), new Term(name(), indexedValueForSearch(value)), null, fuzziness.asDistance(), transpositions, nonFuzzyPrefixLength, minFuzzyPrefixLength, unicodeAware, maxExpansions). }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     if (!super.equals(o))         return false.     CompletionFieldType that = (CompletionFieldType) o.     if (preserveSep != that.preserveSep)         return false.     if (preservePositionIncrements != that.preservePositionIncrements)         return false.     return !(contextMappings != null ? !contextMappings.equals(that.contextMappings) : that.contextMappings != null). }
false;public;0;7;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), preserveSep, preservePositionIncrements, contextMappings). }
false;public;0;4;;@Override public CompletionFieldType clone() {     return new CompletionFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;public;2;17;;@Override public void checkCompatibility(MappedFieldType fieldType, List<String> conflicts) {     super.checkCompatibility(fieldType, conflicts).     CompletionFieldType other = (CompletionFieldType) fieldType.     if (preservePositionIncrements != other.preservePositionIncrements) {         conflicts.add("mapper [" + name() + "] has different [preserve_position_increments] values").     }     if (preserveSep != other.preserveSep) {         conflicts.add("mapper [" + name() + "] has different [preserve_separators] values").     }     if (hasContextMappings() != other.hasContextMappings()) {         conflicts.add("mapper [" + name() + "] has different [context_mappings] values").     } else if (hasContextMappings() && contextMappings.equals(other.contextMappings) == false) {         conflicts.add("mapper [" + name() + "] has different [context_mappings] values").     } }
true;public;1;8;/**  * @param maxInputLength maximum expected prefix length  *                       NOTE: prefixes longer than this will  *                       be truncated  */ ;/**  * @param maxInputLength maximum expected prefix length  *                       NOTE: prefixes longer than this will  *                       be truncated  */ public Builder maxInputLength(int maxInputLength) {     if (maxInputLength <= 0) {         throw new IllegalArgumentException(Fields.MAX_INPUT_LENGTH.getPreferredName() + " must be > 0 but was [" + maxInputLength + "]").     }     this.maxInputLength = maxInputLength.     return this. }
true;public;1;4;/**  * Add context mapping to this field  * @param contextMappings see {@link ContextMappings#load(Object, Version)}  */ ;/**  * Add context mapping to this field  * @param contextMappings see {@link ContextMappings#load(Object, Version)}  */ public Builder contextMappings(ContextMappings contextMappings) {     this.contextMappings = contextMappings.     return this. }
false;public;1;4;;public Builder preserveSeparators(boolean preserveSeparators) {     this.preserveSeparators = preserveSeparators.     return this. }
false;public;1;4;;public Builder preservePositionIncrements(boolean preservePositionIncrements) {     this.preservePositionIncrements = preservePositionIncrements.     return this. }
false;public;1;11;;@Override public CompletionFieldMapper build(BuilderContext context) {     checkCompletionContextsLimit(context).     setupFieldType(context).     CompletionFieldType completionFieldType = (CompletionFieldType) this.fieldType.     completionFieldType.setContextMappings(contextMappings).     completionFieldType.setPreservePositionIncrements(preservePositionIncrements).     completionFieldType.setPreserveSep(preserveSeparators).     return new CompletionFieldMapper(name, this.fieldType, context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo, maxInputLength). }
false;private;1;13;;private void checkCompletionContextsLimit(BuilderContext context) {     if (this.contextMappings != null && this.contextMappings.size() > COMPLETION_CONTEXTS_LIMIT) {         if (context.indexCreatedVersion().onOrAfter(Version.V_8_0_0)) {             throw new IllegalArgumentException("Limit of completion field contexts [" + COMPLETION_CONTEXTS_LIMIT + "] has been exceeded").         } else {             deprecationLogger.deprecated("You have defined more than [" + COMPLETION_CONTEXTS_LIMIT + "] completion contexts" + " in the mapping for index [" + context.indexSettings().get(IndexMetaData.SETTING_INDEX_PROVIDED_NAME) + "]. " + "The maximum allowed number of completion contexts in a mapping will be limited to " + "[" + COMPLETION_CONTEXTS_LIMIT + "] starting in version [8.0].").         }     } }
false;public;0;4;;@Override public CompletionFieldType fieldType() {     return (CompletionFieldType) super.fieldType(). }
true;public;1;55;/**  * Parses and indexes inputs  *  * Parsing:  *  Acceptable format:  *   "STRING" - interpreted as field value (input)  *   "ARRAY" - each element can be one of "OBJECT" (see below)  *   "OBJECT" - { "input": STRING|ARRAY, "weight": STRING|INT, "contexts": ARRAY|OBJECT }  *  * Indexing:  *  if context mappings are defined, delegates to {@link ContextMappings#addField(ParseContext.Document, String, String, int, Map)}  *  else adds inputs as a {@link org.apache.lucene.search.suggest.document.SuggestField}  */ ;/**  * Parses and indexes inputs  *  * Parsing:  *  Acceptable format:  *   "STRING" - interpreted as field value (input)  *   "ARRAY" - each element can be one of "OBJECT" (see below)  *   "OBJECT" - { "input": STRING|ARRAY, "weight": STRING|INT, "contexts": ARRAY|OBJECT }  *  * Indexing:  *  if context mappings are defined, delegates to {@link ContextMappings#addField(ParseContext.Document, String, String, int, Map)}  *  else adds inputs as a {@link org.apache.lucene.search.suggest.document.SuggestField}  */ @Override public void parse(ParseContext context) throws IOException {     // parse     XContentParser parser = context.parser().     Token token = parser.currentToken().     Map<String, CompletionInputMetaData> inputMap = new HashMap<>(1).     if (context.externalValueSet()) {         inputMap = getInputMapFromExternalValue(context).     } else if (token == Token.VALUE_NULL) {         // ignore null values         return.     } else if (token == Token.START_ARRAY) {         while ((token = parser.nextToken()) != Token.END_ARRAY) {             parse(context, token, parser, inputMap).         }     } else {         parse(context, token, parser, inputMap).     }     // index     for (Map.Entry<String, CompletionInputMetaData> completionInput : inputMap.entrySet()) {         String input = completionInput.getKey().         if (input.trim().isEmpty()) {             context.addIgnoredField(fieldType.name()).             continue.         }         // truncate input         if (input.length() > maxInputLength) {             int len = Math.min(maxInputLength, input.length()).             if (Character.isHighSurrogate(input.charAt(len - 1))) {                 assert input.length() >= len + 1 && Character.isLowSurrogate(input.charAt(len)).                 len += 1.             }             input = input.substring(0, len).         }         CompletionInputMetaData metaData = completionInput.getValue().         if (fieldType().hasContextMappings()) {             fieldType().getContextMappings().addField(context.doc(), fieldType().name(), input, metaData.weight, metaData.contexts).         } else {             context.doc().add(new SuggestField(fieldType().name(), input, metaData.weight)).         }     }     List<IndexableField> fields = new ArrayList<>(1).     createFieldNamesField(context, fields).     for (IndexableField field : fields) {         context.doc().add(field).     }     for (CompletionInputMetaData metaData : inputMap.values()) {         ParseContext externalValueContext = context.createExternalValueContext(metaData).         multiFields.parse(this, externalValueContext).     } }
false;private;1;11;;private Map<String, CompletionInputMetaData> getInputMapFromExternalValue(ParseContext context) {     Map<String, CompletionInputMetaData> inputMap.     if (isExternalValueOfClass(context, CompletionInputMetaData.class)) {         CompletionInputMetaData inputAndMeta = (CompletionInputMetaData) context.externalValue().         inputMap = Collections.singletonMap(inputAndMeta.input, inputAndMeta).     } else {         String fieldName = context.externalValue().toString().         inputMap = Collections.singletonMap(fieldName, new CompletionInputMetaData(fieldName, Collections.emptyMap(), 1)).     }     return inputMap. }
false;private;2;3;;private boolean isExternalValueOfClass(ParseContext context, Class<?> clazz) {     return context.externalValue().getClass().equals(clazz). }
true;private;4;90;/**  * Acceptable inputs:  *  "STRING" - interpreted as the field value (input)  *  "OBJECT" - { "input": STRING|ARRAY, "weight": STRING|INT, "contexts": ARRAY|OBJECT }  */ ;/**  * Acceptable inputs:  *  "STRING" - interpreted as the field value (input)  *  "OBJECT" - { "input": STRING|ARRAY, "weight": STRING|INT, "contexts": ARRAY|OBJECT }  */ private void parse(ParseContext parseContext, Token token, XContentParser parser, Map<String, CompletionInputMetaData> inputMap) throws IOException {     String currentFieldName = null.     if (token == Token.VALUE_STRING) {         inputMap.put(parser.text(), new CompletionInputMetaData(parser.text(), Collections.<String, Set<String>>emptyMap(), 1)).     } else if (token == Token.START_OBJECT) {         Set<String> inputs = new HashSet<>().         int weight = 1.         Map<String, Set<String>> contextsMap = new HashMap<>().         while ((token = parser.nextToken()) != Token.END_OBJECT) {             if (token == Token.FIELD_NAME) {                 currentFieldName = parser.currentName().                 if (!ALLOWED_CONTENT_FIELD_NAMES.contains(currentFieldName)) {                     throw new IllegalArgumentException("unknown field name [" + currentFieldName + "], must be one of " + ALLOWED_CONTENT_FIELD_NAMES).                 }             } else if (currentFieldName != null) {                 if (Fields.CONTENT_FIELD_NAME_INPUT.equals(currentFieldName)) {                     if (token == Token.VALUE_STRING) {                         inputs.add(parser.text()).                     } else if (token == Token.START_ARRAY) {                         while ((token = parser.nextToken()) != Token.END_ARRAY) {                             if (token == Token.VALUE_STRING) {                                 inputs.add(parser.text()).                             } else {                                 throw new IllegalArgumentException("input array must have string values, but was [" + token.name() + "]").                             }                         }                     } else {                         throw new IllegalArgumentException("input must be a string or array, but was [" + token.name() + "]").                     }                 } else if (Fields.CONTENT_FIELD_NAME_WEIGHT.equals(currentFieldName)) {                     final Number weightValue.                     if (token == Token.VALUE_STRING) {                         try {                             weightValue = Long.parseLong(parser.text()).                         } catch (NumberFormatException e) {                             throw new IllegalArgumentException("weight must be an integer, but was [" + parser.text() + "]").                         }                     } else if (token == Token.VALUE_NUMBER) {                         NumberType numberType = parser.numberType().                         if (NumberType.LONG != numberType && NumberType.INT != numberType) {                             throw new IllegalArgumentException("weight must be an integer, but was [" + parser.numberValue() + "]").                         }                         weightValue = parser.numberValue().                     } else {                         throw new IllegalArgumentException("weight must be a number or string, but was [" + token.name() + "]").                     }                     // always parse a long to make sure we don't get overflow                     if (weightValue.longValue() < 0 || weightValue.longValue() > Integer.MAX_VALUE) {                         throw new IllegalArgumentException("weight must be in the interval [0..2147483647], but was [" + weightValue.longValue() + "]").                     }                     weight = weightValue.intValue().                 } else if (Fields.CONTENT_FIELD_NAME_CONTEXTS.equals(currentFieldName)) {                     if (fieldType().hasContextMappings() == false) {                         throw new IllegalArgumentException("contexts field is not supported for field: [" + fieldType().name() + "]").                     }                     ContextMappings contextMappings = fieldType().getContextMappings().                     XContentParser.Token currentToken = parser.currentToken().                     if (currentToken == XContentParser.Token.START_OBJECT) {                         ContextMapping contextMapping = null.                         String fieldName = null.                         while ((currentToken = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                             if (currentToken == XContentParser.Token.FIELD_NAME) {                                 fieldName = parser.currentName().                                 contextMapping = contextMappings.get(fieldName).                             } else {                                 assert fieldName != null.                                 assert !contextsMap.containsKey(fieldName).                                 contextsMap.put(fieldName, contextMapping.parseContext(parseContext, parser)).                             }                         }                     } else {                         throw new IllegalArgumentException("contexts must be an object or an array , but was [" + currentToken + "]").                     }                 }             }         }         for (String input : inputs) {             if (inputMap.containsKey(input) == false || inputMap.get(input).weight < weight) {                 inputMap.put(input, new CompletionInputMetaData(input, contextsMap, weight)).             }         }     } else {         throw new ParsingException(parser.getTokenLocation(), "failed to parse [" + parser.currentName() + "]: expected text or object, but got " + token.name()).     } }
false;public;0;4;;@Override public String toString() {     return input. }
false;public;2;21;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(simpleName()).field(Fields.TYPE.getPreferredName(), CONTENT_TYPE).     builder.field(Fields.ANALYZER.getPreferredName(), fieldType().indexAnalyzer().name()).     if (fieldType().indexAnalyzer().name().equals(fieldType().searchAnalyzer().name()) == false) {         builder.field(Fields.SEARCH_ANALYZER.getPreferredName(), fieldType().searchAnalyzer().name()).     }     builder.field(Fields.PRESERVE_SEPARATORS.getPreferredName(), fieldType().preserveSep()).     builder.field(Fields.PRESERVE_POSITION_INCREMENTS.getPreferredName(), fieldType().preservePositionIncrements()).     builder.field(Fields.MAX_INPUT_LENGTH.getPreferredName(), this.maxInputLength).     if (fieldType().hasContextMappings()) {         builder.startArray(Fields.CONTEXTS.getPreferredName()).         fieldType().getContextMappings().toXContent(builder, params).         builder.endArray().     }     multiFields.toXContent(builder, params).     return builder.endObject(). }
false;protected;2;4;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException { // no-op }
false;protected;0;4;;@Override protected String contentType() {     return CONTENT_TYPE. }
false;protected;1;6;;@Override protected void doMerge(Mapper mergeWith) {     super.doMerge(mergeWith).     CompletionFieldMapper fieldMergeWith = (CompletionFieldMapper) mergeWith.     this.maxInputLength = fieldMergeWith.maxInputLength. }
