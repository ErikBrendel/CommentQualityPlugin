commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;4;;@Override protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {     return new ClusterStateUpdateResponse(acknowledged). }
false;public;1;4;;@Override public ClusterState execute(ClusterState currentState) {     return innerExecute(currentState, request.actions()). }
false;public;2;15;;public void indicesAliases(final IndicesAliasesClusterStateUpdateRequest request, final ActionListener<ClusterStateUpdateResponse> listener) {     clusterService.submitStateUpdateTask("index-aliases", new AckedClusterStateUpdateTask<ClusterStateUpdateResponse>(Priority.URGENT, request, listener) {          @Override         protected ClusterStateUpdateResponse newResponse(boolean acknowledged) {             return new ClusterStateUpdateResponse(acknowledged).         }          @Override         public ClusterState execute(ClusterState currentState) {             return innerExecute(currentState, request.actions()).         }     }). }
false;;2;79;;ClusterState innerExecute(ClusterState currentState, Iterable<AliasAction> actions) {     List<Index> indicesToClose = new ArrayList<>().     Map<String, IndexService> indices = new HashMap<>().     try {         boolean changed = false.         // Gather all the indexes that must be removed first so:         // 1. We don't cause error when attempting to replace an index with a alias of the same name.         // 2. We don't allow removal of aliases from indexes that we're just going to delete anyway. That'd be silly.         Set<Index> indicesToDelete = new HashSet<>().         for (AliasAction action : actions) {             if (action.removeIndex()) {                 IndexMetaData index = currentState.metaData().getIndices().get(action.getIndex()).                 if (index == null) {                     throw new IndexNotFoundException(action.getIndex()).                 }                 indicesToDelete.add(index.getIndex()).                 changed = true.             }         }         // Remove the indexes if there are any to remove         if (changed) {             currentState = deleteIndexService.deleteIndices(currentState, indicesToDelete).         }         MetaData.Builder metadata = MetaData.builder(currentState.metaData()).         // Run the remaining alias actions         for (AliasAction action : actions) {             if (action.removeIndex()) {                 // Handled above                 continue.             }             IndexMetaData index = metadata.get(action.getIndex()).             if (index == null) {                 throw new IndexNotFoundException(action.getIndex()).             }             NewAliasValidator newAliasValidator = (alias, indexRouting, filter, writeIndex) -> {                 /* It is important that we look up the index using the metadata builder we are modifying so we can remove an                      * index and replace it with an alias. */                 Function<String, IndexMetaData> indexLookup = name -> metadata.get(name).                 aliasValidator.validateAlias(alias, action.getIndex(), indexRouting, indexLookup).                 if (Strings.hasLength(filter)) {                     IndexService indexService = indices.get(index.getIndex().getName()).                     if (indexService == null) {                         indexService = indicesService.indexService(index.getIndex()).                         if (indexService == null) {                             // temporarily create the index and add mappings so we can parse the filter                             try {                                 indexService = indicesService.createIndex(index, emptyList()).                                 indicesToClose.add(index.getIndex()).                             } catch (IOException e) {                                 throw new ElasticsearchException("Failed to create temporary index for parsing the alias", e).                             }                             indexService.mapperService().merge(index, MapperService.MergeReason.MAPPING_RECOVERY).                         }                         indices.put(action.getIndex(), indexService).                     }                     // the context is only used for validation so it's fine to pass fake values for the shard id and the current                     // timestamp                     aliasValidator.validateAliasFilter(alias, filter, indexService.newQueryShardContext(0, null, () -> 0L, null), xContentRegistry).                 }             }.             changed |= action.apply(newAliasValidator, metadata, index).         }         if (changed) {             ClusterState updatedState = ClusterState.builder(currentState).metaData(metadata).build().             // i.e. remove and add the same alias to the same index             if (!updatedState.metaData().equalsAliases(currentState.metaData())) {                 return updatedState.             }         }         return currentState.     } finally {         for (Index index : indicesToClose) {             indicesService.removeIndex(index, NO_LONGER_ASSIGNED, "created for alias processing").         }     } }
