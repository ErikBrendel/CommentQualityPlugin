commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected String executor() {     // we go async right away...     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected AcknowledgedResponse newResponse() {     return new AcknowledgedResponse(). }
false;protected;2;8;;@Override protected ClusterBlockException checkBlock(IndicesAliasesRequest request, ClusterState state) {     Set<String> indices = new HashSet<>().     for (AliasActions aliasAction : request.aliasActions()) {         Collections.addAll(indices, aliasAction.indices()).     }     return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_WRITE, indices.toArray(new String[indices.size()])). }
false;public;1;4;;@Override public void onResponse(ClusterStateUpdateResponse response) {     listener.onResponse(new AcknowledgedResponse(response.isAcknowledged())). }
false;public;1;5;;@Override public void onFailure(Exception t) {     logger.debug("failed to perform aliases", t).     listener.onFailure(t). }
false;protected;3;54;;@Override protected void masterOperation(final IndicesAliasesRequest request, final ClusterState state, final ActionListener<AcknowledgedResponse> listener) {     // Expand the indices names     List<AliasActions> actions = request.aliasActions().     List<AliasAction> finalActions = new ArrayList<>().     // Resolve all the AliasActions into AliasAction instances and gather all the aliases     Set<String> aliases = new HashSet<>().     for (AliasActions action : actions) {         String[] concreteIndices = indexNameExpressionResolver.concreteIndexNames(state, request.indicesOptions(), action.indices()).         Collections.addAll(aliases, action.getOriginalAliases()).         for (String index : concreteIndices) {             switch(action.actionType()) {                 case ADD:                     for (String alias : concreteAliases(action, state.metaData(), index)) {                         finalActions.add(new AliasAction.Add(index, alias, action.filter(), action.indexRouting(), action.searchRouting(), action.writeIndex())).                     }                     break.                 case REMOVE:                     for (String alias : concreteAliases(action, state.metaData(), index)) {                         finalActions.add(new AliasAction.Remove(index, alias)).                     }                     break.                 case REMOVE_INDEX:                     finalActions.add(new AliasAction.RemoveIndex(index)).                     break.                 default:                     throw new IllegalArgumentException("Unsupported action [" + action.actionType() + "]").             }         }     }     if (finalActions.isEmpty() && false == actions.isEmpty()) {         throw new AliasesNotFoundException(aliases.toArray(new String[aliases.size()])).     }     request.aliasActions().clear().     IndicesAliasesClusterStateUpdateRequest updateRequest = new IndicesAliasesClusterStateUpdateRequest(unmodifiableList(finalActions)).ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout()).     indexAliasesService.indicesAliases(updateRequest, new ActionListener<ClusterStateUpdateResponse>() {          @Override         public void onResponse(ClusterStateUpdateResponse response) {             listener.onResponse(new AcknowledgedResponse(response.isAcknowledged())).         }          @Override         public void onFailure(Exception t) {             logger.debug("failed to perform aliases", t).             listener.onFailure(t).         }     }). }
false;private,static;3;17;;private static String[] concreteAliases(AliasActions action, MetaData metaData, String concreteIndex) {     if (action.expandAliasesWildcards()) {         // for DELETE we expand the aliases         String[] indexAsArray = { concreteIndex }.         ImmutableOpenMap<String, List<AliasMetaData>> aliasMetaData = metaData.findAliases(action, indexAsArray).         List<String> finalAliases = new ArrayList<>().         for (ObjectCursor<List<AliasMetaData>> curAliases : aliasMetaData.values()) {             for (AliasMetaData aliasMeta : curAliases.value) {                 finalAliases.add(aliasMeta.alias()).             }         }         return finalAliases.toArray(new String[finalAliases.size()]).     } else {         // for ADD and REMOVE_INDEX we just return the current aliases         return action.aliases().     } }
