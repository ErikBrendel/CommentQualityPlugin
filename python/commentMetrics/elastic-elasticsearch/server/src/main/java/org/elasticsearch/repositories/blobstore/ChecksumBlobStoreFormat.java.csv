commented;modifiers;parameterAmount;loc;comment;code
true;public;2;19;/**  * Reads blob with specified name without resolving the blobName using using {@link #blobName} method.  *  * @param blobContainer blob container  * @param blobName blob name  */ ;/**  * Reads blob with specified name without resolving the blobName using using {@link #blobName} method.  *  * @param blobContainer blob container  * @param blobName blob name  */ public T readBlob(BlobContainer blobContainer, String blobName) throws IOException {     try (InputStream inputStream = blobContainer.readBlob(blobName)) {         ByteArrayOutputStream out = new ByteArrayOutputStream().         Streams.copy(inputStream, out).         final byte[] bytes = out.toByteArray().         final String resourceDesc = "ChecksumBlobStoreFormat.readBlob(blob=\"" + blobName + "\")".         try (ByteArrayIndexInput indexInput = new ByteArrayIndexInput(resourceDesc, bytes)) {             CodecUtil.checksumEntireFile(indexInput).             CodecUtil.checkHeader(indexInput, codec, VERSION, VERSION).             long filePointer = indexInput.getFilePointer().             long contentSize = indexInput.length() - CodecUtil.footerLength() - filePointer.             BytesReference bytesReference = new BytesArray(bytes, (int) filePointer, (int) contentSize).             return read(bytesReference).         } catch (CorruptIndexException | IndexFormatTooOldException | IndexFormatTooNewException ex) {             // we trick this into a dedicated exception with the original stacktrace             throw new CorruptStateException(ex).         }     } }
true;public;3;8;/**  * Writes blob in atomic manner with resolving the blob name using {@link #blobName} method.  * <p>  * The blob will be compressed and checksum will be written if required.  *  * Atomic move might be very inefficient on some repositories. It also cannot override existing files.  *  * @param obj           object to be serialized  * @param blobContainer blob container  * @param name          blob name  */ ;/**  * Writes blob in atomic manner with resolving the blob name using {@link #blobName} method.  * <p>  * The blob will be compressed and checksum will be written if required.  *  * Atomic move might be very inefficient on some repositories. It also cannot override existing files.  *  * @param obj           object to be serialized  * @param blobContainer blob container  * @param name          blob name  */ public void writeAtomic(T obj, BlobContainer blobContainer, String name) throws IOException {     final String blobName = blobName(name).     writeTo(obj, blobName, bytesArray -> {         try (InputStream stream = bytesArray.streamInput()) {             blobContainer.writeBlobAtomic(blobName, stream, bytesArray.length(), true).         }     }). }
true;public;3;8;/**  * Writes blob with resolving the blob name using {@link #blobName} method.  * <p>  * The blob will be compressed and checksum will be written if required.  *  * @param obj           object to be serialized  * @param blobContainer blob container  * @param name          blob name  */ ;/**  * Writes blob with resolving the blob name using {@link #blobName} method.  * <p>  * The blob will be compressed and checksum will be written if required.  *  * @param obj           object to be serialized  * @param blobContainer blob container  * @param name          blob name  */ public void write(T obj, BlobContainer blobContainer, String name) throws IOException {     final String blobName = blobName(name).     writeTo(obj, blobName, bytesArray -> {         try (InputStream stream = bytesArray.streamInput()) {             blobContainer.writeBlob(blobName, stream, bytesArray.length(), true).         }     }). }
false;public;0;5;;@Override public void close() throws IOException { // this is important since some of the XContentBuilders write bytes on close. // in order to write the footer we need to prevent closing the actual index input. }
false;private;3;20;;private void writeTo(final T obj, final String blobName, final CheckedConsumer<BytesArray, IOException> consumer) throws IOException {     final BytesReference bytes = write(obj).     try (ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {         final String resourceDesc = "ChecksumBlobStoreFormat.writeBlob(blob=\"" + blobName + "\")".         try (OutputStreamIndexOutput indexOutput = new OutputStreamIndexOutput(resourceDesc, blobName, outputStream, BUFFER_SIZE)) {             CodecUtil.writeHeader(indexOutput, codec, VERSION).             try (OutputStream indexOutputOutputStream = new IndexOutputOutputStream(indexOutput) {                  @Override                 public void close() throws IOException {                 // this is important since some of the XContentBuilders write bytes on close.                 // in order to write the footer we need to prevent closing the actual index input.                 }             }) {                 bytes.writeTo(indexOutputOutputStream).             }             CodecUtil.writeFooter(indexOutput).         }         consumer.accept(new BytesArray(outputStream.toByteArray())).     } }
false;protected;1;12;;protected BytesReference write(T obj) throws IOException {     try (BytesStreamOutput bytesStreamOutput = new BytesStreamOutput()) {         if (compress) {             try (StreamOutput compressedStreamOutput = CompressorFactory.COMPRESSOR.streamOutput(bytesStreamOutput)) {                 write(obj, compressedStreamOutput).             }         } else {             write(obj, bytesStreamOutput).         }         return bytesStreamOutput.bytes().     } }
false;protected;2;7;;protected void write(T obj, StreamOutput streamOutput) throws IOException {     try (XContentBuilder builder = XContentFactory.contentBuilder(xContentType, streamOutput)) {         builder.startObject().         obj.toXContent(builder, SNAPSHOT_ONLY_FORMAT_PARAMS).         builder.endObject().     } }
