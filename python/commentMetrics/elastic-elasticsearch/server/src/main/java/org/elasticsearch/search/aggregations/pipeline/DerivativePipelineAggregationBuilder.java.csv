commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;10;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeOptionalString(format).     boolean hasGapPolicy = gapPolicy != null.     out.writeBoolean(hasGapPolicy).     if (hasGapPolicy) {         gapPolicy.writeTo(out).     }     out.writeOptionalString(units). }
false;public;1;7;;public DerivativePipelineAggregationBuilder format(String format) {     if (format == null) {         throw new IllegalArgumentException("[format] must not be null: [" + name + "]").     }     this.format = format.     return this. }
false;public;0;3;;public String format() {     return format. }
false;public;1;7;;public DerivativePipelineAggregationBuilder gapPolicy(GapPolicy gapPolicy) {     if (gapPolicy == null) {         throw new IllegalArgumentException("[gapPolicy] must not be null: [" + name + "]").     }     this.gapPolicy = gapPolicy.     return this. }
false;public;0;3;;public GapPolicy gapPolicy() {     return gapPolicy. }
false;public;1;7;;public DerivativePipelineAggregationBuilder unit(String units) {     if (units == null) {         throw new IllegalArgumentException("[units] must not be null: [" + name + "]").     }     this.units = units.     return this. }
false;public;1;7;;public DerivativePipelineAggregationBuilder unit(DateHistogramInterval units) {     if (units == null) {         throw new IllegalArgumentException("[units] must not be null: [" + name + "]").     }     this.units = units.toString().     return this. }
false;public;0;3;;public String unit() {     return units. }
false;protected;1;22;;@Override protected PipelineAggregator createInternal(Map<String, Object> metaData) throws IOException {     DocValueFormat formatter.     if (format != null) {         formatter = new DocValueFormat.Decimal(format).     } else {         formatter = DocValueFormat.RAW.     }     Long xAxisUnits = null.     if (units != null) {         Rounding.DateTimeUnit dateTimeUnit = DateHistogramAggregationBuilder.DATE_FIELD_UNITS.get(units).         if (dateTimeUnit != null) {             xAxisUnits = dateTimeUnit.getField().getBaseUnit().getDuration().toMillis().         } else {             TimeValue timeValue = TimeValue.parseTimeValue(units, null, getClass().getSimpleName() + ".unit").             if (timeValue != null) {                 xAxisUnits = timeValue.getMillis().             }         }     }     return new DerivativePipelineAggregator(name, bucketsPaths, formatter, gapPolicy, xAxisUnits, metaData). }
false;public;3;10;;@Override public void doValidate(AggregatorFactory<?> parent, Collection<AggregationBuilder> aggFactories, Collection<PipelineAggregationBuilder> pipelineAggregatoractories) {     if (bucketsPaths.length != 1) {         throw new IllegalStateException(PipelineAggregator.Parser.BUCKETS_PATH.getPreferredName() + " must contain a single entry for aggregation [" + name + "]").     }     validateSequentiallyOrderedParentAggs(parent, NAME, name). }
false;protected;2;13;;@Override protected XContentBuilder internalXContent(XContentBuilder builder, Params params) throws IOException {     if (format != null) {         builder.field(FORMAT_FIELD.getPreferredName(), format).     }     if (gapPolicy != null) {         builder.field(GAP_POLICY_FIELD.getPreferredName(), gapPolicy.getName()).     }     if (units != null) {         builder.field(UNIT_FIELD.getPreferredName(), units).     }     return builder. }
false;public,static;2;60;;public static DerivativePipelineAggregationBuilder parse(String pipelineAggregatorName, XContentParser parser) throws IOException {     XContentParser.Token token.     String currentFieldName = null.     String[] bucketsPaths = null.     String format = null.     String units = null.     GapPolicy gapPolicy = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.VALUE_STRING) {             if (FORMAT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 format = parser.text().             } else if (BUCKETS_PATH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 bucketsPaths = new String[] { parser.text() }.             } else if (GAP_POLICY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 gapPolicy = GapPolicy.parse(parser.text(), parser.getTokenLocation()).             } else if (UNIT_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 units = parser.text().             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + pipelineAggregatorName + "]: [" + currentFieldName + "].").             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (BUCKETS_PATH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 List<String> paths = new ArrayList<>().                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     String path = parser.text().                     paths.add(path).                 }                 bucketsPaths = paths.toArray(new String[paths.size()]).             } else {                 throw new ParsingException(parser.getTokenLocation(), "Unknown key for a " + token + " in [" + pipelineAggregatorName + "]: [" + currentFieldName + "].").             }         } else {             throw new ParsingException(parser.getTokenLocation(), "Unexpected token " + token + " in [" + pipelineAggregatorName + "].").         }     }     if (bucketsPaths == null) {         throw new ParsingException(parser.getTokenLocation(), "Missing required field [" + BUCKETS_PATH_FIELD.getPreferredName() + "] for derivative aggregation [" + pipelineAggregatorName + "]").     }     DerivativePipelineAggregationBuilder factory = new DerivativePipelineAggregationBuilder(pipelineAggregatorName, bucketsPaths[0]).     if (format != null) {         factory.format(format).     }     if (gapPolicy != null) {         factory.gapPolicy(gapPolicy).     }     if (units != null) {         factory.unit(units).     }     return factory. }
false;protected;1;14;;@Override protected boolean doEquals(Object obj) {     DerivativePipelineAggregationBuilder other = (DerivativePipelineAggregationBuilder) obj.     if (!Objects.equals(format, other.format)) {         return false.     }     if (!Objects.equals(gapPolicy, other.gapPolicy)) {         return false.     }     if (!Objects.equals(units, other.units)) {         return false.     }     return true. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(format, gapPolicy, units). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
