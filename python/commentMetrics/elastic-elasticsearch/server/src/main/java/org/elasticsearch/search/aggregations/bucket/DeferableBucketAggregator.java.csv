commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;21;;@Override protected void doPreCollection() throws IOException {     List<BucketCollector> collectors = new ArrayList<>().     List<BucketCollector> deferredCollectors = new ArrayList<>().     for (int i = 0. i < subAggregators.length. ++i) {         if (shouldDefer(subAggregators[i])) {             if (recordingWrapper == null) {                 recordingWrapper = getDeferringCollector().             }             deferredCollectors.add(subAggregators[i]).             subAggregators[i] = recordingWrapper.wrap(subAggregators[i]).         } else {             collectors.add(subAggregators[i]).         }     }     if (recordingWrapper != null) {         recordingWrapper.setDeferredCollector(deferredCollectors).         collectors.add(recordingWrapper).     }     collectableSubAggregators = MultiBucketCollector.wrap(collectors). }
false;public,static;1;9;;public static boolean descendsFromGlobalAggregator(Aggregator parent) {     while (parent != null) {         if (parent.getClass() == GlobalAggregator.class) {             return true.         }         parent = parent.parent().     }     return false. }
false;public;0;5;;public DeferringBucketCollector getDeferringCollector() {     // but an alternative defer policy may be based on best docs.     return new BestBucketsDeferringCollector(context(), descendsFromGlobalAggregator(parent())). }
true;protected;1;3;/**  * This method should be overridden by subclasses that want to defer  * calculation of a child aggregation until a first pass is complete and a  * set of buckets has been pruned. Deferring collection will require the  * recording of all doc/bucketIds from the first pass and then the sub class  * should call {@link #runDeferredCollections(long...)} for the selected set  * of buckets that survive the pruning.  *  * @param aggregator  *            the child aggregator  * @return true if the aggregator should be deferred until a first pass at  *         collection has completed  */ ;/**  * This method should be overridden by subclasses that want to defer  * calculation of a child aggregation until a first pass is complete and a  * set of buckets has been pruned. Deferring collection will require the  * recording of all doc/bucketIds from the first pass and then the sub class  * should call {@link #runDeferredCollections(long...)} for the selected set  * of buckets that survive the pruning.  *  * @param aggregator  *            the child aggregator  * @return true if the aggregator should be deferred until a first pass at  *         collection has completed  */ protected boolean shouldDefer(Aggregator aggregator) {     return false. }
false;protected,final;1;7;;protected final void runDeferredCollections(long... bucketOrds) throws IOException {     // collections to playback     if (recordingWrapper != null) {         recordingWrapper.replay(bucketOrds).     } }
