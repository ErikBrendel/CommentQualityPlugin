commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;8;/**  * Returns <code>true</code> iff one of the files exists otherwise <code>false</code>  */ ;/**  * Returns <code>true</code> iff one of the files exists otherwise <code>false</code>  */ public static boolean exists(Path... files) {     for (Path file : files) {         if (Files.exists(file)) {             return true.         }     }     return false. }
true;public,static;1;7;/**  * Check whether the file denoted by the given path is hidden.  * In practice, this will check if the file name starts with a dot.  * This should be preferred to {@link Files#isHidden(Path)} as this  * does not depend on the operating system.  */ ;/**  * Check whether the file denoted by the given path is hidden.  * In practice, this will check if the file name starts with a dot.  * This should be preferred to {@link Files#isHidden(Path)} as this  * does not depend on the operating system.  */ public static boolean isHidden(Path path) {     Path fileName = path.getFileName().     if (fileName == null) {         return false.     }     return fileName.toString().startsWith("."). }
true;public,static;1;3;/**  * Check whether the file denoted by the given path is a desktop services store created by Finder on macOS.  *  * @param path the path  * @return true if the current system is macOS and the specified file appears to be a desktop services store file  */ ;/**  * Check whether the file denoted by the given path is a desktop services store created by Finder on macOS.  *  * @param path the path  * @return true if the current system is macOS and the specified file appears to be a desktop services store file  */ public static boolean isDesktopServicesStore(final Path path) {     return Constants.MAC_OS_X && Files.isRegularFile(path) && ".DS_Store".equals(path.getFileName().toString()). }
true;public,static;3;9;/**  * Appends the path to the given base and strips N elements off the path if strip is &gt. 0.  */ ;/**  * Appends the path to the given base and strips N elements off the path if strip is &gt. 0.  */ public static Path append(Path base, Path path, int strip) {     for (Path subPath : path) {         if (strip-- > 0) {             continue.         }         base = base.resolve(subPath.toString()).     }     return base. }
true;public,static;1;11;/**  * Deletes all subdirectories in the given path recursively  * @throws java.lang.IllegalArgumentException if the given path is not a directory  */ ;/**  * Deletes all subdirectories in the given path recursively  * @throws java.lang.IllegalArgumentException if the given path is not a directory  */ public static void deleteSubDirectories(Path... paths) throws IOException {     for (Path path : paths) {         try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {             for (Path subPath : stream) {                 if (Files.isDirectory(subPath)) {                     IOUtils.rm(subPath).                 }             }         }     } }
true;public,static;2;17;/**  * Check that a directory exists, is a directory and is readable  * by the current user  */ ;/**  * Check that a directory exists, is a directory and is readable  * by the current user  */ public static boolean isAccessibleDirectory(Path directory, Logger logger) {     assert directory != null && logger != null.     if (!Files.exists(directory)) {         logger.debug("[{}] directory does not exist.", directory.toAbsolutePath()).         return false.     }     if (!Files.isDirectory(directory)) {         logger.debug("[{}] should be a directory but is not.", directory.toAbsolutePath()).         return false.     }     if (!Files.isReadable(directory)) {         logger.debug("[{}] directory is not readable.", directory.toAbsolutePath()).         return false.     }     return true. }
true;public,static;1;14;/**  * Returns an InputStream the given url if the url has a protocol of 'file' or 'jar', no host, and no port.  */ ;/**  * Returns an InputStream the given url if the url has a protocol of 'file' or 'jar', no host, and no port.  */ @SuppressForbidden(reason = "Will only open url streams for local files") public static InputStream openFileURLStream(URL url) throws IOException {     String protocol = url.getProtocol().     if ("file".equals(protocol) == false && "jar".equals(protocol) == false) {         throw new IllegalArgumentException("Invalid protocol [" + protocol + "], must be [file] or [jar]").     }     if (Strings.isEmpty(url.getHost()) == false) {         throw new IllegalArgumentException("URL cannot have host. Found: [" + url.getHost() + ']').     }     if (url.getPort() != -1) {         throw new IllegalArgumentException("URL cannot have port. Found: [" + url.getPort() + ']').     }     return url.openStream(). }
true;public,static;2;5;/**  * Returns an array of all files in the given directory matching.  */ ;/**  * Returns an array of all files in the given directory matching.  */ public static Path[] files(Path from, DirectoryStream.Filter<Path> filter) throws IOException {     try (DirectoryStream<Path> stream = Files.newDirectoryStream(from, filter)) {         return toArray(stream).     } }
true;public,static;1;5;/**  * Returns an array of all files in the given directory.  */ ;/**  * Returns an array of all files in the given directory.  */ public static Path[] files(Path directory) throws IOException {     try (DirectoryStream<Path> stream = Files.newDirectoryStream(directory)) {         return toArray(stream).     } }
true;public,static;2;5;/**  * Returns an array of all files in the given directory matching the glob.  */ ;/**  * Returns an array of all files in the given directory matching the glob.  */ public static Path[] files(Path directory, String glob) throws IOException {     try (DirectoryStream<Path> stream = Files.newDirectoryStream(directory, glob)) {         return toArray(stream).     } }
false;private,static;1;3;;private static Path[] toArray(DirectoryStream<Path> stream) {     return StreamSupport.stream(stream.spliterator(), false).toArray(length -> new Path[length]). }
