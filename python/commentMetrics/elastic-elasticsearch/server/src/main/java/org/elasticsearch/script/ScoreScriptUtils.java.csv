commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;3;;/**  * *** STATIC FUNCTIONS that can be used by users for score calculations *  */ public static double saturation(double value, double k) {     return value / (k + value). }
true;public,static;3;3;/**  * Calculate a sigmoid of <code>value</code>  * with scaling parameters <code>k</code> and <code>a</code>  */ ;/**  * Calculate a sigmoid of <code>value</code>  * with scaling parameters <code>k</code> and <code>a</code>  */ public static double sigmoid(double value, double k, double a) {     return Math.pow(value, a) / (Math.pow(k, a) + Math.pow(value, a)). }
true;public,static;2;4;// reproducible random ;// reproducible random public static double randomReproducible(String seedValue, int seed) {     int hash = StringHelper.murmurhash3_x86_32(new BytesRef(seedValue), seed).     // only use the lower 24 bits to construct a float from 0.0-1.0     return (hash & 0x00FFFFFF) / (float) (1 << 24). }
false;public;0;3;;public double randomNotReproducible() {     return rnd.nextDouble(). }
false;public;1;5;;public double decayGeoLinear(GeoPoint docValue) {     double distance = GeoDistance.ARC.calculate(originLat, originLon, docValue.lat(), docValue.lon(), DistanceUnit.METERS).     distance = Math.max(0.0d, distance - offset).     return Math.max(0.0, (scaling - distance) / scaling). }
false;public;1;5;;public double decayGeoExp(GeoPoint docValue) {     double distance = GeoDistance.ARC.calculate(originLat, originLon, docValue.lat(), docValue.lon(), DistanceUnit.METERS).     distance = Math.max(0.0d, distance - offset).     return Math.exp(scaling * distance). }
false;public;1;5;;public double decayGeoGauss(GeoPoint docValue) {     double distance = GeoDistance.ARC.calculate(originLat, originLon, docValue.lat(), docValue.lon(), DistanceUnit.METERS).     distance = Math.max(0.0d, distance - offset).     return Math.exp(0.5 * Math.pow(distance, 2.0) / scaling). }
false;public;1;4;;public double decayNumericLinear(double docValue) {     double distance = Math.max(0.0d, Math.abs(docValue - origin) - offset).     return Math.max(0.0, (scaling - distance) / scaling). }
false;public;1;4;;public double decayNumericExp(double docValue) {     double distance = Math.max(0.0d, Math.abs(docValue - origin) - offset).     return Math.exp(scaling * distance). }
false;public;1;4;;public double decayNumericGauss(double docValue) {     double distance = Math.max(0.0d, Math.abs(docValue - origin) - offset).     return Math.exp(0.5 * Math.pow(distance, 2.0) / scaling). }
false;public;1;7;;public double decayDateLinear(JodaCompatibleZonedDateTime docValueDate) {     long docValue = docValueDate.toInstant().toEpochMilli().     // as java.lang.Math#abs(long) is a forbidden API, have to use this comparison instead     long diff = (docValue >= origin) ? (docValue - origin) : (origin - docValue).     long distance = Math.max(0, diff - offset).     return Math.max(0.0, (scaling - distance) / scaling). }
false;public;1;6;;public double decayDateExp(JodaCompatibleZonedDateTime docValueDate) {     long docValue = docValueDate.toInstant().toEpochMilli().     long diff = (docValue >= origin) ? (docValue - origin) : (origin - docValue).     long distance = Math.max(0, diff - offset).     return Math.exp(scaling * distance). }
false;public;1;6;;public double decayDateGauss(JodaCompatibleZonedDateTime docValueDate) {     long docValue = docValueDate.toInstant().toEpochMilli().     long diff = (docValue >= origin) ? (docValue - origin) : (origin - docValue).     long distance = Math.max(0, diff - offset).     return Math.exp(0.5 * Math.pow(distance, 2.0) / scaling). }
