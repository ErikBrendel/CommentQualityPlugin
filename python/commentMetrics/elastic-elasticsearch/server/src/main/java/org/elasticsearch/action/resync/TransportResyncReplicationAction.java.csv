commented;modifiers;parameterAmount;loc;comment;code
false;protected;5;14;;@Override protected void registerRequestHandlers(String actionName, TransportService transportService, Supplier<ResyncReplicationRequest> request, Supplier<ResyncReplicationRequest> replicaRequest, String executor) {     transportService.registerRequestHandler(actionName, request, ThreadPool.Names.SAME, new OperationTransportHandler()).     // we should never reject resync because of thread pool capacity on primary     transportService.registerRequestHandler(transportPrimaryAction, () -> new ConcreteShardRequest<>(request), executor, true, true, new PrimaryOperationTransportHandler()).     transportService.registerRequestHandler(transportReplicaAction, () -> new ConcreteReplicaRequest<>(replicaRequest), executor, true, true, new ReplicaOperationTransportHandler()). }
false;protected;0;4;;@Override protected ResyncReplicationResponse newResponseInstance() {     return new ResyncReplicationResponse(). }
false;protected;1;4;;@Override protected ReplicationOperation.Replicas newReplicasProxy(long primaryTerm) {     return new ResyncActionReplicasProxy(primaryTerm). }
false;protected;3;12;;@Override protected void sendReplicaRequest(final ConcreteReplicaRequest<ResyncReplicationRequest> replicaRequest, final DiscoveryNode node, final ActionListener<ReplicationOperation.ReplicaResponse> listener) {     if (node.getVersion().onOrAfter(Version.V_6_0_0_alpha1)) {         super.sendReplicaRequest(replicaRequest, node, listener).     } else {         final long pre60NodeCheckpoint = SequenceNumbers.PRE_60_NODE_CHECKPOINT.         listener.onResponse(new ReplicaResponse(pre60NodeCheckpoint, pre60NodeCheckpoint)).     } }
false;protected;0;5;;@Override protected ClusterBlockLevel globalBlockLevel() {     // resync should never be blocked because it's an internal action     return null. }
false;public;0;5;;@Override public ClusterBlockLevel indexBlockLevel() {     // resync should never be blocked because it's an internal action     return null. }
false;protected;2;6;;@Override protected WritePrimaryResult<ResyncReplicationRequest, ResyncReplicationResponse> shardOperationOnPrimary(ResyncReplicationRequest request, IndexShard primary) throws Exception {     final ResyncReplicationRequest replicaRequest = performOnPrimary(request, primary).     return new WritePrimaryResult<>(replicaRequest, new ResyncReplicationResponse(), null, null, primary, logger). }
false;public,static;2;3;;public static ResyncReplicationRequest performOnPrimary(ResyncReplicationRequest request, IndexShard primary) {     return request. }
false;protected;2;5;;@Override protected WriteReplicaResult shardOperationOnReplica(ResyncReplicationRequest request, IndexShard replica) throws Exception {     Translog.Location location = performOnReplica(request, replica).     return new WriteReplicaResult(request, location, null, replica, logger). }
false;public,static;2;21;;public static Translog.Location performOnReplica(ResyncReplicationRequest request, IndexShard replica) throws Exception {     Translog.Location location = null.     /*          * Operations received from resync do not have auto_id_timestamp individually, we need to bootstrap this max_seen_timestamp          * (at least the highest timestamp from any of these operations) to make sure that we will disable optimization for the same          * append-only requests with timestamp (sources of these operations) that are replicated. otherwise we may have duplicates.          */     replica.updateMaxUnsafeAutoIdTimestamp(request.getMaxSeenAutoIdTimestampOnPrimary()).     for (Translog.Operation operation : request.getOperations()) {         final Engine.Result operationResult = replica.applyTranslogOperation(operation, Engine.Operation.Origin.REPLICA).         if (operationResult.getResultType() == Engine.Result.Type.MAPPING_UPDATE_REQUIRED) {             throw new TransportReplicationAction.RetryOnReplicaException(replica.shardId(), "Mappings are not available on the replica yet, triggered update: " + operationResult.getRequiredMappingUpdate()).         }         location = syncOperationResultOrThrow(operationResult, location).     }     if (request.getTrimAboveSeqNo() != SequenceNumbers.UNASSIGNED_SEQ_NO) {         replica.trimOperationOfPreviousPrimaryTerms(request.getTrimAboveSeqNo()).     }     return location. }
false;public;1;6;;@Override public ResyncReplicationResponse read(StreamInput in) throws IOException {     ResyncReplicationResponse response = newResponseInstance().     response.readFrom(in).     return response. }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;public;1;13;;@Override public void handleResponse(ResyncReplicationResponse response) {     final ReplicationResponse.ShardInfo.Failure[] failures = response.getShardInfo().getFailures().     // noinspection ForLoopReplaceableByForEach     for (int i = 0. i < failures.length. i++) {         final ReplicationResponse.ShardInfo.Failure f = failures[i].         logger.info(new ParameterizedMessage("{} primary-replica resync to replica on node [{}] failed", f.fullShardId(), f.nodeId()), f.getCause()).     }     listener.onResponse(response). }
false;public;1;4;;@Override public void handleException(TransportException exp) {     listener.onFailure(exp). }
false;public;5;43;;@Override public void sync(ResyncReplicationRequest request, Task parentTask, String primaryAllocationId, long primaryTerm, ActionListener<ResyncReplicationResponse> listener) {     // skip reroute phase     transportService.sendChildRequest(clusterService.localNode(), transportPrimaryAction, new ConcreteShardRequest<>(request, primaryAllocationId, primaryTerm), parentTask, transportOptions, new TransportResponseHandler<ResyncReplicationResponse>() {          @Override         public ResyncReplicationResponse read(StreamInput in) throws IOException {             ResyncReplicationResponse response = newResponseInstance().             response.readFrom(in).             return response.         }          @Override         public String executor() {             return ThreadPool.Names.SAME.         }          @Override         public void handleResponse(ResyncReplicationResponse response) {             final ReplicationResponse.ShardInfo.Failure[] failures = response.getShardInfo().getFailures().             // noinspection ForLoopReplaceableByForEach             for (int i = 0. i < failures.length. i++) {                 final ReplicationResponse.ShardInfo.Failure f = failures[i].                 logger.info(new ParameterizedMessage("{} primary-replica resync to replica on node [{}] failed", f.fullShardId(), f.nodeId()), f.getCause()).             }             listener.onResponse(response).         }          @Override         public void handleException(TransportException exp) {             listener.onFailure(exp).         }     }). }
false;public;6;6;;@Override public void failShardIfNeeded(ShardRouting replica, String message, Exception exception, Runnable onSuccess, Consumer<Exception> onPrimaryDemoted, Consumer<Exception> onIgnoredFailure) {     shardStateAction.remoteShardFailed(replica.shardId(), replica.allocationId().getId(), primaryTerm, false, message, exception, createShardActionListener(onSuccess, onPrimaryDemoted, onIgnoredFailure)). }
