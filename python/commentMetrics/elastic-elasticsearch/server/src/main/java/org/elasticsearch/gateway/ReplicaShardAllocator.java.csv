# id;timestamp;commentText;codeText;commentWords;codeWords
ReplicaShardAllocator -> private static boolean isResponsibleFor(final ShardRouting shard);1524684173;Is the allocator responsible for allocating the given {@link ShardRouting}?;private static boolean isResponsibleFor(final ShardRouting shard) {_        return shard.primary() == false _                   && shard.unassigned() _                   _                   && shard.unassignedInfo().getReason() != UnassignedInfo.Reason.INDEX_CREATED__    };is,the,allocator,responsible,for,allocating,the,given,link,shard,routing;private,static,boolean,is,responsible,for,final,shard,routing,shard,return,shard,primary,false,shard,unassigned,shard,unassigned,info,get,reason,unassigned,info,reason
ReplicaShardAllocator -> private static boolean isResponsibleFor(final ShardRouting shard);1540847035;Is the allocator responsible for allocating the given {@link ShardRouting}?;private static boolean isResponsibleFor(final ShardRouting shard) {_        return shard.primary() == false _                   && shard.unassigned() _                   _                   && shard.unassignedInfo().getReason() != UnassignedInfo.Reason.INDEX_CREATED__    };is,the,allocator,responsible,for,allocating,the,given,link,shard,routing;private,static,boolean,is,responsible,for,final,shard,routing,shard,return,shard,primary,false,shard,unassigned,shard,unassigned,info,get,reason,unassigned,info,reason
ReplicaShardAllocator -> private static boolean isResponsibleFor(final ShardRouting shard);1541092382;Is the allocator responsible for allocating the given {@link ShardRouting}?;private static boolean isResponsibleFor(final ShardRouting shard) {_        return shard.primary() == false _                   && shard.unassigned() _                   _                   && shard.unassignedInfo().getReason() != UnassignedInfo.Reason.INDEX_CREATED__    };is,the,allocator,responsible,for,allocating,the,given,link,shard,routing;private,static,boolean,is,responsible,for,final,shard,routing,shard,return,shard,primary,false,shard,unassigned,shard,unassigned,info,get,reason,unassigned,info,reason
ReplicaShardAllocator -> private Tuple<Decision, Map<String, NodeAllocationResult>> canBeAllocatedToAtLeastOneNode(ShardRouting shard,                                                                                               RoutingAllocation allocation);1524684173;Determines if the shard can be allocated on at least one node based on the allocation deciders.__Returns the best allocation decision for allocating the shard on any node (i.e. YES if at least one_node decided YES, THROTTLE if at least one node decided THROTTLE, and NO if none of the nodes decided_YES or THROTTLE).  If in explain mode, also returns the node-level explanations as the second element_in the returned tuple.;private Tuple<Decision, Map<String, NodeAllocationResult>> canBeAllocatedToAtLeastOneNode(ShardRouting shard,_                                                                                              RoutingAllocation allocation) {_        Decision madeDecision = Decision.NO__        final boolean explain = allocation.debugDecision()__        Map<String, NodeAllocationResult> nodeDecisions = explain ? new HashMap<>() : null__        for (ObjectCursor<DiscoveryNode> cursor : allocation.nodes().getDataNodes().values()) {_            RoutingNode node = allocation.routingNodes().node(cursor.value.getId())__            if (node == null) {_                continue__            }_            _            _            Decision decision = allocation.deciders().canAllocate(shard, node, allocation)__            if (decision.type() == Decision.Type.YES && madeDecision.type() != Decision.Type.YES) {_                if (explain) {_                    madeDecision = decision__                } else {_                    return Tuple.tuple(decision, nodeDecisions)__                }_            } else if (madeDecision.type() == Decision.Type.NO && decision.type() == Decision.Type.THROTTLE) {_                madeDecision = decision__            }_            if (explain) {_                nodeDecisions.put(node.nodeId(), new NodeAllocationResult(node.node(), null, decision))__            }_        }_        return Tuple.tuple(madeDecision, nodeDecisions)__    };determines,if,the,shard,can,be,allocated,on,at,least,one,node,based,on,the,allocation,deciders,returns,the,best,allocation,decision,for,allocating,the,shard,on,any,node,i,e,yes,if,at,least,one,node,decided,yes,throttle,if,at,least,one,node,decided,throttle,and,no,if,none,of,the,nodes,decided,yes,or,throttle,if,in,explain,mode,also,returns,the,node,level,explanations,as,the,second,element,in,the,returned,tuple;private,tuple,decision,map,string,node,allocation,result,can,be,allocated,to,at,least,one,node,shard,routing,shard,routing,allocation,allocation,decision,made,decision,decision,no,final,boolean,explain,allocation,debug,decision,map,string,node,allocation,result,node,decisions,explain,new,hash,map,null,for,object,cursor,discovery,node,cursor,allocation,nodes,get,data,nodes,values,routing,node,node,allocation,routing,nodes,node,cursor,value,get,id,if,node,null,continue,decision,decision,allocation,deciders,can,allocate,shard,node,allocation,if,decision,type,decision,type,yes,made,decision,type,decision,type,yes,if,explain,made,decision,decision,else,return,tuple,tuple,decision,node,decisions,else,if,made,decision,type,decision,type,no,decision,type,decision,type,throttle,made,decision,decision,if,explain,node,decisions,put,node,node,id,new,node,allocation,result,node,node,null,decision,return,tuple,tuple,made,decision,node,decisions
ReplicaShardAllocator -> private Tuple<Decision, Map<String, NodeAllocationResult>> canBeAllocatedToAtLeastOneNode(ShardRouting shard,                                                                                               RoutingAllocation allocation);1540847035;Determines if the shard can be allocated on at least one node based on the allocation deciders.__Returns the best allocation decision for allocating the shard on any node (i.e. YES if at least one_node decided YES, THROTTLE if at least one node decided THROTTLE, and NO if none of the nodes decided_YES or THROTTLE).  If in explain mode, also returns the node-level explanations as the second element_in the returned tuple.;private Tuple<Decision, Map<String, NodeAllocationResult>> canBeAllocatedToAtLeastOneNode(ShardRouting shard,_                                                                                              RoutingAllocation allocation) {_        Decision madeDecision = Decision.NO__        final boolean explain = allocation.debugDecision()__        Map<String, NodeAllocationResult> nodeDecisions = explain ? new HashMap<>() : null__        for (ObjectCursor<DiscoveryNode> cursor : allocation.nodes().getDataNodes().values()) {_            RoutingNode node = allocation.routingNodes().node(cursor.value.getId())__            if (node == null) {_                continue__            }_            _            _            Decision decision = allocation.deciders().canAllocate(shard, node, allocation)__            if (decision.type() == Decision.Type.YES && madeDecision.type() != Decision.Type.YES) {_                if (explain) {_                    madeDecision = decision__                } else {_                    return Tuple.tuple(decision, nodeDecisions)__                }_            } else if (madeDecision.type() == Decision.Type.NO && decision.type() == Decision.Type.THROTTLE) {_                madeDecision = decision__            }_            if (explain) {_                nodeDecisions.put(node.nodeId(), new NodeAllocationResult(node.node(), null, decision))__            }_        }_        return Tuple.tuple(madeDecision, nodeDecisions)__    };determines,if,the,shard,can,be,allocated,on,at,least,one,node,based,on,the,allocation,deciders,returns,the,best,allocation,decision,for,allocating,the,shard,on,any,node,i,e,yes,if,at,least,one,node,decided,yes,throttle,if,at,least,one,node,decided,throttle,and,no,if,none,of,the,nodes,decided,yes,or,throttle,if,in,explain,mode,also,returns,the,node,level,explanations,as,the,second,element,in,the,returned,tuple;private,tuple,decision,map,string,node,allocation,result,can,be,allocated,to,at,least,one,node,shard,routing,shard,routing,allocation,allocation,decision,made,decision,decision,no,final,boolean,explain,allocation,debug,decision,map,string,node,allocation,result,node,decisions,explain,new,hash,map,null,for,object,cursor,discovery,node,cursor,allocation,nodes,get,data,nodes,values,routing,node,node,allocation,routing,nodes,node,cursor,value,get,id,if,node,null,continue,decision,decision,allocation,deciders,can,allocate,shard,node,allocation,if,decision,type,decision,type,yes,made,decision,type,decision,type,yes,if,explain,made,decision,decision,else,return,tuple,tuple,decision,node,decisions,else,if,made,decision,type,decision,type,no,decision,type,decision,type,throttle,made,decision,decision,if,explain,node,decisions,put,node,node,id,new,node,allocation,result,node,node,null,decision,return,tuple,tuple,made,decision,node,decisions
ReplicaShardAllocator -> private Tuple<Decision, Map<String, NodeAllocationResult>> canBeAllocatedToAtLeastOneNode(ShardRouting shard,                                                                                               RoutingAllocation allocation);1541092382;Determines if the shard can be allocated on at least one node based on the allocation deciders.__Returns the best allocation decision for allocating the shard on any node (i.e. YES if at least one_node decided YES, THROTTLE if at least one node decided THROTTLE, and NO if none of the nodes decided_YES or THROTTLE).  If in explain mode, also returns the node-level explanations as the second element_in the returned tuple.;private Tuple<Decision, Map<String, NodeAllocationResult>> canBeAllocatedToAtLeastOneNode(ShardRouting shard,_                                                                                              RoutingAllocation allocation) {_        Decision madeDecision = Decision.NO__        final boolean explain = allocation.debugDecision()__        Map<String, NodeAllocationResult> nodeDecisions = explain ? new HashMap<>() : null__        for (ObjectCursor<DiscoveryNode> cursor : allocation.nodes().getDataNodes().values()) {_            RoutingNode node = allocation.routingNodes().node(cursor.value.getId())__            if (node == null) {_                continue__            }_            _            _            Decision decision = allocation.deciders().canAllocate(shard, node, allocation)__            if (decision.type() == Decision.Type.YES && madeDecision.type() != Decision.Type.YES) {_                if (explain) {_                    madeDecision = decision__                } else {_                    return Tuple.tuple(decision, nodeDecisions)__                }_            } else if (madeDecision.type() == Decision.Type.NO && decision.type() == Decision.Type.THROTTLE) {_                madeDecision = decision__            }_            if (explain) {_                nodeDecisions.put(node.nodeId(), new NodeAllocationResult(node.node(), null, decision))__            }_        }_        return Tuple.tuple(madeDecision, nodeDecisions)__    };determines,if,the,shard,can,be,allocated,on,at,least,one,node,based,on,the,allocation,deciders,returns,the,best,allocation,decision,for,allocating,the,shard,on,any,node,i,e,yes,if,at,least,one,node,decided,yes,throttle,if,at,least,one,node,decided,throttle,and,no,if,none,of,the,nodes,decided,yes,or,throttle,if,in,explain,mode,also,returns,the,node,level,explanations,as,the,second,element,in,the,returned,tuple;private,tuple,decision,map,string,node,allocation,result,can,be,allocated,to,at,least,one,node,shard,routing,shard,routing,allocation,allocation,decision,made,decision,decision,no,final,boolean,explain,allocation,debug,decision,map,string,node,allocation,result,node,decisions,explain,new,hash,map,null,for,object,cursor,discovery,node,cursor,allocation,nodes,get,data,nodes,values,routing,node,node,allocation,routing,nodes,node,cursor,value,get,id,if,node,null,continue,decision,decision,allocation,deciders,can,allocate,shard,node,allocation,if,decision,type,decision,type,yes,made,decision,type,decision,type,yes,if,explain,made,decision,decision,else,return,tuple,tuple,decision,node,decisions,else,if,made,decision,type,decision,type,no,decision,type,decision,type,throttle,made,decision,decision,if,explain,node,decisions,put,node,node,id,new,node,allocation,result,node,node,null,decision,return,tuple,tuple,made,decision,node,decisions
ReplicaShardAllocator -> private List<NodeAllocationResult> augmentExplanationsWithStoreInfo(Map<String, NodeAllocationResult> nodeDecisions,                                                                         Map<String, NodeAllocationResult> withShardStores);1524684173;Takes the store info for nodes that have a shard store and adds them to the node decisions,_leaving the node explanations untouched for those nodes that do not have any store information.;private List<NodeAllocationResult> augmentExplanationsWithStoreInfo(Map<String, NodeAllocationResult> nodeDecisions,_                                                                        Map<String, NodeAllocationResult> withShardStores) {_        if (nodeDecisions == null || withShardStores == null) {_            return null__        }_        List<NodeAllocationResult> augmented = new ArrayList<>()__        for (Map.Entry<String, NodeAllocationResult> entry : nodeDecisions.entrySet()) {_            if (withShardStores.containsKey(entry.getKey())) {_                augmented.add(withShardStores.get(entry.getKey()))__            } else {_                augmented.add(entry.getValue())__            }_        }_        return augmented__    };takes,the,store,info,for,nodes,that,have,a,shard,store,and,adds,them,to,the,node,decisions,leaving,the,node,explanations,untouched,for,those,nodes,that,do,not,have,any,store,information;private,list,node,allocation,result,augment,explanations,with,store,info,map,string,node,allocation,result,node,decisions,map,string,node,allocation,result,with,shard,stores,if,node,decisions,null,with,shard,stores,null,return,null,list,node,allocation,result,augmented,new,array,list,for,map,entry,string,node,allocation,result,entry,node,decisions,entry,set,if,with,shard,stores,contains,key,entry,get,key,augmented,add,with,shard,stores,get,entry,get,key,else,augmented,add,entry,get,value,return,augmented
ReplicaShardAllocator -> private List<NodeAllocationResult> augmentExplanationsWithStoreInfo(Map<String, NodeAllocationResult> nodeDecisions,                                                                         Map<String, NodeAllocationResult> withShardStores);1540847035;Takes the store info for nodes that have a shard store and adds them to the node decisions,_leaving the node explanations untouched for those nodes that do not have any store information.;private List<NodeAllocationResult> augmentExplanationsWithStoreInfo(Map<String, NodeAllocationResult> nodeDecisions,_                                                                        Map<String, NodeAllocationResult> withShardStores) {_        if (nodeDecisions == null || withShardStores == null) {_            return null__        }_        List<NodeAllocationResult> augmented = new ArrayList<>()__        for (Map.Entry<String, NodeAllocationResult> entry : nodeDecisions.entrySet()) {_            if (withShardStores.containsKey(entry.getKey())) {_                augmented.add(withShardStores.get(entry.getKey()))__            } else {_                augmented.add(entry.getValue())__            }_        }_        return augmented__    };takes,the,store,info,for,nodes,that,have,a,shard,store,and,adds,them,to,the,node,decisions,leaving,the,node,explanations,untouched,for,those,nodes,that,do,not,have,any,store,information;private,list,node,allocation,result,augment,explanations,with,store,info,map,string,node,allocation,result,node,decisions,map,string,node,allocation,result,with,shard,stores,if,node,decisions,null,with,shard,stores,null,return,null,list,node,allocation,result,augmented,new,array,list,for,map,entry,string,node,allocation,result,entry,node,decisions,entry,set,if,with,shard,stores,contains,key,entry,get,key,augmented,add,with,shard,stores,get,entry,get,key,else,augmented,add,entry,get,value,return,augmented
ReplicaShardAllocator -> private List<NodeAllocationResult> augmentExplanationsWithStoreInfo(Map<String, NodeAllocationResult> nodeDecisions,                                                                         Map<String, NodeAllocationResult> withShardStores);1541092382;Takes the store info for nodes that have a shard store and adds them to the node decisions,_leaving the node explanations untouched for those nodes that do not have any store information.;private List<NodeAllocationResult> augmentExplanationsWithStoreInfo(Map<String, NodeAllocationResult> nodeDecisions,_                                                                        Map<String, NodeAllocationResult> withShardStores) {_        if (nodeDecisions == null || withShardStores == null) {_            return null__        }_        List<NodeAllocationResult> augmented = new ArrayList<>()__        for (Map.Entry<String, NodeAllocationResult> entry : nodeDecisions.entrySet()) {_            if (withShardStores.containsKey(entry.getKey())) {_                augmented.add(withShardStores.get(entry.getKey()))__            } else {_                augmented.add(entry.getValue())__            }_        }_        return augmented__    };takes,the,store,info,for,nodes,that,have,a,shard,store,and,adds,them,to,the,node,decisions,leaving,the,node,explanations,untouched,for,those,nodes,that,do,not,have,any,store,information;private,list,node,allocation,result,augment,explanations,with,store,info,map,string,node,allocation,result,node,decisions,map,string,node,allocation,result,with,shard,stores,if,node,decisions,null,with,shard,stores,null,return,null,list,node,allocation,result,augmented,new,array,list,for,map,entry,string,node,allocation,result,entry,node,decisions,entry,set,if,with,shard,stores,contains,key,entry,get,key,augmented,add,with,shard,stores,get,entry,get,key,else,augmented,add,entry,get,value,return,augmented
ReplicaShardAllocator -> private TransportNodesListShardStoreMetaData.StoreFilesMetaData findStore(ShardRouting shard, RoutingAllocation allocation,                                                                               AsyncShardFetch.FetchResult<NodeStoreFilesMetaData> data);1540847035;Finds the store for the assigned shard in the fetched data, returns null if none is found.;private TransportNodesListShardStoreMetaData.StoreFilesMetaData findStore(ShardRouting shard, RoutingAllocation allocation,_                                                                              AsyncShardFetch.FetchResult<NodeStoreFilesMetaData> data) {_        assert shard.currentNodeId() != null__        DiscoveryNode primaryNode = allocation.nodes().get(shard.currentNodeId())__        if (primaryNode == null) {_            return null__        }_        NodeStoreFilesMetaData primaryNodeFilesStore = data.getData().get(primaryNode)__        if (primaryNodeFilesStore == null) {_            return null__        }_        return primaryNodeFilesStore.storeFilesMetaData()__    };finds,the,store,for,the,assigned,shard,in,the,fetched,data,returns,null,if,none,is,found;private,transport,nodes,list,shard,store,meta,data,store,files,meta,data,find,store,shard,routing,shard,routing,allocation,allocation,async,shard,fetch,fetch,result,node,store,files,meta,data,data,assert,shard,current,node,id,null,discovery,node,primary,node,allocation,nodes,get,shard,current,node,id,if,primary,node,null,return,null,node,store,files,meta,data,primary,node,files,store,data,get,data,get,primary,node,if,primary,node,files,store,null,return,null,return,primary,node,files,store,store,files,meta,data
ReplicaShardAllocator -> private TransportNodesListShardStoreMetaData.StoreFilesMetaData findStore(ShardRouting shard, RoutingAllocation allocation,                                                                               AsyncShardFetch.FetchResult<NodeStoreFilesMetaData> data);1541092382;Finds the store for the assigned shard in the fetched data, returns null if none is found.;private TransportNodesListShardStoreMetaData.StoreFilesMetaData findStore(ShardRouting shard, RoutingAllocation allocation,_                                                                              AsyncShardFetch.FetchResult<NodeStoreFilesMetaData> data) {_        assert shard.currentNodeId() != null__        DiscoveryNode primaryNode = allocation.nodes().get(shard.currentNodeId())__        if (primaryNode == null) {_            return null__        }_        NodeStoreFilesMetaData primaryNodeFilesStore = data.getData().get(primaryNode)__        if (primaryNodeFilesStore == null) {_            return null__        }_        return primaryNodeFilesStore.storeFilesMetaData()__    };finds,the,store,for,the,assigned,shard,in,the,fetched,data,returns,null,if,none,is,found;private,transport,nodes,list,shard,store,meta,data,store,files,meta,data,find,store,shard,routing,shard,routing,allocation,allocation,async,shard,fetch,fetch,result,node,store,files,meta,data,data,assert,shard,current,node,id,null,discovery,node,primary,node,allocation,nodes,get,shard,current,node,id,if,primary,node,null,return,null,node,store,files,meta,data,primary,node,files,store,data,get,data,get,primary,node,if,primary,node,files,store,null,return,null,return,primary,node,files,store,store,files,meta,data
ReplicaShardAllocator -> MatchingNodes -> public boolean hasAnyData();1524684173;Did we manage to find any data, regardless how well they matched or not.;public boolean hasAnyData() {_            return nodesToSize.isEmpty() == false__        };did,we,manage,to,find,any,data,regardless,how,well,they,matched,or,not;public,boolean,has,any,data,return,nodes,to,size,is,empty,false
ReplicaShardAllocator -> MatchingNodes -> public boolean hasAnyData();1540847035;Did we manage to find any data, regardless how well they matched or not.;public boolean hasAnyData() {_            return nodesToSize.isEmpty() == false__        };did,we,manage,to,find,any,data,regardless,how,well,they,matched,or,not;public,boolean,has,any,data,return,nodes,to,size,is,empty,false
ReplicaShardAllocator -> MatchingNodes -> public boolean hasAnyData();1541092382;Did we manage to find any data, regardless how well they matched or not.;public boolean hasAnyData() {_            return nodesToSize.isEmpty() == false__        };did,we,manage,to,find,any,data,regardless,how,well,they,matched,or,not;public,boolean,has,any,data,return,nodes,to,size,is,empty,false
ReplicaShardAllocator -> public void processExistingRecoveries(RoutingAllocation allocation);1524684173;Process existing recoveries of replicas and see if we need to cancel them if we find a better_match. Today, a better match is one that has full sync id match compared to not having one in_the previous recovery.;public void processExistingRecoveries(RoutingAllocation allocation) {_        MetaData metaData = allocation.metaData()__        RoutingNodes routingNodes = allocation.routingNodes()__        List<Runnable> shardCancellationActions = new ArrayList<>()__        for (RoutingNode routingNode : routingNodes) {_            for (ShardRouting shard : routingNode) {_                if (shard.primary()) {_                    continue__                }_                if (shard.initializing() == false) {_                    continue__                }_                if (shard.relocatingNodeId() != null) {_                    continue__                }__                _                if (shard.unassignedInfo() != null && shard.unassignedInfo().getReason() == UnassignedInfo.Reason.INDEX_CREATED) {_                    continue__                }__                AsyncShardFetch.FetchResult<NodeStoreFilesMetaData> shardStores = fetchData(shard, allocation)__                if (shardStores.hasData() == false) {_                    logger.trace("{}: fetching new stores for initializing shard", shard)__                    continue_ _                }__                ShardRouting primaryShard = allocation.routingNodes().activePrimary(shard.shardId())__                assert primaryShard != null : "the replica shard can be allocated on at least one node, so there must be an active primary"__                TransportNodesListShardStoreMetaData.StoreFilesMetaData primaryStore = findStore(primaryShard, allocation, shardStores)__                if (primaryStore == null) {_                    _                    _                    logger.trace("{}: no primary shard store found or allocated, letting actual allocation figure it out", shard)__                    continue__                }__                MatchingNodes matchingNodes = findMatchingNodes(shard, allocation, primaryStore, shardStores, false)__                if (matchingNodes.getNodeWithHighestMatch() != null) {_                    DiscoveryNode currentNode = allocation.nodes().get(shard.currentNodeId())__                    DiscoveryNode nodeWithHighestMatch = matchingNodes.getNodeWithHighestMatch()__                    _                    final String currentSyncId__                    if (shardStores.getData().containsKey(currentNode)) {_                        currentSyncId = shardStores.getData().get(currentNode).storeFilesMetaData().syncId()__                    } else {_                        currentSyncId = null__                    }_                    if (currentNode.equals(nodeWithHighestMatch) == false_                            && Objects.equals(currentSyncId, primaryStore.syncId()) == false_                            && matchingNodes.isNodeMatchBySyncID(nodeWithHighestMatch)) {_                        _                        _                        logger.debug("cancelling allocation of replica on [{}], sync id match found on node [{}]",_                                currentNode, nodeWithHighestMatch)__                        UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.REALLOCATED_REPLICA,_                            "existing allocation of replica to [" + currentNode + "] cancelled, sync id match found on node ["+ nodeWithHighestMatch + "]",_                            null, 0, allocation.getCurrentNanoTime(), System.currentTimeMillis(), false, UnassignedInfo.AllocationStatus.NO_ATTEMPT)__                        _                        shardCancellationActions.add(() -> routingNodes.failShard(logger, shard, unassignedInfo, metaData.getIndexSafe(shard.index()), allocation.changes()))__                    }_                }_            }_        }_        for (Runnable action : shardCancellationActions) {_            action.run()__        }_    };process,existing,recoveries,of,replicas,and,see,if,we,need,to,cancel,them,if,we,find,a,better,match,today,a,better,match,is,one,that,has,full,sync,id,match,compared,to,not,having,one,in,the,previous,recovery;public,void,process,existing,recoveries,routing,allocation,allocation,meta,data,meta,data,allocation,meta,data,routing,nodes,routing,nodes,allocation,routing,nodes,list,runnable,shard,cancellation,actions,new,array,list,for,routing,node,routing,node,routing,nodes,for,shard,routing,shard,routing,node,if,shard,primary,continue,if,shard,initializing,false,continue,if,shard,relocating,node,id,null,continue,if,shard,unassigned,info,null,shard,unassigned,info,get,reason,unassigned,info,reason,continue,async,shard,fetch,fetch,result,node,store,files,meta,data,shard,stores,fetch,data,shard,allocation,if,shard,stores,has,data,false,logger,trace,fetching,new,stores,for,initializing,shard,shard,continue,shard,routing,primary,shard,allocation,routing,nodes,active,primary,shard,shard,id,assert,primary,shard,null,the,replica,shard,can,be,allocated,on,at,least,one,node,so,there,must,be,an,active,primary,transport,nodes,list,shard,store,meta,data,store,files,meta,data,primary,store,find,store,primary,shard,allocation,shard,stores,if,primary,store,null,logger,trace,no,primary,shard,store,found,or,allocated,letting,actual,allocation,figure,it,out,shard,continue,matching,nodes,matching,nodes,find,matching,nodes,shard,allocation,primary,store,shard,stores,false,if,matching,nodes,get,node,with,highest,match,null,discovery,node,current,node,allocation,nodes,get,shard,current,node,id,discovery,node,node,with,highest,match,matching,nodes,get,node,with,highest,match,final,string,current,sync,id,if,shard,stores,get,data,contains,key,current,node,current,sync,id,shard,stores,get,data,get,current,node,store,files,meta,data,sync,id,else,current,sync,id,null,if,current,node,equals,node,with,highest,match,false,objects,equals,current,sync,id,primary,store,sync,id,false,matching,nodes,is,node,match,by,sync,id,node,with,highest,match,logger,debug,cancelling,allocation,of,replica,on,sync,id,match,found,on,node,current,node,node,with,highest,match,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,existing,allocation,of,replica,to,current,node,cancelled,sync,id,match,found,on,node,node,with,highest,match,null,0,allocation,get,current,nano,time,system,current,time,millis,false,unassigned,info,allocation,status,shard,cancellation,actions,add,routing,nodes,fail,shard,logger,shard,unassigned,info,meta,data,get,index,safe,shard,index,allocation,changes,for,runnable,action,shard,cancellation,actions,action,run
ReplicaShardAllocator -> public void processExistingRecoveries(RoutingAllocation allocation);1540847035;Process existing recoveries of replicas and see if we need to cancel them if we find a better_match. Today, a better match is one that has full sync id match compared to not having one in_the previous recovery.;public void processExistingRecoveries(RoutingAllocation allocation) {_        MetaData metaData = allocation.metaData()__        RoutingNodes routingNodes = allocation.routingNodes()__        List<Runnable> shardCancellationActions = new ArrayList<>()__        for (RoutingNode routingNode : routingNodes) {_            for (ShardRouting shard : routingNode) {_                if (shard.primary()) {_                    continue__                }_                if (shard.initializing() == false) {_                    continue__                }_                if (shard.relocatingNodeId() != null) {_                    continue__                }__                _                if (shard.unassignedInfo() != null && shard.unassignedInfo().getReason() == UnassignedInfo.Reason.INDEX_CREATED) {_                    continue__                }__                AsyncShardFetch.FetchResult<NodeStoreFilesMetaData> shardStores = fetchData(shard, allocation)__                if (shardStores.hasData() == false) {_                    logger.trace("{}: fetching new stores for initializing shard", shard)__                    continue_ _                }__                ShardRouting primaryShard = allocation.routingNodes().activePrimary(shard.shardId())__                assert primaryShard != null : "the replica shard can be allocated on at least one node, so there must be an active primary"__                TransportNodesListShardStoreMetaData.StoreFilesMetaData primaryStore = findStore(primaryShard, allocation, shardStores)__                if (primaryStore == null) {_                    _                    _                    logger.trace("{}: no primary shard store found or allocated, letting actual allocation figure it out", shard)__                    continue__                }__                MatchingNodes matchingNodes = findMatchingNodes(shard, allocation, primaryStore, shardStores, false)__                if (matchingNodes.getNodeWithHighestMatch() != null) {_                    DiscoveryNode currentNode = allocation.nodes().get(shard.currentNodeId())__                    DiscoveryNode nodeWithHighestMatch = matchingNodes.getNodeWithHighestMatch()__                    _                    final String currentSyncId__                    if (shardStores.getData().containsKey(currentNode)) {_                        currentSyncId = shardStores.getData().get(currentNode).storeFilesMetaData().syncId()__                    } else {_                        currentSyncId = null__                    }_                    if (currentNode.equals(nodeWithHighestMatch) == false_                            && Objects.equals(currentSyncId, primaryStore.syncId()) == false_                            && matchingNodes.isNodeMatchBySyncID(nodeWithHighestMatch)) {_                        _                        _                        logger.debug("cancelling allocation of replica on [{}], sync id match found on node [{}]",_                                currentNode, nodeWithHighestMatch)__                        UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.REALLOCATED_REPLICA,_                            "existing allocation of replica to [" + currentNode + "] cancelled, sync id match found on node ["+_                                nodeWithHighestMatch + "]",_                            null, 0, allocation.getCurrentNanoTime(), System.currentTimeMillis(), false,_                            UnassignedInfo.AllocationStatus.NO_ATTEMPT)__                        _                        shardCancellationActions.add(() -> routingNodes.failShard(logger, shard, unassignedInfo,_                            metaData.getIndexSafe(shard.index()), allocation.changes()))__                    }_                }_            }_        }_        for (Runnable action : shardCancellationActions) {_            action.run()__        }_    };process,existing,recoveries,of,replicas,and,see,if,we,need,to,cancel,them,if,we,find,a,better,match,today,a,better,match,is,one,that,has,full,sync,id,match,compared,to,not,having,one,in,the,previous,recovery;public,void,process,existing,recoveries,routing,allocation,allocation,meta,data,meta,data,allocation,meta,data,routing,nodes,routing,nodes,allocation,routing,nodes,list,runnable,shard,cancellation,actions,new,array,list,for,routing,node,routing,node,routing,nodes,for,shard,routing,shard,routing,node,if,shard,primary,continue,if,shard,initializing,false,continue,if,shard,relocating,node,id,null,continue,if,shard,unassigned,info,null,shard,unassigned,info,get,reason,unassigned,info,reason,continue,async,shard,fetch,fetch,result,node,store,files,meta,data,shard,stores,fetch,data,shard,allocation,if,shard,stores,has,data,false,logger,trace,fetching,new,stores,for,initializing,shard,shard,continue,shard,routing,primary,shard,allocation,routing,nodes,active,primary,shard,shard,id,assert,primary,shard,null,the,replica,shard,can,be,allocated,on,at,least,one,node,so,there,must,be,an,active,primary,transport,nodes,list,shard,store,meta,data,store,files,meta,data,primary,store,find,store,primary,shard,allocation,shard,stores,if,primary,store,null,logger,trace,no,primary,shard,store,found,or,allocated,letting,actual,allocation,figure,it,out,shard,continue,matching,nodes,matching,nodes,find,matching,nodes,shard,allocation,primary,store,shard,stores,false,if,matching,nodes,get,node,with,highest,match,null,discovery,node,current,node,allocation,nodes,get,shard,current,node,id,discovery,node,node,with,highest,match,matching,nodes,get,node,with,highest,match,final,string,current,sync,id,if,shard,stores,get,data,contains,key,current,node,current,sync,id,shard,stores,get,data,get,current,node,store,files,meta,data,sync,id,else,current,sync,id,null,if,current,node,equals,node,with,highest,match,false,objects,equals,current,sync,id,primary,store,sync,id,false,matching,nodes,is,node,match,by,sync,id,node,with,highest,match,logger,debug,cancelling,allocation,of,replica,on,sync,id,match,found,on,node,current,node,node,with,highest,match,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,existing,allocation,of,replica,to,current,node,cancelled,sync,id,match,found,on,node,node,with,highest,match,null,0,allocation,get,current,nano,time,system,current,time,millis,false,unassigned,info,allocation,status,shard,cancellation,actions,add,routing,nodes,fail,shard,logger,shard,unassigned,info,meta,data,get,index,safe,shard,index,allocation,changes,for,runnable,action,shard,cancellation,actions,action,run
ReplicaShardAllocator -> public void processExistingRecoveries(RoutingAllocation allocation);1541092382;Process existing recoveries of replicas and see if we need to cancel them if we find a better_match. Today, a better match is one that has full sync id match compared to not having one in_the previous recovery.;public void processExistingRecoveries(RoutingAllocation allocation) {_        MetaData metaData = allocation.metaData()__        RoutingNodes routingNodes = allocation.routingNodes()__        List<Runnable> shardCancellationActions = new ArrayList<>()__        for (RoutingNode routingNode : routingNodes) {_            for (ShardRouting shard : routingNode) {_                if (shard.primary()) {_                    continue__                }_                if (shard.initializing() == false) {_                    continue__                }_                if (shard.relocatingNodeId() != null) {_                    continue__                }__                _                if (shard.unassignedInfo() != null && shard.unassignedInfo().getReason() == UnassignedInfo.Reason.INDEX_CREATED) {_                    continue__                }__                AsyncShardFetch.FetchResult<NodeStoreFilesMetaData> shardStores = fetchData(shard, allocation)__                if (shardStores.hasData() == false) {_                    logger.trace("{}: fetching new stores for initializing shard", shard)__                    continue_ _                }__                ShardRouting primaryShard = allocation.routingNodes().activePrimary(shard.shardId())__                assert primaryShard != null : "the replica shard can be allocated on at least one node, so there must be an active primary"__                TransportNodesListShardStoreMetaData.StoreFilesMetaData primaryStore = findStore(primaryShard, allocation, shardStores)__                if (primaryStore == null) {_                    _                    _                    logger.trace("{}: no primary shard store found or allocated, letting actual allocation figure it out", shard)__                    continue__                }__                MatchingNodes matchingNodes = findMatchingNodes(shard, allocation, primaryStore, shardStores, false)__                if (matchingNodes.getNodeWithHighestMatch() != null) {_                    DiscoveryNode currentNode = allocation.nodes().get(shard.currentNodeId())__                    DiscoveryNode nodeWithHighestMatch = matchingNodes.getNodeWithHighestMatch()__                    _                    final String currentSyncId__                    if (shardStores.getData().containsKey(currentNode)) {_                        currentSyncId = shardStores.getData().get(currentNode).storeFilesMetaData().syncId()__                    } else {_                        currentSyncId = null__                    }_                    if (currentNode.equals(nodeWithHighestMatch) == false_                            && Objects.equals(currentSyncId, primaryStore.syncId()) == false_                            && matchingNodes.isNodeMatchBySyncID(nodeWithHighestMatch)) {_                        _                        _                        logger.debug("cancelling allocation of replica on [{}], sync id match found on node [{}]",_                                currentNode, nodeWithHighestMatch)__                        UnassignedInfo unassignedInfo = new UnassignedInfo(UnassignedInfo.Reason.REALLOCATED_REPLICA,_                            "existing allocation of replica to [" + currentNode + "] cancelled, sync id match found on node ["+_                                nodeWithHighestMatch + "]",_                            null, 0, allocation.getCurrentNanoTime(), System.currentTimeMillis(), false,_                            UnassignedInfo.AllocationStatus.NO_ATTEMPT)__                        _                        shardCancellationActions.add(() -> routingNodes.failShard(logger, shard, unassignedInfo,_                            metaData.getIndexSafe(shard.index()), allocation.changes()))__                    }_                }_            }_        }_        for (Runnable action : shardCancellationActions) {_            action.run()__        }_    };process,existing,recoveries,of,replicas,and,see,if,we,need,to,cancel,them,if,we,find,a,better,match,today,a,better,match,is,one,that,has,full,sync,id,match,compared,to,not,having,one,in,the,previous,recovery;public,void,process,existing,recoveries,routing,allocation,allocation,meta,data,meta,data,allocation,meta,data,routing,nodes,routing,nodes,allocation,routing,nodes,list,runnable,shard,cancellation,actions,new,array,list,for,routing,node,routing,node,routing,nodes,for,shard,routing,shard,routing,node,if,shard,primary,continue,if,shard,initializing,false,continue,if,shard,relocating,node,id,null,continue,if,shard,unassigned,info,null,shard,unassigned,info,get,reason,unassigned,info,reason,continue,async,shard,fetch,fetch,result,node,store,files,meta,data,shard,stores,fetch,data,shard,allocation,if,shard,stores,has,data,false,logger,trace,fetching,new,stores,for,initializing,shard,shard,continue,shard,routing,primary,shard,allocation,routing,nodes,active,primary,shard,shard,id,assert,primary,shard,null,the,replica,shard,can,be,allocated,on,at,least,one,node,so,there,must,be,an,active,primary,transport,nodes,list,shard,store,meta,data,store,files,meta,data,primary,store,find,store,primary,shard,allocation,shard,stores,if,primary,store,null,logger,trace,no,primary,shard,store,found,or,allocated,letting,actual,allocation,figure,it,out,shard,continue,matching,nodes,matching,nodes,find,matching,nodes,shard,allocation,primary,store,shard,stores,false,if,matching,nodes,get,node,with,highest,match,null,discovery,node,current,node,allocation,nodes,get,shard,current,node,id,discovery,node,node,with,highest,match,matching,nodes,get,node,with,highest,match,final,string,current,sync,id,if,shard,stores,get,data,contains,key,current,node,current,sync,id,shard,stores,get,data,get,current,node,store,files,meta,data,sync,id,else,current,sync,id,null,if,current,node,equals,node,with,highest,match,false,objects,equals,current,sync,id,primary,store,sync,id,false,matching,nodes,is,node,match,by,sync,id,node,with,highest,match,logger,debug,cancelling,allocation,of,replica,on,sync,id,match,found,on,node,current,node,node,with,highest,match,unassigned,info,unassigned,info,new,unassigned,info,unassigned,info,reason,existing,allocation,of,replica,to,current,node,cancelled,sync,id,match,found,on,node,node,with,highest,match,null,0,allocation,get,current,nano,time,system,current,time,millis,false,unassigned,info,allocation,status,shard,cancellation,actions,add,routing,nodes,fail,shard,logger,shard,unassigned,info,meta,data,get,index,safe,shard,index,allocation,changes,for,runnable,action,shard,cancellation,actions,action,run
ReplicaShardAllocator -> MatchingNodes -> @Nullable         public DiscoveryNode getNodeWithHighestMatch();1524684173;Returns the node with the highest "non zero byte" match compared to_the primary.;@Nullable_        public DiscoveryNode getNodeWithHighestMatch() {_            return this.nodeWithHighestMatch__        };returns,the,node,with,the,highest,non,zero,byte,match,compared,to,the,primary;nullable,public,discovery,node,get,node,with,highest,match,return,this,node,with,highest,match
ReplicaShardAllocator -> MatchingNodes -> @Nullable         public DiscoveryNode getNodeWithHighestMatch();1540847035;Returns the node with the highest "non zero byte" match compared to_the primary.;@Nullable_        public DiscoveryNode getNodeWithHighestMatch() {_            return this.nodeWithHighestMatch__        };returns,the,node,with,the,highest,non,zero,byte,match,compared,to,the,primary;nullable,public,discovery,node,get,node,with,highest,match,return,this,node,with,highest,match
ReplicaShardAllocator -> MatchingNodes -> @Nullable         public DiscoveryNode getNodeWithHighestMatch();1541092382;Returns the node with the highest "non zero byte" match compared to_the primary.;@Nullable_        public DiscoveryNode getNodeWithHighestMatch() {_            return this.nodeWithHighestMatch__        };returns,the,node,with,the,highest,non,zero,byte,match,compared,to,the,primary;nullable,public,discovery,node,get,node,with,highest,match,return,this,node,with,highest,match
ReplicaShardAllocator -> protected abstract boolean hasInitiatedFetching(ShardRouting shard)_;1524684173;Returns a boolean indicating whether fetching shard data has been triggered at any point for the given shard.;protected abstract boolean hasInitiatedFetching(ShardRouting shard)_;returns,a,boolean,indicating,whether,fetching,shard,data,has,been,triggered,at,any,point,for,the,given,shard;protected,abstract,boolean,has,initiated,fetching,shard,routing,shard
ReplicaShardAllocator -> protected abstract boolean hasInitiatedFetching(ShardRouting shard)_;1540847035;Returns a boolean indicating whether fetching shard data has been triggered at any point for the given shard.;protected abstract boolean hasInitiatedFetching(ShardRouting shard)_;returns,a,boolean,indicating,whether,fetching,shard,data,has,been,triggered,at,any,point,for,the,given,shard;protected,abstract,boolean,has,initiated,fetching,shard,routing,shard
ReplicaShardAllocator -> protected abstract boolean hasInitiatedFetching(ShardRouting shard)_;1541092382;Returns a boolean indicating whether fetching shard data has been triggered at any point for the given shard.;protected abstract boolean hasInitiatedFetching(ShardRouting shard)_;returns,a,boolean,indicating,whether,fetching,shard,data,has,been,triggered,at,any,point,for,the,given,shard;protected,abstract,boolean,has,initiated,fetching,shard,routing,shard
