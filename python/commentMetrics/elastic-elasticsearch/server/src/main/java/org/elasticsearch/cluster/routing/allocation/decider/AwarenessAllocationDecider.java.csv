commented;modifiers;parameterAmount;loc;comment;code
false;private;1;11;;private void setForcedAwarenessAttributes(Settings forceSettings) {     Map<String, List<String>> forcedAwarenessAttributes = new HashMap<>().     Map<String, Settings> forceGroups = forceSettings.getAsGroups().     for (Map.Entry<String, Settings> entry : forceGroups.entrySet()) {         List<String> aValues = entry.getValue().getAsList("values").         if (aValues.size() > 0) {             forcedAwarenessAttributes.put(entry.getKey(), aValues).         }     }     this.forcedAwarenessAttributes = forcedAwarenessAttributes. }
false;private;1;3;;private void setAwarenessAttributes(List<String> awarenessAttributes) {     this.awarenessAttributes = awarenessAttributes. }
false;public;3;4;;@Override public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     return underCapacity(shardRouting, node, allocation, true). }
false;public;3;4;;@Override public Decision canRemain(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     return underCapacity(shardRouting, node, allocation, false). }
false;private;4;74;;private Decision underCapacity(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation, boolean moveToNode) {     if (awarenessAttributes.isEmpty()) {         return allocation.decision(Decision.YES, NAME, "allocation awareness is not enabled, set cluster setting [%s] to enable it", CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTE_SETTING.getKey()).     }     IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardRouting.index()).     // 1 for primary     int shardCount = indexMetaData.getNumberOfReplicas() + 1.     for (String awarenessAttribute : awarenessAttributes) {         // the node the shard exists on must be associated with an awareness attribute         if (node.node().getAttributes().containsKey(awarenessAttribute) == false) {             return allocation.decision(Decision.NO, NAME, "node does not contain the awareness attribute [%s]. required attributes cluster setting [%s=%s]", awarenessAttribute, CLUSTER_ROUTING_ALLOCATION_AWARENESS_ATTRIBUTE_SETTING.getKey(), allocation.debugDecision() ? Strings.collectionToCommaDelimitedString(awarenessAttributes) : null).         }         // build attr_value -> nodes map         ObjectIntHashMap<String> nodesPerAttribute = allocation.routingNodes().nodesPerAttributesCounts(awarenessAttribute).         // build the count of shards per attribute value         ObjectIntHashMap<String> shardPerAttribute = new ObjectIntHashMap<>().         for (ShardRouting assignedShard : allocation.routingNodes().assignedShards(shardRouting.shardId())) {             if (assignedShard.started() || assignedShard.initializing()) {                 // Note: this also counts relocation targets as that will be the new location of the shard.                 // Relocation sources should not be counted as the shard is moving away                 RoutingNode routingNode = allocation.routingNodes().node(assignedShard.currentNodeId()).                 shardPerAttribute.addTo(routingNode.node().getAttributes().get(awarenessAttribute), 1).             }         }         if (moveToNode) {             if (shardRouting.assignedToNode()) {                 String nodeId = shardRouting.relocating() ? shardRouting.relocatingNodeId() : shardRouting.currentNodeId().                 if (node.nodeId().equals(nodeId) == false) {                     // we work on different nodes, move counts around                     shardPerAttribute.putOrAdd(allocation.routingNodes().node(nodeId).node().getAttributes().get(awarenessAttribute), 0, -1).                     shardPerAttribute.addTo(node.node().getAttributes().get(awarenessAttribute), 1).                 }             } else {                 shardPerAttribute.addTo(node.node().getAttributes().get(awarenessAttribute), 1).             }         }         int numberOfAttributes = nodesPerAttribute.size().         List<String> fullValues = forcedAwarenessAttributes.get(awarenessAttribute).         if (fullValues != null) {             for (String fullValue : fullValues) {                 if (shardPerAttribute.containsKey(fullValue) == false) {                     numberOfAttributes++.                 }             }         }         // TODO should we remove ones that are not part of full list?         final int currentNodeCount = shardPerAttribute.get(node.node().getAttributes().get(awarenessAttribute)).         // ceil(shardCount/numberOfAttributes)         final int maximumNodeCount = (shardCount + numberOfAttributes - 1) / numberOfAttributes.         if (currentNodeCount > maximumNodeCount) {             return allocation.decision(Decision.NO, NAME, "there are too many copies of the shard allocated to nodes with attribute [%s], there are [%d] total configured " + "shard copies for this shard id and [%d] total attribute values, expected the allocated shard count per " + "attribute [%d] to be less than or equal to the upper bound of the required number of shards per attribute [%d]", awarenessAttribute, shardCount, numberOfAttributes, currentNodeCount, maximumNodeCount).         }     }     return allocation.decision(Decision.YES, NAME, "node meets all awareness attribute requirements"). }
