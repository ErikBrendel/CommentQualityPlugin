commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String name() {     return NAME. }
false;public,static;1;3;;public static AllocateReplicaAllocationCommand fromXContent(XContentParser parser) throws IOException {     return new Builder().parse(parser).build(). }
false;public;1;4;;@Override public Builder parse(XContentParser parser) throws IOException {     return REPLICA_PARSER.parse(parser, this, null). }
false;public;0;5;;@Override public AllocateReplicaAllocationCommand build() {     validate().     return new AllocateReplicaAllocationCommand(index, shard, node). }
false;public;2;49;;@Override public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {     final DiscoveryNode discoNode.     try {         discoNode = allocation.nodes().resolveNode(node).     } catch (IllegalArgumentException e) {         return explainOrThrowRejectedCommand(explain, allocation, e).     }     final RoutingNodes routingNodes = allocation.routingNodes().     RoutingNode routingNode = routingNodes.node(discoNode.getId()).     if (routingNode == null) {         return explainOrThrowMissingRoutingNode(allocation, explain, discoNode).     }     final ShardRouting primaryShardRouting.     try {         primaryShardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard().     } catch (IndexNotFoundException | ShardNotFoundException e) {         return explainOrThrowRejectedCommand(explain, allocation, e).     }     if (primaryShardRouting.unassigned()) {         return explainOrThrowRejectedCommand(explain, allocation, "trying to allocate a replica shard [" + index + "][" + shardId + "], while corresponding primary shard is still unassigned").     }     List<ShardRouting> replicaShardRoutings = allocation.routingTable().shardRoutingTable(index, shardId).replicaShardsWithState(ShardRoutingState.UNASSIGNED).     ShardRouting shardRouting.     if (replicaShardRoutings.isEmpty()) {         return explainOrThrowRejectedCommand(explain, allocation, "all copies of [" + index + "][" + shardId + "] are already assigned. Use the move allocation command instead").     } else {         shardRouting = replicaShardRoutings.get(0).     }     Decision decision = allocation.deciders().canAllocate(shardRouting, routingNode, allocation).     if (decision.type() == Decision.Type.NO) {         // don't use explainOrThrowRejectedCommand to keep the original "NO" decision         if (explain) {             return new RerouteExplanation(this, decision).         }         throw new IllegalArgumentException("[" + name() + "] allocation of [" + index + "][" + shardId + "] on node " + discoNode + " is not allowed, reason: " + decision).     }     initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting).     return new RerouteExplanation(this, decision). }
