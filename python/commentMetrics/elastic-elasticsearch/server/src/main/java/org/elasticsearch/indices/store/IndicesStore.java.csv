commented;modifiers;parameterAmount;loc;comment;code
false;public;0;6;;@Override public void close() {     if (DiscoveryNode.isDataNode(settings)) {         clusterService.removeListener(this).     } }
false;public;1;61;;@Override public void clusterChanged(ClusterChangedEvent event) {     if (!event.routingTableChanged()) {         return.     }     if (event.state().blocks().disableStatePersistence()) {         return.     }     RoutingTable routingTable = event.state().routingTable().     // remove entries from cache that don't exist in the routing table anymore (either closed or deleted indices)     // - removing shard data of deleted indices is handled by IndicesClusterStateService     // - closed indices don't need to be removed from the cache but we do it anyway for code simplicity     folderNotFoundCache.removeIf(shardId -> !routingTable.hasIndex(shardId.getIndex())).     // remove entries from cache which are allocated to this node     final String localNodeId = event.state().nodes().getLocalNodeId().     RoutingNode localRoutingNode = event.state().getRoutingNodes().node(localNodeId).     if (localRoutingNode != null) {         for (ShardRouting routing : localRoutingNode) {             folderNotFoundCache.remove(routing.shardId()).         }     }     for (IndexRoutingTable indexRoutingTable : routingTable) {         // Note, closed indices will not have any routing information, so won't be deleted         for (IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable) {             ShardId shardId = indexShardRoutingTable.shardId().             if (folderNotFoundCache.contains(shardId) == false && shardCanBeDeleted(localNodeId, indexShardRoutingTable)) {                 IndexService indexService = indicesService.indexService(indexRoutingTable.getIndex()).                 final IndexSettings indexSettings.                 if (indexService == null) {                     IndexMetaData indexMetaData = event.state().getMetaData().getIndexSafe(indexRoutingTable.getIndex()).                     indexSettings = new IndexSettings(indexMetaData, settings).                 } else {                     indexSettings = indexService.getIndexSettings().                 }                 IndicesService.ShardDeletionCheckResult shardDeletionCheckResult = indicesService.canDeleteShardContent(shardId, indexSettings).                 switch(shardDeletionCheckResult) {                     case FOLDER_FOUND_CAN_DELETE:                         deleteShardIfExistElseWhere(event.state(), indexShardRoutingTable).                         break.                     case NO_FOLDER_FOUND:                         folderNotFoundCache.add(shardId).                         break.                     case NO_LOCAL_STORAGE:                         assert false : "shard deletion only runs on data nodes which always have local storage".                         // nothing to do                         break.                     case STILL_ALLOCATED:                         // nothing to do                         break.                     default:                         assert false : "unknown shard deletion check result: " + shardDeletionCheckResult.                 }             }         }     } }
false;static;2;22;;static boolean shardCanBeDeleted(String localNodeId, IndexShardRoutingTable indexShardRoutingTable) {     // a shard can be deleted if all its copies are active, and its not allocated on this node     if (indexShardRoutingTable.size() == 0) {         // shard replication group, in any case, protected from deleting something by mistake         return false.     }     for (ShardRouting shardRouting : indexShardRoutingTable) {         // be conservative here, check on started, not even active         if (shardRouting.started() == false) {             return false.         }         // check if shard is active on the current node         if (localNodeId.equals(shardRouting.currentNodeId())) {             return false.         }     }     return true. }
false;private;2;18;;private void deleteShardIfExistElseWhere(ClusterState state, IndexShardRoutingTable indexShardRoutingTable) {     List<Tuple<DiscoveryNode, ShardActiveRequest>> requests = new ArrayList<>(indexShardRoutingTable.size()).     String indexUUID = indexShardRoutingTable.shardId().getIndex().getUUID().     ClusterName clusterName = state.getClusterName().     for (ShardRouting shardRouting : indexShardRoutingTable) {         assert shardRouting.started() : "expected started shard but was " + shardRouting.         DiscoveryNode currentNode = state.nodes().get(shardRouting.currentNodeId()).         requests.add(new Tuple<>(currentNode, new ShardActiveRequest(clusterName, indexUUID, shardRouting.shardId(), deleteShardTimeout))).     }     ShardActiveResponseHandler responseHandler = new ShardActiveResponseHandler(indexShardRoutingTable.shardId(), state.getVersion(), requests.size()).     for (Tuple<DiscoveryNode, ShardActiveRequest> request : requests) {         logger.trace("{} sending shard active check to {}", request.v2().shardId, request.v1()).         transportService.sendRequest(request.v1(), ACTION_SHARD_EXISTS, request.v2(), responseHandler).     } }
false;public;1;4;;@Override public ShardActiveResponse read(StreamInput in) throws IOException {     return new ShardActiveResponse(in). }
false;public;1;11;;@Override public void handleResponse(ShardActiveResponse response) {     logger.trace("{} is {}active on node {}", shardId, response.shardActive ? "" : "not ", response.node).     if (response.shardActive) {         activeCopies.incrementAndGet().     }     if (awaitingResponses.decrementAndGet() == 0) {         allNodesResponded().     } }
false;public;1;7;;@Override public void handleException(TransportException exp) {     logger.debug(() -> new ParameterizedMessage("shards active request failed for {}", shardId), exp).     if (awaitingResponses.decrementAndGet() == 0) {         allNodesResponded().     } }
false;public;0;4;;@Override public String executor() {     return ThreadPool.Names.SAME. }
false;private;0;31;;private void allNodesResponded() {     if (activeCopies.get() != expectedActiveCopies) {         logger.trace("not deleting shard {}, expected {} active copies, but only {} found active copies", shardId, expectedActiveCopies, activeCopies.get()).         return.     }     ClusterState latestClusterState = clusterService.state().     if (clusterStateVersion != latestClusterState.getVersion()) {         logger.trace("not deleting shard {}, the latest cluster state version[{}] is not equal to cluster state " + "before shard active api call [{}]", shardId, latestClusterState.getVersion(), clusterStateVersion).         return.     }     clusterService.getClusterApplierService().runOnApplierThread("indices_store ([" + shardId + "] active fully on other nodes)", currentState -> {         if (clusterStateVersion != currentState.getVersion()) {             logger.trace("not deleting shard {}, the update task state version[{}] is not equal to cluster state before " + "shard active api call [{}]", shardId, currentState.getVersion(), clusterStateVersion).             return.         }         try {             indicesService.deleteShardStore("no longer used", shardId, currentState).         } catch (Exception ex) {             logger.debug(() -> new ParameterizedMessage("{} failed to delete unallocated shard, ignoring", shardId), ex).         }     }, (source, e) -> logger.error(() -> new ParameterizedMessage("{} unexpected error during deletion of unallocated shard", shardId), e)). }
false;public;1;4;;@Override public void onNewClusterState(ClusterState state) {     sendResult(shardActive(getShard(request))). }
false;public;0;4;;@Override public void onClusterServiceClose() {     sendResult(false). }
false;public;1;4;;@Override public void onTimeout(TimeValue timeout) {     sendResult(shardActive(getShard(request))). }
false;public;1;11;;public void sendResult(boolean shardActive) {     try {         channel.sendResponse(new ShardActiveResponse(shardActive, clusterService.localNode())).     } catch (IOException e) {         logger.error(() -> new ParameterizedMessage("failed send response for shard active while trying to " + "delete shard {} - shard will probably not be removed", request.shardId), e).     } catch (EsRejectedExecutionException e) {         logger.error(() -> new ParameterizedMessage("failed send response for shard active while trying to " + "delete shard {} - shard will probably not be removed", request.shardId), e).     } }
false;public;3;61;;@Override public void messageReceived(final ShardActiveRequest request, final TransportChannel channel, Task task) throws Exception {     IndexShard indexShard = getShard(request).     // make sure shard is really there before register cluster state observer     if (indexShard == null) {         channel.sendResponse(new ShardActiveResponse(false, clusterService.localNode())).     } else {         // create observer here. we need to register it here because we need to capture the current cluster state         // which will then be compared to the one that is applied when we call waitForNextChange(). if we create it         // later we might miss an update and wait forever in case no new cluster state comes in.         // in general, using a cluster state observer here is a workaround for the fact that we cannot listen on         // shard state changes explicitly. instead we wait for the cluster state changes because we know any         // shard state change will trigger or be triggered by a cluster state change.         ClusterStateObserver observer = new ClusterStateObserver(clusterService, request.timeout, logger, threadPool.getThreadContext()).         // check if shard is active. if so, all is good         boolean shardActive = shardActive(indexShard).         if (shardActive) {             channel.sendResponse(new ShardActiveResponse(true, clusterService.localNode())).         } else {             // shard is not active, might be POST_RECOVERY so check if cluster state changed inbetween or wait for next change             observer.waitForNextChange(new ClusterStateObserver.Listener() {                  @Override                 public void onNewClusterState(ClusterState state) {                     sendResult(shardActive(getShard(request))).                 }                  @Override                 public void onClusterServiceClose() {                     sendResult(false).                 }                  @Override                 public void onTimeout(TimeValue timeout) {                     sendResult(shardActive(getShard(request))).                 }                  public void sendResult(boolean shardActive) {                     try {                         channel.sendResponse(new ShardActiveResponse(shardActive, clusterService.localNode())).                     } catch (IOException e) {                         logger.error(() -> new ParameterizedMessage("failed send response for shard active while trying to " + "delete shard {} - shard will probably not be removed", request.shardId), e).                     } catch (EsRejectedExecutionException e) {                         logger.error(() -> new ParameterizedMessage("failed send response for shard active while trying to " + "delete shard {} - shard will probably not be removed", request.shardId), e).                     }                 }             }, newState -> {                 // the shard is not there in which case we want to send back a false (shard is not active),                 // so the cluster state listener must be notified or the shard is active in which case we want to                 // send back that the shard is active here we could also evaluate the cluster state and get the                 // information from there. we don't do it because we would have to write another method for this                 // that would have the same effect                 IndexShard currentShard = getShard(request).                 return currentShard == null || shardActive(currentShard).             }).         }     } }
false;private;1;6;;private boolean shardActive(IndexShard indexShard) {     if (indexShard != null) {         return ACTIVE_STATES.contains(indexShard.state()).     }     return false. }
false;private;1;14;;private IndexShard getShard(ShardActiveRequest request) {     ClusterName thisClusterName = clusterService.getClusterName().     if (!thisClusterName.equals(request.clusterName)) {         logger.trace("shard exists request meant for cluster[{}], but this is cluster[{}], ignoring request", request.clusterName, thisClusterName).         return null.     }     ShardId shardId = request.shardId.     IndexService indexService = indicesService.indexService(shardId.getIndex()).     if (indexService != null && indexService.indexUUID().equals(request.indexUUID)) {         return indexService.getShardOrNull(shardId.id()).     }     return null. }
false;public;1;8;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     clusterName = new ClusterName(in).     indexUUID = in.readString().     shardId = ShardId.readShardId(in).     timeout = new TimeValue(in.readLong(), TimeUnit.MILLISECONDS). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     clusterName.writeTo(out).     out.writeString(indexUUID).     shardId.writeTo(out).     out.writeLong(timeout.millis()). }
false;public;1;6;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeBoolean(shardActive).     node.writeTo(out). }
