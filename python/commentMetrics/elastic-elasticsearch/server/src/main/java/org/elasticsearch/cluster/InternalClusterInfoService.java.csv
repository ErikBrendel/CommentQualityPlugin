# id;timestamp;commentText;codeText;commentWords;codeWords
InternalClusterInfoService -> protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener);1524684173;Retrieve the latest nodes stats, calling the listener when complete_@return a latch that can be used to wait for the nodes stats to complete if desired;protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final NodesStatsRequest nodesStatsRequest = new NodesStatsRequest("data:true")__        nodesStatsRequest.clear()__        nodesStatsRequest.fs(true)__        nodesStatsRequest.timeout(fetchTimeout)__        client.admin().cluster().nodesStats(nodesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,nodes,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,nodes,stats,to,complete,if,desired;protected,count,down,latch,update,node,stats,final,action,listener,nodes,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,nodes,stats,request,nodes,stats,request,new,nodes,stats,request,data,true,nodes,stats,request,clear,nodes,stats,request,fs,true,nodes,stats,request,timeout,fetch,timeout,client,admin,cluster,nodes,stats,nodes,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener);1528762805;Retrieve the latest nodes stats, calling the listener when complete_@return a latch that can be used to wait for the nodes stats to complete if desired;protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final NodesStatsRequest nodesStatsRequest = new NodesStatsRequest("data:true")__        nodesStatsRequest.clear()__        nodesStatsRequest.fs(true)__        nodesStatsRequest.timeout(fetchTimeout)__        client.admin().cluster().nodesStats(nodesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,nodes,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,nodes,stats,to,complete,if,desired;protected,count,down,latch,update,node,stats,final,action,listener,nodes,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,nodes,stats,request,nodes,stats,request,new,nodes,stats,request,data,true,nodes,stats,request,clear,nodes,stats,request,fs,true,nodes,stats,request,timeout,fetch,timeout,client,admin,cluster,nodes,stats,nodes,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener);1540847035;Retrieve the latest nodes stats, calling the listener when complete_@return a latch that can be used to wait for the nodes stats to complete if desired;protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final NodesStatsRequest nodesStatsRequest = new NodesStatsRequest("data:true")__        nodesStatsRequest.clear()__        nodesStatsRequest.fs(true)__        nodesStatsRequest.timeout(fetchTimeout)__        client.admin().cluster().nodesStats(nodesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,nodes,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,nodes,stats,to,complete,if,desired;protected,count,down,latch,update,node,stats,final,action,listener,nodes,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,nodes,stats,request,nodes,stats,request,new,nodes,stats,request,data,true,nodes,stats,request,clear,nodes,stats,request,fs,true,nodes,stats,request,timeout,fetch,timeout,client,admin,cluster,nodes,stats,nodes,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener);1541092382;Retrieve the latest nodes stats, calling the listener when complete_@return a latch that can be used to wait for the nodes stats to complete if desired;protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final NodesStatsRequest nodesStatsRequest = new NodesStatsRequest("data:true")__        nodesStatsRequest.clear()__        nodesStatsRequest.fs(true)__        nodesStatsRequest.timeout(fetchTimeout)__        client.admin().cluster().nodesStats(nodesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,nodes,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,nodes,stats,to,complete,if,desired;protected,count,down,latch,update,node,stats,final,action,listener,nodes,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,nodes,stats,request,nodes,stats,request,new,nodes,stats,request,data,true,nodes,stats,request,clear,nodes,stats,request,fs,true,nodes,stats,request,timeout,fetch,timeout,client,admin,cluster,nodes,stats,nodes,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener);1542402632;Retrieve the latest nodes stats, calling the listener when complete_@return a latch that can be used to wait for the nodes stats to complete if desired;protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final NodesStatsRequest nodesStatsRequest = new NodesStatsRequest("data:true")__        nodesStatsRequest.clear()__        nodesStatsRequest.fs(true)__        nodesStatsRequest.timeout(fetchTimeout)__        client.admin().cluster().nodesStats(nodesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,nodes,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,nodes,stats,to,complete,if,desired;protected,count,down,latch,update,node,stats,final,action,listener,nodes,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,nodes,stats,request,nodes,stats,request,new,nodes,stats,request,data,true,nodes,stats,request,clear,nodes,stats,request,fs,true,nodes,stats,request,timeout,fetch,timeout,client,admin,cluster,nodes,stats,nodes,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener);1545224398;Retrieve the latest nodes stats, calling the listener when complete_@return a latch that can be used to wait for the nodes stats to complete if desired;protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final NodesStatsRequest nodesStatsRequest = new NodesStatsRequest("data:true")__        nodesStatsRequest.clear()__        nodesStatsRequest.fs(true)__        nodesStatsRequest.timeout(fetchTimeout)__        client.admin().cluster().nodesStats(nodesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,nodes,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,nodes,stats,to,complete,if,desired;protected,count,down,latch,update,node,stats,final,action,listener,nodes,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,nodes,stats,request,nodes,stats,request,new,nodes,stats,request,data,true,nodes,stats,request,clear,nodes,stats,request,fs,true,nodes,stats,request,timeout,fetch,timeout,client,admin,cluster,nodes,stats,nodes,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener);1548662486;Retrieve the latest nodes stats, calling the listener when complete_@return a latch that can be used to wait for the nodes stats to complete if desired;protected CountDownLatch updateNodeStats(final ActionListener<NodesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final NodesStatsRequest nodesStatsRequest = new NodesStatsRequest("data:true")__        nodesStatsRequest.clear()__        nodesStatsRequest.fs(true)__        nodesStatsRequest.timeout(fetchTimeout)__        client.admin().cluster().nodesStats(nodesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,nodes,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,nodes,stats,to,complete,if,desired;protected,count,down,latch,update,node,stats,final,action,listener,nodes,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,nodes,stats,request,nodes,stats,request,new,nodes,stats,request,data,true,nodes,stats,request,clear,nodes,stats,request,fs,true,nodes,stats,request,timeout,fetch,timeout,client,admin,cluster,nodes,stats,nodes,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> public final ClusterInfo refresh();1524684173;Refreshes the ClusterInfo in a blocking fashion;public final ClusterInfo refresh() {_        if (logger.isTraceEnabled()) {_            logger.trace("Performing ClusterInfoUpdateJob")__        }_        final CountDownLatch nodeLatch = updateNodeStats(new ActionListener<NodesStatsResponse>() {_            @Override_            public void onResponse(NodesStatsResponse nodeStatses) {_                ImmutableOpenMap.Builder<String, DiskUsage> newLeastAvaiableUsages = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<String, DiskUsage> newMostAvaiableUsages = ImmutableOpenMap.builder()__                fillDiskUsagePerNode(logger, nodeStatses.getNodes(), newLeastAvaiableUsages, newMostAvaiableUsages)__                leastAvailableSpaceUsages = newLeastAvaiableUsages.build()__                mostAvailableSpaceUsages = newMostAvaiableUsages.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("NodeStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    leastAvailableSpaceUsages = ImmutableOpenMap.of()__                    mostAvailableSpaceUsages = ImmutableOpenMap.of()__                }_            }_        })___        final CountDownLatch indicesLatch = updateIndicesStats(new ActionListener<IndicesStatsResponse>() {_            @Override_            public void onResponse(IndicesStatsResponse indicesStatsResponse) {_                ShardStats[] stats = indicesStatsResponse.getShards()__                ImmutableOpenMap.Builder<String, Long> newShardSizes = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<ShardRouting, String> newShardRoutingToDataPath = ImmutableOpenMap.builder()__                buildShardLevelInfo(logger, stats, newShardSizes, newShardRoutingToDataPath, clusterService.state())__                shardSizes = newShardSizes.build()__                shardRoutingToDataPath = newShardRoutingToDataPath.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("IndicesStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    shardSizes = ImmutableOpenMap.of()__                    shardRoutingToDataPath = ImmutableOpenMap.of()__                }_            }_        })___        try {_            nodeLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _            logger.warn("Failed to update node information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__        }__        try {_            indicesLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _            logger.warn("Failed to update shard information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__        }_        ClusterInfo clusterInfo = getClusterInfo()__        try {_            listener.accept(clusterInfo)__        } catch (Exception e) {_            logger.info("Failed executing ClusterInfoService listener", e)__        }_        return clusterInfo__    };refreshes,the,cluster,info,in,a,blocking,fashion;public,final,cluster,info,refresh,if,logger,is,trace,enabled,logger,trace,performing,cluster,info,update,job,final,count,down,latch,node,latch,update,node,stats,new,action,listener,nodes,stats,response,override,public,void,on,response,nodes,stats,response,node,statses,immutable,open,map,builder,string,disk,usage,new,least,avaiable,usages,immutable,open,map,builder,immutable,open,map,builder,string,disk,usage,new,most,avaiable,usages,immutable,open,map,builder,fill,disk,usage,per,node,logger,node,statses,get,nodes,new,least,avaiable,usages,new,most,avaiable,usages,least,available,space,usages,new,least,avaiable,usages,build,most,available,space,usages,new,most,avaiable,usages,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,node,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,least,available,space,usages,immutable,open,map,of,most,available,space,usages,immutable,open,map,of,final,count,down,latch,indices,latch,update,indices,stats,new,action,listener,indices,stats,response,override,public,void,on,response,indices,stats,response,indices,stats,response,shard,stats,stats,indices,stats,response,get,shards,immutable,open,map,builder,string,long,new,shard,sizes,immutable,open,map,builder,immutable,open,map,builder,shard,routing,string,new,shard,routing,to,data,path,immutable,open,map,builder,build,shard,level,info,logger,stats,new,shard,sizes,new,shard,routing,to,data,path,cluster,service,state,shard,sizes,new,shard,sizes,build,shard,routing,to,data,path,new,shard,routing,to,data,path,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,indices,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,shard,sizes,immutable,open,map,of,shard,routing,to,data,path,immutable,open,map,of,try,node,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,logger,warn,failed,to,update,node,information,for,cluster,info,update,job,within,timeout,fetch,timeout,try,indices,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,logger,warn,failed,to,update,shard,information,for,cluster,info,update,job,within,timeout,fetch,timeout,cluster,info,cluster,info,get,cluster,info,try,listener,accept,cluster,info,catch,exception,e,logger,info,failed,executing,cluster,info,service,listener,e,return,cluster,info
InternalClusterInfoService -> public final ClusterInfo refresh();1528762805;Refreshes the ClusterInfo in a blocking fashion;public final ClusterInfo refresh() {_        if (logger.isTraceEnabled()) {_            logger.trace("Performing ClusterInfoUpdateJob")__        }_        final CountDownLatch nodeLatch = updateNodeStats(new ActionListener<NodesStatsResponse>() {_            @Override_            public void onResponse(NodesStatsResponse nodeStatses) {_                ImmutableOpenMap.Builder<String, DiskUsage> newLeastAvaiableUsages = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<String, DiskUsage> newMostAvaiableUsages = ImmutableOpenMap.builder()__                fillDiskUsagePerNode(logger, nodeStatses.getNodes(), newLeastAvaiableUsages, newMostAvaiableUsages)__                leastAvailableSpaceUsages = newLeastAvaiableUsages.build()__                mostAvailableSpaceUsages = newMostAvaiableUsages.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("NodeStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    leastAvailableSpaceUsages = ImmutableOpenMap.of()__                    mostAvailableSpaceUsages = ImmutableOpenMap.of()__                }_            }_        })___        final CountDownLatch indicesLatch = updateIndicesStats(new ActionListener<IndicesStatsResponse>() {_            @Override_            public void onResponse(IndicesStatsResponse indicesStatsResponse) {_                ShardStats[] stats = indicesStatsResponse.getShards()__                ImmutableOpenMap.Builder<String, Long> newShardSizes = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<ShardRouting, String> newShardRoutingToDataPath = ImmutableOpenMap.builder()__                buildShardLevelInfo(logger, stats, newShardSizes, newShardRoutingToDataPath, clusterService.state())__                shardSizes = newShardSizes.build()__                shardRoutingToDataPath = newShardRoutingToDataPath.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("IndicesStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    shardSizes = ImmutableOpenMap.of()__                    shardRoutingToDataPath = ImmutableOpenMap.of()__                }_            }_        })___        try {_            nodeLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _            logger.warn("Failed to update node information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__        }__        try {_            indicesLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _            logger.warn("Failed to update shard information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__        }_        ClusterInfo clusterInfo = getClusterInfo()__        try {_            listener.accept(clusterInfo)__        } catch (Exception e) {_            logger.info("Failed executing ClusterInfoService listener", e)__        }_        return clusterInfo__    };refreshes,the,cluster,info,in,a,blocking,fashion;public,final,cluster,info,refresh,if,logger,is,trace,enabled,logger,trace,performing,cluster,info,update,job,final,count,down,latch,node,latch,update,node,stats,new,action,listener,nodes,stats,response,override,public,void,on,response,nodes,stats,response,node,statses,immutable,open,map,builder,string,disk,usage,new,least,avaiable,usages,immutable,open,map,builder,immutable,open,map,builder,string,disk,usage,new,most,avaiable,usages,immutable,open,map,builder,fill,disk,usage,per,node,logger,node,statses,get,nodes,new,least,avaiable,usages,new,most,avaiable,usages,least,available,space,usages,new,least,avaiable,usages,build,most,available,space,usages,new,most,avaiable,usages,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,node,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,least,available,space,usages,immutable,open,map,of,most,available,space,usages,immutable,open,map,of,final,count,down,latch,indices,latch,update,indices,stats,new,action,listener,indices,stats,response,override,public,void,on,response,indices,stats,response,indices,stats,response,shard,stats,stats,indices,stats,response,get,shards,immutable,open,map,builder,string,long,new,shard,sizes,immutable,open,map,builder,immutable,open,map,builder,shard,routing,string,new,shard,routing,to,data,path,immutable,open,map,builder,build,shard,level,info,logger,stats,new,shard,sizes,new,shard,routing,to,data,path,cluster,service,state,shard,sizes,new,shard,sizes,build,shard,routing,to,data,path,new,shard,routing,to,data,path,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,indices,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,shard,sizes,immutable,open,map,of,shard,routing,to,data,path,immutable,open,map,of,try,node,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,logger,warn,failed,to,update,node,information,for,cluster,info,update,job,within,timeout,fetch,timeout,try,indices,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,logger,warn,failed,to,update,shard,information,for,cluster,info,update,job,within,timeout,fetch,timeout,cluster,info,cluster,info,get,cluster,info,try,listener,accept,cluster,info,catch,exception,e,logger,info,failed,executing,cluster,info,service,listener,e,return,cluster,info
InternalClusterInfoService -> public final ClusterInfo refresh();1540847035;Refreshes the ClusterInfo in a blocking fashion;public final ClusterInfo refresh() {_        if (logger.isTraceEnabled()) {_            logger.trace("Performing ClusterInfoUpdateJob")__        }_        final CountDownLatch nodeLatch = updateNodeStats(new ActionListener<NodesStatsResponse>() {_            @Override_            public void onResponse(NodesStatsResponse nodeStatses) {_                ImmutableOpenMap.Builder<String, DiskUsage> newLeastAvaiableUsages = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<String, DiskUsage> newMostAvaiableUsages = ImmutableOpenMap.builder()__                fillDiskUsagePerNode(logger, nodeStatses.getNodes(), newLeastAvaiableUsages, newMostAvaiableUsages)__                leastAvailableSpaceUsages = newLeastAvaiableUsages.build()__                mostAvailableSpaceUsages = newMostAvaiableUsages.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("NodeStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    leastAvailableSpaceUsages = ImmutableOpenMap.of()__                    mostAvailableSpaceUsages = ImmutableOpenMap.of()__                }_            }_        })___        final CountDownLatch indicesLatch = updateIndicesStats(new ActionListener<IndicesStatsResponse>() {_            @Override_            public void onResponse(IndicesStatsResponse indicesStatsResponse) {_                ShardStats[] stats = indicesStatsResponse.getShards()__                ImmutableOpenMap.Builder<String, Long> newShardSizes = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<ShardRouting, String> newShardRoutingToDataPath = ImmutableOpenMap.builder()__                buildShardLevelInfo(logger, stats, newShardSizes, newShardRoutingToDataPath, clusterService.state())__                shardSizes = newShardSizes.build()__                shardRoutingToDataPath = newShardRoutingToDataPath.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("IndicesStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    shardSizes = ImmutableOpenMap.of()__                    shardRoutingToDataPath = ImmutableOpenMap.of()__                }_            }_        })___        try {_            nodeLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _            logger.warn("Failed to update node information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__        }__        try {_            indicesLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _            logger.warn("Failed to update shard information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__        }_        ClusterInfo clusterInfo = getClusterInfo()__        try {_            listener.accept(clusterInfo)__        } catch (Exception e) {_            logger.info("Failed executing ClusterInfoService listener", e)__        }_        return clusterInfo__    };refreshes,the,cluster,info,in,a,blocking,fashion;public,final,cluster,info,refresh,if,logger,is,trace,enabled,logger,trace,performing,cluster,info,update,job,final,count,down,latch,node,latch,update,node,stats,new,action,listener,nodes,stats,response,override,public,void,on,response,nodes,stats,response,node,statses,immutable,open,map,builder,string,disk,usage,new,least,avaiable,usages,immutable,open,map,builder,immutable,open,map,builder,string,disk,usage,new,most,avaiable,usages,immutable,open,map,builder,fill,disk,usage,per,node,logger,node,statses,get,nodes,new,least,avaiable,usages,new,most,avaiable,usages,least,available,space,usages,new,least,avaiable,usages,build,most,available,space,usages,new,most,avaiable,usages,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,node,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,least,available,space,usages,immutable,open,map,of,most,available,space,usages,immutable,open,map,of,final,count,down,latch,indices,latch,update,indices,stats,new,action,listener,indices,stats,response,override,public,void,on,response,indices,stats,response,indices,stats,response,shard,stats,stats,indices,stats,response,get,shards,immutable,open,map,builder,string,long,new,shard,sizes,immutable,open,map,builder,immutable,open,map,builder,shard,routing,string,new,shard,routing,to,data,path,immutable,open,map,builder,build,shard,level,info,logger,stats,new,shard,sizes,new,shard,routing,to,data,path,cluster,service,state,shard,sizes,new,shard,sizes,build,shard,routing,to,data,path,new,shard,routing,to,data,path,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,indices,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,shard,sizes,immutable,open,map,of,shard,routing,to,data,path,immutable,open,map,of,try,node,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,logger,warn,failed,to,update,node,information,for,cluster,info,update,job,within,timeout,fetch,timeout,try,indices,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,logger,warn,failed,to,update,shard,information,for,cluster,info,update,job,within,timeout,fetch,timeout,cluster,info,cluster,info,get,cluster,info,try,listener,accept,cluster,info,catch,exception,e,logger,info,failed,executing,cluster,info,service,listener,e,return,cluster,info
InternalClusterInfoService -> public final ClusterInfo refresh();1541092382;Refreshes the ClusterInfo in a blocking fashion;public final ClusterInfo refresh() {_        if (logger.isTraceEnabled()) {_            logger.trace("Performing ClusterInfoUpdateJob")__        }_        final CountDownLatch nodeLatch = updateNodeStats(new ActionListener<NodesStatsResponse>() {_            @Override_            public void onResponse(NodesStatsResponse nodeStatses) {_                ImmutableOpenMap.Builder<String, DiskUsage> newLeastAvaiableUsages = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<String, DiskUsage> newMostAvaiableUsages = ImmutableOpenMap.builder()__                fillDiskUsagePerNode(logger, nodeStatses.getNodes(), newLeastAvaiableUsages, newMostAvaiableUsages)__                leastAvailableSpaceUsages = newLeastAvaiableUsages.build()__                mostAvailableSpaceUsages = newMostAvaiableUsages.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("NodeStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    leastAvailableSpaceUsages = ImmutableOpenMap.of()__                    mostAvailableSpaceUsages = ImmutableOpenMap.of()__                }_            }_        })___        final CountDownLatch indicesLatch = updateIndicesStats(new ActionListener<IndicesStatsResponse>() {_            @Override_            public void onResponse(IndicesStatsResponse indicesStatsResponse) {_                ShardStats[] stats = indicesStatsResponse.getShards()__                ImmutableOpenMap.Builder<String, Long> newShardSizes = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<ShardRouting, String> newShardRoutingToDataPath = ImmutableOpenMap.builder()__                buildShardLevelInfo(logger, stats, newShardSizes, newShardRoutingToDataPath, clusterService.state())__                shardSizes = newShardSizes.build()__                shardRoutingToDataPath = newShardRoutingToDataPath.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("IndicesStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    shardSizes = ImmutableOpenMap.of()__                    shardRoutingToDataPath = ImmutableOpenMap.of()__                }_            }_        })___        try {_            nodeLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _            logger.warn("Failed to update node information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__        }__        try {_            indicesLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _            logger.warn("Failed to update shard information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__        }_        ClusterInfo clusterInfo = getClusterInfo()__        try {_            listener.accept(clusterInfo)__        } catch (Exception e) {_            logger.info("Failed executing ClusterInfoService listener", e)__        }_        return clusterInfo__    };refreshes,the,cluster,info,in,a,blocking,fashion;public,final,cluster,info,refresh,if,logger,is,trace,enabled,logger,trace,performing,cluster,info,update,job,final,count,down,latch,node,latch,update,node,stats,new,action,listener,nodes,stats,response,override,public,void,on,response,nodes,stats,response,node,statses,immutable,open,map,builder,string,disk,usage,new,least,avaiable,usages,immutable,open,map,builder,immutable,open,map,builder,string,disk,usage,new,most,avaiable,usages,immutable,open,map,builder,fill,disk,usage,per,node,logger,node,statses,get,nodes,new,least,avaiable,usages,new,most,avaiable,usages,least,available,space,usages,new,least,avaiable,usages,build,most,available,space,usages,new,most,avaiable,usages,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,node,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,least,available,space,usages,immutable,open,map,of,most,available,space,usages,immutable,open,map,of,final,count,down,latch,indices,latch,update,indices,stats,new,action,listener,indices,stats,response,override,public,void,on,response,indices,stats,response,indices,stats,response,shard,stats,stats,indices,stats,response,get,shards,immutable,open,map,builder,string,long,new,shard,sizes,immutable,open,map,builder,immutable,open,map,builder,shard,routing,string,new,shard,routing,to,data,path,immutable,open,map,builder,build,shard,level,info,logger,stats,new,shard,sizes,new,shard,routing,to,data,path,cluster,service,state,shard,sizes,new,shard,sizes,build,shard,routing,to,data,path,new,shard,routing,to,data,path,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,indices,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,shard,sizes,immutable,open,map,of,shard,routing,to,data,path,immutable,open,map,of,try,node,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,logger,warn,failed,to,update,node,information,for,cluster,info,update,job,within,timeout,fetch,timeout,try,indices,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,logger,warn,failed,to,update,shard,information,for,cluster,info,update,job,within,timeout,fetch,timeout,cluster,info,cluster,info,get,cluster,info,try,listener,accept,cluster,info,catch,exception,e,logger,info,failed,executing,cluster,info,service,listener,e,return,cluster,info
InternalClusterInfoService -> public final ClusterInfo refresh();1542402632;Refreshes the ClusterInfo in a blocking fashion;public final ClusterInfo refresh() {_        if (logger.isTraceEnabled()) {_            logger.trace("Performing ClusterInfoUpdateJob")__        }_        final CountDownLatch nodeLatch = updateNodeStats(new ActionListener<NodesStatsResponse>() {_            @Override_            public void onResponse(NodesStatsResponse nodeStatses) {_                ImmutableOpenMap.Builder<String, DiskUsage> newLeastAvaiableUsages = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<String, DiskUsage> newMostAvaiableUsages = ImmutableOpenMap.builder()__                fillDiskUsagePerNode(logger, nodeStatses.getNodes(), newLeastAvaiableUsages, newMostAvaiableUsages)__                leastAvailableSpaceUsages = newLeastAvaiableUsages.build()__                mostAvailableSpaceUsages = newMostAvaiableUsages.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("NodeStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    leastAvailableSpaceUsages = ImmutableOpenMap.of()__                    mostAvailableSpaceUsages = ImmutableOpenMap.of()__                }_            }_        })___        final CountDownLatch indicesLatch = updateIndicesStats(new ActionListener<IndicesStatsResponse>() {_            @Override_            public void onResponse(IndicesStatsResponse indicesStatsResponse) {_                ShardStats[] stats = indicesStatsResponse.getShards()__                ImmutableOpenMap.Builder<String, Long> newShardSizes = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<ShardRouting, String> newShardRoutingToDataPath = ImmutableOpenMap.builder()__                buildShardLevelInfo(logger, stats, newShardSizes, newShardRoutingToDataPath, clusterService.state())__                shardSizes = newShardSizes.build()__                shardRoutingToDataPath = newShardRoutingToDataPath.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("IndicesStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    shardSizes = ImmutableOpenMap.of()__                    shardRoutingToDataPath = ImmutableOpenMap.of()__                }_            }_        })___        try {_            nodeLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _            logger.warn("Failed to update node information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__        }__        try {_            indicesLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS)__        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _            logger.warn("Failed to update shard information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__        }_        ClusterInfo clusterInfo = getClusterInfo()__        try {_            listener.accept(clusterInfo)__        } catch (Exception e) {_            logger.info("Failed executing ClusterInfoService listener", e)__        }_        return clusterInfo__    };refreshes,the,cluster,info,in,a,blocking,fashion;public,final,cluster,info,refresh,if,logger,is,trace,enabled,logger,trace,performing,cluster,info,update,job,final,count,down,latch,node,latch,update,node,stats,new,action,listener,nodes,stats,response,override,public,void,on,response,nodes,stats,response,node,statses,immutable,open,map,builder,string,disk,usage,new,least,avaiable,usages,immutable,open,map,builder,immutable,open,map,builder,string,disk,usage,new,most,avaiable,usages,immutable,open,map,builder,fill,disk,usage,per,node,logger,node,statses,get,nodes,new,least,avaiable,usages,new,most,avaiable,usages,least,available,space,usages,new,least,avaiable,usages,build,most,available,space,usages,new,most,avaiable,usages,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,node,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,least,available,space,usages,immutable,open,map,of,most,available,space,usages,immutable,open,map,of,final,count,down,latch,indices,latch,update,indices,stats,new,action,listener,indices,stats,response,override,public,void,on,response,indices,stats,response,indices,stats,response,shard,stats,stats,indices,stats,response,get,shards,immutable,open,map,builder,string,long,new,shard,sizes,immutable,open,map,builder,immutable,open,map,builder,shard,routing,string,new,shard,routing,to,data,path,immutable,open,map,builder,build,shard,level,info,logger,stats,new,shard,sizes,new,shard,routing,to,data,path,cluster,service,state,shard,sizes,new,shard,sizes,build,shard,routing,to,data,path,new,shard,routing,to,data,path,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,indices,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,shard,sizes,immutable,open,map,of,shard,routing,to,data,path,immutable,open,map,of,try,node,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,logger,warn,failed,to,update,node,information,for,cluster,info,update,job,within,timeout,fetch,timeout,try,indices,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,catch,interrupted,exception,e,thread,current,thread,interrupt,logger,warn,failed,to,update,shard,information,for,cluster,info,update,job,within,timeout,fetch,timeout,cluster,info,cluster,info,get,cluster,info,try,listener,accept,cluster,info,catch,exception,e,logger,info,failed,executing,cluster,info,service,listener,e,return,cluster,info
InternalClusterInfoService -> public final ClusterInfo refresh();1545224398;Refreshes the ClusterInfo in a blocking fashion;public final ClusterInfo refresh() {_        if (logger.isTraceEnabled()) {_            logger.trace("Performing ClusterInfoUpdateJob")__        }_        final CountDownLatch nodeLatch = updateNodeStats(new ActionListener<NodesStatsResponse>() {_            @Override_            public void onResponse(NodesStatsResponse nodeStatses) {_                ImmutableOpenMap.Builder<String, DiskUsage> newLeastAvaiableUsages = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<String, DiskUsage> newMostAvaiableUsages = ImmutableOpenMap.builder()__                fillDiskUsagePerNode(logger, nodeStatses.getNodes(), newLeastAvaiableUsages, newMostAvaiableUsages)__                leastAvailableSpaceUsages = newLeastAvaiableUsages.build()__                mostAvailableSpaceUsages = newMostAvaiableUsages.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("NodeStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    leastAvailableSpaceUsages = ImmutableOpenMap.of()__                    mostAvailableSpaceUsages = ImmutableOpenMap.of()__                }_            }_        })___        final CountDownLatch indicesLatch = updateIndicesStats(new ActionListener<IndicesStatsResponse>() {_            @Override_            public void onResponse(IndicesStatsResponse indicesStatsResponse) {_                ShardStats[] stats = indicesStatsResponse.getShards()__                ImmutableOpenMap.Builder<String, Long> newShardSizes = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<ShardRouting, String> newShardRoutingToDataPath = ImmutableOpenMap.builder()__                buildShardLevelInfo(logger, stats, newShardSizes, newShardRoutingToDataPath, clusterService.state())__                shardSizes = newShardSizes.build()__                shardRoutingToDataPath = newShardRoutingToDataPath.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("IndicesStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    shardSizes = ImmutableOpenMap.of()__                    shardRoutingToDataPath = ImmutableOpenMap.of()__                }_            }_        })___        try {_            if (nodeLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS) == false) {_                logger.warn("Failed to update node information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _        }__        try {_            if (indicesLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS) == false) {_                logger.warn("Failed to update shard information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _        }_        ClusterInfo clusterInfo = getClusterInfo()__        try {_            listener.accept(clusterInfo)__        } catch (Exception e) {_            logger.info("Failed executing ClusterInfoService listener", e)__        }_        return clusterInfo__    };refreshes,the,cluster,info,in,a,blocking,fashion;public,final,cluster,info,refresh,if,logger,is,trace,enabled,logger,trace,performing,cluster,info,update,job,final,count,down,latch,node,latch,update,node,stats,new,action,listener,nodes,stats,response,override,public,void,on,response,nodes,stats,response,node,statses,immutable,open,map,builder,string,disk,usage,new,least,avaiable,usages,immutable,open,map,builder,immutable,open,map,builder,string,disk,usage,new,most,avaiable,usages,immutable,open,map,builder,fill,disk,usage,per,node,logger,node,statses,get,nodes,new,least,avaiable,usages,new,most,avaiable,usages,least,available,space,usages,new,least,avaiable,usages,build,most,available,space,usages,new,most,avaiable,usages,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,node,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,least,available,space,usages,immutable,open,map,of,most,available,space,usages,immutable,open,map,of,final,count,down,latch,indices,latch,update,indices,stats,new,action,listener,indices,stats,response,override,public,void,on,response,indices,stats,response,indices,stats,response,shard,stats,stats,indices,stats,response,get,shards,immutable,open,map,builder,string,long,new,shard,sizes,immutable,open,map,builder,immutable,open,map,builder,shard,routing,string,new,shard,routing,to,data,path,immutable,open,map,builder,build,shard,level,info,logger,stats,new,shard,sizes,new,shard,routing,to,data,path,cluster,service,state,shard,sizes,new,shard,sizes,build,shard,routing,to,data,path,new,shard,routing,to,data,path,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,indices,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,shard,sizes,immutable,open,map,of,shard,routing,to,data,path,immutable,open,map,of,try,if,node,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,false,logger,warn,failed,to,update,node,information,for,cluster,info,update,job,within,timeout,fetch,timeout,catch,interrupted,exception,e,thread,current,thread,interrupt,try,if,indices,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,false,logger,warn,failed,to,update,shard,information,for,cluster,info,update,job,within,timeout,fetch,timeout,catch,interrupted,exception,e,thread,current,thread,interrupt,cluster,info,cluster,info,get,cluster,info,try,listener,accept,cluster,info,catch,exception,e,logger,info,failed,executing,cluster,info,service,listener,e,return,cluster,info
InternalClusterInfoService -> public final ClusterInfo refresh();1548662486;Refreshes the ClusterInfo in a blocking fashion;public final ClusterInfo refresh() {_        if (logger.isTraceEnabled()) {_            logger.trace("Performing ClusterInfoUpdateJob")__        }_        final CountDownLatch nodeLatch = updateNodeStats(new ActionListener<NodesStatsResponse>() {_            @Override_            public void onResponse(NodesStatsResponse nodeStatses) {_                ImmutableOpenMap.Builder<String, DiskUsage> newLeastAvaiableUsages = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<String, DiskUsage> newMostAvaiableUsages = ImmutableOpenMap.builder()__                fillDiskUsagePerNode(logger, nodeStatses.getNodes(), newLeastAvaiableUsages, newMostAvaiableUsages)__                leastAvailableSpaceUsages = newLeastAvaiableUsages.build()__                mostAvailableSpaceUsages = newMostAvaiableUsages.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("NodeStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute NodeStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    leastAvailableSpaceUsages = ImmutableOpenMap.of()__                    mostAvailableSpaceUsages = ImmutableOpenMap.of()__                }_            }_        })___        final CountDownLatch indicesLatch = updateIndicesStats(new ActionListener<IndicesStatsResponse>() {_            @Override_            public void onResponse(IndicesStatsResponse indicesStatsResponse) {_                ShardStats[] stats = indicesStatsResponse.getShards()__                ImmutableOpenMap.Builder<String, Long> newShardSizes = ImmutableOpenMap.builder()__                ImmutableOpenMap.Builder<ShardRouting, String> newShardRoutingToDataPath = ImmutableOpenMap.builder()__                buildShardLevelInfo(logger, stats, newShardSizes, newShardRoutingToDataPath, clusterService.state())__                shardSizes = newShardSizes.build()__                shardRoutingToDataPath = newShardRoutingToDataPath.build()__            }__            @Override_            public void onFailure(Exception e) {_                if (e instanceof ReceiveTimeoutTransportException) {_                    logger.error("IndicesStatsAction timed out for ClusterInfoUpdateJob", e)__                } else {_                    if (e instanceof ClusterBlockException) {_                        if (logger.isTraceEnabled()) {_                            logger.trace("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                        }_                    } else {_                        logger.warn("Failed to execute IndicesStatsAction for ClusterInfoUpdateJob", e)__                    }_                    _                    shardSizes = ImmutableOpenMap.of()__                    shardRoutingToDataPath = ImmutableOpenMap.of()__                }_            }_        })___        try {_            if (nodeLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS) == false) {_                logger.warn("Failed to update node information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _        }__        try {_            if (indicesLatch.await(fetchTimeout.getMillis(), TimeUnit.MILLISECONDS) == false) {_                logger.warn("Failed to update shard information for ClusterInfoUpdateJob within {} timeout", fetchTimeout)__            }_        } catch (InterruptedException e) {_            Thread.currentThread().interrupt()_ _        }_        ClusterInfo clusterInfo = getClusterInfo()__        try {_            listener.accept(clusterInfo)__        } catch (Exception e) {_            logger.info("Failed executing ClusterInfoService listener", e)__        }_        return clusterInfo__    };refreshes,the,cluster,info,in,a,blocking,fashion;public,final,cluster,info,refresh,if,logger,is,trace,enabled,logger,trace,performing,cluster,info,update,job,final,count,down,latch,node,latch,update,node,stats,new,action,listener,nodes,stats,response,override,public,void,on,response,nodes,stats,response,node,statses,immutable,open,map,builder,string,disk,usage,new,least,avaiable,usages,immutable,open,map,builder,immutable,open,map,builder,string,disk,usage,new,most,avaiable,usages,immutable,open,map,builder,fill,disk,usage,per,node,logger,node,statses,get,nodes,new,least,avaiable,usages,new,most,avaiable,usages,least,available,space,usages,new,least,avaiable,usages,build,most,available,space,usages,new,most,avaiable,usages,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,node,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,node,stats,action,for,cluster,info,update,job,e,least,available,space,usages,immutable,open,map,of,most,available,space,usages,immutable,open,map,of,final,count,down,latch,indices,latch,update,indices,stats,new,action,listener,indices,stats,response,override,public,void,on,response,indices,stats,response,indices,stats,response,shard,stats,stats,indices,stats,response,get,shards,immutable,open,map,builder,string,long,new,shard,sizes,immutable,open,map,builder,immutable,open,map,builder,shard,routing,string,new,shard,routing,to,data,path,immutable,open,map,builder,build,shard,level,info,logger,stats,new,shard,sizes,new,shard,routing,to,data,path,cluster,service,state,shard,sizes,new,shard,sizes,build,shard,routing,to,data,path,new,shard,routing,to,data,path,build,override,public,void,on,failure,exception,e,if,e,instanceof,receive,timeout,transport,exception,logger,error,indices,stats,action,timed,out,for,cluster,info,update,job,e,else,if,e,instanceof,cluster,block,exception,if,logger,is,trace,enabled,logger,trace,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,else,logger,warn,failed,to,execute,indices,stats,action,for,cluster,info,update,job,e,shard,sizes,immutable,open,map,of,shard,routing,to,data,path,immutable,open,map,of,try,if,node,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,false,logger,warn,failed,to,update,node,information,for,cluster,info,update,job,within,timeout,fetch,timeout,catch,interrupted,exception,e,thread,current,thread,interrupt,try,if,indices,latch,await,fetch,timeout,get,millis,time,unit,milliseconds,false,logger,warn,failed,to,update,shard,information,for,cluster,info,update,job,within,timeout,fetch,timeout,catch,interrupted,exception,e,thread,current,thread,interrupt,cluster,info,cluster,info,get,cluster,info,try,listener,accept,cluster,info,catch,exception,e,logger,info,failed,executing,cluster,info,service,listener,e,return,cluster,info
InternalClusterInfoService -> protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener);1524684173;Retrieve the latest indices stats, calling the listener when complete_@return a latch that can be used to wait for the indices stats to complete if desired;protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest()__        indicesStatsRequest.clear()__        indicesStatsRequest.store(true)___        client.admin().indices().stats(indicesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,indices,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,indices,stats,to,complete,if,desired;protected,count,down,latch,update,indices,stats,final,action,listener,indices,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,indices,stats,request,indices,stats,request,new,indices,stats,request,indices,stats,request,clear,indices,stats,request,store,true,client,admin,indices,stats,indices,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener);1528762805;Retrieve the latest indices stats, calling the listener when complete_@return a latch that can be used to wait for the indices stats to complete if desired;protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest()__        indicesStatsRequest.clear()__        indicesStatsRequest.store(true)___        client.admin().indices().stats(indicesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,indices,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,indices,stats,to,complete,if,desired;protected,count,down,latch,update,indices,stats,final,action,listener,indices,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,indices,stats,request,indices,stats,request,new,indices,stats,request,indices,stats,request,clear,indices,stats,request,store,true,client,admin,indices,stats,indices,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener);1540847035;Retrieve the latest indices stats, calling the listener when complete_@return a latch that can be used to wait for the indices stats to complete if desired;protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest()__        indicesStatsRequest.clear()__        indicesStatsRequest.store(true)___        client.admin().indices().stats(indicesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,indices,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,indices,stats,to,complete,if,desired;protected,count,down,latch,update,indices,stats,final,action,listener,indices,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,indices,stats,request,indices,stats,request,new,indices,stats,request,indices,stats,request,clear,indices,stats,request,store,true,client,admin,indices,stats,indices,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener);1541092382;Retrieve the latest indices stats, calling the listener when complete_@return a latch that can be used to wait for the indices stats to complete if desired;protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest()__        indicesStatsRequest.clear()__        indicesStatsRequest.store(true)___        client.admin().indices().stats(indicesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,indices,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,indices,stats,to,complete,if,desired;protected,count,down,latch,update,indices,stats,final,action,listener,indices,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,indices,stats,request,indices,stats,request,new,indices,stats,request,indices,stats,request,clear,indices,stats,request,store,true,client,admin,indices,stats,indices,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener);1542402632;Retrieve the latest indices stats, calling the listener when complete_@return a latch that can be used to wait for the indices stats to complete if desired;protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest()__        indicesStatsRequest.clear()__        indicesStatsRequest.store(true)___        client.admin().indices().stats(indicesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,indices,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,indices,stats,to,complete,if,desired;protected,count,down,latch,update,indices,stats,final,action,listener,indices,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,indices,stats,request,indices,stats,request,new,indices,stats,request,indices,stats,request,clear,indices,stats,request,store,true,client,admin,indices,stats,indices,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener);1545224398;Retrieve the latest indices stats, calling the listener when complete_@return a latch that can be used to wait for the indices stats to complete if desired;protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest()__        indicesStatsRequest.clear()__        indicesStatsRequest.store(true)___        client.admin().indices().stats(indicesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,indices,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,indices,stats,to,complete,if,desired;protected,count,down,latch,update,indices,stats,final,action,listener,indices,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,indices,stats,request,indices,stats,request,new,indices,stats,request,indices,stats,request,clear,indices,stats,request,store,true,client,admin,indices,stats,indices,stats,request,new,latched,action,listener,listener,latch,return,latch
InternalClusterInfoService -> protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener);1548662486;Retrieve the latest indices stats, calling the listener when complete_@return a latch that can be used to wait for the indices stats to complete if desired;protected CountDownLatch updateIndicesStats(final ActionListener<IndicesStatsResponse> listener) {_        final CountDownLatch latch = new CountDownLatch(1)__        final IndicesStatsRequest indicesStatsRequest = new IndicesStatsRequest()__        indicesStatsRequest.clear()__        indicesStatsRequest.store(true)___        client.admin().indices().stats(indicesStatsRequest, new LatchedActionListener<>(listener, latch))__        return latch__    };retrieve,the,latest,indices,stats,calling,the,listener,when,complete,return,a,latch,that,can,be,used,to,wait,for,the,indices,stats,to,complete,if,desired;protected,count,down,latch,update,indices,stats,final,action,listener,indices,stats,response,listener,final,count,down,latch,latch,new,count,down,latch,1,final,indices,stats,request,indices,stats,request,new,indices,stats,request,indices,stats,request,clear,indices,stats,request,store,true,client,admin,indices,stats,indices,stats,request,new,latched,action,listener,listener,latch,return,latch
