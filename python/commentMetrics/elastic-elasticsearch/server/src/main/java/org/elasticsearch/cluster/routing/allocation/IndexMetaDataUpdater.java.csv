commented;modifiers;parameterAmount;loc;comment;code
false;public;2;12;;@Override public void shardInitialized(ShardRouting unassignedShard, ShardRouting initializedShard) {     assert initializedShard.isRelocationTarget() == false : "shardInitialized is not called on relocation target: " + initializedShard.     if (initializedShard.primary()) {         increasePrimaryTerm(initializedShard.shardId()).         Updates updates = changes(initializedShard.shardId()).         assert updates.initializedPrimary == null : "Primary cannot be initialized more than once in same allocation round: " + "(previous: " + updates.initializedPrimary + ", next: " + initializedShard + ")".         updates.initializedPrimary = initializedShard.     } }
false;public;2;13;;@Override public void shardStarted(ShardRouting initializingShard, ShardRouting startedShard) {     assert Objects.equals(initializingShard.allocationId().getId(), startedShard.allocationId().getId()) : "initializingShard.allocationId [" + initializingShard.allocationId().getId() + "] and startedShard.allocationId [" + startedShard.allocationId().getId() + "] have to have the same".     Updates updates = changes(startedShard.shardId()).     updates.addedAllocationIds.add(startedShard.allocationId().getId()).     if (startedShard.primary() && // started shard has to have null recoverySource. have to pick up recoverySource from its initializing state     (initializingShard.recoverySource() == RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE)) {         updates.removedAllocationIds.add(RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID).     } }
false;public;2;11;;@Override public void shardFailed(ShardRouting failedShard, UnassignedInfo unassignedInfo) {     if (failedShard.active() && failedShard.primary()) {         Updates updates = changes(failedShard.shardId()).         if (updates.firstFailedPrimary == null) {             // more than one primary can be failed (because of batching, primary can be failed, replica promoted and then failed...)             updates.firstFailedPrimary = failedShard.         }         increasePrimaryTerm(failedShard.shardId()).     } }
false;public;1;4;;@Override public void relocationCompleted(ShardRouting removedRelocationSource) {     removeAllocationId(removedRelocationSource). }
true;public;2;30;/**  * Updates the current {@link MetaData} based on the changes of this RoutingChangesObserver. Specifically  * we update {@link IndexMetaData#getInSyncAllocationIds()} and {@link IndexMetaData#primaryTerm(int)} based on  * the changes made during this allocation.  *  * @param oldMetaData {@link MetaData} object from before the routing nodes was changed.  * @param newRoutingTable {@link RoutingTable} object after routing changes were applied.  * @return adapted {@link MetaData}, potentially the original one if no change was needed.  */ ;/**  * Updates the current {@link MetaData} based on the changes of this RoutingChangesObserver. Specifically  * we update {@link IndexMetaData#getInSyncAllocationIds()} and {@link IndexMetaData#primaryTerm(int)} based on  * the changes made during this allocation.  *  * @param oldMetaData {@link MetaData} object from before the routing nodes was changed.  * @param newRoutingTable {@link RoutingTable} object after routing changes were applied.  * @return adapted {@link MetaData}, potentially the original one if no change was needed.  */ public MetaData applyChanges(MetaData oldMetaData, RoutingTable newRoutingTable) {     Map<Index, List<Map.Entry<ShardId, Updates>>> changesGroupedByIndex = shardChanges.entrySet().stream().collect(Collectors.groupingBy(e -> e.getKey().getIndex())).     MetaData.Builder metaDataBuilder = null.     for (Map.Entry<Index, List<Map.Entry<ShardId, Updates>>> indexChanges : changesGroupedByIndex.entrySet()) {         Index index = indexChanges.getKey().         final IndexMetaData oldIndexMetaData = oldMetaData.getIndexSafe(index).         IndexMetaData.Builder indexMetaDataBuilder = null.         for (Map.Entry<ShardId, Updates> shardEntry : indexChanges.getValue()) {             ShardId shardId = shardEntry.getKey().             Updates updates = shardEntry.getValue().             indexMetaDataBuilder = updateInSyncAllocations(newRoutingTable, oldIndexMetaData, indexMetaDataBuilder, shardId, updates).             indexMetaDataBuilder = updatePrimaryTerm(oldIndexMetaData, indexMetaDataBuilder, shardId, updates).         }         if (indexMetaDataBuilder != null) {             if (metaDataBuilder == null) {                 metaDataBuilder = MetaData.builder(oldMetaData).             }             metaDataBuilder.put(indexMetaDataBuilder).         }     }     if (metaDataBuilder != null) {         return metaDataBuilder.build().     } else {         return oldMetaData.     } }
true;private;5;86;/**  * Updates in-sync allocations with routing changes that were made to the routing table.  */ ;/**  * Updates in-sync allocations with routing changes that were made to the routing table.  */ private IndexMetaData.Builder updateInSyncAllocations(RoutingTable newRoutingTable, IndexMetaData oldIndexMetaData, IndexMetaData.Builder indexMetaDataBuilder, ShardId shardId, Updates updates) {     assert Sets.haveEmptyIntersection(updates.addedAllocationIds, updates.removedAllocationIds) : "allocation ids cannot be both added and removed in the same allocation round, added ids: " + updates.addedAllocationIds + ", removed ids: " + updates.removedAllocationIds.     Set<String> oldInSyncAllocationIds = oldIndexMetaData.inSyncAllocationIds(shardId.id()).     // check if we have been force-initializing an empty primary or a stale primary     if (updates.initializedPrimary != null && oldInSyncAllocationIds.isEmpty() == false && oldInSyncAllocationIds.contains(updates.initializedPrimary.allocationId().getId()) == false) {         // we're not reusing an existing in-sync allocation id to initialize a primary, which means that we're either force-allocating         // an empty or a stale primary (see AllocateEmptyPrimaryAllocationCommand or AllocateStalePrimaryAllocationCommand).         RecoverySource recoverySource = updates.initializedPrimary.recoverySource().         RecoverySource.Type recoverySourceType = recoverySource.getType().         boolean emptyPrimary = recoverySourceType == RecoverySource.Type.EMPTY_STORE.         assert updates.addedAllocationIds.isEmpty() : (emptyPrimary ? "empty" : "stale") + " primary is not force-initialized in same allocation round where shards are started".         if (indexMetaDataBuilder == null) {             indexMetaDataBuilder = IndexMetaData.builder(oldIndexMetaData).         }         if (emptyPrimary) {             // forcing an empty primary resets the in-sync allocations to the empty set (ShardRouting.allocatedPostIndexCreate)             indexMetaDataBuilder.putInSyncAllocationIds(shardId.id(), Collections.emptySet()).         } else {             final String allocationId.             if (recoverySource == RecoverySource.ExistingStoreRecoverySource.FORCE_STALE_PRIMARY_INSTANCE) {                 allocationId = RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID.             } else {                 assert recoverySource instanceof RecoverySource.SnapshotRecoverySource : recoverySource.                 allocationId = updates.initializedPrimary.allocationId().getId().             }             // forcing a stale primary resets the in-sync allocations to the singleton set with the stale id             indexMetaDataBuilder.putInSyncAllocationIds(shardId.id(), Collections.singleton(allocationId)).         }     } else {         // standard path for updating in-sync ids         Set<String> inSyncAllocationIds = new HashSet<>(oldInSyncAllocationIds).         inSyncAllocationIds.addAll(updates.addedAllocationIds).         inSyncAllocationIds.removeAll(updates.removedAllocationIds).         assert oldInSyncAllocationIds.contains(RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID) == false || inSyncAllocationIds.contains(RecoverySource.ExistingStoreRecoverySource.FORCED_ALLOCATION_ID) == false : "fake allocation id has to be removed, inSyncAllocationIds:" + inSyncAllocationIds.         // Prevent set of inSyncAllocationIds to grow unboundedly. This can happen for example if we don't write to a primary         // but repeatedly shut down nodes that have active replicas.         // We use number_of_replicas + 1 (= possible active shard copies) to bound the inSyncAllocationIds set         // Only trim the set of allocation ids when it grows, otherwise we might trim too eagerly when the number         // of replicas was decreased while shards were unassigned.         // +1 for the primary         int maxActiveShards = oldIndexMetaData.getNumberOfReplicas() + 1.         IndexShardRoutingTable newShardRoutingTable = newRoutingTable.shardRoutingTable(shardId).         if (inSyncAllocationIds.size() > oldInSyncAllocationIds.size() && inSyncAllocationIds.size() > maxActiveShards) {             // trim entries that have no corresponding shard routing in the cluster state (i.e. trim unavailable copies)             List<ShardRouting> assignedShards = newShardRoutingTable.assignedShards().             assert assignedShards.size() <= maxActiveShards : "cannot have more assigned shards " + assignedShards + " than maximum possible active shards " + maxActiveShards.             Set<String> assignedAllocations = assignedShards.stream().map(s -> s.allocationId().getId()).collect(Collectors.toSet()).             inSyncAllocationIds = inSyncAllocationIds.stream().sorted(// values with routing entries first             Comparator.comparing(assignedAllocations::contains).reversed()).limit(maxActiveShards).collect(Collectors.toSet()).         }         // in-sync set, this could create an empty primary on the next allocation.         if (newShardRoutingTable.activeShards().isEmpty() && updates.firstFailedPrimary != null) {             // add back allocation id of failed primary             inSyncAllocationIds.add(updates.firstFailedPrimary.allocationId().getId()).         }         assert inSyncAllocationIds.isEmpty() == false || oldInSyncAllocationIds.isEmpty() : "in-sync allocations cannot become empty after they have been non-empty: " + oldInSyncAllocationIds.         // be extra safe here and only update in-sync set if it is non-empty         if (inSyncAllocationIds.isEmpty() == false) {             if (indexMetaDataBuilder == null) {                 indexMetaDataBuilder = IndexMetaData.builder(oldIndexMetaData).             }             indexMetaDataBuilder.putInSyncAllocationIds(shardId.id(), inSyncAllocationIds).         }     }     return indexMetaDataBuilder. }
true;public,static;3;45;/**  * Removes allocation ids from the in-sync set for shard copies for which there is no routing entries in the routing table.  * This method is called in AllocationService before any changes to the routing table are made.  */ ;/**  * Removes allocation ids from the in-sync set for shard copies for which there is no routing entries in the routing table.  * This method is called in AllocationService before any changes to the routing table are made.  */ public static ClusterState removeStaleIdsWithoutRoutings(ClusterState clusterState, List<StaleShard> staleShards, Logger logger) {     MetaData oldMetaData = clusterState.metaData().     RoutingTable oldRoutingTable = clusterState.routingTable().     MetaData.Builder metaDataBuilder = null.     // group staleShards entries by index     for (Map.Entry<Index, List<StaleShard>> indexEntry : staleShards.stream().collect(Collectors.groupingBy(fs -> fs.getShardId().getIndex())).entrySet()) {         final IndexMetaData oldIndexMetaData = oldMetaData.getIndexSafe(indexEntry.getKey()).         IndexMetaData.Builder indexMetaDataBuilder = null.         // group staleShards entries by shard id         for (Map.Entry<ShardId, List<StaleShard>> shardEntry : indexEntry.getValue().stream().collect(Collectors.groupingBy(staleShard -> staleShard.getShardId())).entrySet()) {             int shardNumber = shardEntry.getKey().getId().             Set<String> oldInSyncAllocations = oldIndexMetaData.inSyncAllocationIds(shardNumber).             Set<String> idsToRemove = shardEntry.getValue().stream().map(e -> e.getAllocationId()).collect(Collectors.toSet()).             assert idsToRemove.stream().allMatch(id -> oldRoutingTable.getByAllocationId(shardEntry.getKey(), id) == null) : "removing stale ids: " + idsToRemove + ", some of which have still a routing entry: " + oldRoutingTable.             Set<String> remainingInSyncAllocations = Sets.difference(oldInSyncAllocations, idsToRemove).             assert remainingInSyncAllocations.isEmpty() == false : "Set of in-sync ids cannot become empty for shard " + shardEntry.getKey() + " (before: " + oldInSyncAllocations + ", ids to remove: " + idsToRemove + ")".             // (see ShardRouting#allocatedPostIndexCreate)             if (remainingInSyncAllocations.isEmpty() == false) {                 if (indexMetaDataBuilder == null) {                     indexMetaDataBuilder = IndexMetaData.builder(oldIndexMetaData).                 }                 indexMetaDataBuilder.putInSyncAllocationIds(shardNumber, remainingInSyncAllocations).             }             logger.warn("{} marking unavailable shards as stale: {}", shardEntry.getKey(), idsToRemove).         }         if (indexMetaDataBuilder != null) {             if (metaDataBuilder == null) {                 metaDataBuilder = MetaData.builder(oldMetaData).             }             metaDataBuilder.put(indexMetaDataBuilder).         }     }     if (metaDataBuilder != null) {         return ClusterState.builder(clusterState).metaData(metaDataBuilder).build().     } else {         return clusterState.     } }
true;private;4;10;/**  * Increases the primary term if {@link #increasePrimaryTerm} was called for this shard id.  */ ;/**  * Increases the primary term if {@link #increasePrimaryTerm} was called for this shard id.  */ private IndexMetaData.Builder updatePrimaryTerm(IndexMetaData oldIndexMetaData, IndexMetaData.Builder indexMetaDataBuilder, ShardId shardId, Updates updates) {     if (updates.increaseTerm) {         if (indexMetaDataBuilder == null) {             indexMetaDataBuilder = IndexMetaData.builder(oldIndexMetaData).         }         indexMetaDataBuilder.primaryTerm(shardId.id(), oldIndexMetaData.primaryTerm(shardId.id()) + 1).     }     return indexMetaDataBuilder. }
true;private;1;3;/**  * Helper method that creates update entry for the given shard id if such an entry does not exist yet.  */ ;/**  * Helper method that creates update entry for the given shard id if such an entry does not exist yet.  */ private Updates changes(ShardId shardId) {     return shardChanges.computeIfAbsent(shardId, k -> new Updates()). }
true;;1;5;/**  * Remove allocation id of this shard from the set of in-sync shard copies  */ ;/**  * Remove allocation id of this shard from the set of in-sync shard copies  */ void removeAllocationId(ShardRouting shardRouting) {     if (shardRouting.active()) {         changes(shardRouting.shardId()).removedAllocationIds.add(shardRouting.allocationId().getId()).     } }
true;private;1;3;/**  * Increase primary term for this shard id  */ ;/**  * Increase primary term for this shard id  */ private void increasePrimaryTerm(ShardId shardId) {     changes(shardId).increaseTerm = true. }
