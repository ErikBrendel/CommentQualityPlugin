commented;modifiers;parameterAmount;loc;comment;code
false;public;1;5;;@Override public void log(StatusData data) {     error.set(true).     super.log(data). }
true;public,static;0;4;/**  * Registers a listener for status logger errors. This listener should be registered as early as possible to ensure that no errors are  * logged by the status logger before logging is configured.  */ ;/**  * Registers a listener for status logger errors. This listener should be registered as early as possible to ensure that no errors are  * logged by the status logger before logging is configured.  */ public static void registerErrorListener() {     error.set(false).     StatusLogger.getLogger().registerListener(ERROR_LISTENER). }
true;public,static;1;6;/**  * Configure logging without reading a log4j2.properties file, effectively configuring the  * status logger and all loggers to the console.  *  * @param settings for configuring logger.level and individual loggers  */ ;/**  * Configure logging without reading a log4j2.properties file, effectively configuring the  * status logger and all loggers to the console.  *  * @param settings for configuring logger.level and individual loggers  */ public static void configureWithoutConfig(final Settings settings) {     Objects.requireNonNull(settings).     // we initialize the status logger immediately otherwise Log4j will complain when we try to get the context     configureStatusLogger().     configureLoggerLevels(settings). }
true;public,static;1;11;/**  * Configure logging reading from any log4j2.properties found in the config directory and its  * subdirectories from the specified environment. Will also configure logging to point the logs  * directory from the specified environment.  *  * @param environment the environment for reading configs and the logs path  * @throws IOException   if there is an issue readings any log4j2.properties in the config  *                       directory  * @throws UserException if there are no log4j2.properties in the specified configs path  */ ;/**  * Configure logging reading from any log4j2.properties found in the config directory and its  * subdirectories from the specified environment. Will also configure logging to point the logs  * directory from the specified environment.  *  * @param environment the environment for reading configs and the logs path  * @throws IOException   if there is an issue readings any log4j2.properties in the config  *                       directory  * @throws UserException if there are no log4j2.properties in the specified configs path  */ public static void configure(final Environment environment) throws IOException, UserException {     Objects.requireNonNull(environment).     try {         // we are about to configure logging, check that the status logger did not log any error-level messages         checkErrorListener().     } finally {         // whether or not the error listener check failed we can remove the listener now         StatusLogger.getLogger().removeListener(ERROR_LISTENER).     }     configure(environment.settings(), environment.configFile(), environment.logsFile()). }
true;public,static;0;3;/**  * Load logging plugins so we can have {@code node_name} in the pattern.  */ ;/**  * Load logging plugins so we can have {@code node_name} in the pattern.  */ public static void loadLog4jPlugins() {     PluginManager.addPackage(LogConfigurator.class.getPackage().getName()). }
true;public,static;1;3;/**  * Sets the node name. This is called before logging is configured if the  * node name is set in elasticsearch.yml. Otherwise it is called as soon  * as the node id is available.  */ ;/**  * Sets the node name. This is called before logging is configured if the  * node name is set in elasticsearch.yml. Otherwise it is called as soon  * as the node id is available.  */ public static void setNodeName(String nodeName) {     NodeNamePatternConverter.setNodeName(nodeName). }
false;private,static;0;6;;private static void checkErrorListener() {     assert errorListenerIsRegistered() : "expected error listener to be registered".     if (error.get()) {         throw new IllegalStateException("status logger logged an error before logging was configured").     } }
false;private,static;0;3;;private static boolean errorListenerIsRegistered() {     return StreamSupport.stream(StatusLogger.getLogger().getListeners().spliterator(), false).anyMatch(l -> l == ERROR_LISTENER). }
false;public;2;33;;@Override public PropertiesConfiguration getConfiguration(final LoggerContext loggerContext, final ConfigurationSource source) {     final Properties properties = new Properties().     try (InputStream configStream = source.getInputStream()) {         properties.load(configStream).     } catch (final IOException ioe) {         throw new ConfigurationException("Unable to load " + source.toString(), ioe).     }     // Hack the new pattern into place     for (String name : properties.stringPropertyNames()) {         if (false == name.endsWith(".pattern"))             continue.         // Null is weird here but we can't do anything with it so ignore it         String value = properties.getProperty(name).         if (value == null)             continue.         // Tests don't need to be changed         if (value.contains("%test_thread_info"))             continue.         /*                      * Patterns without a marker are sufficiently customized                      * that we don't have an opinion about them.                      */         if (false == value.contains("%marker"))             continue.         if (false == value.contains("%node_name")) {             locationsWithDeprecatedPatterns.add(source.getLocation()).             properties.setProperty(name, value.replace("%marker", "[%node_name]%marker ")).         }     }     // end hack     return new PropertiesConfigurationBuilder().setConfigurationSource(source).setRootProperties(properties).setLoggerContext(loggerContext).build(). }
false;public;2;7;;@Override public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {     if (file.getFileName().toString().equals("log4j2.properties")) {         configurations.add((PropertiesConfiguration) factory.getConfiguration(context, file.toString(), file.toUri())).     }     return FileVisitResult.CONTINUE. }
false;private,static;3;89;;private static void configure(final Settings settings, final Path configsPath, final Path logsPath) throws IOException, UserException {     Objects.requireNonNull(settings).     Objects.requireNonNull(configsPath).     Objects.requireNonNull(logsPath).     loadLog4jPlugins().     setLogConfigurationSystemProperty(logsPath, settings).     // we initialize the status logger immediately otherwise Log4j will complain when we try to get the context     configureStatusLogger().     final LoggerContext context = (LoggerContext) LogManager.getContext(false).     final Set<String> locationsWithDeprecatedPatterns = Collections.synchronizedSet(new HashSet<>()).     final List<AbstractConfiguration> configurations = new ArrayList<>().     /*          * Subclass the properties configurator to hack the new pattern in          * place so users don't have to change log4j2.properties in          * a minor release. In 7.0 we'll remove this and force users to          * change log4j2.properties. If they don't customize log4j2.properties          * then they won't have to do anything anyway.          *          * Everything in this subclass that isn't marked as a hack is copied          * from log4j2's source.          */     final PropertiesConfigurationFactory factory = new PropertiesConfigurationFactory() {          @Override         public PropertiesConfiguration getConfiguration(final LoggerContext loggerContext, final ConfigurationSource source) {             final Properties properties = new Properties().             try (InputStream configStream = source.getInputStream()) {                 properties.load(configStream).             } catch (final IOException ioe) {                 throw new ConfigurationException("Unable to load " + source.toString(), ioe).             }             // Hack the new pattern into place             for (String name : properties.stringPropertyNames()) {                 if (false == name.endsWith(".pattern"))                     continue.                 // Null is weird here but we can't do anything with it so ignore it                 String value = properties.getProperty(name).                 if (value == null)                     continue.                 // Tests don't need to be changed                 if (value.contains("%test_thread_info"))                     continue.                 /*                      * Patterns without a marker are sufficiently customized                      * that we don't have an opinion about them.                      */                 if (false == value.contains("%marker"))                     continue.                 if (false == value.contains("%node_name")) {                     locationsWithDeprecatedPatterns.add(source.getLocation()).                     properties.setProperty(name, value.replace("%marker", "[%node_name]%marker ")).                 }             }             // end hack             return new PropertiesConfigurationBuilder().setConfigurationSource(source).setRootProperties(properties).setLoggerContext(loggerContext).build().         }     }.     final Set<FileVisitOption> options = EnumSet.of(FileVisitOption.FOLLOW_LINKS).     Files.walkFileTree(configsPath, options, Integer.MAX_VALUE, new SimpleFileVisitor<Path>() {          @Override         public FileVisitResult visitFile(final Path file, final BasicFileAttributes attrs) throws IOException {             if (file.getFileName().toString().equals("log4j2.properties")) {                 configurations.add((PropertiesConfiguration) factory.getConfiguration(context, file.toString(), file.toUri())).             }             return FileVisitResult.CONTINUE.         }     }).     if (configurations.isEmpty()) {         throw new UserException(ExitCodes.CONFIG, "no log4j2.properties found. tried [" + configsPath + "] and its subdirectories").     }     context.start(new CompositeConfiguration(configurations)).     configureLoggerLevels(settings).     final String deprecatedLocationsString = String.join("\n  ", locationsWithDeprecatedPatterns).     if (deprecatedLocationsString.length() > 0) {         LogManager.getLogger(LogConfigurator.class).warn("Some logging configurations have %marker but don't have %node_name. " + "We will automatically add %node_name to the pattern to ease the migration for users who customize " + "log4j2.properties but will stop this behavior in 7.0. You should manually replace `%node_name` with " + "`[%node_name]%marker ` in these locations:\n  {}", deprecatedLocationsString).     } }
false;private,static;0;5;;private static void configureStatusLogger() {     final ConfigurationBuilder<BuiltConfiguration> builder = ConfigurationBuilderFactory.newConfigurationBuilder().     builder.setStatusLevel(Level.ERROR).     Configurator.initialize(builder.build()). }
true;private,static;1;12;/**  * Configures the logging levels for loggers configured in the specified settings.  *  * @param settings the settings from which logger levels will be extracted  */ ;/**  * Configures the logging levels for loggers configured in the specified settings.  *  * @param settings the settings from which logger levels will be extracted  */ private static void configureLoggerLevels(final Settings settings) {     if (Loggers.LOG_DEFAULT_LEVEL_SETTING.exists(settings)) {         final Level level = Loggers.LOG_DEFAULT_LEVEL_SETTING.get(settings).         Loggers.setLevel(LogManager.getRootLogger(), level).     }     Loggers.LOG_LEVEL_SETTING.getAllConcreteSettings(settings).filter(s -> s.getKey().equals(Loggers.LOG_DEFAULT_LEVEL_SETTING.getKey()) == false).forEach(s -> {         final Level level = s.get(settings).         Loggers.setLevel(LogManager.getLogger(s.getKey().substring("logger.".length())), level).     }). }
true;private,static;2;6;/**  * Set system properties that can be used in configuration files to specify paths and file patterns for log files. We expose three  * properties here:  * <ul>  * <li>  * {@code es.logs.base_path} the base path containing the log files  * </li>  * <li>  * {@code es.logs.cluster_name} the cluster name, used as the prefix of log filenames in the default configuration  * </li>  * <li>  * {@code es.logs.node_name} the node name, can be used as part of log filenames  * </li>  * </ul>  *  * @param logsPath the path to the log files  * @param settings the settings to extract the cluster and node names  */ ;/**  * Set system properties that can be used in configuration files to specify paths and file patterns for log files. We expose three  * properties here:  * <ul>  * <li>  * {@code es.logs.base_path} the base path containing the log files  * </li>  * <li>  * {@code es.logs.cluster_name} the cluster name, used as the prefix of log filenames in the default configuration  * </li>  * <li>  * {@code es.logs.node_name} the node name, can be used as part of log filenames  * </li>  * </ul>  *  * @param logsPath the path to the log files  * @param settings the settings to extract the cluster and node names  */ @SuppressForbidden(reason = "sets system property for logging configuration") private static void setLogConfigurationSystemProperty(final Path logsPath, final Settings settings) {     System.setProperty("es.logs.base_path", logsPath.toString()).     System.setProperty("es.logs.cluster_name", ClusterName.CLUSTER_NAME_SETTING.get(settings).value()).     System.setProperty("es.logs.node_name", Node.NODE_NAME_SETTING.get(settings)). }
