commented;modifiers;parameterAmount;loc;comment;code
false;private;2;7;;private void setRequestBreakerLimit(ByteSizeValue newRequestMax, Double newRequestOverhead) {     BreakerSettings newRequestSettings = new BreakerSettings(CircuitBreaker.REQUEST, newRequestMax.getBytes(), newRequestOverhead, this.requestSettings.getType(), this.requestSettings.getDurability()).     registerBreaker(newRequestSettings).     this.requestSettings = newRequestSettings.     logger.info("Updated breaker settings request: {}", newRequestSettings). }
false;private;2;8;;private void setInFlightRequestsBreakerLimit(ByteSizeValue newInFlightRequestsMax, Double newInFlightRequestsOverhead) {     BreakerSettings newInFlightRequestsSettings = new BreakerSettings(CircuitBreaker.IN_FLIGHT_REQUESTS, newInFlightRequestsMax.getBytes(), newInFlightRequestsOverhead, this.inFlightRequestsSettings.getType(), this.inFlightRequestsSettings.getDurability()).     registerBreaker(newInFlightRequestsSettings).     this.inFlightRequestsSettings = newInFlightRequestsSettings.     logger.info("Updated breaker settings for in-flight requests: {}", newInFlightRequestsSettings). }
false;private;2;11;;private void setFieldDataBreakerLimit(ByteSizeValue newFielddataMax, Double newFielddataOverhead) {     long newFielddataLimitBytes = newFielddataMax == null ? HierarchyCircuitBreakerService.this.fielddataSettings.getLimit() : newFielddataMax.getBytes().     newFielddataOverhead = newFielddataOverhead == null ? HierarchyCircuitBreakerService.this.fielddataSettings.getOverhead() : newFielddataOverhead.     BreakerSettings newFielddataSettings = new BreakerSettings(CircuitBreaker.FIELDDATA, newFielddataLimitBytes, newFielddataOverhead, this.fielddataSettings.getType(), this.fielddataSettings.getDurability()).     registerBreaker(newFielddataSettings).     HierarchyCircuitBreakerService.this.fielddataSettings = newFielddataSettings.     logger.info("Updated breaker settings field data: {}", newFielddataSettings). }
false;private;2;8;;private void setAccountingBreakerLimit(ByteSizeValue newAccountingMax, Double newAccountingOverhead) {     BreakerSettings newAccountingSettings = new BreakerSettings(CircuitBreaker.ACCOUNTING, newAccountingMax.getBytes(), newAccountingOverhead, HierarchyCircuitBreakerService.this.accountingSettings.getType(), this.accountingSettings.getDurability()).     registerBreaker(newAccountingSettings).     HierarchyCircuitBreakerService.this.accountingSettings = newAccountingSettings.     logger.info("Updated breaker settings for accounting requests: {}", newAccountingSettings). }
false;private;1;6;;private boolean validateTotalCircuitBreakerLimit(ByteSizeValue byteSizeValue) {     BreakerSettings newParentSettings = new BreakerSettings(CircuitBreaker.PARENT, byteSizeValue.getBytes(), 1.0, CircuitBreaker.Type.PARENT, null).     validateSettings(new BreakerSettings[] { newParentSettings }).     return true. }
false;private;1;5;;private void setTotalCircuitBreakerLimit(ByteSizeValue byteSizeValue) {     BreakerSettings newParentSettings = new BreakerSettings(CircuitBreaker.PARENT, byteSizeValue.getBytes(), 1.0, CircuitBreaker.Type.PARENT, null).     this.parentSettings = newParentSettings. }
true;public,static;1;12;/**  * Validate that child settings are valid  */ ;/**  * Validate that child settings are valid  */ public static void validateSettings(BreakerSettings[] childrenSettings) throws IllegalStateException {     for (BreakerSettings childSettings : childrenSettings) {         // If the child is disabled, ignore it         if (childSettings.getLimit() == -1) {             continue.         }         if (childSettings.getOverhead() < 0) {             throw new IllegalStateException("Child breaker overhead " + childSettings + " must be non-negative").         }     } }
false;public;1;4;;@Override public CircuitBreaker getBreaker(String name) {     return this.breakers.get(name). }
false;public;0;13;;@Override public AllCircuitBreakerStats stats() {     List<CircuitBreakerStats> allStats = new ArrayList<>(this.breakers.size()).     // estimations for each individual breaker     for (CircuitBreaker breaker : this.breakers.values()) {         allStats.add(stats(breaker.getName())).     }     // Manually add the parent breaker settings since they aren't part of the breaker map     allStats.add(new CircuitBreakerStats(CircuitBreaker.PARENT, parentSettings.getLimit(), memoryUsed(0L).totalUsage, 1.0, parentTripCount.get())).     return new AllCircuitBreakerStats(allStats.toArray(new CircuitBreakerStats[allStats.size()])). }
false;public;1;6;;@Override public CircuitBreakerStats stats(String name) {     CircuitBreaker breaker = this.breakers.get(name).     return new CircuitBreakerStats(breaker.getName(), breaker.getLimit(), breaker.getUsed(), breaker.getOverhead(), breaker.getTrippedCount()). }
false;private;1;20;;private MemoryUsage memoryUsed(long newBytesReserved) {     long transientUsage = 0.     long permanentUsage = 0.     for (CircuitBreaker breaker : this.breakers.values()) {         long breakerUsed = (long) (breaker.getUsed() * breaker.getOverhead()).         if (breaker.getDurability() == CircuitBreaker.Durability.TRANSIENT) {             transientUsage += breakerUsed.         } else if (breaker.getDurability() == CircuitBreaker.Durability.PERMANENT) {             permanentUsage += breakerUsed.         }     }     if (this.trackRealMemoryUsage) {         final long current = currentMemoryUsage().         return new MemoryUsage(current, current + newBytesReserved, transientUsage, permanentUsage).     } else {         long parentEstimated = transientUsage + permanentUsage.         return new MemoryUsage(parentEstimated, parentEstimated, transientUsage, permanentUsage).     } }
true;;0;12;// package private to allow overriding it in tests ;// package private to allow overriding it in tests long currentMemoryUsage() {     try {         return MEMORY_MX_BEAN.getHeapMemoryUsage().getUsed().     } catch (IllegalArgumentException ex) {         // recently determined memory usage, we would overestimate memory usage immediately after a garbage collection event.         assert ex.getMessage().matches("committed = \\d+ should be < max = \\d+").         logger.info("Cannot determine current memory usage due to JDK-8207200.", ex).         return 0.     } }
true;public;2;38;/**  * Checks whether the parent breaker has been tripped  */ ;/**  * Checks whether the parent breaker has been tripped  */ public void checkParentLimit(long newBytesReserved, String label) throws CircuitBreakingException {     final MemoryUsage memoryUsed = memoryUsed(newBytesReserved).     long parentLimit = this.parentSettings.getLimit().     if (memoryUsed.totalUsage > parentLimit) {         this.parentTripCount.incrementAndGet().         final StringBuilder message = new StringBuilder("[parent] Data too large, data for [" + label + "]" + " would be [" + memoryUsed.totalUsage + "/" + new ByteSizeValue(memoryUsed.totalUsage) + "]" + ", which is larger than the limit of [" + parentLimit + "/" + new ByteSizeValue(parentLimit) + "]").         if (this.trackRealMemoryUsage) {             final long realUsage = memoryUsed.baseUsage.             message.append(", real usage: [").             message.append(realUsage).             message.append("/").             message.append(new ByteSizeValue(realUsage)).             message.append("], new bytes reserved: [").             message.append(newBytesReserved).             message.append("/").             message.append(new ByteSizeValue(newBytesReserved)).             message.append("]").         } else {             message.append(", usages [").             message.append(String.join(", ", this.breakers.entrySet().stream().map(e -> {                 final CircuitBreaker breaker = e.getValue().                 final long breakerUsed = (long) (breaker.getUsed() * breaker.getOverhead()).                 return e.getKey() + "=" + breakerUsed + "/" + new ByteSizeValue(breakerUsed).             }).collect(Collectors.toList()))).             message.append("]").         }         // derive durability of a tripped parent breaker depending on whether the majority of memory tracked by         // child circuit breakers is categorized as transient or permanent.         CircuitBreaker.Durability durability = memoryUsed.transientChildUsage >= memoryUsed.permanentChildUsage ? CircuitBreaker.Durability.TRANSIENT : CircuitBreaker.Durability.PERMANENT.         throw new CircuitBreakingException(message.toString(), memoryUsed.totalUsage, parentLimit, durability).     } }
true;public;1;31;/**  * Allows to register a custom circuit breaker.  * Warning: Will overwrite any existing custom breaker with the same name.  */ ;/**  * Allows to register a custom circuit breaker.  * Warning: Will overwrite any existing custom breaker with the same name.  */ @Override public void registerBreaker(BreakerSettings breakerSettings) {     // Validate the settings     validateSettings(new BreakerSettings[] { breakerSettings }).     if (breakerSettings.getType() == CircuitBreaker.Type.NOOP) {         CircuitBreaker breaker = new NoopCircuitBreaker(breakerSettings.getName()).         breakers.put(breakerSettings.getName(), breaker).     } else {         CircuitBreaker oldBreaker.         CircuitBreaker breaker = new ChildMemoryCircuitBreaker(breakerSettings, LogManager.getLogger(CHILD_LOGGER_PREFIX + breakerSettings.getName()), this, breakerSettings.getName()).         for (. . ) {             oldBreaker = breakers.putIfAbsent(breakerSettings.getName(), breaker).             if (oldBreaker == null) {                 return.             }             breaker = new ChildMemoryCircuitBreaker(breakerSettings, (ChildMemoryCircuitBreaker) oldBreaker, LogManager.getLogger(CHILD_LOGGER_PREFIX + breakerSettings.getName()), this, breakerSettings.getName()).             if (breakers.replace(breakerSettings.getName(), oldBreaker, breaker)) {                 return.             }         }     } }
