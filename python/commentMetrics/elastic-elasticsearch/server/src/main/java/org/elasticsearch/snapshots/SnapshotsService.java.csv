# id;timestamp;commentText;codeText;commentWords;codeWords
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1524684173;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1524839522;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1542646292;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1542826731;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1544783963;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1545215361;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1547023537;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1547625930;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1547633328;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1547760072;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1548072633;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1548321078;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1548996340;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1549050374;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1549381458;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1549407419;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId);1549637959;Retrieves snapshot from repository__@param repositoryName  repository name_@param snapshotId      snapshot id_@return snapshot_@throws SnapshotMissingException if snapshot is not found;public SnapshotInfo snapshot(final String repositoryName, final SnapshotId snapshotId) {_        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.singletonList(snapshotId.getName()))__        if (!entries.isEmpty()) {_            return inProgressSnapshot(entries.iterator().next())__        }_        return repositoriesService.repository(repositoryName).getSnapshotInfo(snapshotId)__    };retrieves,snapshot,from,repository,param,repository,name,repository,name,param,snapshot,id,snapshot,id,return,snapshot,throws,snapshot,missing,exception,if,snapshot,is,not,found;public,snapshot,info,snapshot,final,string,repository,name,final,snapshot,id,snapshot,id,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,singleton,list,snapshot,id,get,name,if,entries,is,empty,return,in,progress,snapshot,entries,iterator,next,return,repositories,service,repository,repository,name,get,snapshot,info,snapshot,id
SnapshotsService -> public void addListener(SnapshotCompletionListener listener);1524684173;Adds snapshot completion listener__@param listener listener;public void addListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.add(listener)__    };adds,snapshot,completion,listener,param,listener,listener;public,void,add,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,add,listener
SnapshotsService -> public void addListener(SnapshotCompletionListener listener);1524839522;Adds snapshot completion listener__@param listener listener;public void addListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.add(listener)__    };adds,snapshot,completion,listener,param,listener,listener;public,void,add,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,add,listener
SnapshotsService -> public void addListener(SnapshotCompletionListener listener);1542646292;Adds snapshot completion listener__@param listener listener;public void addListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.add(listener)__    };adds,snapshot,completion,listener,param,listener,listener;public,void,add,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,add,listener
SnapshotsService -> public void addListener(SnapshotCompletionListener listener);1542826731;Adds snapshot completion listener__@param listener listener;public void addListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.add(listener)__    };adds,snapshot,completion,listener,param,listener,listener;public,void,add,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,add,listener
SnapshotsService -> public void addListener(SnapshotCompletionListener listener);1544783963;Adds snapshot completion listener__@param listener listener;public void addListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.add(listener)__    };adds,snapshot,completion,listener,param,listener,listener;public,void,add,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,add,listener
SnapshotsService -> public void addListener(SnapshotCompletionListener listener);1545215361;Adds snapshot completion listener__@param listener listener;public void addListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.add(listener)__    };adds,snapshot,completion,listener,param,listener,listener;public,void,add,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,add,listener
SnapshotsService -> public void addListener(SnapshotCompletionListener listener);1547023537;Adds snapshot completion listener__@param listener listener;public void addListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.add(listener)__    };adds,snapshot,completion,listener,param,listener,listener;public,void,add,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,add,listener
SnapshotsService -> public void addListener(SnapshotCompletionListener listener);1547625930;Adds snapshot completion listener__@param listener listener;public void addListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.add(listener)__    };adds,snapshot,completion,listener,param,listener,listener;public,void,add,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,add,listener
SnapshotsService -> public void addListener(SnapshotCompletionListener listener);1547633328;Adds snapshot completion listener__@param listener listener;public void addListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.add(listener)__    };adds,snapshot,completion,listener,param,listener,listener;public,void,add,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,add,listener
SnapshotsService -> public void addListener(SnapshotCompletionListener listener);1547760072;Adds snapshot completion listener__@param listener listener;public void addListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.add(listener)__    };adds,snapshot,completion,listener,param,listener,listener;public,void,add,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,add,listener
SnapshotsService -> public void addListener(SnapshotCompletionListener listener);1548072633;Adds snapshot completion listener__@param listener listener;public void addListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.add(listener)__    };adds,snapshot,completion,listener,param,listener,listener;public,void,add,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,add,listener
SnapshotsService -> SnapshotRequest -> public String[] indices();1524684173;Returns the list of indices to be snapshotted__@return the list of indices;public String[] indices() {_            return indices__        };returns,the,list,of,indices,to,be,snapshotted,return,the,list,of,indices;public,string,indices,return,indices
SnapshotsService -> SnapshotRequest -> public String[] indices();1524839522;Returns the list of indices to be snapshotted__@return the list of indices;public String[] indices() {_            return indices__        };returns,the,list,of,indices,to,be,snapshotted,return,the,list,of,indices;public,string,indices,return,indices
SnapshotsService -> SnapshotRequest -> public String[] indices();1542646292;Returns the list of indices to be snapshotted__@return the list of indices;public String[] indices() {_            return indices__        };returns,the,list,of,indices,to,be,snapshotted,return,the,list,of,indices;public,string,indices,return,indices
SnapshotsService -> SnapshotRequest -> public String[] indices();1542826731;Returns the list of indices to be snapshotted__@return the list of indices;public String[] indices() {_            return indices__        };returns,the,list,of,indices,to,be,snapshotted,return,the,list,of,indices;public,string,indices,return,indices
SnapshotsService -> SnapshotRequest -> public String[] indices();1544783963;Returns the list of indices to be snapshotted__@return the list of indices;public String[] indices() {_            return indices__        };returns,the,list,of,indices,to,be,snapshotted,return,the,list,of,indices;public,string,indices,return,indices
SnapshotsService -> SnapshotRequest -> public String[] indices();1545215361;Returns the list of indices to be snapshotted__@return the list of indices;public String[] indices() {_            return indices__        };returns,the,list,of,indices,to,be,snapshotted,return,the,list,of,indices;public,string,indices,return,indices
SnapshotsService -> SnapshotRequest -> public String[] indices();1547023537;Returns the list of indices to be snapshotted__@return the list of indices;public String[] indices() {_            return indices__        };returns,the,list,of,indices,to,be,snapshotted,return,the,list,of,indices;public,string,indices,return,indices
SnapshotsService -> SnapshotRequest -> public String[] indices();1547625930;Returns the list of indices to be snapshotted__@return the list of indices;public String[] indices() {_            return indices__        };returns,the,list,of,indices,to,be,snapshotted,return,the,list,of,indices;public,string,indices,return,indices
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final DeleteSnapshotListener listener);1524684173;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final DeleteSnapshotListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse()__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,delete,snapshot,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final DeleteSnapshotListener listener);1524839522;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final DeleteSnapshotListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse()__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,delete,snapshot,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final DeleteSnapshotListener listener);1542646292;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final DeleteSnapshotListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse()__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,delete,snapshot,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final DeleteSnapshotListener listener);1542826731;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final DeleteSnapshotListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse()__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,delete,snapshot,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final DeleteSnapshotListener listener);1544783963;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final DeleteSnapshotListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse()__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,delete,snapshot,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final DeleteSnapshotListener listener);1545215361;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final DeleteSnapshotListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse()__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,delete,snapshot,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final DeleteSnapshotListener listener);1547023537;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final DeleteSnapshotListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse()__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,delete,snapshot,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final DeleteSnapshotListener listener);1547625930;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final DeleteSnapshotListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse()__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,delete,snapshot,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final DeleteSnapshotListener listener);1547633328;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final DeleteSnapshotListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse()__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,delete,snapshot,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final DeleteSnapshotListener listener);1547760072;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final DeleteSnapshotListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse()__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,delete,snapshot,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final DeleteSnapshotListener listener);1548072633;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final DeleteSnapshotListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse()__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,delete,snapshot,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indices(String[] indices);1524684173;Sets the list of indices to be snapshotted__@param indices list of indices_@return this request;public SnapshotRequest indices(String[] indices) {_            this.indices = indices__            return this__        };sets,the,list,of,indices,to,be,snapshotted,param,indices,list,of,indices,return,this,request;public,snapshot,request,indices,string,indices,this,indices,indices,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indices(String[] indices);1524839522;Sets the list of indices to be snapshotted__@param indices list of indices_@return this request;public SnapshotRequest indices(String[] indices) {_            this.indices = indices__            return this__        };sets,the,list,of,indices,to,be,snapshotted,param,indices,list,of,indices,return,this,request;public,snapshot,request,indices,string,indices,this,indices,indices,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indices(String[] indices);1542646292;Sets the list of indices to be snapshotted__@param indices list of indices_@return this request;public SnapshotRequest indices(String[] indices) {_            this.indices = indices__            return this__        };sets,the,list,of,indices,to,be,snapshotted,param,indices,list,of,indices,return,this,request;public,snapshot,request,indices,string,indices,this,indices,indices,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indices(String[] indices);1542826731;Sets the list of indices to be snapshotted__@param indices list of indices_@return this request;public SnapshotRequest indices(String[] indices) {_            this.indices = indices__            return this__        };sets,the,list,of,indices,to,be,snapshotted,param,indices,list,of,indices,return,this,request;public,snapshot,request,indices,string,indices,this,indices,indices,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indices(String[] indices);1544783963;Sets the list of indices to be snapshotted__@param indices list of indices_@return this request;public SnapshotRequest indices(String[] indices) {_            this.indices = indices__            return this__        };sets,the,list,of,indices,to,be,snapshotted,param,indices,list,of,indices,return,this,request;public,snapshot,request,indices,string,indices,this,indices,indices,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indices(String[] indices);1545215361;Sets the list of indices to be snapshotted__@param indices list of indices_@return this request;public SnapshotRequest indices(String[] indices) {_            this.indices = indices__            return this__        };sets,the,list,of,indices,to,be,snapshotted,param,indices,list,of,indices,return,this,request;public,snapshot,request,indices,string,indices,this,indices,indices,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indices(String[] indices);1547023537;Sets the list of indices to be snapshotted__@param indices list of indices_@return this request;public SnapshotRequest indices(String[] indices) {_            this.indices = indices__            return this__        };sets,the,list,of,indices,to,be,snapshotted,param,indices,list,of,indices,return,this,request;public,snapshot,request,indices,string,indices,this,indices,indices,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indices(String[] indices);1547625930;Sets the list of indices to be snapshotted__@param indices list of indices_@return this request;public SnapshotRequest indices(String[] indices) {_            this.indices = indices__            return this__        };sets,the,list,of,indices,to,be,snapshotted,param,indices,list,of,indices,return,this,request;public,snapshot,request,indices,string,indices,this,indices,indices,return,this
SnapshotsService -> public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener);1548321078;Same as {@link #createSnapshot(CreateSnapshotRequest, ActionListener)} but invokes its callback on completion of_the snapshot.__@param request snapshot request_@param listener snapshot completion listener;public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener) {_        createSnapshot(request, ActionListener.wrap(snapshot -> addListener(snapshot, listener), listener::onFailure))__    };same,as,link,create,snapshot,create,snapshot,request,action,listener,but,invokes,its,callback,on,completion,of,the,snapshot,param,request,snapshot,request,param,listener,snapshot,completion,listener;public,void,execute,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,info,listener,create,snapshot,request,action,listener,wrap,snapshot,add,listener,snapshot,listener,listener,on,failure
SnapshotsService -> public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener);1548996340;Same as {@link #createSnapshot(CreateSnapshotRequest, ActionListener)} but invokes its callback on completion of_the snapshot.__@param request snapshot request_@param listener snapshot completion listener;public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener) {_        createSnapshot(request, ActionListener.wrap(snapshot -> addListener(snapshot, listener), listener::onFailure))__    };same,as,link,create,snapshot,create,snapshot,request,action,listener,but,invokes,its,callback,on,completion,of,the,snapshot,param,request,snapshot,request,param,listener,snapshot,completion,listener;public,void,execute,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,info,listener,create,snapshot,request,action,listener,wrap,snapshot,add,listener,snapshot,listener,listener,on,failure
SnapshotsService -> public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener);1549050374;Same as {@link #createSnapshot(CreateSnapshotRequest, ActionListener)} but invokes its callback on completion of_the snapshot.__@param request snapshot request_@param listener snapshot completion listener;public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener) {_        createSnapshot(request, ActionListener.wrap(snapshot -> addListener(snapshot, listener), listener::onFailure))__    };same,as,link,create,snapshot,create,snapshot,request,action,listener,but,invokes,its,callback,on,completion,of,the,snapshot,param,request,snapshot,request,param,listener,snapshot,completion,listener;public,void,execute,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,info,listener,create,snapshot,request,action,listener,wrap,snapshot,add,listener,snapshot,listener,listener,on,failure
SnapshotsService -> public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener);1549381458;Same as {@link #createSnapshot(CreateSnapshotRequest, ActionListener)} but invokes its callback on completion of_the snapshot.__@param request snapshot request_@param listener snapshot completion listener;public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener) {_        createSnapshot(request, ActionListener.wrap(snapshot -> addListener(snapshot, listener), listener::onFailure))__    };same,as,link,create,snapshot,create,snapshot,request,action,listener,but,invokes,its,callback,on,completion,of,the,snapshot,param,request,snapshot,request,param,listener,snapshot,completion,listener;public,void,execute,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,info,listener,create,snapshot,request,action,listener,wrap,snapshot,add,listener,snapshot,listener,listener,on,failure
SnapshotsService -> public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener);1549407419;Same as {@link #createSnapshot(CreateSnapshotRequest, ActionListener)} but invokes its callback on completion of_the snapshot.__@param request snapshot request_@param listener snapshot completion listener;public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener) {_        createSnapshot(request, ActionListener.wrap(snapshot -> addListener(snapshot, listener), listener::onFailure))__    };same,as,link,create,snapshot,create,snapshot,request,action,listener,but,invokes,its,callback,on,completion,of,the,snapshot,param,request,snapshot,request,param,listener,snapshot,completion,listener;public,void,execute,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,info,listener,create,snapshot,request,action,listener,wrap,snapshot,add,listener,snapshot,listener,listener,on,failure
SnapshotsService -> public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener);1549637959;Same as {@link #createSnapshot(CreateSnapshotRequest, ActionListener)} but invokes its callback on completion of_the snapshot.__@param request snapshot request_@param listener snapshot completion listener;public void executeSnapshot(final CreateSnapshotRequest request, final ActionListener<SnapshotInfo> listener) {_        createSnapshot(request, ActionListener.wrap(snapshot -> addListener(snapshot, listener), listener::onFailure))__    };same,as,link,create,snapshot,create,snapshot,request,action,listener,but,invokes,its,callback,on,completion,of,the,snapshot,param,request,snapshot,request,param,listener,snapshot,completion,listener;public,void,execute,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,info,listener,create,snapshot,request,action,listener,wrap,snapshot,add,listener,snapshot,listener,listener,on,failure
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1524684173;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1524839522;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1542646292;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1542826731;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1544783963;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1545215361;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1547023537;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1547625930;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1547633328;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1547760072;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1548072633;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1548321078;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1548996340;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1549050374;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1549381458;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1549407419;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> public RepositoryData getRepositoryData(final String repositoryName);1549637959;Gets the {@link RepositoryData} for the given repository.__@param repositoryName repository name_@return repository data;public RepositoryData getRepositoryData(final String repositoryName) {_        Repository repository = repositoriesService.repository(repositoryName)__        assert repository != null_ _        return repository.getRepositoryData()__    };gets,the,link,repository,data,for,the,given,repository,param,repository,name,repository,name,return,repository,data;public,repository,data,get,repository,data,final,string,repository,name,repository,repository,repositories,service,repository,repository,name,assert,repository,null,return,repository,get,repository,data
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1524684173;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1524839522;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1542646292;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1542826731;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1544783963;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1545215361;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1547023537;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1547625930;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1547633328;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1547760072;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1548072633;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1548321078;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1548996340;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1549050374;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        if (event.localNodeMaster() && event.previousState().nodes().isLocalNodeElectedMaster() == false) {_            SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__            if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__                SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__                deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__            }_        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,false,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1549381458;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_            assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__            SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__            deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1549407419;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_            assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__            SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__            deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event);1549637959;Finalizes a snapshot deletion in progress if the current node is the master but it_was not master in the previous cluster state and there is still a lingering snapshot_deletion in progress in the cluster state.  This means that the old master failed_before it could clean up an in-progress snapshot deletion.  We attempt to delete the_snapshot files and remove the deletion from the cluster state.  It is possible that the_old master was in a state of long GC and then it resumes and tries to delete the snapshot_that has already been deleted by the current master.  This is acceptable however, since_the old master's snapshot deletion will just respond with an error but in actuality, the_snapshot was deleted and a call to GET snapshots would reveal that the snapshot no longer exists.;private void finalizeSnapshotDeletionFromPreviousMaster(ClusterChangedEvent event) {_        SnapshotDeletionsInProgress deletionsInProgress = event.state().custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_            assert deletionsInProgress.getEntries().size() == 1 : "only one in-progress deletion allowed per cluster"__            SnapshotDeletionsInProgress.Entry entry = deletionsInProgress.getEntries().get(0)__            deleteSnapshotFromRepository(entry.getSnapshot(), null, entry.getRepositoryStateId())__        }_    };finalizes,a,snapshot,deletion,in,progress,if,the,current,node,is,the,master,but,it,was,not,master,in,the,previous,cluster,state,and,there,is,still,a,lingering,snapshot,deletion,in,progress,in,the,cluster,state,this,means,that,the,old,master,failed,before,it,could,clean,up,an,in,progress,snapshot,deletion,we,attempt,to,delete,the,snapshot,files,and,remove,the,deletion,from,the,cluster,state,it,is,possible,that,the,old,master,was,in,a,state,of,long,gc,and,then,it,resumes,and,tries,to,delete,the,snapshot,that,has,already,been,deleted,by,the,current,master,this,is,acceptable,however,since,the,old,master,s,snapshot,deletion,will,just,respond,with,an,error,but,in,actuality,the,snapshot,was,deleted,and,a,call,to,get,snapshots,would,reveal,that,the,snapshot,no,longer,exists;private,void,finalize,snapshot,deletion,from,previous,master,cluster,changed,event,event,snapshot,deletions,in,progress,deletions,in,progress,event,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,assert,deletions,in,progress,get,entries,size,1,only,one,in,progress,deletion,allowed,per,cluster,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,get,0,delete,snapshot,from,repository,entry,get,snapshot,null,entry,get,repository,state,id
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1524684173;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster(source)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                for (SnapshotCompletionListener listener : snapshotCompletionListeners) {_                    try {_                        if (snapshotInfo != null) {_                            listener.onSnapshotCompletion(snapshot, snapshotInfo)__                        } else {_                            listener.onSnapshotFailure(snapshot, failure)__                        }_                    } catch (Exception t) {_                        logger.warn(() -> new ParameterizedMessage("failed to notify listener [{}]", listener), t)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,source,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,for,snapshot,completion,listener,listener,snapshot,completion,listeners,try,if,snapshot,info,null,listener,on,snapshot,completion,snapshot,snapshot,info,else,listener,on,snapshot,failure,snapshot,failure,catch,exception,t,logger,warn,new,parameterized,message,failed,to,notify,listener,listener,t,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1524839522;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster(source)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                for (SnapshotCompletionListener listener : snapshotCompletionListeners) {_                    try {_                        if (snapshotInfo != null) {_                            listener.onSnapshotCompletion(snapshot, snapshotInfo)__                        } else {_                            listener.onSnapshotFailure(snapshot, failure)__                        }_                    } catch (Exception t) {_                        logger.warn(() -> new ParameterizedMessage("failed to notify listener [{}]", listener), t)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,source,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,for,snapshot,completion,listener,listener,snapshot,completion,listeners,try,if,snapshot,info,null,listener,on,snapshot,completion,snapshot,snapshot,info,else,listener,on,snapshot,failure,snapshot,failure,catch,exception,t,logger,warn,new,parameterized,message,failed,to,notify,listener,listener,t,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1542646292;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster(source)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                for (SnapshotCompletionListener listener : snapshotCompletionListeners) {_                    try {_                        if (snapshotInfo != null) {_                            listener.onSnapshotCompletion(snapshot, snapshotInfo)__                        } else {_                            listener.onSnapshotFailure(snapshot, failure)__                        }_                    } catch (Exception t) {_                        logger.warn(() -> new ParameterizedMessage("failed to notify listener [{}]", listener), t)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,source,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,for,snapshot,completion,listener,listener,snapshot,completion,listeners,try,if,snapshot,info,null,listener,on,snapshot,completion,snapshot,snapshot,info,else,listener,on,snapshot,failure,snapshot,failure,catch,exception,t,logger,warn,new,parameterized,message,failed,to,notify,listener,listener,t,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1542826731;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster(source)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                for (SnapshotCompletionListener listener : snapshotCompletionListeners) {_                    try {_                        if (snapshotInfo != null) {_                            listener.onSnapshotCompletion(snapshot, snapshotInfo)__                        } else {_                            listener.onSnapshotFailure(snapshot, failure)__                        }_                    } catch (Exception t) {_                        logger.warn(() -> new ParameterizedMessage("failed to notify listener [{}]", listener), t)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,source,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,for,snapshot,completion,listener,listener,snapshot,completion,listeners,try,if,snapshot,info,null,listener,on,snapshot,completion,snapshot,snapshot,info,else,listener,on,snapshot,failure,snapshot,failure,catch,exception,t,logger,warn,new,parameterized,message,failed,to,notify,listener,listener,t,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1544783963;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster(source)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                for (SnapshotCompletionListener listener : snapshotCompletionListeners) {_                    try {_                        if (snapshotInfo != null) {_                            listener.onSnapshotCompletion(snapshot, snapshotInfo)__                        } else {_                            listener.onSnapshotFailure(snapshot, failure)__                        }_                    } catch (Exception t) {_                        logger.warn(() -> new ParameterizedMessage("failed to notify listener [{}]", listener), t)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,source,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,for,snapshot,completion,listener,listener,snapshot,completion,listeners,try,if,snapshot,info,null,listener,on,snapshot,completion,snapshot,snapshot,info,else,listener,on,snapshot,failure,snapshot,failure,catch,exception,t,logger,warn,new,parameterized,message,failed,to,notify,listener,listener,t,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1545215361;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster(source)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                for (SnapshotCompletionListener listener : snapshotCompletionListeners) {_                    try {_                        if (snapshotInfo != null) {_                            listener.onSnapshotCompletion(snapshot, snapshotInfo)__                        } else {_                            listener.onSnapshotFailure(snapshot, failure)__                        }_                    } catch (Exception t) {_                        logger.warn(() -> new ParameterizedMessage("failed to notify listener [{}]", listener), t)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,source,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,for,snapshot,completion,listener,listener,snapshot,completion,listeners,try,if,snapshot,info,null,listener,on,snapshot,completion,snapshot,snapshot,info,else,listener,on,snapshot,failure,snapshot,failure,catch,exception,t,logger,warn,new,parameterized,message,failed,to,notify,listener,listener,t,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1547023537;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster()__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                for (SnapshotCompletionListener listener : snapshotCompletionListeners) {_                    try {_                        if (snapshotInfo != null) {_                            listener.onSnapshotCompletion(snapshot, snapshotInfo)__                        } else {_                            listener.onSnapshotFailure(snapshot, failure)__                        }_                    } catch (Exception t) {_                        logger.warn(() -> new ParameterizedMessage("failed to notify listener [{}]", listener), t)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,for,snapshot,completion,listener,listener,snapshot,completion,listeners,try,if,snapshot,info,null,listener,on,snapshot,completion,snapshot,snapshot,info,else,listener,on,snapshot,failure,snapshot,failure,catch,exception,t,logger,warn,new,parameterized,message,failed,to,notify,listener,listener,t,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1547625930;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster()__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                for (SnapshotCompletionListener listener : snapshotCompletionListeners) {_                    try {_                        if (snapshotInfo != null) {_                            listener.onSnapshotCompletion(snapshot, snapshotInfo)__                        } else {_                            listener.onSnapshotFailure(snapshot, failure)__                        }_                    } catch (Exception t) {_                        logger.warn(() -> new ParameterizedMessage("failed to notify listener [{}]", listener), t)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,for,snapshot,completion,listener,listener,snapshot,completion,listeners,try,if,snapshot,info,null,listener,on,snapshot,completion,snapshot,snapshot,info,else,listener,on,snapshot,failure,snapshot,failure,catch,exception,t,logger,warn,new,parameterized,message,failed,to,notify,listener,listener,t,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1547633328;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster()__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                for (SnapshotCompletionListener listener : snapshotCompletionListeners) {_                    try {_                        if (snapshotInfo != null) {_                            listener.onSnapshotCompletion(snapshot, snapshotInfo)__                        } else {_                            listener.onSnapshotFailure(snapshot, failure)__                        }_                    } catch (Exception t) {_                        logger.warn(() -> new ParameterizedMessage("failed to notify listener [{}]", listener), t)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,for,snapshot,completion,listener,listener,snapshot,completion,listeners,try,if,snapshot,info,null,listener,on,snapshot,completion,snapshot,snapshot,info,else,listener,on,snapshot,failure,snapshot,failure,catch,exception,t,logger,warn,new,parameterized,message,failed,to,notify,listener,listener,t,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1547760072;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster()__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                for (SnapshotCompletionListener listener : snapshotCompletionListeners) {_                    try {_                        if (snapshotInfo != null) {_                            listener.onSnapshotCompletion(snapshot, snapshotInfo)__                        } else {_                            listener.onSnapshotFailure(snapshot, failure)__                        }_                    } catch (Exception t) {_                        logger.warn(() -> new ParameterizedMessage("failed to notify listener [{}]", listener), t)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,for,snapshot,completion,listener,listener,snapshot,completion,listeners,try,if,snapshot,info,null,listener,on,snapshot,completion,snapshot,snapshot,info,else,listener,on,snapshot,failure,snapshot,failure,catch,exception,t,logger,warn,new,parameterized,message,failed,to,notify,listener,listener,t,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1548072633;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster()__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                for (SnapshotCompletionListener listener : snapshotCompletionListeners) {_                    try {_                        if (snapshotInfo != null) {_                            listener.onSnapshotCompletion(snapshot, snapshotInfo)__                        } else {_                            listener.onSnapshotFailure(snapshot, failure)__                        }_                    } catch (Exception t) {_                        logger.warn(() -> new ParameterizedMessage("failed to notify listener [{}]", listener), t)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,for,snapshot,completion,listener,listener,snapshot,completion,listeners,try,if,snapshot,info,null,listener,on,snapshot,completion,snapshot,snapshot,info,else,listener,on,snapshot,failure,snapshot,failure,catch,exception,t,logger,warn,new,parameterized,message,failed,to,notify,listener,listener,t,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1548321078;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster()__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                final List<ActionListener<SnapshotInfo>> completionListeners = snapshotCompletionListeners.remove(snapshot)__                if (completionListeners != null) {_                    try {_                        if (snapshotInfo == null) {_                            ActionListener.onFailure(completionListeners, failure)__                        } else {_                            ActionListener.onResponse(completionListeners, snapshotInfo)__                        }_                    } catch (Exception e) {_                        logger.warn("Failed to notify listeners", e)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,final,list,action,listener,snapshot,info,completion,listeners,snapshot,completion,listeners,remove,snapshot,if,completion,listeners,null,try,if,snapshot,info,null,action,listener,on,failure,completion,listeners,failure,else,action,listener,on,response,completion,listeners,snapshot,info,catch,exception,e,logger,warn,failed,to,notify,listeners,e,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1548996340;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster()__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                final List<ActionListener<SnapshotInfo>> completionListeners = snapshotCompletionListeners.remove(snapshot)__                if (completionListeners != null) {_                    try {_                        if (snapshotInfo == null) {_                            ActionListener.onFailure(completionListeners, failure)__                        } else {_                            ActionListener.onResponse(completionListeners, snapshotInfo)__                        }_                    } catch (Exception e) {_                        logger.warn("Failed to notify listeners", e)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,final,list,action,listener,snapshot,info,completion,listeners,snapshot,completion,listeners,remove,snapshot,if,completion,listeners,null,try,if,snapshot,info,null,action,listener,on,failure,completion,listeners,failure,else,action,listener,on,response,completion,listeners,snapshot,info,catch,exception,e,logger,warn,failed,to,notify,listeners,e,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1549050374;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                if (listener != null) {_                    listener.onNoLongerMaster()__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                final List<ActionListener<SnapshotInfo>> completionListeners = snapshotCompletionListeners.remove(snapshot)__                if (completionListeners != null) {_                    try {_                        if (snapshotInfo == null) {_                            ActionListener.onFailure(completionListeners, failure)__                        } else {_                            ActionListener.onResponse(completionListeners, snapshotInfo)__                        }_                    } catch (Exception e) {_                        logger.warn("Failed to notify listeners", e)__                    }_                }_                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,if,listener,null,listener,on,no,longer,master,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,final,list,action,listener,snapshot,info,completion,listeners,snapshot,completion,listeners,remove,snapshot,if,completion,listeners,null,try,if,snapshot,info,null,action,listener,on,failure,completion,listeners,failure,else,action,listener,on,response,completion,listeners,snapshot,info,catch,exception,e,logger,warn,failed,to,notify,listeners,e,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> SnapshotRequest -> public SnapshotRequest settings(Settings settings);1524684173;Sets repository-specific snapshot settings__@param settings snapshot settings_@return this request;public SnapshotRequest settings(Settings settings) {_            this.settings = settings__            return this__        };sets,repository,specific,snapshot,settings,param,settings,snapshot,settings,return,this,request;public,snapshot,request,settings,settings,settings,this,settings,settings,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest settings(Settings settings);1524839522;Sets repository-specific snapshot settings__@param settings snapshot settings_@return this request;public SnapshotRequest settings(Settings settings) {_            this.settings = settings__            return this__        };sets,repository,specific,snapshot,settings,param,settings,snapshot,settings,return,this,request;public,snapshot,request,settings,settings,settings,this,settings,settings,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest settings(Settings settings);1542646292;Sets repository-specific snapshot settings__@param settings snapshot settings_@return this request;public SnapshotRequest settings(Settings settings) {_            this.settings = settings__            return this__        };sets,repository,specific,snapshot,settings,param,settings,snapshot,settings,return,this,request;public,snapshot,request,settings,settings,settings,this,settings,settings,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest settings(Settings settings);1542826731;Sets repository-specific snapshot settings__@param settings snapshot settings_@return this request;public SnapshotRequest settings(Settings settings) {_            this.settings = settings__            return this__        };sets,repository,specific,snapshot,settings,param,settings,snapshot,settings,return,this,request;public,snapshot,request,settings,settings,settings,this,settings,settings,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest settings(Settings settings);1544783963;Sets repository-specific snapshot settings__@param settings snapshot settings_@return this request;public SnapshotRequest settings(Settings settings) {_            this.settings = settings__            return this__        };sets,repository,specific,snapshot,settings,param,settings,snapshot,settings,return,this,request;public,snapshot,request,settings,settings,settings,this,settings,settings,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest settings(Settings settings);1545215361;Sets repository-specific snapshot settings__@param settings snapshot settings_@return this request;public SnapshotRequest settings(Settings settings) {_            this.settings = settings__            return this__        };sets,repository,specific,snapshot,settings,param,settings,snapshot,settings,return,this,request;public,snapshot,request,settings,settings,settings,this,settings,settings,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest settings(Settings settings);1547023537;Sets repository-specific snapshot settings__@param settings snapshot settings_@return this request;public SnapshotRequest settings(Settings settings) {_            this.settings = settings__            return this__        };sets,repository,specific,snapshot,settings,param,settings,snapshot,settings,return,this,request;public,snapshot,request,settings,settings,settings,this,settings,settings,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest settings(Settings settings);1547625930;Sets repository-specific snapshot settings__@param settings snapshot settings_@return this request;public SnapshotRequest settings(Settings settings) {_            this.settings = settings__            return this__        };sets,repository,specific,snapshot,settings,param,settings,snapshot,settings,return,this,request;public,snapshot,request,settings,settings,settings,this,settings,settings,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indicesOptions(IndicesOptions indicesOptions);1524684173;Sets the indices options__@param indicesOptions indices options_@return this request;public SnapshotRequest indicesOptions(IndicesOptions indicesOptions) {_            this.indicesOptions = indicesOptions__            return this__        };sets,the,indices,options,param,indices,options,indices,options,return,this,request;public,snapshot,request,indices,options,indices,options,indices,options,this,indices,options,indices,options,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indicesOptions(IndicesOptions indicesOptions);1524839522;Sets the indices options__@param indicesOptions indices options_@return this request;public SnapshotRequest indicesOptions(IndicesOptions indicesOptions) {_            this.indicesOptions = indicesOptions__            return this__        };sets,the,indices,options,param,indices,options,indices,options,return,this,request;public,snapshot,request,indices,options,indices,options,indices,options,this,indices,options,indices,options,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indicesOptions(IndicesOptions indicesOptions);1542646292;Sets the indices options__@param indicesOptions indices options_@return this request;public SnapshotRequest indicesOptions(IndicesOptions indicesOptions) {_            this.indicesOptions = indicesOptions__            return this__        };sets,the,indices,options,param,indices,options,indices,options,return,this,request;public,snapshot,request,indices,options,indices,options,indices,options,this,indices,options,indices,options,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indicesOptions(IndicesOptions indicesOptions);1542826731;Sets the indices options__@param indicesOptions indices options_@return this request;public SnapshotRequest indicesOptions(IndicesOptions indicesOptions) {_            this.indicesOptions = indicesOptions__            return this__        };sets,the,indices,options,param,indices,options,indices,options,return,this,request;public,snapshot,request,indices,options,indices,options,indices,options,this,indices,options,indices,options,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indicesOptions(IndicesOptions indicesOptions);1544783963;Sets the indices options__@param indicesOptions indices options_@return this request;public SnapshotRequest indicesOptions(IndicesOptions indicesOptions) {_            this.indicesOptions = indicesOptions__            return this__        };sets,the,indices,options,param,indices,options,indices,options,return,this,request;public,snapshot,request,indices,options,indices,options,indices,options,this,indices,options,indices,options,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indicesOptions(IndicesOptions indicesOptions);1545215361;Sets the indices options__@param indicesOptions indices options_@return this request;public SnapshotRequest indicesOptions(IndicesOptions indicesOptions) {_            this.indicesOptions = indicesOptions__            return this__        };sets,the,indices,options,param,indices,options,indices,options,return,this,request;public,snapshot,request,indices,options,indices,options,indices,options,this,indices,options,indices,options,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indicesOptions(IndicesOptions indicesOptions);1547023537;Sets the indices options__@param indicesOptions indices options_@return this request;public SnapshotRequest indicesOptions(IndicesOptions indicesOptions) {_            this.indicesOptions = indicesOptions__            return this__        };sets,the,indices,options,param,indices,options,indices,options,return,this,request;public,snapshot,request,indices,options,indices,options,indices,options,this,indices,options,indices,options,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest indicesOptions(IndicesOptions indicesOptions);1547625930;Sets the indices options__@param indicesOptions indices options_@return this request;public SnapshotRequest indicesOptions(IndicesOptions indicesOptions) {_            this.indicesOptions = indicesOptions__            return this__        };sets,the,indices,options,param,indices,options,indices,options,return,this,request;public,snapshot,request,indices,options,indices,options,indices,options,this,indices,options,indices,options,return,this
SnapshotsService -> private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId);1548321078;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,snapshot,snapshot,nullable,action,listener,void,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId);1548996340;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,snapshot,snapshot,nullable,action,listener,void,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId);1549050374;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,snapshot,snapshot,nullable,action,listener,void,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId);1549381458;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,snapshot,snapshot,nullable,action,listener,void,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId);1549407419;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,snapshot,snapshot,nullable,action,listener,void,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId);1549637959;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(Snapshot snapshot, @Nullable ActionListener<Void> listener, long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,snapshot,snapshot,nullable,action,listener,void,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1524684173;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1524839522;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1542646292;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1542826731;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1544783963;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1545215361;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1547023537;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1547625930;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1547633328;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1547760072;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1548072633;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1548321078;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1548996340;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event);1549050374;Removes a finished snapshot from the cluster state.  This can happen if the previous_master node processed a cluster state update that marked the snapshot as finished,_but the previous master node died before removing the snapshot in progress from the_cluster state.  It is then the responsibility of the new master node to end the_snapshot and remove it from the cluster state.;private void removeFinishedSnapshotFromClusterState(ClusterChangedEvent event) {_        if (event.localNodeMaster() && !event.previousState().nodes().isLocalNodeElectedMaster()) {_            SnapshotsInProgress snapshotsInProgress = event.state().custom(SnapshotsInProgress.TYPE)__            if (snapshotsInProgress != null && !snapshotsInProgress.entries().isEmpty()) {_                for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_                    if (entry.state().completed()) {_                        endSnapshot(entry)__                    }_                }_            }_        }_    };removes,a,finished,snapshot,from,the,cluster,state,this,can,happen,if,the,previous,master,node,processed,a,cluster,state,update,that,marked,the,snapshot,as,finished,but,the,previous,master,node,died,before,removing,the,snapshot,in,progress,from,the,cluster,state,it,is,then,the,responsibility,of,the,new,master,node,to,end,the,snapshot,and,remove,it,from,the,cluster,state;private,void,remove,finished,snapshot,from,cluster,state,cluster,changed,event,event,if,event,local,node,master,event,previous,state,nodes,is,local,node,elected,master,snapshots,in,progress,snapshots,in,progress,event,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,state,completed,end,snapshot,entry
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1545215361;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1547023537;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1547625930;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1547633328;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1547760072;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1548072633;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1548321078;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1548996340;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1549050374;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1549381458;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1549407419;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(         ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1549637959;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(_        ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) &&_                    metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> CreateSnapshotListener -> void onFailure(Exception e)_;1524684173;Called if a snapshot operation couldn't start;void onFailure(Exception e)_;called,if,a,snapshot,operation,couldn,t,start;void,on,failure,exception,e
SnapshotsService -> CreateSnapshotListener -> void onFailure(Exception e)_;1524839522;Called if a snapshot operation couldn't start;void onFailure(Exception e)_;called,if,a,snapshot,operation,couldn,t,start;void,on,failure,exception,e
SnapshotsService -> CreateSnapshotListener -> void onFailure(Exception e)_;1542646292;Called if a snapshot operation couldn't start;void onFailure(Exception e)_;called,if,a,snapshot,operation,couldn,t,start;void,on,failure,exception,e
SnapshotsService -> CreateSnapshotListener -> void onFailure(Exception e)_;1542826731;Called if a snapshot operation couldn't start;void onFailure(Exception e)_;called,if,a,snapshot,operation,couldn,t,start;void,on,failure,exception,e
SnapshotsService -> CreateSnapshotListener -> void onFailure(Exception e)_;1544783963;Called if a snapshot operation couldn't start;void onFailure(Exception e)_;called,if,a,snapshot,operation,couldn,t,start;void,on,failure,exception,e
SnapshotsService -> CreateSnapshotListener -> void onFailure(Exception e)_;1545215361;Called if a snapshot operation couldn't start;void onFailure(Exception e)_;called,if,a,snapshot,operation,couldn,t,start;void,on,failure,exception,e
SnapshotsService -> CreateSnapshotListener -> void onFailure(Exception e)_;1547023537;Called if a snapshot operation couldn't start;void onFailure(Exception e)_;called,if,a,snapshot,operation,couldn,t,start;void,on,failure,exception,e
SnapshotsService -> CreateSnapshotListener -> void onFailure(Exception e)_;1547625930;Called if a snapshot operation couldn't start;void onFailure(Exception e)_;called,if,a,snapshot,operation,couldn,t,start;void,on,failure,exception,e
SnapshotsService -> CreateSnapshotListener -> void onFailure(Exception e)_;1547633328;Called if a snapshot operation couldn't start;void onFailure(Exception e)_;called,if,a,snapshot,operation,couldn,t,start;void,on,failure,exception,e
SnapshotsService -> CreateSnapshotListener -> void onFailure(Exception e)_;1547760072;Called if a snapshot operation couldn't start;void onFailure(Exception e)_;called,if,a,snapshot,operation,couldn,t,start;void,on,failure,exception,e
SnapshotsService -> CreateSnapshotListener -> void onFailure(Exception e)_;1548072633;Called if a snapshot operation couldn't start;void onFailure(Exception e)_;called,if,a,snapshot,operation,couldn,t,start;void,on,failure,exception,e
SnapshotsService -> private void validate(String repositoryName, String snapshotName, ClusterState state);1547633328;Validates snapshot request__@param repositoryName repository name_@param snapshotName snapshot name_@param state   current cluster state;private void validate(String repositoryName, String snapshotName, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repositoryName) == null) {_            throw new RepositoryMissingException(repositoryName)__        }_        validate(repositoryName, snapshotName)__    };validates,snapshot,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,state,current,cluster,state;private,void,validate,string,repository,name,string,snapshot,name,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,if,repositories,meta,data,null,repositories,meta,data,repository,repository,name,null,throw,new,repository,missing,exception,repository,name,validate,repository,name,snapshot,name
SnapshotsService -> private void validate(String repositoryName, String snapshotName, ClusterState state);1547760072;Validates snapshot request__@param repositoryName repository name_@param snapshotName snapshot name_@param state   current cluster state;private void validate(String repositoryName, String snapshotName, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repositoryName) == null) {_            throw new RepositoryMissingException(repositoryName)__        }_        validate(repositoryName, snapshotName)__    };validates,snapshot,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,state,current,cluster,state;private,void,validate,string,repository,name,string,snapshot,name,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,if,repositories,meta,data,null,repositories,meta,data,repository,repository,name,null,throw,new,repository,missing,exception,repository,name,validate,repository,name,snapshot,name
SnapshotsService -> private void validate(String repositoryName, String snapshotName, ClusterState state);1548072633;Validates snapshot request__@param repositoryName repository name_@param snapshotName snapshot name_@param state   current cluster state;private void validate(String repositoryName, String snapshotName, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repositoryName) == null) {_            throw new RepositoryMissingException(repositoryName)__        }_        validate(repositoryName, snapshotName)__    };validates,snapshot,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,state,current,cluster,state;private,void,validate,string,repository,name,string,snapshot,name,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,if,repositories,meta,data,null,repositories,meta,data,repository,repository,name,null,throw,new,repository,missing,exception,repository,name,validate,repository,name,snapshot,name
SnapshotsService -> private void validate(String repositoryName, String snapshotName, ClusterState state);1548321078;Validates snapshot request__@param repositoryName repository name_@param snapshotName snapshot name_@param state   current cluster state;private void validate(String repositoryName, String snapshotName, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repositoryName) == null) {_            throw new RepositoryMissingException(repositoryName)__        }_        validate(repositoryName, snapshotName)__    };validates,snapshot,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,state,current,cluster,state;private,void,validate,string,repository,name,string,snapshot,name,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,if,repositories,meta,data,null,repositories,meta,data,repository,repository,name,null,throw,new,repository,missing,exception,repository,name,validate,repository,name,snapshot,name
SnapshotsService -> private void validate(String repositoryName, String snapshotName, ClusterState state);1548996340;Validates snapshot request__@param repositoryName repository name_@param snapshotName snapshot name_@param state   current cluster state;private void validate(String repositoryName, String snapshotName, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repositoryName) == null) {_            throw new RepositoryMissingException(repositoryName)__        }_        validate(repositoryName, snapshotName)__    };validates,snapshot,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,state,current,cluster,state;private,void,validate,string,repository,name,string,snapshot,name,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,if,repositories,meta,data,null,repositories,meta,data,repository,repository,name,null,throw,new,repository,missing,exception,repository,name,validate,repository,name,snapshot,name
SnapshotsService -> private void validate(String repositoryName, String snapshotName, ClusterState state);1549050374;Validates snapshot request__@param repositoryName repository name_@param snapshotName snapshot name_@param state   current cluster state;private void validate(String repositoryName, String snapshotName, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repositoryName) == null) {_            throw new RepositoryMissingException(repositoryName)__        }_        validate(repositoryName, snapshotName)__    };validates,snapshot,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,state,current,cluster,state;private,void,validate,string,repository,name,string,snapshot,name,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,if,repositories,meta,data,null,repositories,meta,data,repository,repository,name,null,throw,new,repository,missing,exception,repository,name,validate,repository,name,snapshot,name
SnapshotsService -> private void validate(String repositoryName, String snapshotName, ClusterState state);1549381458;Validates snapshot request__@param repositoryName repository name_@param snapshotName snapshot name_@param state   current cluster state;private void validate(String repositoryName, String snapshotName, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repositoryName) == null) {_            throw new RepositoryMissingException(repositoryName)__        }_        validate(repositoryName, snapshotName)__    };validates,snapshot,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,state,current,cluster,state;private,void,validate,string,repository,name,string,snapshot,name,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,if,repositories,meta,data,null,repositories,meta,data,repository,repository,name,null,throw,new,repository,missing,exception,repository,name,validate,repository,name,snapshot,name
SnapshotsService -> private void validate(String repositoryName, String snapshotName, ClusterState state);1549407419;Validates snapshot request__@param repositoryName repository name_@param snapshotName snapshot name_@param state   current cluster state;private void validate(String repositoryName, String snapshotName, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repositoryName) == null) {_            throw new RepositoryMissingException(repositoryName)__        }_        validate(repositoryName, snapshotName)__    };validates,snapshot,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,state,current,cluster,state;private,void,validate,string,repository,name,string,snapshot,name,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,if,repositories,meta,data,null,repositories,meta,data,repository,repository,name,null,throw,new,repository,missing,exception,repository,name,validate,repository,name,snapshot,name
SnapshotsService -> private void validate(String repositoryName, String snapshotName, ClusterState state);1549637959;Validates snapshot request__@param repositoryName repository name_@param snapshotName snapshot name_@param state   current cluster state;private void validate(String repositoryName, String snapshotName, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repositoryName) == null) {_            throw new RepositoryMissingException(repositoryName)__        }_        validate(repositoryName, snapshotName)__    };validates,snapshot,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,state,current,cluster,state;private,void,validate,string,repository,name,string,snapshot,name,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,if,repositories,meta,data,null,repositories,meta,data,repository,repository,name,null,throw,new,repository,missing,exception,repository,name,validate,repository,name,snapshot,name
SnapshotsService -> CreateSnapshotListener -> void onResponse(Snapshot snapshot)_;1547633328;Called when snapshot has successfully started__@param snapshot snapshot that was created;void onResponse(Snapshot snapshot)_;called,when,snapshot,has,successfully,started,param,snapshot,snapshot,that,was,created;void,on,response,snapshot,snapshot
SnapshotsService -> CreateSnapshotListener -> void onResponse(Snapshot snapshot)_;1547760072;Called when snapshot has successfully started__@param snapshot snapshot that was created;void onResponse(Snapshot snapshot)_;called,when,snapshot,has,successfully,started,param,snapshot,snapshot,that,was,created;void,on,response,snapshot,snapshot
SnapshotsService -> CreateSnapshotListener -> void onResponse(Snapshot snapshot)_;1548072633;Called when snapshot has successfully started__@param snapshot snapshot that was created;void onResponse(Snapshot snapshot)_;called,when,snapshot,has,successfully,started,param,snapshot,snapshot,that,was,created;void,on,response,snapshot,snapshot
SnapshotsService -> private void processSnapshotsOnRemovedNodes();1549381458;Cleans up shard snapshots that were running on removed nodes;private void processSnapshotsOnRemovedNodes() {_        clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                DiscoveryNodes nodes = currentState.nodes()__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null) {_                    return currentState__                }_                boolean changed = false__                ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                    SnapshotsInProgress.Entry updatedSnapshot = snapshot__                    if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                        ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                        boolean snapshotChanged = false__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                            ShardSnapshotStatus shardStatus = shardEntry.value__                            if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                if (nodes.nodeExists(shardStatus.nodeId())) {_                                    shards.put(shardEntry.key, shardEntry.value)__                                } else {_                                    _                                    snapshotChanged = true__                                    logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                        shardEntry.key, shardStatus.nodeId())__                                    shards.put(shardEntry.key,_                                        new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                }_                            }_                        }_                        if (snapshotChanged) {_                            changed = true__                            ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                            if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                            } else {_                                updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                            }_                        }_                        entries.add(updatedSnapshot)__                    } else if (snapshot.state() == State.INIT && initializingSnapshots.contains(snapshot.snapshot()) == false) {_                        changed = true__                        _                        updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                        entries.add(updatedSnapshot)___                        _                        deleteSnapshot(snapshot.snapshot(), new ActionListener<Void>() {_                            @Override_                            public void onResponse(Void aVoid) {_                                logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                            }__                            @Override_                            public void onFailure(Exception e) {_                                logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                            }_                        }, updatedSnapshot.getRepositoryStateId(), false)__                    }_                }_                if (changed) {_                    return ClusterState.builder(currentState)_                        .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(unmodifiableList(entries))).build()__                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn("failed to update snapshot state after node removal")__            }_        })__    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes;private,void,process,snapshots,on,removed,nodes,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,boolean,snapshot,changed,false,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,initializing,snapshots,contains,snapshot,snapshot,false,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,action,listener,void,override,public,void,on,response,void,a,void,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,unmodifiable,list,entries,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes();1549407419;Cleans up shard snapshots that were running on removed nodes;private void processSnapshotsOnRemovedNodes() {_        clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                DiscoveryNodes nodes = currentState.nodes()__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null) {_                    return currentState__                }_                boolean changed = false__                ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                    SnapshotsInProgress.Entry updatedSnapshot = snapshot__                    if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                        ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                        boolean snapshotChanged = false__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                            ShardSnapshotStatus shardStatus = shardEntry.value__                            if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                if (nodes.nodeExists(shardStatus.nodeId())) {_                                    shards.put(shardEntry.key, shardEntry.value)__                                } else {_                                    _                                    snapshotChanged = true__                                    logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                        shardEntry.key, shardStatus.nodeId())__                                    shards.put(shardEntry.key,_                                        new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                }_                            }_                        }_                        if (snapshotChanged) {_                            changed = true__                            ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                            if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                            } else {_                                updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                            }_                        }_                        entries.add(updatedSnapshot)__                    } else if (snapshot.state() == State.INIT && initializingSnapshots.contains(snapshot.snapshot()) == false) {_                        changed = true__                        _                        updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                        entries.add(updatedSnapshot)___                        _                        deleteSnapshot(snapshot.snapshot(), new ActionListener<Void>() {_                            @Override_                            public void onResponse(Void aVoid) {_                                logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                            }__                            @Override_                            public void onFailure(Exception e) {_                                logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                            }_                        }, updatedSnapshot.getRepositoryStateId(), false)__                    }_                }_                if (changed) {_                    return ClusterState.builder(currentState)_                        .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(unmodifiableList(entries))).build()__                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn("failed to update snapshot state after node removal")__            }_        })__    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes;private,void,process,snapshots,on,removed,nodes,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,boolean,snapshot,changed,false,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,initializing,snapshots,contains,snapshot,snapshot,false,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,action,listener,void,override,public,void,on,response,void,a,void,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,unmodifiable,list,entries,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes();1549637959;Cleans up shard snapshots that were running on removed nodes;private void processSnapshotsOnRemovedNodes() {_        clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                DiscoveryNodes nodes = currentState.nodes()__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null) {_                    return currentState__                }_                boolean changed = false__                ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                    SnapshotsInProgress.Entry updatedSnapshot = snapshot__                    if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                        ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                        boolean snapshotChanged = false__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                            ShardSnapshotStatus shardStatus = shardEntry.value__                            if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                if (nodes.nodeExists(shardStatus.nodeId())) {_                                    shards.put(shardEntry.key, shardEntry.value)__                                } else {_                                    _                                    snapshotChanged = true__                                    logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                        shardEntry.key, shardStatus.nodeId())__                                    shards.put(shardEntry.key,_                                        new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                }_                            }_                        }_                        if (snapshotChanged) {_                            changed = true__                            ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                            if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                            } else {_                                updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                            }_                        }_                        entries.add(updatedSnapshot)__                    } else if (snapshot.state() == State.INIT && initializingSnapshots.contains(snapshot.snapshot()) == false) {_                        changed = true__                        _                        updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                        entries.add(updatedSnapshot)___                        _                        deleteSnapshot(snapshot.snapshot(), new ActionListener<Void>() {_                            @Override_                            public void onResponse(Void aVoid) {_                                logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                            }__                            @Override_                            public void onFailure(Exception e) {_                                logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                            }_                        }, updatedSnapshot.getRepositoryStateId(), false)__                    }_                }_                if (changed) {_                    return ClusterState.builder(currentState)_                        .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(unmodifiableList(entries))).build()__                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn("failed to update snapshot state after node removal")__            }_        })__    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes;private,void,process,snapshots,on,removed,nodes,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,boolean,snapshot,changed,false,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,initializing,snapshots,contains,snapshot,snapshot,false,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,action,listener,void,override,public,void,on,response,void,a,void,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,unmodifiable,list,entries,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> DeleteSnapshotListener -> void onFailure(Exception e)_;1524684173;Called if delete operation failed;void onFailure(Exception e)_;called,if,delete,operation,failed;void,on,failure,exception,e
SnapshotsService -> DeleteSnapshotListener -> void onFailure(Exception e)_;1524839522;Called if delete operation failed;void onFailure(Exception e)_;called,if,delete,operation,failed;void,on,failure,exception,e
SnapshotsService -> DeleteSnapshotListener -> void onFailure(Exception e)_;1542646292;Called if delete operation failed;void onFailure(Exception e)_;called,if,delete,operation,failed;void,on,failure,exception,e
SnapshotsService -> DeleteSnapshotListener -> void onFailure(Exception e)_;1542826731;Called if delete operation failed;void onFailure(Exception e)_;called,if,delete,operation,failed;void,on,failure,exception,e
SnapshotsService -> DeleteSnapshotListener -> void onFailure(Exception e)_;1544783963;Called if delete operation failed;void onFailure(Exception e)_;called,if,delete,operation,failed;void,on,failure,exception,e
SnapshotsService -> DeleteSnapshotListener -> void onFailure(Exception e)_;1545215361;Called if delete operation failed;void onFailure(Exception e)_;called,if,delete,operation,failed;void,on,failure,exception,e
SnapshotsService -> DeleteSnapshotListener -> void onFailure(Exception e)_;1547023537;Called if delete operation failed;void onFailure(Exception e)_;called,if,delete,operation,failed;void,on,failure,exception,e
SnapshotsService -> DeleteSnapshotListener -> void onFailure(Exception e)_;1547625930;Called if delete operation failed;void onFailure(Exception e)_;called,if,delete,operation,failed;void,on,failure,exception,e
SnapshotsService -> DeleteSnapshotListener -> void onFailure(Exception e)_;1547633328;Called if delete operation failed;void onFailure(Exception e)_;called,if,delete,operation,failed;void,on,failure,exception,e
SnapshotsService -> DeleteSnapshotListener -> void onFailure(Exception e)_;1547760072;Called if delete operation failed;void onFailure(Exception e)_;called,if,delete,operation,failed;void,on,failure,exception,e
SnapshotsService -> DeleteSnapshotListener -> void onFailure(Exception e)_;1548072633;Called if delete operation failed;void onFailure(Exception e)_;called,if,delete,operation,failed;void,on,failure,exception,e
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, @Nullable SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1549381458;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, @Nullable SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(unmodifiableList(entries))).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                endingSnapshots.remove(snapshot)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                endingSnapshots.remove(snapshot)__                if (listener != null) {_                    listener.onNoLongerMaster()__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                final List<ActionListener<SnapshotInfo>> completionListeners = snapshotCompletionListeners.remove(snapshot)__                if (completionListeners != null) {_                    try {_                        if (snapshotInfo == null) {_                            ActionListener.onFailure(completionListeners, failure)__                        } else {_                            ActionListener.onResponse(completionListeners, snapshotInfo)__                        }_                    } catch (Exception e) {_                        logger.warn("Failed to notify listeners", e)__                    }_                }_                endingSnapshots.remove(snapshot)__                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,nullable,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,unmodifiable,list,entries,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,ending,snapshots,remove,snapshot,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,ending,snapshots,remove,snapshot,if,listener,null,listener,on,no,longer,master,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,final,list,action,listener,snapshot,info,completion,listeners,snapshot,completion,listeners,remove,snapshot,if,completion,listeners,null,try,if,snapshot,info,null,action,listener,on,failure,completion,listeners,failure,else,action,listener,on,response,completion,listeners,snapshot,info,catch,exception,e,logger,warn,failed,to,notify,listeners,e,ending,snapshots,remove,snapshot,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, @Nullable SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1549407419;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, @Nullable SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(unmodifiableList(entries))).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                endingSnapshots.remove(snapshot)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                endingSnapshots.remove(snapshot)__                if (listener != null) {_                    listener.onNoLongerMaster()__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                final List<ActionListener<SnapshotInfo>> completionListeners = snapshotCompletionListeners.remove(snapshot)__                if (completionListeners != null) {_                    try {_                        if (snapshotInfo == null) {_                            ActionListener.onFailure(completionListeners, failure)__                        } else {_                            ActionListener.onResponse(completionListeners, snapshotInfo)__                        }_                    } catch (Exception e) {_                        logger.warn("Failed to notify listeners", e)__                    }_                }_                endingSnapshots.remove(snapshot)__                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,nullable,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,unmodifiable,list,entries,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,ending,snapshots,remove,snapshot,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,ending,snapshots,remove,snapshot,if,listener,null,listener,on,no,longer,master,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,final,list,action,listener,snapshot,info,completion,listeners,snapshot,completion,listeners,remove,snapshot,if,completion,listeners,null,try,if,snapshot,info,null,action,listener,on,failure,completion,listeners,failure,else,action,listener,on,response,completion,listeners,snapshot,info,catch,exception,e,logger,warn,failed,to,notify,listeners,e,ending,snapshots,remove,snapshot,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, @Nullable SnapshotInfo snapshotInfo, final Exception failure,                                                 @Nullable CleanupAfterErrorListener listener);1549637959;Removes record of running snapshot from cluster state and notifies the listener when this action is complete_@param snapshot   snapshot_@param failure          exception if snapshot failed_@param listener   listener to notify when snapshot information is removed from the cluster state;private void removeSnapshotFromClusterState(final Snapshot snapshot, @Nullable SnapshotInfo snapshotInfo, final Exception failure,_                                                @Nullable CleanupAfterErrorListener listener) {_        clusterService.submitStateUpdateTask("remove snapshot metadata", new ClusterStateUpdateTask() {__            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots != null) {_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot)) {_                            changed = true__                        } else {_                            entries.add(entry)__                        }_                    }_                    if (changed) {_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(unmodifiableList(entries))).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot metadata", snapshot), e)__                endingSnapshots.remove(snapshot)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void onNoLongerMaster(String source) {_                endingSnapshots.remove(snapshot)__                if (listener != null) {_                    listener.onNoLongerMaster()__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                final List<ActionListener<SnapshotInfo>> completionListeners = snapshotCompletionListeners.remove(snapshot)__                if (completionListeners != null) {_                    try {_                        if (snapshotInfo == null) {_                            ActionListener.onFailure(completionListeners, failure)__                        } else {_                            ActionListener.onResponse(completionListeners, snapshotInfo)__                        }_                    } catch (Exception e) {_                        logger.warn("Failed to notify listeners", e)__                    }_                }_                endingSnapshots.remove(snapshot)__                if (listener != null) {_                    listener.onResponse(snapshotInfo)__                }_            }_        })__    };removes,record,of,running,snapshot,from,cluster,state,and,notifies,the,listener,when,this,action,is,complete,param,snapshot,snapshot,param,failure,exception,if,snapshot,failed,param,listener,listener,to,notify,when,snapshot,information,is,removed,from,the,cluster,state;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,nullable,snapshot,info,snapshot,info,final,exception,failure,nullable,cleanup,after,error,listener,listener,cluster,service,submit,state,update,task,remove,snapshot,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,changed,true,else,entries,add,entry,if,changed,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,unmodifiable,list,entries,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,metadata,snapshot,e,ending,snapshots,remove,snapshot,if,listener,null,listener,on,failure,e,override,public,void,on,no,longer,master,string,source,ending,snapshots,remove,snapshot,if,listener,null,listener,on,no,longer,master,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,final,list,action,listener,snapshot,info,completion,listeners,snapshot,completion,listeners,remove,snapshot,if,completion,listeners,null,try,if,snapshot,info,null,action,listener,on,failure,completion,listeners,failure,else,action,listener,on,response,completion,listeners,snapshot,info,catch,exception,e,logger,warn,failed,to,notify,listeners,e,ending,snapshots,remove,snapshot,if,listener,null,listener,on,response,snapshot,info
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry);1549381458;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;private void endSnapshot(final SnapshotsInProgress.Entry entry) {_        if (endingSnapshots.add(entry.snapshot()) == false) {_            return__        }_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                final String failure = entry.failure()__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,if,ending,snapshots,add,entry,snapshot,false,return,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,final,string,failure,entry,failure,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry);1549407419;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;private void endSnapshot(final SnapshotsInProgress.Entry entry) {_        if (endingSnapshots.add(entry.snapshot()) == false) {_            return__        }_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                final String failure = entry.failure()__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,if,ending,snapshots,add,entry,snapshot,false,return,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,final,string,failure,entry,failure,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry);1549637959;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;private void endSnapshot(final SnapshotsInProgress.Entry entry) {_        if (endingSnapshots.add(entry.snapshot()) == false) {_            return__        }_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                final String failure = entry.failure()__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,if,ending,snapshots,add,entry,snapshot,false,return,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,final,string,failure,entry,failure,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,                                 final boolean immediatePriority);1524684173;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.entries().isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, snapshots)__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(new SnapshotCompletionListener() {_                        @Override_                        public void onSnapshotCompletion(Snapshot completedSnapshot, SnapshotInfo snapshotInfo) {_                            if (completedSnapshot.equals(snapshot)) {_                                logger.debug("deleted snapshot completed - deleting files")__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                        try {_                                            deleteSnapshot(completedSnapshot.getRepository(), completedSnapshot.getSnapshotId().getName(),_                                                listener, true)___                                        } catch (Exception ex) {_                                            logger.warn(() -> new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                        }_                                    }_                                )__                            }_                        }__                        @Override_                        public void onSnapshotFailure(Snapshot failedSnapshot, Exception e) {_                            if (failedSnapshot.equals(snapshot)) {_                                logger.warn("deleted snapshot failed - deleting files", e)__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(failedSnapshot.getRepository(),_                                                       failedSnapshot.getSnapshotId().getName(),_                                                       listener,_                                                       true)__                                    } catch (SnapshotMissingException smex) {_                                        logger.info(() -> new ParameterizedMessage(_                                            "Tried deleting in-progress snapshot [{}], but it " +_                                            "could not be found after failing to abort.",_                                            smex.getSnapshotName()), e)__                                        listener.onFailure(new SnapshotException(snapshot,_                                            "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                    }_                                })__                            }_                        }_                    })__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,delete,snapshot,listener,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,entries,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,snapshots,new,snapshots,in,progress,new,snapshot,cluster,state,builder,put,custom,snapshots,in,progress,type,snapshots,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,new,snapshot,completion,listener,override,public,void,on,snapshot,completion,snapshot,completed,snapshot,snapshot,info,snapshot,info,if,completed,snapshot,equals,snapshot,logger,debug,deleted,snapshot,completed,deleting,files,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,completed,snapshot,get,repository,completed,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,override,public,void,on,snapshot,failure,snapshot,failed,snapshot,exception,e,if,failed,snapshot,equals,snapshot,logger,warn,deleted,snapshot,failed,deleting,files,e,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,failed,snapshot,get,repository,failed,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,                                 final boolean immediatePriority);1524839522;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.entries().isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, snapshots)__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(new SnapshotCompletionListener() {_                        @Override_                        public void onSnapshotCompletion(Snapshot completedSnapshot, SnapshotInfo snapshotInfo) {_                            if (completedSnapshot.equals(snapshot)) {_                                logger.debug("deleted snapshot completed - deleting files")__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                        try {_                                            deleteSnapshot(completedSnapshot.getRepository(), completedSnapshot.getSnapshotId().getName(),_                                                listener, true)___                                        } catch (Exception ex) {_                                            logger.warn(() -> new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                        }_                                    }_                                )__                            }_                        }__                        @Override_                        public void onSnapshotFailure(Snapshot failedSnapshot, Exception e) {_                            if (failedSnapshot.equals(snapshot)) {_                                logger.warn("deleted snapshot failed - deleting files", e)__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(failedSnapshot.getRepository(),_                                                       failedSnapshot.getSnapshotId().getName(),_                                                       listener,_                                                       true)__                                    } catch (SnapshotMissingException smex) {_                                        logger.info(() -> new ParameterizedMessage(_                                            "Tried deleting in-progress snapshot [{}], but it " +_                                            "could not be found after failing to abort.",_                                            smex.getSnapshotName()), e)__                                        listener.onFailure(new SnapshotException(snapshot,_                                            "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                    }_                                })__                            }_                        }_                    })__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,delete,snapshot,listener,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,entries,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,snapshots,new,snapshots,in,progress,new,snapshot,cluster,state,builder,put,custom,snapshots,in,progress,type,snapshots,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,new,snapshot,completion,listener,override,public,void,on,snapshot,completion,snapshot,completed,snapshot,snapshot,info,snapshot,info,if,completed,snapshot,equals,snapshot,logger,debug,deleted,snapshot,completed,deleting,files,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,completed,snapshot,get,repository,completed,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,override,public,void,on,snapshot,failure,snapshot,failed,snapshot,exception,e,if,failed,snapshot,equals,snapshot,logger,warn,deleted,snapshot,failed,deleting,files,e,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,failed,snapshot,get,repository,failed,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,                                 final boolean immediatePriority);1542646292;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.entries().isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, snapshots)__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(new SnapshotCompletionListener() {_                        @Override_                        public void onSnapshotCompletion(Snapshot completedSnapshot, SnapshotInfo snapshotInfo) {_                            if (completedSnapshot.equals(snapshot)) {_                                logger.debug("deleted snapshot completed - deleting files")__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                        try {_                                            deleteSnapshot(completedSnapshot.getRepository(), completedSnapshot.getSnapshotId().getName(),_                                                listener, true)___                                        } catch (Exception ex) {_                                            logger.warn(() -> new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                        }_                                    }_                                )__                            }_                        }__                        @Override_                        public void onSnapshotFailure(Snapshot failedSnapshot, Exception e) {_                            if (failedSnapshot.equals(snapshot)) {_                                logger.warn("deleted snapshot failed - deleting files", e)__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(failedSnapshot.getRepository(),_                                                       failedSnapshot.getSnapshotId().getName(),_                                                       listener,_                                                       true)__                                    } catch (SnapshotMissingException smex) {_                                        logger.info(() -> new ParameterizedMessage(_                                            "Tried deleting in-progress snapshot [{}], but it " +_                                            "could not be found after failing to abort.",_                                            smex.getSnapshotName()), e)__                                        listener.onFailure(new SnapshotException(snapshot,_                                            "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                    }_                                })__                            }_                        }_                    })__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,delete,snapshot,listener,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,entries,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,snapshots,new,snapshots,in,progress,new,snapshot,cluster,state,builder,put,custom,snapshots,in,progress,type,snapshots,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,new,snapshot,completion,listener,override,public,void,on,snapshot,completion,snapshot,completed,snapshot,snapshot,info,snapshot,info,if,completed,snapshot,equals,snapshot,logger,debug,deleted,snapshot,completed,deleting,files,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,completed,snapshot,get,repository,completed,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,override,public,void,on,snapshot,failure,snapshot,failed,snapshot,exception,e,if,failed,snapshot,equals,snapshot,logger,warn,deleted,snapshot,failed,deleting,files,e,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,failed,snapshot,get,repository,failed,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,                                 final boolean immediatePriority);1542826731;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.entries().isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, snapshots)__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(new SnapshotCompletionListener() {_                        @Override_                        public void onSnapshotCompletion(Snapshot completedSnapshot, SnapshotInfo snapshotInfo) {_                            if (completedSnapshot.equals(snapshot)) {_                                logger.debug("deleted snapshot completed - deleting files")__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                        try {_                                            deleteSnapshot(completedSnapshot.getRepository(), completedSnapshot.getSnapshotId().getName(),_                                                listener, true)___                                        } catch (Exception ex) {_                                            logger.warn(() -> new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                        }_                                    }_                                )__                            }_                        }__                        @Override_                        public void onSnapshotFailure(Snapshot failedSnapshot, Exception e) {_                            if (failedSnapshot.equals(snapshot)) {_                                logger.warn("deleted snapshot failed - deleting files", e)__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(failedSnapshot.getRepository(),_                                                       failedSnapshot.getSnapshotId().getName(),_                                                       listener,_                                                       true)__                                    } catch (SnapshotMissingException smex) {_                                        logger.info(() -> new ParameterizedMessage(_                                            "Tried deleting in-progress snapshot [{}], but it " +_                                            "could not be found after failing to abort.",_                                            smex.getSnapshotName()), e)__                                        listener.onFailure(new SnapshotException(snapshot,_                                            "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                    }_                                })__                            }_                        }_                    })__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,delete,snapshot,listener,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,entries,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,snapshots,new,snapshots,in,progress,new,snapshot,cluster,state,builder,put,custom,snapshots,in,progress,type,snapshots,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,new,snapshot,completion,listener,override,public,void,on,snapshot,completion,snapshot,completed,snapshot,snapshot,info,snapshot,info,if,completed,snapshot,equals,snapshot,logger,debug,deleted,snapshot,completed,deleting,files,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,completed,snapshot,get,repository,completed,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,override,public,void,on,snapshot,failure,snapshot,failed,snapshot,exception,e,if,failed,snapshot,equals,snapshot,logger,warn,deleted,snapshot,failed,deleting,files,e,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,failed,snapshot,get,repository,failed,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,                                 final boolean immediatePriority);1544783963;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, snapshots)__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(new SnapshotCompletionListener() {_                        @Override_                        public void onSnapshotCompletion(Snapshot completedSnapshot, SnapshotInfo snapshotInfo) {_                            if (completedSnapshot.equals(snapshot)) {_                                logger.debug("deleted snapshot completed - deleting files")__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                        try {_                                            deleteSnapshot(completedSnapshot.getRepository(), completedSnapshot.getSnapshotId().getName(),_                                                listener, true)___                                        } catch (Exception ex) {_                                            logger.warn(() -> new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                        }_                                    }_                                )__                            }_                        }__                        @Override_                        public void onSnapshotFailure(Snapshot failedSnapshot, Exception e) {_                            if (failedSnapshot.equals(snapshot)) {_                                logger.warn("deleted snapshot failed - deleting files", e)__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(failedSnapshot.getRepository(),_                                                       failedSnapshot.getSnapshotId().getName(),_                                                       listener,_                                                       true)__                                    } catch (SnapshotMissingException smex) {_                                        logger.info(() -> new ParameterizedMessage(_                                            "Tried deleting in-progress snapshot [{}], but it " +_                                            "could not be found after failing to abort.",_                                            smex.getSnapshotName()), e)__                                        listener.onFailure(new SnapshotException(snapshot,_                                            "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                    }_                                })__                            }_                        }_                    })__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,delete,snapshot,listener,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,snapshots,new,snapshots,in,progress,new,snapshot,cluster,state,builder,put,custom,snapshots,in,progress,type,snapshots,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,new,snapshot,completion,listener,override,public,void,on,snapshot,completion,snapshot,completed,snapshot,snapshot,info,snapshot,info,if,completed,snapshot,equals,snapshot,logger,debug,deleted,snapshot,completed,deleting,files,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,completed,snapshot,get,repository,completed,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,override,public,void,on,snapshot,failure,snapshot,failed,snapshot,exception,e,if,failed,snapshot,equals,snapshot,logger,warn,deleted,snapshot,failed,deleting,files,e,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,failed,snapshot,get,repository,failed,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,                                 final boolean immediatePriority);1545215361;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, snapshots)__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(new SnapshotCompletionListener() {_                        @Override_                        public void onSnapshotCompletion(Snapshot completedSnapshot, SnapshotInfo snapshotInfo) {_                            if (completedSnapshot.equals(snapshot)) {_                                logger.debug("deleted snapshot completed - deleting files")__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                        try {_                                            deleteSnapshot(completedSnapshot.getRepository(), completedSnapshot.getSnapshotId().getName(),_                                                listener, true)___                                        } catch (Exception ex) {_                                            logger.warn(() ->_                                                new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                        }_                                    }_                                )__                            }_                        }__                        @Override_                        public void onSnapshotFailure(Snapshot failedSnapshot, Exception e) {_                            if (failedSnapshot.equals(snapshot)) {_                                logger.warn("deleted snapshot failed - deleting files", e)__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(failedSnapshot.getRepository(),_                                                       failedSnapshot.getSnapshotId().getName(),_                                                       listener,_                                                       true)__                                    } catch (SnapshotMissingException smex) {_                                        logger.info(() -> new ParameterizedMessage(_                                            "Tried deleting in-progress snapshot [{}], but it " +_                                            "could not be found after failing to abort.",_                                            smex.getSnapshotName()), e)__                                        listener.onFailure(new SnapshotException(snapshot,_                                            "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                    }_                                })__                            }_                        }_                    })__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,delete,snapshot,listener,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,snapshots,new,snapshots,in,progress,new,snapshot,cluster,state,builder,put,custom,snapshots,in,progress,type,snapshots,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,new,snapshot,completion,listener,override,public,void,on,snapshot,completion,snapshot,completed,snapshot,snapshot,info,snapshot,info,if,completed,snapshot,equals,snapshot,logger,debug,deleted,snapshot,completed,deleting,files,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,completed,snapshot,get,repository,completed,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,override,public,void,on,snapshot,failure,snapshot,failed,snapshot,exception,e,if,failed,snapshot,equals,snapshot,logger,warn,deleted,snapshot,failed,deleting,files,e,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,failed,snapshot,get,repository,failed,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,                                 final boolean immediatePriority);1547023537;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, snapshots)__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(new SnapshotCompletionListener() {_                        @Override_                        public void onSnapshotCompletion(Snapshot completedSnapshot, SnapshotInfo snapshotInfo) {_                            if (completedSnapshot.equals(snapshot)) {_                                logger.debug("deleted snapshot completed - deleting files")__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                        try {_                                            deleteSnapshot(completedSnapshot.getRepository(), completedSnapshot.getSnapshotId().getName(),_                                                listener, true)___                                        } catch (Exception ex) {_                                            logger.warn(() ->_                                                new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                        }_                                    }_                                )__                            }_                        }__                        @Override_                        public void onSnapshotFailure(Snapshot failedSnapshot, Exception e) {_                            if (failedSnapshot.equals(snapshot)) {_                                logger.warn("deleted snapshot failed - deleting files", e)__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(failedSnapshot.getRepository(),_                                                       failedSnapshot.getSnapshotId().getName(),_                                                       listener,_                                                       true)__                                    } catch (SnapshotMissingException smex) {_                                        logger.info(() -> new ParameterizedMessage(_                                            "Tried deleting in-progress snapshot [{}], but it " +_                                            "could not be found after failing to abort.",_                                            smex.getSnapshotName()), e)__                                        listener.onFailure(new SnapshotException(snapshot,_                                            "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                    }_                                })__                            }_                        }_                    })__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,delete,snapshot,listener,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,snapshots,new,snapshots,in,progress,new,snapshot,cluster,state,builder,put,custom,snapshots,in,progress,type,snapshots,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,new,snapshot,completion,listener,override,public,void,on,snapshot,completion,snapshot,completed,snapshot,snapshot,info,snapshot,info,if,completed,snapshot,equals,snapshot,logger,debug,deleted,snapshot,completed,deleting,files,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,completed,snapshot,get,repository,completed,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,override,public,void,on,snapshot,failure,snapshot,failed,snapshot,exception,e,if,failed,snapshot,equals,snapshot,logger,warn,deleted,snapshot,failed,deleting,files,e,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,failed,snapshot,get,repository,failed,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,                                 final boolean immediatePriority);1547625930;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, snapshots)__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(new SnapshotCompletionListener() {_                        @Override_                        public void onSnapshotCompletion(Snapshot completedSnapshot, SnapshotInfo snapshotInfo) {_                            if (completedSnapshot.equals(snapshot)) {_                                logger.debug("deleted snapshot completed - deleting files")__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                        try {_                                            deleteSnapshot(completedSnapshot.getRepository(), completedSnapshot.getSnapshotId().getName(),_                                                listener, true)___                                        } catch (Exception ex) {_                                            logger.warn(() ->_                                                new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                        }_                                    }_                                )__                            }_                        }__                        @Override_                        public void onSnapshotFailure(Snapshot failedSnapshot, Exception e) {_                            if (failedSnapshot.equals(snapshot)) {_                                logger.warn("deleted snapshot failed - deleting files", e)__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(failedSnapshot.getRepository(),_                                                       failedSnapshot.getSnapshotId().getName(),_                                                       listener,_                                                       true)__                                    } catch (SnapshotMissingException smex) {_                                        logger.info(() -> new ParameterizedMessage(_                                            "Tried deleting in-progress snapshot [{}], but it " +_                                            "could not be found after failing to abort.",_                                            smex.getSnapshotName()), e)__                                        listener.onFailure(new SnapshotException(snapshot,_                                            "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                    }_                                })__                            }_                        }_                    })__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,delete,snapshot,listener,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,snapshots,new,snapshots,in,progress,new,snapshot,cluster,state,builder,put,custom,snapshots,in,progress,type,snapshots,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,new,snapshot,completion,listener,override,public,void,on,snapshot,completion,snapshot,completed,snapshot,snapshot,info,snapshot,info,if,completed,snapshot,equals,snapshot,logger,debug,deleted,snapshot,completed,deleting,files,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,completed,snapshot,get,repository,completed,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,override,public,void,on,snapshot,failure,snapshot,failed,snapshot,exception,e,if,failed,snapshot,equals,snapshot,logger,warn,deleted,snapshot,failed,deleting,files,e,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,failed,snapshot,get,repository,failed,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,                                 final boolean immediatePriority);1547633328;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, snapshots)__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(new SnapshotCompletionListener() {_                        @Override_                        public void onSnapshotCompletion(Snapshot completedSnapshot, SnapshotInfo snapshotInfo) {_                            if (completedSnapshot.equals(snapshot)) {_                                logger.debug("deleted snapshot completed - deleting files")__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                        try {_                                            deleteSnapshot(completedSnapshot.getRepository(), completedSnapshot.getSnapshotId().getName(),_                                                listener, true)___                                        } catch (Exception ex) {_                                            logger.warn(() ->_                                                new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                        }_                                    }_                                )__                            }_                        }__                        @Override_                        public void onSnapshotFailure(Snapshot failedSnapshot, Exception e) {_                            if (failedSnapshot.equals(snapshot)) {_                                logger.warn("deleted snapshot failed - deleting files", e)__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(failedSnapshot.getRepository(),_                                                       failedSnapshot.getSnapshotId().getName(),_                                                       listener,_                                                       true)__                                    } catch (SnapshotMissingException smex) {_                                        logger.info(() -> new ParameterizedMessage(_                                            "Tried deleting in-progress snapshot [{}], but it " +_                                            "could not be found after failing to abort.",_                                            smex.getSnapshotName()), e)__                                        listener.onFailure(new SnapshotException(snapshot,_                                            "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                    }_                                })__                            }_                        }_                    })__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,delete,snapshot,listener,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,snapshots,new,snapshots,in,progress,new,snapshot,cluster,state,builder,put,custom,snapshots,in,progress,type,snapshots,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,new,snapshot,completion,listener,override,public,void,on,snapshot,completion,snapshot,completed,snapshot,snapshot,info,snapshot,info,if,completed,snapshot,equals,snapshot,logger,debug,deleted,snapshot,completed,deleting,files,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,completed,snapshot,get,repository,completed,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,override,public,void,on,snapshot,failure,snapshot,failed,snapshot,exception,e,if,failed,snapshot,equals,snapshot,logger,warn,deleted,snapshot,failed,deleting,files,e,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,failed,snapshot,get,repository,failed,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,                                 final boolean immediatePriority);1547760072;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, snapshots)__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(new SnapshotCompletionListener() {_                        @Override_                        public void onSnapshotCompletion(Snapshot completedSnapshot, SnapshotInfo snapshotInfo) {_                            if (completedSnapshot.equals(snapshot)) {_                                logger.debug("deleted snapshot completed - deleting files")__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                        try {_                                            deleteSnapshot(completedSnapshot.getRepository(), completedSnapshot.getSnapshotId().getName(),_                                                listener, true)___                                        } catch (Exception ex) {_                                            logger.warn(() ->_                                                new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                        }_                                    }_                                )__                            }_                        }__                        @Override_                        public void onSnapshotFailure(Snapshot failedSnapshot, Exception e) {_                            if (failedSnapshot.equals(snapshot)) {_                                logger.warn("deleted snapshot failed - deleting files", e)__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(failedSnapshot.getRepository(),_                                                       failedSnapshot.getSnapshotId().getName(),_                                                       listener,_                                                       true)__                                    } catch (SnapshotMissingException smex) {_                                        logger.info(() -> new ParameterizedMessage(_                                            "Tried deleting in-progress snapshot [{}], but it " +_                                            "could not be found after failing to abort.",_                                            smex.getSnapshotName()), e)__                                        listener.onFailure(new SnapshotException(snapshot,_                                            "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                    }_                                })__                            }_                        }_                    })__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,delete,snapshot,listener,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,snapshots,new,snapshots,in,progress,new,snapshot,cluster,state,builder,put,custom,snapshots,in,progress,type,snapshots,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,new,snapshot,completion,listener,override,public,void,on,snapshot,completion,snapshot,completed,snapshot,snapshot,info,snapshot,info,if,completed,snapshot,equals,snapshot,logger,debug,deleted,snapshot,completed,deleting,files,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,completed,snapshot,get,repository,completed,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,override,public,void,on,snapshot,failure,snapshot,failed,snapshot,exception,e,if,failed,snapshot,equals,snapshot,logger,warn,deleted,snapshot,failed,deleting,files,e,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,failed,snapshot,get,repository,failed,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,                                 final boolean immediatePriority);1548072633;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final DeleteSnapshotListener listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, snapshots)__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(new SnapshotCompletionListener() {_                        @Override_                        public void onSnapshotCompletion(Snapshot completedSnapshot, SnapshotInfo snapshotInfo) {_                            if (completedSnapshot.equals(snapshot)) {_                                logger.debug("deleted snapshot completed - deleting files")__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                        try {_                                            deleteSnapshot(completedSnapshot.getRepository(), completedSnapshot.getSnapshotId().getName(),_                                                listener, true)___                                        } catch (Exception ex) {_                                            logger.warn(() ->_                                                new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                        }_                                    }_                                )__                            }_                        }__                        @Override_                        public void onSnapshotFailure(Snapshot failedSnapshot, Exception e) {_                            if (failedSnapshot.equals(snapshot)) {_                                logger.warn("deleted snapshot failed - deleting files", e)__                                removeListener(this)__                                threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(failedSnapshot.getRepository(),_                                                       failedSnapshot.getSnapshotId().getName(),_                                                       listener,_                                                       true)__                                    } catch (SnapshotMissingException smex) {_                                        logger.info(() -> new ParameterizedMessage(_                                            "Tried deleting in-progress snapshot [{}], but it " +_                                            "could not be found after failing to abort.",_                                            smex.getSnapshotName()), e)__                                        listener.onFailure(new SnapshotException(snapshot,_                                            "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                    }_                                })__                            }_                        }_                    })__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,delete,snapshot,listener,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,snapshots,new,snapshots,in,progress,new,snapshot,cluster,state,builder,put,custom,snapshots,in,progress,type,snapshots,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,new,snapshot,completion,listener,override,public,void,on,snapshot,completion,snapshot,completed,snapshot,snapshot,info,snapshot,info,if,completed,snapshot,equals,snapshot,logger,debug,deleted,snapshot,completed,deleting,files,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,completed,snapshot,get,repository,completed,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,override,public,void,on,snapshot,failure,snapshot,failed,snapshot,exception,e,if,failed,snapshot,equals,snapshot,logger,warn,deleted,snapshot,failed,deleting,files,e,remove,listener,this,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,failed,snapshot,get,repository,failed,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1524684173;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1524839522;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1542646292;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1542826731;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1544783963;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1545215361;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1547023537;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1547625930;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1547633328;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1547760072;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1548072633;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1548321078;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1548996340;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1549050374;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return Collections.unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,collections,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1549381458;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1549407419;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,unmodifiable,list,builder
SnapshotsService -> public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots);1549637959;Returns status of the currently running snapshots_<p>_This method is executed on master node_</p>__@param repository repository id_@param snapshots  list of snapshots that will be used as a filter, empty list means no snapshots are filtered_@return list of metadata for currently running snapshots;public List<SnapshotsInProgress.Entry> currentSnapshots(final String repository, final List<String> snapshots) {_        SnapshotsInProgress snapshotsInProgress = clusterService.state().custom(SnapshotsInProgress.TYPE)__        if (snapshotsInProgress == null || snapshotsInProgress.entries().isEmpty()) {_            return Collections.emptyList()__        }_        if ("_all".equals(repository)) {_            return snapshotsInProgress.entries()__        }_        if (snapshotsInProgress.entries().size() == 1) {_            _            _            SnapshotsInProgress.Entry entry = snapshotsInProgress.entries().get(0)__            if (entry.snapshot().getRepository().equals(repository) == false) {_                return Collections.emptyList()__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        return snapshotsInProgress.entries()__                    }_                }_                return Collections.emptyList()__            } else {_                return snapshotsInProgress.entries()__            }_        }_        List<SnapshotsInProgress.Entry> builder = new ArrayList<>()__        for (SnapshotsInProgress.Entry entry : snapshotsInProgress.entries()) {_            if (entry.snapshot().getRepository().equals(repository) == false) {_                continue__            }_            if (snapshots.isEmpty() == false) {_                for (String snapshot : snapshots) {_                    if (entry.snapshot().getSnapshotId().getName().equals(snapshot)) {_                        builder.add(entry)__                        break__                    }_                }_            } else {_                builder.add(entry)__            }_        }_        return unmodifiableList(builder)__    };returns,status,of,the,currently,running,snapshots,p,this,method,is,executed,on,master,node,p,param,repository,repository,id,param,snapshots,list,of,snapshots,that,will,be,used,as,a,filter,empty,list,means,no,snapshots,are,filtered,return,list,of,metadata,for,currently,running,snapshots;public,list,snapshots,in,progress,entry,current,snapshots,final,string,repository,final,list,string,snapshots,snapshots,in,progress,snapshots,in,progress,cluster,service,state,custom,snapshots,in,progress,type,if,snapshots,in,progress,null,snapshots,in,progress,entries,is,empty,return,collections,empty,list,if,equals,repository,return,snapshots,in,progress,entries,if,snapshots,in,progress,entries,size,1,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,get,0,if,entry,snapshot,get,repository,equals,repository,false,return,collections,empty,list,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,return,snapshots,in,progress,entries,return,collections,empty,list,else,return,snapshots,in,progress,entries,list,snapshots,in,progress,entry,builder,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,in,progress,entries,if,entry,snapshot,get,repository,equals,repository,false,continue,if,snapshots,is,empty,false,for,string,snapshot,snapshots,if,entry,snapshot,get,snapshot,id,get,name,equals,snapshot,builder,add,entry,break,else,builder,add,entry,return,unmodifiable,list,builder
SnapshotsService -> SnapshotRequest -> public String cause();1524684173;Returns cause for snapshot operation__@return cause for snapshot operation;public String cause() {_            return cause__        };returns,cause,for,snapshot,operation,return,cause,for,snapshot,operation;public,string,cause,return,cause
SnapshotsService -> SnapshotRequest -> public String cause();1524839522;Returns cause for snapshot operation__@return cause for snapshot operation;public String cause() {_            return cause__        };returns,cause,for,snapshot,operation,return,cause,for,snapshot,operation;public,string,cause,return,cause
SnapshotsService -> SnapshotRequest -> public String cause();1542646292;Returns cause for snapshot operation__@return cause for snapshot operation;public String cause() {_            return cause__        };returns,cause,for,snapshot,operation,return,cause,for,snapshot,operation;public,string,cause,return,cause
SnapshotsService -> SnapshotRequest -> public String cause();1542826731;Returns cause for snapshot operation__@return cause for snapshot operation;public String cause() {_            return cause__        };returns,cause,for,snapshot,operation,return,cause,for,snapshot,operation;public,string,cause,return,cause
SnapshotsService -> SnapshotRequest -> public String cause();1544783963;Returns cause for snapshot operation__@return cause for snapshot operation;public String cause() {_            return cause__        };returns,cause,for,snapshot,operation,return,cause,for,snapshot,operation;public,string,cause,return,cause
SnapshotsService -> SnapshotRequest -> public String cause();1545215361;Returns cause for snapshot operation__@return cause for snapshot operation;public String cause() {_            return cause__        };returns,cause,for,snapshot,operation,return,cause,for,snapshot,operation;public,string,cause,return,cause
SnapshotsService -> SnapshotRequest -> public String cause();1547023537;Returns cause for snapshot operation__@return cause for snapshot operation;public String cause() {_            return cause__        };returns,cause,for,snapshot,operation,return,cause,for,snapshot,operation;public,string,cause,return,cause
SnapshotsService -> SnapshotRequest -> public String cause();1547625930;Returns cause for snapshot operation__@return cause for snapshot operation;public String cause() {_            return cause__        };returns,cause,for,snapshot,operation,return,cause,for,snapshot,operation;public,string,cause,return,cause
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1524684173;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            final Snapshot snapshot = entry.snapshot()__            try {_                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,final,snapshot,snapshot,entry,snapshot,try,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1524839522;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            final Snapshot snapshot = entry.snapshot()__            try {_                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,final,snapshot,snapshot,entry,snapshot,try,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1542646292;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            final Snapshot snapshot = entry.snapshot()__            try {_                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            } catch (Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,final,snapshot,snapshot,entry,snapshot,try,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,catch,exception,e,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1542826731;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1544783963;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1545215361;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1547023537;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1547625930;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1547633328;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1547760072;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1548072633;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1548321078;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1548996340;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure);1549050374;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry   snapshot_@param failure failure reason or null if snapshot was successful;private void endSnapshot(final SnapshotsInProgress.Entry entry, final String failure) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {_            @Override_            protected void doRun() {_                final Snapshot snapshot = entry.snapshot()__                final Repository repository = repositoriesService.repository(snapshot.getRepository())__                logger.trace("[{}] finalizing snapshot in repository, state: [{}], failure[{}]", snapshot, entry.state(), failure)__                ArrayList<SnapshotShardFailure> shardFailures = new ArrayList<>()__                for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardStatus : entry.shards()) {_                    ShardId shardId = shardStatus.key__                    ShardSnapshotStatus status = shardStatus.value__                    if (status.state().failed()) {_                        shardFailures.add(new SnapshotShardFailure(status.nodeId(), shardId, status.reason()))__                    }_                }_                SnapshotInfo snapshotInfo = repository.finalizeSnapshot(_                    snapshot.getSnapshotId(),_                    entry.indices(),_                    entry.startTime(),_                    failure,_                    entry.shards().size(),_                    Collections.unmodifiableList(shardFailures),_                    entry.getRepositoryStateId(),_                    entry.includeGlobalState())__                removeSnapshotFromClusterState(snapshot, snapshotInfo, null)__                logger.info("snapshot [{}] completed with state [{}]", snapshot, snapshotInfo.state())__            }__            @Override_            public void onFailure(final Exception e) {_                Snapshot snapshot = entry.snapshot()__                logger.warn(() -> new ParameterizedMessage("[{}] failed to finalize snapshot", snapshot), e)__                removeSnapshotFromClusterState(snapshot, null, e)__            }_        })__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot,param,failure,failure,reason,or,null,if,snapshot,was,successful;private,void,end,snapshot,final,snapshots,in,progress,entry,entry,final,string,failure,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,override,protected,void,do,run,final,snapshot,snapshot,entry,snapshot,final,repository,repository,repositories,service,repository,snapshot,get,repository,logger,trace,finalizing,snapshot,in,repository,state,failure,snapshot,entry,state,failure,array,list,snapshot,shard,failure,shard,failures,new,array,list,for,object,object,cursor,shard,id,shard,snapshot,status,shard,status,entry,shards,shard,id,shard,id,shard,status,key,shard,snapshot,status,status,shard,status,value,if,status,state,failed,shard,failures,add,new,snapshot,shard,failure,status,node,id,shard,id,status,reason,snapshot,info,snapshot,info,repository,finalize,snapshot,snapshot,get,snapshot,id,entry,indices,entry,start,time,failure,entry,shards,size,collections,unmodifiable,list,shard,failures,entry,get,repository,state,id,entry,include,global,state,remove,snapshot,from,cluster,state,snapshot,snapshot,info,null,logger,info,snapshot,completed,with,state,snapshot,snapshot,info,state,override,public,void,on,failure,final,exception,e,snapshot,snapshot,entry,snapshot,logger,warn,new,parameterized,message,failed,to,finalize,snapshot,snapshot,e,remove,snapshot,from,cluster,state,snapshot,null,e
SnapshotsService -> SnapshotRequest -> public String repositoryName();1524684173;Returns the repository name;public String repositoryName() {_            return repositoryName__        };returns,the,repository,name;public,string,repository,name,return,repository,name
SnapshotsService -> SnapshotRequest -> public String repositoryName();1524839522;Returns the repository name;public String repositoryName() {_            return repositoryName__        };returns,the,repository,name;public,string,repository,name,return,repository,name
SnapshotsService -> SnapshotRequest -> public String repositoryName();1542646292;Returns the repository name;public String repositoryName() {_            return repositoryName__        };returns,the,repository,name;public,string,repository,name,return,repository,name
SnapshotsService -> SnapshotRequest -> public String repositoryName();1542826731;Returns the repository name;public String repositoryName() {_            return repositoryName__        };returns,the,repository,name;public,string,repository,name,return,repository,name
SnapshotsService -> SnapshotRequest -> public String repositoryName();1544783963;Returns the repository name;public String repositoryName() {_            return repositoryName__        };returns,the,repository,name;public,string,repository,name,return,repository,name
SnapshotsService -> SnapshotRequest -> public String repositoryName();1545215361;Returns the repository name;public String repositoryName() {_            return repositoryName__        };returns,the,repository,name;public,string,repository,name,return,repository,name
SnapshotsService -> SnapshotRequest -> public String repositoryName();1547023537;Returns the repository name;public String repositoryName() {_            return repositoryName__        };returns,the,repository,name;public,string,repository,name,return,repository,name
SnapshotsService -> SnapshotRequest -> public String repositoryName();1547625930;Returns the repository name;public String repositoryName() {_            return repositoryName__        };returns,the,repository,name;public,string,repository,name,return,repository,name
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1524684173;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1524839522;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1542646292;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1542826731;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1544783963;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1545215361;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1547023537;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1547625930;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1547633328;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1547760072;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1548072633;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1548321078;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1548996340;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1549050374;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1549381458;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1549407419;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> snapshots(final String repositoryName,                                         final List<SnapshotId> snapshotIds,                                         final Set<SnapshotId> incompatibleSnapshotIds,                                         final boolean ignoreUnavailable);1549637959;Returns a list of snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@param snapshotIds       snapshots for which to fetch snapshot information_@param incompatibleSnapshotIds   snapshots for which not to fetch snapshot information_@param ignoreUnavailable if true, snapshots that could not be read will only be logged with a warning,_if false, they will throw an error_@return list of snapshots;public List<SnapshotInfo> snapshots(final String repositoryName,_                                        final List<SnapshotId> snapshotIds,_                                        final Set<SnapshotId> incompatibleSnapshotIds,_                                        final boolean ignoreUnavailable) {_        final Set<SnapshotInfo> snapshotSet = new HashSet<>()__        final Set<SnapshotId> snapshotIdsToIterate = new HashSet<>(snapshotIds)__        _        final List<SnapshotsInProgress.Entry> entries =_            currentSnapshots(repositoryName, snapshotIdsToIterate.stream().map(SnapshotId::getName).collect(Collectors.toList()))__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotSet.add(inProgressSnapshot(entry))__            snapshotIdsToIterate.remove(entry.snapshot().getSnapshotId())__        }_        _        final Repository repository = repositoriesService.repository(repositoryName)__        for (SnapshotId snapshotId : snapshotIdsToIterate) {_            try {_                if (incompatibleSnapshotIds.contains(snapshotId)) {_                    _                    _                    snapshotSet.add(SnapshotInfo.incompatible(snapshotId))__                } else {_                    snapshotSet.add(repository.getSnapshotInfo(snapshotId))__                }_            } catch (Exception ex) {_                if (ignoreUnavailable) {_                    logger.warn(() -> new ParameterizedMessage("failed to get snapshot [{}]", snapshotId), ex)__                } else {_                    throw new SnapshotException(repositoryName, snapshotId, "Snapshot could not be read", ex)__                }_            }_        }_        final ArrayList<SnapshotInfo> snapshotList = new ArrayList<>(snapshotSet)__        CollectionUtil.timSort(snapshotList)__        return unmodifiableList(snapshotList)__    };returns,a,list,of,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,param,snapshot,ids,snapshots,for,which,to,fetch,snapshot,information,param,incompatible,snapshot,ids,snapshots,for,which,not,to,fetch,snapshot,information,param,ignore,unavailable,if,true,snapshots,that,could,not,be,read,will,only,be,logged,with,a,warning,if,false,they,will,throw,an,error,return,list,of,snapshots;public,list,snapshot,info,snapshots,final,string,repository,name,final,list,snapshot,id,snapshot,ids,final,set,snapshot,id,incompatible,snapshot,ids,final,boolean,ignore,unavailable,final,set,snapshot,info,snapshot,set,new,hash,set,final,set,snapshot,id,snapshot,ids,to,iterate,new,hash,set,snapshot,ids,final,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,snapshot,ids,to,iterate,stream,map,snapshot,id,get,name,collect,collectors,to,list,for,snapshots,in,progress,entry,entry,entries,snapshot,set,add,in,progress,snapshot,entry,snapshot,ids,to,iterate,remove,entry,snapshot,get,snapshot,id,final,repository,repository,repositories,service,repository,repository,name,for,snapshot,id,snapshot,id,snapshot,ids,to,iterate,try,if,incompatible,snapshot,ids,contains,snapshot,id,snapshot,set,add,snapshot,info,incompatible,snapshot,id,else,snapshot,set,add,repository,get,snapshot,info,snapshot,id,catch,exception,ex,if,ignore,unavailable,logger,warn,new,parameterized,message,failed,to,get,snapshot,snapshot,id,ex,else,throw,new,snapshot,exception,repository,name,snapshot,id,snapshot,could,not,be,read,ex,final,array,list,snapshot,info,snapshot,list,new,array,list,snapshot,set,collection,util,tim,sort,snapshot,list,return,unmodifiable,list,snapshot,list
SnapshotsService -> private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,                                               long repositoryStateId);1524684173;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,_                                              long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,final,snapshot,snapshot,nullable,final,delete,snapshot,listener,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,                                               long repositoryStateId);1524839522;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,_                                              long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,final,snapshot,snapshot,nullable,final,delete,snapshot,listener,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,                                               long repositoryStateId);1542646292;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,_                                              long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,final,snapshot,snapshot,nullable,final,delete,snapshot,listener,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,                                               long repositoryStateId);1542826731;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,_                                              long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,final,snapshot,snapshot,nullable,final,delete,snapshot,listener,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,                                               long repositoryStateId);1544783963;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,_                                              long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,final,snapshot,snapshot,nullable,final,delete,snapshot,listener,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,                                               long repositoryStateId);1545215361;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,_                                              long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,final,snapshot,snapshot,nullable,final,delete,snapshot,listener,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,                                               long repositoryStateId);1547023537;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,_                                              long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,final,snapshot,snapshot,nullable,final,delete,snapshot,listener,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,                                               long repositoryStateId);1547625930;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,_                                              long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,final,snapshot,snapshot,nullable,final,delete,snapshot,listener,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,                                               long repositoryStateId);1547633328;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,_                                              long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,final,snapshot,snapshot,nullable,final,delete,snapshot,listener,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,                                               long repositoryStateId);1547760072;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,_                                              long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,final,snapshot,snapshot,nullable,final,delete,snapshot,listener,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,                                               long repositoryStateId);1548072633;Deletes snapshot from repository__@param snapshot   snapshot_@param listener   listener_@param repositoryStateId the unique id representing the state of the repository at the time the deletion began;private void deleteSnapshotFromRepository(final Snapshot snapshot, @Nullable final DeleteSnapshotListener listener,_                                              long repositoryStateId) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_            try {_                Repository repository = repositoriesService.repository(snapshot.getRepository())__                repository.deleteSnapshot(snapshot.getSnapshotId(), repositoryStateId)__                logger.info("snapshot [{}] deleted", snapshot)___                removeSnapshotDeletionFromClusterState(snapshot, null, listener)__            } catch (Exception ex) {_                removeSnapshotDeletionFromClusterState(snapshot, ex, listener)__            }_        })__    };deletes,snapshot,from,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,representing,the,state,of,the,repository,at,the,time,the,deletion,began;private,void,delete,snapshot,from,repository,final,snapshot,snapshot,nullable,final,delete,snapshot,listener,listener,long,repository,state,id,thread,pool,executor,thread,pool,names,snapshot,execute,try,repository,repository,repositories,service,repository,snapshot,get,repository,repository,delete,snapshot,snapshot,get,snapshot,id,repository,state,id,logger,info,snapshot,deleted,snapshot,remove,snapshot,deletion,from,cluster,state,snapshot,null,listener,catch,exception,ex,remove,snapshot,deletion,from,cluster,state,snapshot,ex,listener
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final CreateSnapshotListener userCreateSnapshotListener);1524684173;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final CreateSnapshotListener userCreateSnapshotListener) {_        boolean snapshotCreated = false__        try {_            Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___            MetaData metaData = clusterState.metaData()__            if (!snapshot.includeGlobalState()) {_                _                MetaData.Builder builder = MetaData.builder()__                for (IndexId index : snapshot.indices()) {_                    builder.put(metaData.index(index.getName()), false)__                }_                metaData = builder.build()__            }__            repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__            snapshotCreated = true___            logger.info("snapshot [{}] started", snapshot.snapshot())__            if (snapshot.indices().isEmpty()) {_                _                userCreateSnapshotListener.onResponse()__                endSnapshot(snapshot)__                return__            }_            clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                SnapshotsInProgress.Entry endSnapshot__                String failure = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                            entries.add(entry)__                            continue__                        }__                        if (entry.state() != State.ABORTED) {_                            _                            ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards = shards(currentState, entry.indices())__                            if (!partial) {_                                Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards, currentState.metaData())__                                Set<String> missing = indicesWithMissingShards.v1()__                                Set<String> closed = indicesWithMissingShards.v2()__                                if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                    endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                    entries.add(endSnapshot)___                                    final StringBuilder failureMessage = new StringBuilder()__                                    if (missing.isEmpty() == false) {_                                        failureMessage.append("Indices don't have primary shards ")__                                        failureMessage.append(missing)__                                    }_                                    if (closed.isEmpty() == false) {_                                        if (failureMessage.length() > 0) {_                                            failureMessage.append("_ ")__                                        }_                                        failureMessage.append("Indices are closed ")__                                        failureMessage.append(closed)__                                    }_                                    failure = failureMessage.toString()__                                    continue__                                }_                            }_                            SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                            entries.add(updatedSnapshot)__                            if (completed(shards.values())) {_                                endSnapshot = updatedSnapshot__                            }_                        } else {_                            assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                            failure = "snapshot was aborted during initialization"__                            endSnapshot = entry__                            entries.add(endSnapshot)__                        }_                    }_                    return ClusterState.builder(currentState)_                                       .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                                       .build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot", snapshot.snapshot().getSnapshotId()), e)__                    removeSnapshotFromClusterState(snapshot.snapshot(), null, e, new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                }__                @Override_                public void onNoLongerMaster(String source) {_                    _                    _                    logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                    userCreateSnapshotListener.onFailure(_                        new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    _                    _                    _                    _                    userCreateSnapshotListener.onResponse()___                    _                    _                    _                    _                    if (endSnapshot != null) {_                        endSnapshot(endSnapshot, failure)__                    }_                }_            })__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]", snapshot.snapshot().getSnapshotId()), e)__            removeSnapshotFromClusterState(snapshot.snapshot(), null, e, new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__        }_    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,create,snapshot,listener,user,create,snapshot,listener,boolean,snapshot,created,false,try,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,null,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,if,end,snapshot,null,end,snapshot,end,snapshot,failure,catch,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final CreateSnapshotListener userCreateSnapshotListener);1524839522;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final CreateSnapshotListener userCreateSnapshotListener) {_        boolean snapshotCreated = false__        try {_            Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___            MetaData metaData = clusterState.metaData()__            if (!snapshot.includeGlobalState()) {_                _                MetaData.Builder builder = MetaData.builder()__                for (IndexId index : snapshot.indices()) {_                    builder.put(metaData.index(index.getName()), false)__                }_                metaData = builder.build()__            }__            repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__            snapshotCreated = true___            logger.info("snapshot [{}] started", snapshot.snapshot())__            if (snapshot.indices().isEmpty()) {_                _                userCreateSnapshotListener.onResponse()__                endSnapshot(snapshot)__                return__            }_            clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                SnapshotsInProgress.Entry endSnapshot__                String failure = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                            entries.add(entry)__                            continue__                        }__                        if (entry.state() != State.ABORTED) {_                            _                            ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards = shards(currentState, entry.indices())__                            if (!partial) {_                                Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards, currentState.metaData())__                                Set<String> missing = indicesWithMissingShards.v1()__                                Set<String> closed = indicesWithMissingShards.v2()__                                if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                    endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                    entries.add(endSnapshot)___                                    final StringBuilder failureMessage = new StringBuilder()__                                    if (missing.isEmpty() == false) {_                                        failureMessage.append("Indices don't have primary shards ")__                                        failureMessage.append(missing)__                                    }_                                    if (closed.isEmpty() == false) {_                                        if (failureMessage.length() > 0) {_                                            failureMessage.append("_ ")__                                        }_                                        failureMessage.append("Indices are closed ")__                                        failureMessage.append(closed)__                                    }_                                    failure = failureMessage.toString()__                                    continue__                                }_                            }_                            SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                            entries.add(updatedSnapshot)__                            if (completed(shards.values())) {_                                endSnapshot = updatedSnapshot__                            }_                        } else {_                            assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                            failure = "snapshot was aborted during initialization"__                            endSnapshot = entry__                            entries.add(endSnapshot)__                        }_                    }_                    return ClusterState.builder(currentState)_                                       .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                                       .build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot", snapshot.snapshot().getSnapshotId()), e)__                    removeSnapshotFromClusterState(snapshot.snapshot(), null, e, new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                }__                @Override_                public void onNoLongerMaster(String source) {_                    _                    _                    logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                    userCreateSnapshotListener.onFailure(_                        new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    _                    _                    _                    _                    userCreateSnapshotListener.onResponse()___                    _                    _                    _                    _                    if (endSnapshot != null) {_                        endSnapshot(endSnapshot, failure)__                    }_                }_            })__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]", snapshot.snapshot().getSnapshotId()), e)__            removeSnapshotFromClusterState(snapshot.snapshot(), null, e, new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__        }_    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,create,snapshot,listener,user,create,snapshot,listener,boolean,snapshot,created,false,try,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,null,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,if,end,snapshot,null,end,snapshot,end,snapshot,failure,catch,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final CreateSnapshotListener userCreateSnapshotListener);1542646292;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final CreateSnapshotListener userCreateSnapshotListener) {_        boolean snapshotCreated = false__        try {_            Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___            MetaData metaData = clusterState.metaData()__            if (!snapshot.includeGlobalState()) {_                _                MetaData.Builder builder = MetaData.builder()__                for (IndexId index : snapshot.indices()) {_                    builder.put(metaData.index(index.getName()), false)__                }_                metaData = builder.build()__            }__            repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__            snapshotCreated = true___            logger.info("snapshot [{}] started", snapshot.snapshot())__            if (snapshot.indices().isEmpty()) {_                _                userCreateSnapshotListener.onResponse()__                endSnapshot(snapshot)__                return__            }_            clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                SnapshotsInProgress.Entry endSnapshot__                String failure = null___                @Override_                public ClusterState execute(ClusterState currentState) {_                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                        if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                            entries.add(entry)__                            continue__                        }__                        if (entry.state() != State.ABORTED) {_                            _                            ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards = shards(currentState, entry.indices())__                            if (!partial) {_                                Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards, currentState.metaData())__                                Set<String> missing = indicesWithMissingShards.v1()__                                Set<String> closed = indicesWithMissingShards.v2()__                                if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                    endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                    entries.add(endSnapshot)___                                    final StringBuilder failureMessage = new StringBuilder()__                                    if (missing.isEmpty() == false) {_                                        failureMessage.append("Indices don't have primary shards ")__                                        failureMessage.append(missing)__                                    }_                                    if (closed.isEmpty() == false) {_                                        if (failureMessage.length() > 0) {_                                            failureMessage.append("_ ")__                                        }_                                        failureMessage.append("Indices are closed ")__                                        failureMessage.append(closed)__                                    }_                                    failure = failureMessage.toString()__                                    continue__                                }_                            }_                            SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                            entries.add(updatedSnapshot)__                            if (completed(shards.values())) {_                                endSnapshot = updatedSnapshot__                            }_                        } else {_                            assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                            failure = "snapshot was aborted during initialization"__                            endSnapshot = entry__                            entries.add(endSnapshot)__                        }_                    }_                    return ClusterState.builder(currentState)_                                       .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                                       .build()__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot", snapshot.snapshot().getSnapshotId()), e)__                    removeSnapshotFromClusterState(snapshot.snapshot(), null, e, new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                }__                @Override_                public void onNoLongerMaster(String source) {_                    _                    _                    logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                    userCreateSnapshotListener.onFailure(_                        new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                }__                @Override_                public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                    _                    _                    _                    _                    userCreateSnapshotListener.onResponse()___                    _                    _                    _                    _                    if (endSnapshot != null) {_                        endSnapshot(endSnapshot, failure)__                    }_                }_            })__        } catch (Exception e) {_            logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]", snapshot.snapshot().getSnapshotId()), e)__            removeSnapshotFromClusterState(snapshot.snapshot(), null, e, new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__        }_    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,create,snapshot,listener,user,create,snapshot,listener,boolean,snapshot,created,false,try,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,null,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,if,end,snapshot,null,end,snapshot,end,snapshot,failure,catch,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final CreateSnapshotListener userCreateSnapshotListener);1542826731;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final CreateSnapshotListener userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse()__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    SnapshotsInProgress.Entry endSnapshot__                    String failure___                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() != State.ABORTED) {_                                _                                ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards = shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards, currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                        entries.add(endSnapshot)___                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        failure = failureMessage.toString()__                                        continue__                                    }_                                }_                                SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                                entries.add(updatedSnapshot)__                                if (completed(shards.values())) {_                                    endSnapshot = updatedSnapshot__                                }_                            } else {_                                assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                                failure = "snapshot was aborted during initialization"__                                endSnapshot = entry__                                entries.add(endSnapshot)__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot", snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e, new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse()___                        _                        _                        _                        _                        if (endSnapshot != null) {_                            endSnapshot(endSnapshot, failure)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]", snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e, new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,create,snapshot,listener,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,if,end,snapshot,null,end,snapshot,end,snapshot,failure,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final CreateSnapshotListener userCreateSnapshotListener);1544783963;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final CreateSnapshotListener userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse()__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    SnapshotsInProgress.Entry endSnapshot__                    String failure___                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() != State.ABORTED) {_                                _                                ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards = shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards, currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                        entries.add(endSnapshot)___                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        failure = failureMessage.toString()__                                        continue__                                    }_                                }_                                SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                                entries.add(updatedSnapshot)__                                if (completed(shards.values())) {_                                    endSnapshot = updatedSnapshot__                                }_                            } else {_                                assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                                failure = "snapshot was aborted during initialization"__                                endSnapshot = entry__                                entries.add(endSnapshot)__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot", snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e, new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse()___                        _                        _                        _                        _                        if (endSnapshot != null) {_                            endSnapshot(endSnapshot, failure)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]", snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e, new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,create,snapshot,listener,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,if,end,snapshot,null,end,snapshot,end,snapshot,failure,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final CreateSnapshotListener userCreateSnapshotListener);1545215361;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final CreateSnapshotListener userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse()__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    SnapshotsInProgress.Entry endSnapshot__                    String failure___                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() != State.ABORTED) {_                                _                                ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards =_                                        shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                        entries.add(endSnapshot)___                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        failure = failureMessage.toString()__                                        continue__                                    }_                                }_                                SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                                entries.add(updatedSnapshot)__                                if (completed(shards.values())) {_                                    endSnapshot = updatedSnapshot__                                }_                            } else {_                                assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                                failure = "snapshot was aborted during initialization"__                                endSnapshot = entry__                                entries.add(endSnapshot)__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse()___                        _                        _                        _                        _                        if (endSnapshot != null) {_                            endSnapshot(endSnapshot, failure)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,create,snapshot,listener,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,if,end,snapshot,null,end,snapshot,end,snapshot,failure,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final CreateSnapshotListener userCreateSnapshotListener);1547023537;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final CreateSnapshotListener userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse()__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    SnapshotsInProgress.Entry endSnapshot__                    String failure___                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() != State.ABORTED) {_                                _                                ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards =_                                        shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                        entries.add(endSnapshot)___                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        failure = failureMessage.toString()__                                        continue__                                    }_                                }_                                SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                                entries.add(updatedSnapshot)__                                if (completed(shards.values())) {_                                    endSnapshot = updatedSnapshot__                                }_                            } else {_                                assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                                failure = "snapshot was aborted during initialization"__                                endSnapshot = entry__                                entries.add(endSnapshot)__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse()___                        _                        _                        _                        _                        if (endSnapshot != null) {_                            endSnapshot(endSnapshot, failure)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,create,snapshot,listener,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,if,end,snapshot,null,end,snapshot,end,snapshot,failure,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final CreateSnapshotListener userCreateSnapshotListener);1547625930;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final CreateSnapshotListener userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse()__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    SnapshotsInProgress.Entry endSnapshot__                    String failure___                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() != State.ABORTED) {_                                _                                ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards =_                                        shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                        entries.add(endSnapshot)___                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        failure = failureMessage.toString()__                                        continue__                                    }_                                }_                                SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                                entries.add(updatedSnapshot)__                                if (completed(shards.values())) {_                                    endSnapshot = updatedSnapshot__                                }_                            } else {_                                assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                                failure = "snapshot was aborted during initialization"__                                endSnapshot = entry__                                entries.add(endSnapshot)__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse()___                        _                        _                        _                        _                        if (endSnapshot != null) {_                            endSnapshot(endSnapshot, failure)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,create,snapshot,listener,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,if,end,snapshot,null,end,snapshot,end,snapshot,failure,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final CreateSnapshotListener userCreateSnapshotListener);1547633328;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final CreateSnapshotListener userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse(snapshot.snapshot())__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    SnapshotsInProgress.Entry endSnapshot__                    String failure___                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() != State.ABORTED) {_                                _                                ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards =_                                        shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                        entries.add(endSnapshot)___                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        failure = failureMessage.toString()__                                        continue__                                    }_                                }_                                SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                                entries.add(updatedSnapshot)__                                if (completed(shards.values())) {_                                    endSnapshot = updatedSnapshot__                                }_                            } else {_                                assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                                failure = "snapshot was aborted during initialization"__                                endSnapshot = entry__                                entries.add(endSnapshot)__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse(snapshot.snapshot())___                        _                        _                        _                        _                        if (endSnapshot != null) {_                            endSnapshot(endSnapshot, failure)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,create,snapshot,listener,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,snapshot,snapshot,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,snapshot,snapshot,if,end,snapshot,null,end,snapshot,end,snapshot,failure,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final CreateSnapshotListener userCreateSnapshotListener);1547760072;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final CreateSnapshotListener userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse(snapshot.snapshot())__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    SnapshotsInProgress.Entry endSnapshot__                    String failure___                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() != State.ABORTED) {_                                _                                ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards =_                                        shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                        entries.add(endSnapshot)___                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        failure = failureMessage.toString()__                                        continue__                                    }_                                }_                                SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                                entries.add(updatedSnapshot)__                                if (completed(shards.values())) {_                                    endSnapshot = updatedSnapshot__                                }_                            } else {_                                assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                                failure = "snapshot was aborted during initialization"__                                endSnapshot = entry__                                entries.add(endSnapshot)__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse(snapshot.snapshot())___                        _                        _                        _                        _                        if (endSnapshot != null) {_                            endSnapshot(endSnapshot, failure)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,create,snapshot,listener,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,snapshot,snapshot,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,snapshot,snapshot,if,end,snapshot,null,end,snapshot,end,snapshot,failure,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final CreateSnapshotListener userCreateSnapshotListener);1548072633;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final CreateSnapshotListener userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse(snapshot.snapshot())__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    SnapshotsInProgress.Entry endSnapshot__                    String failure___                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() != State.ABORTED) {_                                _                                ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards =_                                        shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                        entries.add(endSnapshot)___                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        failure = failureMessage.toString()__                                        continue__                                    }_                                }_                                SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                                entries.add(updatedSnapshot)__                                if (completed(shards.values())) {_                                    endSnapshot = updatedSnapshot__                                }_                            } else {_                                assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                                failure = "snapshot was aborted during initialization"__                                endSnapshot = entry__                                entries.add(endSnapshot)__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse(snapshot.snapshot())___                        _                        _                        _                        _                        if (endSnapshot != null) {_                            endSnapshot(endSnapshot, failure)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,create,snapshot,listener,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,snapshot,snapshot,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,snapshot,snapshot,if,end,snapshot,null,end,snapshot,end,snapshot,failure,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> SnapshotRequest -> public IndicesOptions indicesOptions();1524684173;Returns indices options__@return indices options;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,options,return,indices,options;public,indices,options,indices,options,return,indices,options
SnapshotsService -> SnapshotRequest -> public IndicesOptions indicesOptions();1524839522;Returns indices options__@return indices options;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,options,return,indices,options;public,indices,options,indices,options,return,indices,options
SnapshotsService -> SnapshotRequest -> public IndicesOptions indicesOptions();1542646292;Returns indices options__@return indices options;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,options,return,indices,options;public,indices,options,indices,options,return,indices,options
SnapshotsService -> SnapshotRequest -> public IndicesOptions indicesOptions();1542826731;Returns indices options__@return indices options;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,options,return,indices,options;public,indices,options,indices,options,return,indices,options
SnapshotsService -> SnapshotRequest -> public IndicesOptions indicesOptions();1544783963;Returns indices options__@return indices options;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,options,return,indices,options;public,indices,options,indices,options,return,indices,options
SnapshotsService -> SnapshotRequest -> public IndicesOptions indicesOptions();1545215361;Returns indices options__@return indices options;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,options,return,indices,options;public,indices,options,indices,options,return,indices,options
SnapshotsService -> SnapshotRequest -> public IndicesOptions indicesOptions();1547023537;Returns indices options__@return indices options;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,options,return,indices,options;public,indices,options,indices,options,return,indices,options
SnapshotsService -> SnapshotRequest -> public IndicesOptions indicesOptions();1547625930;Returns indices options__@return indices options;public IndicesOptions indicesOptions() {_            return indicesOptions__        };returns,indices,options,return,indices,options;public,indices,options,indices,options,return,indices,options
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1524684173;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1524839522;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1542646292;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1542826731;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1544783963;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1545215361;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1547023537;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1547625930;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1547633328;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1547760072;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1548072633;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1548321078;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1548996340;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1549050374;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1549381458;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1549407419;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices);1549637959;Check if any of the indices to be deleted are currently being snapshotted. Fail as deleting an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexDeletion(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot delete indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,deleted,are,currently,being,snapshotted,fail,as,deleting,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,deletion,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,delete,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public void createSnapshot(final CreateSnapshotRequest request, final CreateSnapshotListener listener);1547633328;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final CreateSnapshotRequest request, final CreateSnapshotListener listener) {_        final String repositoryName = request.repository()__        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot())__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask("create_snapshot [" + snapshotName + ']', new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(repositoryName, snapshotName, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    beginSnapshot(newState, newSnapshot, request.partial(), listener)__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,create,snapshot,request,request,final,create,snapshot,listener,listener,final,string,repository,name,request,repository,final,string,snapshot,name,index,name,expression,resolver,resolve,date,math,expression,request,snapshot,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,snapshot,name,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,repository,name,snapshot,name,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final CreateSnapshotRequest request, final CreateSnapshotListener listener);1547760072;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final CreateSnapshotRequest request, final CreateSnapshotListener listener) {_        final String repositoryName = request.repository()__        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot())__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask("create_snapshot [" + snapshotName + ']', new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(repositoryName, snapshotName, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    beginSnapshot(newState, newSnapshot, request.partial(), listener)__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,create,snapshot,request,request,final,create,snapshot,listener,listener,final,string,repository,name,request,repository,final,string,snapshot,name,index,name,expression,resolver,resolve,date,math,expression,request,snapshot,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,snapshot,name,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,repository,name,snapshot,name,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final CreateSnapshotRequest request, final CreateSnapshotListener listener);1548072633;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final CreateSnapshotRequest request, final CreateSnapshotListener listener) {_        final String repositoryName = request.repository()__        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot())__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask("create_snapshot [" + snapshotName + ']', new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(repositoryName, snapshotName, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    beginSnapshot(newState, newSnapshot, request.partial(), listener)__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,create,snapshot,request,request,final,create,snapshot,listener,listener,final,string,repository,name,request,repository,final,string,snapshot,name,index,name,expression,resolver,resolve,date,math,expression,request,snapshot,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,snapshot,name,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,repository,name,snapshot,name,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1524684173;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1524839522;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1542646292;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1542826731;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1544783963;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1545215361;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1547023537;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1547625930;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1547633328;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1547760072;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1548072633;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1548321078;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1548996340;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1549050374;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return Collections.unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,collections,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1549381458;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1549407419;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,unmodifiable,list,snapshot,list
SnapshotsService -> public List<SnapshotInfo> currentSnapshots(final String repositoryName);1549637959;Returns a list of currently running snapshots from repository sorted by snapshot creation date__@param repositoryName repository name_@return list of snapshots;public List<SnapshotInfo> currentSnapshots(final String repositoryName) {_        List<SnapshotInfo> snapshotList = new ArrayList<>()__        List<SnapshotsInProgress.Entry> entries = currentSnapshots(repositoryName, Collections.emptyList())__        for (SnapshotsInProgress.Entry entry : entries) {_            snapshotList.add(inProgressSnapshot(entry))__        }_        CollectionUtil.timSort(snapshotList)__        return unmodifiableList(snapshotList)__    };returns,a,list,of,currently,running,snapshots,from,repository,sorted,by,snapshot,creation,date,param,repository,name,repository,name,return,list,of,snapshots;public,list,snapshot,info,current,snapshots,final,string,repository,name,list,snapshot,info,snapshot,list,new,array,list,list,snapshots,in,progress,entry,entries,current,snapshots,repository,name,collections,empty,list,for,snapshots,in,progress,entry,entry,entries,snapshot,list,add,in,progress,snapshot,entry,collection,util,tim,sort,snapshot,list,return,unmodifiable,list,snapshot,list
SnapshotsService -> SnapshotRequest -> public String snapshotName();1524684173;Returns the snapshot name;public String snapshotName() {_            return snapshotName__        };returns,the,snapshot,name;public,string,snapshot,name,return,snapshot,name
SnapshotsService -> SnapshotRequest -> public String snapshotName();1524839522;Returns the snapshot name;public String snapshotName() {_            return snapshotName__        };returns,the,snapshot,name;public,string,snapshot,name,return,snapshot,name
SnapshotsService -> SnapshotRequest -> public String snapshotName();1542646292;Returns the snapshot name;public String snapshotName() {_            return snapshotName__        };returns,the,snapshot,name;public,string,snapshot,name,return,snapshot,name
SnapshotsService -> SnapshotRequest -> public String snapshotName();1542826731;Returns the snapshot name;public String snapshotName() {_            return snapshotName__        };returns,the,snapshot,name;public,string,snapshot,name,return,snapshot,name
SnapshotsService -> SnapshotRequest -> public String snapshotName();1544783963;Returns the snapshot name;public String snapshotName() {_            return snapshotName__        };returns,the,snapshot,name;public,string,snapshot,name,return,snapshot,name
SnapshotsService -> SnapshotRequest -> public String snapshotName();1545215361;Returns the snapshot name;public String snapshotName() {_            return snapshotName__        };returns,the,snapshot,name;public,string,snapshot,name,return,snapshot,name
SnapshotsService -> SnapshotRequest -> public String snapshotName();1547023537;Returns the snapshot name;public String snapshotName() {_            return snapshotName__        };returns,the,snapshot,name;public,string,snapshot,name,return,snapshot,name
SnapshotsService -> SnapshotRequest -> public String snapshotName();1547625930;Returns the snapshot name;public String snapshotName() {_            return snapshotName__        };returns,the,snapshot,name;public,string,snapshot,name,return,snapshot,name
SnapshotsService -> SnapshotRequest -> public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause);1524684173;Constructs new snapshot creation request__@param repositoryName  repository name_@param snapshotName    snapshot name_@param cause           cause for snapshot operation;public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.cause = Objects.requireNonNull(cause)__        };constructs,new,snapshot,creation,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,cause,cause,for,snapshot,operation;public,snapshot,request,final,string,repository,name,final,string,snapshot,name,final,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,cause,objects,require,non,null,cause
SnapshotsService -> SnapshotRequest -> public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause);1524839522;Constructs new snapshot creation request__@param repositoryName  repository name_@param snapshotName    snapshot name_@param cause           cause for snapshot operation;public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.cause = Objects.requireNonNull(cause)__        };constructs,new,snapshot,creation,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,cause,cause,for,snapshot,operation;public,snapshot,request,final,string,repository,name,final,string,snapshot,name,final,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,cause,objects,require,non,null,cause
SnapshotsService -> SnapshotRequest -> public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause);1542646292;Constructs new snapshot creation request__@param repositoryName  repository name_@param snapshotName    snapshot name_@param cause           cause for snapshot operation;public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.cause = Objects.requireNonNull(cause)__        };constructs,new,snapshot,creation,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,cause,cause,for,snapshot,operation;public,snapshot,request,final,string,repository,name,final,string,snapshot,name,final,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,cause,objects,require,non,null,cause
SnapshotsService -> SnapshotRequest -> public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause);1542826731;Constructs new snapshot creation request__@param repositoryName  repository name_@param snapshotName    snapshot name_@param cause           cause for snapshot operation;public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.cause = Objects.requireNonNull(cause)__        };constructs,new,snapshot,creation,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,cause,cause,for,snapshot,operation;public,snapshot,request,final,string,repository,name,final,string,snapshot,name,final,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,cause,objects,require,non,null,cause
SnapshotsService -> SnapshotRequest -> public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause);1544783963;Constructs new snapshot creation request__@param repositoryName  repository name_@param snapshotName    snapshot name_@param cause           cause for snapshot operation;public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.cause = Objects.requireNonNull(cause)__        };constructs,new,snapshot,creation,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,cause,cause,for,snapshot,operation;public,snapshot,request,final,string,repository,name,final,string,snapshot,name,final,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,cause,objects,require,non,null,cause
SnapshotsService -> SnapshotRequest -> public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause);1545215361;Constructs new snapshot creation request__@param repositoryName  repository name_@param snapshotName    snapshot name_@param cause           cause for snapshot operation;public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.cause = Objects.requireNonNull(cause)__        };constructs,new,snapshot,creation,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,cause,cause,for,snapshot,operation;public,snapshot,request,final,string,repository,name,final,string,snapshot,name,final,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,cause,objects,require,non,null,cause
SnapshotsService -> SnapshotRequest -> public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause);1547023537;Constructs new snapshot creation request__@param repositoryName  repository name_@param snapshotName    snapshot name_@param cause           cause for snapshot operation;public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.cause = Objects.requireNonNull(cause)__        };constructs,new,snapshot,creation,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,cause,cause,for,snapshot,operation;public,snapshot,request,final,string,repository,name,final,string,snapshot,name,final,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,cause,objects,require,non,null,cause
SnapshotsService -> SnapshotRequest -> public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause);1547625930;Constructs new snapshot creation request__@param repositoryName  repository name_@param snapshotName    snapshot name_@param cause           cause for snapshot operation;public SnapshotRequest(final String repositoryName, final String snapshotName, final String cause) {_            this.repositoryName = Objects.requireNonNull(repositoryName)__            this.snapshotName = Objects.requireNonNull(snapshotName)__            this.cause = Objects.requireNonNull(cause)__        };constructs,new,snapshot,creation,request,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,cause,cause,for,snapshot,operation;public,snapshot,request,final,string,repository,name,final,string,snapshot,name,final,string,cause,this,repository,name,objects,require,non,null,repository,name,this,snapshot,name,objects,require,non,null,snapshot,name,this,cause,objects,require,non,null,cause
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1524684173;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0), new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            _                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING, "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1524839522;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0), new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            _                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING, "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1542646292;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0), new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            _                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING, "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1542826731;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0), new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            _                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING, "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1544783963;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0), new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            _                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING, "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1545215361;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            _                            _                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1547023537;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1547625930;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1547633328;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1547760072;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1548072633;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1548321078;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1548996340;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices);1549050374;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState, List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> SnapshotRequest -> public Settings settings();1524684173;Returns repository-specific settings for the snapshot operation__@return repository-specific settings;public Settings settings() {_            return settings__        };returns,repository,specific,settings,for,the,snapshot,operation,return,repository,specific,settings;public,settings,settings,return,settings
SnapshotsService -> SnapshotRequest -> public Settings settings();1524839522;Returns repository-specific settings for the snapshot operation__@return repository-specific settings;public Settings settings() {_            return settings__        };returns,repository,specific,settings,for,the,snapshot,operation,return,repository,specific,settings;public,settings,settings,return,settings
SnapshotsService -> SnapshotRequest -> public Settings settings();1542646292;Returns repository-specific settings for the snapshot operation__@return repository-specific settings;public Settings settings() {_            return settings__        };returns,repository,specific,settings,for,the,snapshot,operation,return,repository,specific,settings;public,settings,settings,return,settings
SnapshotsService -> SnapshotRequest -> public Settings settings();1542826731;Returns repository-specific settings for the snapshot operation__@return repository-specific settings;public Settings settings() {_            return settings__        };returns,repository,specific,settings,for,the,snapshot,operation,return,repository,specific,settings;public,settings,settings,return,settings
SnapshotsService -> SnapshotRequest -> public Settings settings();1544783963;Returns repository-specific settings for the snapshot operation__@return repository-specific settings;public Settings settings() {_            return settings__        };returns,repository,specific,settings,for,the,snapshot,operation,return,repository,specific,settings;public,settings,settings,return,settings
SnapshotsService -> SnapshotRequest -> public Settings settings();1545215361;Returns repository-specific settings for the snapshot operation__@return repository-specific settings;public Settings settings() {_            return settings__        };returns,repository,specific,settings,for,the,snapshot,operation,return,repository,specific,settings;public,settings,settings,return,settings
SnapshotsService -> SnapshotRequest -> public Settings settings();1547023537;Returns repository-specific settings for the snapshot operation__@return repository-specific settings;public Settings settings() {_            return settings__        };returns,repository,specific,settings,for,the,snapshot,operation,return,repository,specific,settings;public,settings,settings,return,settings
SnapshotsService -> SnapshotRequest -> public Settings settings();1547625930;Returns repository-specific settings for the snapshot operation__@return repository-specific settings;public Settings settings() {_            return settings__        };returns,repository,specific,settings,for,the,snapshot,operation,return,repository,specific,settings;public,settings,settings,return,settings
SnapshotsService -> private void validate(SnapshotRequest request, ClusterState state);1524684173;Validates snapshot request__@param request snapshot request_@param state   current cluster state;private void validate(SnapshotRequest request, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        final String repository = request.repositoryName__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repository) == null) {_            throw new RepositoryMissingException(repository)__        }_        validate(repository, request.snapshotName)__    };validates,snapshot,request,param,request,snapshot,request,param,state,current,cluster,state;private,void,validate,snapshot,request,request,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,final,string,repository,request,repository,name,if,repositories,meta,data,null,repositories,meta,data,repository,repository,null,throw,new,repository,missing,exception,repository,validate,repository,request,snapshot,name
SnapshotsService -> private void validate(SnapshotRequest request, ClusterState state);1524839522;Validates snapshot request__@param request snapshot request_@param state   current cluster state;private void validate(SnapshotRequest request, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        final String repository = request.repositoryName__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repository) == null) {_            throw new RepositoryMissingException(repository)__        }_        validate(repository, request.snapshotName)__    };validates,snapshot,request,param,request,snapshot,request,param,state,current,cluster,state;private,void,validate,snapshot,request,request,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,final,string,repository,request,repository,name,if,repositories,meta,data,null,repositories,meta,data,repository,repository,null,throw,new,repository,missing,exception,repository,validate,repository,request,snapshot,name
SnapshotsService -> private void validate(SnapshotRequest request, ClusterState state);1542646292;Validates snapshot request__@param request snapshot request_@param state   current cluster state;private void validate(SnapshotRequest request, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        final String repository = request.repositoryName__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repository) == null) {_            throw new RepositoryMissingException(repository)__        }_        validate(repository, request.snapshotName)__    };validates,snapshot,request,param,request,snapshot,request,param,state,current,cluster,state;private,void,validate,snapshot,request,request,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,final,string,repository,request,repository,name,if,repositories,meta,data,null,repositories,meta,data,repository,repository,null,throw,new,repository,missing,exception,repository,validate,repository,request,snapshot,name
SnapshotsService -> private void validate(SnapshotRequest request, ClusterState state);1542826731;Validates snapshot request__@param request snapshot request_@param state   current cluster state;private void validate(SnapshotRequest request, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        final String repository = request.repositoryName__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repository) == null) {_            throw new RepositoryMissingException(repository)__        }_        validate(repository, request.snapshotName)__    };validates,snapshot,request,param,request,snapshot,request,param,state,current,cluster,state;private,void,validate,snapshot,request,request,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,final,string,repository,request,repository,name,if,repositories,meta,data,null,repositories,meta,data,repository,repository,null,throw,new,repository,missing,exception,repository,validate,repository,request,snapshot,name
SnapshotsService -> private void validate(SnapshotRequest request, ClusterState state);1544783963;Validates snapshot request__@param request snapshot request_@param state   current cluster state;private void validate(SnapshotRequest request, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        final String repository = request.repositoryName__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repository) == null) {_            throw new RepositoryMissingException(repository)__        }_        validate(repository, request.snapshotName)__    };validates,snapshot,request,param,request,snapshot,request,param,state,current,cluster,state;private,void,validate,snapshot,request,request,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,final,string,repository,request,repository,name,if,repositories,meta,data,null,repositories,meta,data,repository,repository,null,throw,new,repository,missing,exception,repository,validate,repository,request,snapshot,name
SnapshotsService -> private void validate(SnapshotRequest request, ClusterState state);1545215361;Validates snapshot request__@param request snapshot request_@param state   current cluster state;private void validate(SnapshotRequest request, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        final String repository = request.repositoryName__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repository) == null) {_            throw new RepositoryMissingException(repository)__        }_        validate(repository, request.snapshotName)__    };validates,snapshot,request,param,request,snapshot,request,param,state,current,cluster,state;private,void,validate,snapshot,request,request,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,final,string,repository,request,repository,name,if,repositories,meta,data,null,repositories,meta,data,repository,repository,null,throw,new,repository,missing,exception,repository,validate,repository,request,snapshot,name
SnapshotsService -> private void validate(SnapshotRequest request, ClusterState state);1547023537;Validates snapshot request__@param request snapshot request_@param state   current cluster state;private void validate(SnapshotRequest request, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        final String repository = request.repositoryName__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repository) == null) {_            throw new RepositoryMissingException(repository)__        }_        validate(repository, request.snapshotName)__    };validates,snapshot,request,param,request,snapshot,request,param,state,current,cluster,state;private,void,validate,snapshot,request,request,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,final,string,repository,request,repository,name,if,repositories,meta,data,null,repositories,meta,data,repository,repository,null,throw,new,repository,missing,exception,repository,validate,repository,request,snapshot,name
SnapshotsService -> private void validate(SnapshotRequest request, ClusterState state);1547625930;Validates snapshot request__@param request snapshot request_@param state   current cluster state;private void validate(SnapshotRequest request, ClusterState state) {_        RepositoriesMetaData repositoriesMetaData = state.getMetaData().custom(RepositoriesMetaData.TYPE)__        final String repository = request.repositoryName__        if (repositoriesMetaData == null || repositoriesMetaData.repository(repository) == null) {_            throw new RepositoryMissingException(repository)__        }_        validate(repository, request.snapshotName)__    };validates,snapshot,request,param,request,snapshot,request,param,state,current,cluster,state;private,void,validate,snapshot,request,request,cluster,state,state,repositories,meta,data,repositories,meta,data,state,get,meta,data,custom,repositories,meta,data,type,final,string,repository,request,repository,name,if,repositories,meta,data,null,repositories,meta,data,repository,repository,null,throw,new,repository,missing,exception,repository,validate,repository,request,snapshot,name
SnapshotsService -> SnapshotRequest -> public boolean includeGlobalState();1524684173;Returns true if global state should be stored as part of the snapshot__@return true if global state should be stored as part of the snapshot;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,true,if,global,state,should,be,stored,as,part,of,the,snapshot;public,boolean,include,global,state,return,include,global,state
SnapshotsService -> SnapshotRequest -> public boolean includeGlobalState();1524839522;Returns true if global state should be stored as part of the snapshot__@return true if global state should be stored as part of the snapshot;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,true,if,global,state,should,be,stored,as,part,of,the,snapshot;public,boolean,include,global,state,return,include,global,state
SnapshotsService -> SnapshotRequest -> public boolean includeGlobalState();1542646292;Returns true if global state should be stored as part of the snapshot__@return true if global state should be stored as part of the snapshot;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,true,if,global,state,should,be,stored,as,part,of,the,snapshot;public,boolean,include,global,state,return,include,global,state
SnapshotsService -> SnapshotRequest -> public boolean includeGlobalState();1542826731;Returns true if global state should be stored as part of the snapshot__@return true if global state should be stored as part of the snapshot;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,true,if,global,state,should,be,stored,as,part,of,the,snapshot;public,boolean,include,global,state,return,include,global,state
SnapshotsService -> SnapshotRequest -> public boolean includeGlobalState();1544783963;Returns true if global state should be stored as part of the snapshot__@return true if global state should be stored as part of the snapshot;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,true,if,global,state,should,be,stored,as,part,of,the,snapshot;public,boolean,include,global,state,return,include,global,state
SnapshotsService -> SnapshotRequest -> public boolean includeGlobalState();1545215361;Returns true if global state should be stored as part of the snapshot__@return true if global state should be stored as part of the snapshot;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,true,if,global,state,should,be,stored,as,part,of,the,snapshot;public,boolean,include,global,state,return,include,global,state
SnapshotsService -> SnapshotRequest -> public boolean includeGlobalState();1547023537;Returns true if global state should be stored as part of the snapshot__@return true if global state should be stored as part of the snapshot;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,true,if,global,state,should,be,stored,as,part,of,the,snapshot;public,boolean,include,global,state,return,include,global,state
SnapshotsService -> SnapshotRequest -> public boolean includeGlobalState();1547625930;Returns true if global state should be stored as part of the snapshot__@return true if global state should be stored as part of the snapshot;public boolean includeGlobalState() {_            return includeGlobalState__        };returns,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,true,if,global,state,should,be,stored,as,part,of,the,snapshot;public,boolean,include,global,state,return,include,global,state
SnapshotsService -> CreateSnapshotListener -> void onResponse()_;1524684173;Called when snapshot has successfully started;void onResponse()_;called,when,snapshot,has,successfully,started;void,on,response
SnapshotsService -> CreateSnapshotListener -> void onResponse()_;1524839522;Called when snapshot has successfully started;void onResponse()_;called,when,snapshot,has,successfully,started;void,on,response
SnapshotsService -> CreateSnapshotListener -> void onResponse()_;1542646292;Called when snapshot has successfully started;void onResponse()_;called,when,snapshot,has,successfully,started;void,on,response
SnapshotsService -> CreateSnapshotListener -> void onResponse()_;1542826731;Called when snapshot has successfully started;void onResponse()_;called,when,snapshot,has,successfully,started;void,on,response
SnapshotsService -> CreateSnapshotListener -> void onResponse()_;1544783963;Called when snapshot has successfully started;void onResponse()_;called,when,snapshot,has,successfully,started;void,on,response
SnapshotsService -> CreateSnapshotListener -> void onResponse()_;1545215361;Called when snapshot has successfully started;void onResponse()_;called,when,snapshot,has,successfully,started;void,on,response
SnapshotsService -> CreateSnapshotListener -> void onResponse()_;1547023537;Called when snapshot has successfully started;void onResponse()_;called,when,snapshot,has,successfully,started;void,on,response
SnapshotsService -> CreateSnapshotListener -> void onResponse()_;1547625930;Called when snapshot has successfully started;void onResponse()_;called,when,snapshot,has,successfully,started;void,on,response
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1524684173;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1524839522;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1542646292;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1542826731;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1544783963;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1545215361;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1547023537;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1547625930;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1547633328;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1547760072;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1548072633;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1548321078;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1548996340;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> void endSnapshot(final SnapshotsInProgress.Entry entry);1549050374;Finalizes the shard in repository and then removes it from cluster state_<p>_This is non-blocking method that runs on a thread from SNAPSHOT thread pool__@param entry snapshot;void endSnapshot(final SnapshotsInProgress.Entry entry) {_        endSnapshot(entry, null)__    };finalizes,the,shard,in,repository,and,then,removes,it,from,cluster,state,p,this,is,non,blocking,method,that,runs,on,a,thread,from,snapshot,thread,pool,param,entry,snapshot;void,end,snapshot,final,snapshots,in,progress,entry,entry,end,snapshot,entry,null
SnapshotsService -> public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener);1524684173;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener) {_        final String repositoryName = request.repositoryName__        final String snapshotName = request.snapshotName__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(request, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState, request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() ->_                        beginSnapshot(newState, newSnapshot, request.partial(), listener)_                    )__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,snapshot,request,request,final,create,snapshot,listener,listener,final,string,repository,name,request,repository,name,final,string,snapshot,name,request,snapshot,name,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,request,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,thread,pool,executor,thread,pool,names,snapshot,execute,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener);1524839522;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener) {_        final String repositoryName = request.repositoryName__        final String snapshotName = request.snapshotName__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(request, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState, request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() ->_                        beginSnapshot(newState, newSnapshot, request.partial(), listener)_                    )__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,snapshot,request,request,final,create,snapshot,listener,listener,final,string,repository,name,request,repository,name,final,string,snapshot,name,request,snapshot,name,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,request,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,thread,pool,executor,thread,pool,names,snapshot,execute,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener);1542646292;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener) {_        final String repositoryName = request.repositoryName__        final String snapshotName = request.snapshotName__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(request, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState, request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() ->_                        beginSnapshot(newState, newSnapshot, request.partial(), listener)_                    )__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,snapshot,request,request,final,create,snapshot,listener,listener,final,string,repository,name,request,repository,name,final,string,snapshot,name,request,snapshot,name,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,request,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,thread,pool,executor,thread,pool,names,snapshot,execute,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener);1542826731;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener) {_        final String repositoryName = request.repositoryName__        final String snapshotName = request.snapshotName__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(request, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState, request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    beginSnapshot(newState, newSnapshot, request.partial(), listener)__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,snapshot,request,request,final,create,snapshot,listener,listener,final,string,repository,name,request,repository,name,final,string,snapshot,name,request,snapshot,name,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,request,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener);1544783963;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener) {_        final String repositoryName = request.repositoryName__        final String snapshotName = request.snapshotName__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(request, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState, request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    beginSnapshot(newState, newSnapshot, request.partial(), listener)__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,snapshot,request,request,final,create,snapshot,listener,listener,final,string,repository,name,request,repository,name,final,string,snapshot,name,request,snapshot,name,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,request,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener);1545215361;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener) {_        final String repositoryName = request.repositoryName__        final String snapshotName = request.snapshotName__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(request, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    beginSnapshot(newState, newSnapshot, request.partial(), listener)__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,snapshot,request,request,final,create,snapshot,listener,listener,final,string,repository,name,request,repository,name,final,string,snapshot,name,request,snapshot,name,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,request,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener);1547023537;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener) {_        final String repositoryName = request.repositoryName__        final String snapshotName = request.snapshotName__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(request, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    beginSnapshot(newState, newSnapshot, request.partial(), listener)__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,snapshot,request,request,final,create,snapshot,listener,listener,final,string,repository,name,request,repository,name,final,string,snapshot,name,request,snapshot,name,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,request,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener);1547625930;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final SnapshotRequest request, final CreateSnapshotListener listener) {_        final String repositoryName = request.repositoryName__        final String snapshotName = request.snapshotName__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask(request.cause(), new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(request, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    beginSnapshot(newState, newSnapshot, request.partial(), listener)__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,snapshot,request,request,final,create,snapshot,listener,listener,final,string,repository,name,request,repository,name,final,string,snapshot,name,request,snapshot,name,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,request,cause,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,request,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final ActionListener<Snapshot> userCreateSnapshotListener);1548321078;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final ActionListener<Snapshot> userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse(snapshot.snapshot())__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    SnapshotsInProgress.Entry endSnapshot__                    String failure___                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() != State.ABORTED) {_                                _                                ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards =_                                        shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                        entries.add(endSnapshot)___                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        failure = failureMessage.toString()__                                        continue__                                    }_                                }_                                SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                                entries.add(updatedSnapshot)__                                if (completed(shards.values())) {_                                    endSnapshot = updatedSnapshot__                                }_                            } else {_                                assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                                failure = "snapshot was aborted during initialization"__                                endSnapshot = entry__                                entries.add(endSnapshot)__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse(snapshot.snapshot())___                        _                        _                        _                        _                        if (endSnapshot != null) {_                            endSnapshot(endSnapshot, failure)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,action,listener,snapshot,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,snapshot,snapshot,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,snapshot,snapshot,if,end,snapshot,null,end,snapshot,end,snapshot,failure,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final ActionListener<Snapshot> userCreateSnapshotListener);1548996340;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final ActionListener<Snapshot> userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse(snapshot.snapshot())__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    SnapshotsInProgress.Entry endSnapshot__                    String failure___                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() != State.ABORTED) {_                                _                                ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards =_                                        shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                        entries.add(endSnapshot)___                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        failure = failureMessage.toString()__                                        continue__                                    }_                                }_                                SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                                entries.add(updatedSnapshot)__                                if (completed(shards.values())) {_                                    endSnapshot = updatedSnapshot__                                }_                            } else {_                                assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                                failure = "snapshot was aborted during initialization"__                                endSnapshot = entry__                                entries.add(endSnapshot)__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse(snapshot.snapshot())___                        _                        _                        _                        _                        if (endSnapshot != null) {_                            endSnapshot(endSnapshot, failure)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,action,listener,snapshot,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,snapshot,snapshot,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,snapshot,snapshot,if,end,snapshot,null,end,snapshot,end,snapshot,failure,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final ActionListener<Snapshot> userCreateSnapshotListener);1549050374;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final ActionListener<Snapshot> userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse(snapshot.snapshot())__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    SnapshotsInProgress.Entry endSnapshot__                    String failure___                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() != State.ABORTED) {_                                _                                ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards =_                                        shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        endSnapshot = new SnapshotsInProgress.Entry(entry, State.FAILED, shards)__                                        entries.add(endSnapshot)___                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        failure = failureMessage.toString()__                                        continue__                                    }_                                }_                                SnapshotsInProgress.Entry updatedSnapshot = new SnapshotsInProgress.Entry(entry, State.STARTED, shards)__                                entries.add(updatedSnapshot)__                                if (completed(shards.values())) {_                                    endSnapshot = updatedSnapshot__                                }_                            } else {_                                assert entry.state() == State.ABORTED : "expecting snapshot to be aborted during initialization"__                                failure = "snapshot was aborted during initialization"__                                endSnapshot = entry__                                entries.add(endSnapshot)__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(Collections.unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse(snapshot.snapshot())___                        _                        _                        _                        _                        if (endSnapshot != null) {_                            endSnapshot(endSnapshot, failure)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,action,listener,snapshot,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,snapshot,snapshot,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,snapshots,in,progress,entry,end,snapshot,string,failure,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,end,snapshot,new,snapshots,in,progress,entry,entry,state,failed,shards,entries,add,end,snapshot,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,failure,failure,message,to,string,continue,snapshots,in,progress,entry,updated,snapshot,new,snapshots,in,progress,entry,entry,state,started,shards,entries,add,updated,snapshot,if,completed,shards,values,end,snapshot,updated,snapshot,else,assert,entry,state,state,aborted,expecting,snapshot,to,be,aborted,during,initialization,failure,snapshot,was,aborted,during,initialization,end,snapshot,entry,entries,add,end,snapshot,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,collections,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,snapshot,snapshot,if,end,snapshot,null,end,snapshot,end,snapshot,failure,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final ActionListener<Snapshot> userCreateSnapshotListener);1549381458;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final ActionListener<Snapshot> userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                assert initializingSnapshots.contains(snapshot.snapshot())__                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse(snapshot.snapshot())__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() == State.ABORTED) {_                                entries.add(entry)__                            } else {_                                _                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards =_                                    shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        entries.add(new SnapshotsInProgress.Entry(entry, State.FAILED, shards, failureMessage.toString()))__                                        continue__                                    }_                                }_                                entries.add(new SnapshotsInProgress.Entry(entry, State.STARTED, shards))__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse(snapshot.snapshot())__                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,action,listener,snapshot,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,assert,initializing,snapshots,contains,snapshot,snapshot,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,snapshot,snapshot,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,entries,add,entry,else,immutable,open,map,shard,id,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,entries,add,new,snapshots,in,progress,entry,entry,state,failed,shards,failure,message,to,string,continue,entries,add,new,snapshots,in,progress,entry,entry,state,started,shards,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final ActionListener<Snapshot> userCreateSnapshotListener);1549407419;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final ActionListener<Snapshot> userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            @Override_            protected void doRun() {_                assert initializingSnapshots.contains(snapshot.snapshot())__                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse(snapshot.snapshot())__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() == State.ABORTED) {_                                entries.add(entry)__                            } else {_                                _                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards =_                                    shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        entries.add(new SnapshotsInProgress.Entry(entry, State.FAILED, shards, failureMessage.toString()))__                                        continue__                                    }_                                }_                                entries.add(new SnapshotsInProgress.Entry(entry, State.STARTED, shards))__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse(snapshot.snapshot())__                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,action,listener,snapshot,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,override,protected,void,do,run,assert,initializing,snapshots,contains,snapshot,snapshot,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,snapshot,snapshot,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,entries,add,entry,else,immutable,open,map,shard,id,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,entries,add,new,snapshots,in,progress,entry,entry,state,failed,shards,failure,message,to,string,continue,entries,add,new,snapshots,in,progress,entry,entry,state,started,shards,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void beginSnapshot(final ClusterState clusterState,                                final SnapshotsInProgress.Entry snapshot,                                final boolean partial,                                final ActionListener<Snapshot> userCreateSnapshotListener);1549637959;Starts snapshot._<p>_Creates snapshot in repository and updates snapshot metadata record with list of shards that needs to be processed.__@param clusterState               cluster state_@param snapshot                   snapshot meta data_@param partial                    allow partial snapshots_@param userCreateSnapshotListener listener;private void beginSnapshot(final ClusterState clusterState,_                               final SnapshotsInProgress.Entry snapshot,_                               final boolean partial,_                               final ActionListener<Snapshot> userCreateSnapshotListener) {_        threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(new AbstractRunnable() {__            boolean snapshotCreated___            boolean hadAbortedInitializations___            @Override_            protected void doRun() {_                assert initializingSnapshots.contains(snapshot.snapshot())__                Repository repository = repositoriesService.repository(snapshot.snapshot().getRepository())___                MetaData metaData = clusterState.metaData()__                if (!snapshot.includeGlobalState()) {_                    _                    MetaData.Builder builder = MetaData.builder()__                    for (IndexId index : snapshot.indices()) {_                        builder.put(metaData.index(index.getName()), false)__                    }_                    metaData = builder.build()__                }__                repository.initializeSnapshot(snapshot.snapshot().getSnapshotId(), snapshot.indices(), metaData)__                snapshotCreated = true___                logger.info("snapshot [{}] started", snapshot.snapshot())__                if (snapshot.indices().isEmpty()) {_                    _                    userCreateSnapshotListener.onResponse(snapshot.snapshot())__                    endSnapshot(snapshot)__                    return__                }_                clusterService.submitStateUpdateTask("update_snapshot [" + snapshot.snapshot() + "]", new ClusterStateUpdateTask() {__                    @Override_                    public ClusterState execute(ClusterState currentState) {_                        SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                        List<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                        for (SnapshotsInProgress.Entry entry : snapshots.entries()) {_                            if (entry.snapshot().equals(snapshot.snapshot()) == false) {_                                entries.add(entry)__                                continue__                            }__                            if (entry.state() == State.ABORTED) {_                                entries.add(entry)__                                assert entry.shards().isEmpty()__                                hadAbortedInitializations = true__                            } else {_                                _                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards =_                                    shards(currentState, entry.indices())__                                if (!partial) {_                                    Tuple<Set<String>, Set<String>> indicesWithMissingShards = indicesWithMissingShards(shards,_                                        currentState.metaData())__                                    Set<String> missing = indicesWithMissingShards.v1()__                                    Set<String> closed = indicesWithMissingShards.v2()__                                    if (missing.isEmpty() == false || closed.isEmpty() == false) {_                                        final StringBuilder failureMessage = new StringBuilder()__                                        if (missing.isEmpty() == false) {_                                            failureMessage.append("Indices don't have primary shards ")__                                            failureMessage.append(missing)__                                        }_                                        if (closed.isEmpty() == false) {_                                            if (failureMessage.length() > 0) {_                                                failureMessage.append("_ ")__                                            }_                                            failureMessage.append("Indices are closed ")__                                            failureMessage.append(closed)__                                        }_                                        entries.add(new SnapshotsInProgress.Entry(entry, State.FAILED, shards, failureMessage.toString()))__                                        continue__                                    }_                                }_                                entries.add(new SnapshotsInProgress.Entry(entry, State.STARTED, shards))__                            }_                        }_                        return ClusterState.builder(currentState)_                            .putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(unmodifiableList(entries)))_                            .build()__                    }__                    @Override_                    public void onFailure(String source, Exception e) {_                        logger.warn(() -> new ParameterizedMessage("[{}] failed to create snapshot",_                            snapshot.snapshot().getSnapshotId()), e)__                        removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                            new CleanupAfterErrorListener(snapshot, true, userCreateSnapshotListener, e))__                    }__                    @Override_                    public void onNoLongerMaster(String source) {_                        _                        _                        logger.warn("[{}] failed to create snapshot - no longer a master", snapshot.snapshot().getSnapshotId())__                        userCreateSnapshotListener.onFailure(_                            new SnapshotException(snapshot.snapshot(), "master changed during snapshot initialization"))__                    }__                    @Override_                    public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                        _                        _                        _                        _                        userCreateSnapshotListener.onResponse(snapshot.snapshot())___                        if (hadAbortedInitializations) {_                            final SnapshotsInProgress snapshotsInProgress = newState.custom(SnapshotsInProgress.TYPE)__                            assert snapshotsInProgress != null__                            final SnapshotsInProgress.Entry entry = snapshotsInProgress.snapshot(snapshot.snapshot())__                            assert entry != null__                            endSnapshot(entry)__                        }_                    }_                })__            }__            @Override_            public void onFailure(Exception e) {_                logger.warn(() -> new ParameterizedMessage("failed to create snapshot [{}]",_                    snapshot.snapshot().getSnapshotId()), e)__                removeSnapshotFromClusterState(snapshot.snapshot(), null, e,_                    new CleanupAfterErrorListener(snapshot, snapshotCreated, userCreateSnapshotListener, e))__            }_        })__    };starts,snapshot,p,creates,snapshot,in,repository,and,updates,snapshot,metadata,record,with,list,of,shards,that,needs,to,be,processed,param,cluster,state,cluster,state,param,snapshot,snapshot,meta,data,param,partial,allow,partial,snapshots,param,user,create,snapshot,listener,listener;private,void,begin,snapshot,final,cluster,state,cluster,state,final,snapshots,in,progress,entry,snapshot,final,boolean,partial,final,action,listener,snapshot,user,create,snapshot,listener,thread,pool,executor,thread,pool,names,snapshot,execute,new,abstract,runnable,boolean,snapshot,created,boolean,had,aborted,initializations,override,protected,void,do,run,assert,initializing,snapshots,contains,snapshot,snapshot,repository,repository,repositories,service,repository,snapshot,snapshot,get,repository,meta,data,meta,data,cluster,state,meta,data,if,snapshot,include,global,state,meta,data,builder,builder,meta,data,builder,for,index,id,index,snapshot,indices,builder,put,meta,data,index,index,get,name,false,meta,data,builder,build,repository,initialize,snapshot,snapshot,snapshot,get,snapshot,id,snapshot,indices,meta,data,snapshot,created,true,logger,info,snapshot,started,snapshot,snapshot,if,snapshot,indices,is,empty,user,create,snapshot,listener,on,response,snapshot,snapshot,end,snapshot,snapshot,return,cluster,service,submit,state,update,task,snapshot,snapshot,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,list,snapshots,in,progress,entry,entries,new,array,list,for,snapshots,in,progress,entry,entry,snapshots,entries,if,entry,snapshot,equals,snapshot,snapshot,false,entries,add,entry,continue,if,entry,state,state,aborted,entries,add,entry,assert,entry,shards,is,empty,had,aborted,initializations,true,else,immutable,open,map,shard,id,shard,snapshot,status,shards,shards,current,state,entry,indices,if,partial,tuple,set,string,set,string,indices,with,missing,shards,indices,with,missing,shards,shards,current,state,meta,data,set,string,missing,indices,with,missing,shards,v1,set,string,closed,indices,with,missing,shards,v2,if,missing,is,empty,false,closed,is,empty,false,final,string,builder,failure,message,new,string,builder,if,missing,is,empty,false,failure,message,append,indices,don,t,have,primary,shards,failure,message,append,missing,if,closed,is,empty,false,if,failure,message,length,0,failure,message,append,failure,message,append,indices,are,closed,failure,message,append,closed,entries,add,new,snapshots,in,progress,entry,entry,state,failed,shards,failure,message,to,string,continue,entries,add,new,snapshots,in,progress,entry,entry,state,started,shards,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,unmodifiable,list,entries,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,true,user,create,snapshot,listener,e,override,public,void,on,no,longer,master,string,source,logger,warn,failed,to,create,snapshot,no,longer,a,master,snapshot,snapshot,get,snapshot,id,user,create,snapshot,listener,on,failure,new,snapshot,exception,snapshot,snapshot,master,changed,during,snapshot,initialization,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,user,create,snapshot,listener,on,response,snapshot,snapshot,if,had,aborted,initializations,final,snapshots,in,progress,snapshots,in,progress,new,state,custom,snapshots,in,progress,type,assert,snapshots,in,progress,null,final,snapshots,in,progress,entry,entry,snapshots,in,progress,snapshot,snapshot,snapshot,assert,entry,null,end,snapshot,entry,override,public,void,on,failure,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,snapshot,snapshot,get,snapshot,id,e,remove,snapshot,from,cluster,state,snapshot,snapshot,null,e,new,cleanup,after,error,listener,snapshot,snapshot,created,user,create,snapshot,listener,e
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1524684173;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1524839522;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1542646292;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1542826731;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1544783963;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1545215361;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1547023537;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1547625930;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1547633328;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1547760072;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1548072633;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1548321078;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1548996340;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1549050374;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1549381458;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1549407419;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e);1549637959;Removes record of running snapshot from cluster state_@param snapshot       snapshot_@param snapshotInfo   snapshot info if snapshot was successful_@param e              exception if snapshot failed;private void removeSnapshotFromClusterState(final Snapshot snapshot, final SnapshotInfo snapshotInfo, final Exception e) {_        removeSnapshotFromClusterState(snapshot, snapshotInfo, e, null)__    };removes,record,of,running,snapshot,from,cluster,state,param,snapshot,snapshot,param,snapshot,info,snapshot,info,if,snapshot,was,successful,param,e,exception,if,snapshot,failed;private,void,remove,snapshot,from,cluster,state,final,snapshot,snapshot,final,snapshot,info,snapshot,info,final,exception,e,remove,snapshot,from,cluster,state,snapshot,snapshot,info,e,null
SnapshotsService -> SnapshotRequest -> public TimeValue masterNodeTimeout();1524684173;Returns master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };returns,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
SnapshotsService -> SnapshotRequest -> public TimeValue masterNodeTimeout();1524839522;Returns master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };returns,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
SnapshotsService -> SnapshotRequest -> public TimeValue masterNodeTimeout();1542646292;Returns master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };returns,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
SnapshotsService -> SnapshotRequest -> public TimeValue masterNodeTimeout();1542826731;Returns master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };returns,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
SnapshotsService -> SnapshotRequest -> public TimeValue masterNodeTimeout();1544783963;Returns master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };returns,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
SnapshotsService -> SnapshotRequest -> public TimeValue masterNodeTimeout();1545215361;Returns master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };returns,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
SnapshotsService -> SnapshotRequest -> public TimeValue masterNodeTimeout();1547023537;Returns master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };returns,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
SnapshotsService -> SnapshotRequest -> public TimeValue masterNodeTimeout();1547625930;Returns master node timeout__@return master node timeout;public TimeValue masterNodeTimeout() {_            return masterNodeTimeout__        };returns,master,node,timeout,return,master,node,timeout;public,time,value,master,node,timeout,return,master,node,timeout
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,                                 final boolean immediatePriority);1548321078;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()___                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(newSnapshot))__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(snapshot, ActionListener.wrap(_                        snapshotInfo -> {_                            logger.debug("deleted snapshot completed - deleting files")__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                    } catch (Exception ex) {_                                        logger.warn(() -> new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                    }_                                }_                            )__                        },_                        e -> {_                            logger.warn("deleted snapshot failed - deleting files", e)__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                try {_                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                } catch (SnapshotMissingException smex) {_                                    logger.info(() -> new ParameterizedMessage(_                                        "Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.",_                                        smex.getSnapshotName()), e)__                                    listener.onFailure(new SnapshotException(snapshot,_                                        "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                }_                            })__                        }_                    ))__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,action,listener,void,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,cluster,state,builder,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,new,snapshot,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,snapshot,action,listener,wrap,snapshot,info,logger,debug,deleted,snapshot,completed,deleting,files,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,e,logger,warn,deleted,snapshot,failed,deleting,files,e,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,                                 final boolean immediatePriority);1548996340;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()__                        assert shards.isEmpty()__                        _                        _                        endSnapshot(snapshotEntry)__                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(newSnapshot))__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(snapshot, ActionListener.wrap(_                        snapshotInfo -> {_                            logger.debug("deleted snapshot completed - deleting files")__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                    } catch (Exception ex) {_                                        logger.warn(() -> new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                    }_                                }_                            )__                        },_                        e -> {_                            logger.warn("deleted snapshot failed - deleting files", e)__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                try {_                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                } catch (SnapshotMissingException smex) {_                                    logger.info(() -> new ParameterizedMessage(_                                        "Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.",_                                        smex.getSnapshotName()), e)__                                    listener.onFailure(new SnapshotException(snapshot,_                                        "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                }_                            })__                        }_                    ))__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,action,listener,void,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,assert,shards,is,empty,end,snapshot,snapshot,entry,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,cluster,state,builder,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,new,snapshot,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,snapshot,action,listener,wrap,snapshot,info,logger,debug,deleted,snapshot,completed,deleting,files,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,e,logger,warn,deleted,snapshot,failed,deleting,files,e,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,                                 final boolean immediatePriority);1549050374;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()__                        assert shards.isEmpty()__                        _                        _                        endSnapshot(snapshotEntry)__                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()___                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                            endSnapshot(snapshotEntry)__                        }_                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(newSnapshot))__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(snapshot, ActionListener.wrap(_                        snapshotInfo -> {_                            logger.debug("deleted snapshot completed - deleting files")__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                    } catch (Exception ex) {_                                        logger.warn(() -> new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                    }_                                }_                            )__                        },_                        e -> {_                            logger.warn("deleted snapshot failed - deleting files", e)__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                try {_                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                } catch (SnapshotMissingException smex) {_                                    logger.info(() -> new ParameterizedMessage(_                                        "Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.",_                                        smex.getSnapshotName()), e)__                                    listener.onFailure(new SnapshotException(snapshot,_                                        "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                }_                            })__                        }_                    ))__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,action,listener,void,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,if,state,state,init,shards,snapshot,entry,shards,assert,shards,is,empty,end,snapshot,snapshot,entry,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,end,snapshot,snapshot,entry,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,cluster,state,builder,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,new,snapshot,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,snapshot,action,listener,wrap,snapshot,info,logger,debug,deleted,snapshot,completed,deleting,files,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,e,logger,warn,deleted,snapshot,failed,deleting,files,e,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,                                 final boolean immediatePriority);1549381458;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    final String failure__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()__                        assert shards.isEmpty()__                        failure = "Snapshot was aborted during initialization"__                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()__                        failure = "Snapshot was aborted by deletion"__                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                        }_                        failure = snapshotEntry.failure()__                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards, failure)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(newSnapshot))__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(snapshot, ActionListener.wrap(_                        snapshotInfo -> {_                            logger.debug("deleted snapshot completed - deleting files")__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                    } catch (Exception ex) {_                                        logger.warn(() -> new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                    }_                                }_                            )__                        },_                        e -> {_                            logger.warn("deleted snapshot failed - deleting files", e)__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                try {_                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                } catch (SnapshotMissingException smex) {_                                    logger.info(() -> new ParameterizedMessage(_                                        "Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.",_                                        smex.getSnapshotName()), e)__                                    listener.onFailure(new SnapshotException(snapshot,_                                        "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                }_                            })__                        }_                    ))__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,action,listener,void,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,final,string,failure,if,state,state,init,shards,snapshot,entry,shards,assert,shards,is,empty,failure,snapshot,was,aborted,during,initialization,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,failure,snapshot,was,aborted,by,deletion,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,failure,snapshot,entry,failure,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,failure,cluster,state,builder,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,new,snapshot,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,snapshot,action,listener,wrap,snapshot,info,logger,debug,deleted,snapshot,completed,deleting,files,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,e,logger,warn,deleted,snapshot,failed,deleting,files,e,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,                                 final boolean immediatePriority);1549407419;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    final String failure__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()__                        assert shards.isEmpty()__                        failure = "Snapshot was aborted during initialization"__                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()__                        failure = "Snapshot was aborted by deletion"__                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                        }_                        failure = snapshotEntry.failure()__                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards, failure)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(newSnapshot))__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(snapshot, ActionListener.wrap(_                        snapshotInfo -> {_                            logger.debug("deleted snapshot completed - deleting files")__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                    } catch (Exception ex) {_                                        logger.warn(() -> new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                    }_                                }_                            )__                        },_                        e -> {_                            logger.warn("deleted snapshot failed - deleting files", e)__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                try {_                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                } catch (SnapshotMissingException smex) {_                                    logger.info(() -> new ParameterizedMessage(_                                        "Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.",_                                        smex.getSnapshotName()), e)__                                    listener.onFailure(new SnapshotException(snapshot,_                                        "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                }_                            })__                        }_                    ))__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,action,listener,void,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,final,string,failure,if,state,state,init,shards,snapshot,entry,shards,assert,shards,is,empty,failure,snapshot,was,aborted,during,initialization,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,failure,snapshot,was,aborted,by,deletion,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,failure,snapshot,entry,failure,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,failure,cluster,state,builder,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,new,snapshot,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,snapshot,action,listener,wrap,snapshot,info,logger,debug,deleted,snapshot,completed,deleting,files,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,e,logger,warn,deleted,snapshot,failed,deleting,files,e,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,                                 final boolean immediatePriority);1549637959;Deletes snapshot from repository._<p>_If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param snapshot snapshot_@param listener listener_@param repositoryStateId the unique id for the state of the repository;private void deleteSnapshot(final Snapshot snapshot, final ActionListener<Void> listener, final long repositoryStateId,_                                final boolean immediatePriority) {_        Priority priority = immediatePriority ? Priority.IMMEDIATE : Priority.NORMAL__        clusterService.submitStateUpdateTask("delete snapshot", new ClusterStateUpdateTask(priority) {__            boolean waitForSnapshot = false___            @Override_            public ClusterState execute(ClusterState currentState) throws Exception {_                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(snapshot,_                        "cannot delete - another snapshot is currently being deleted")__                }_                RestoreInProgress restoreInProgress = currentState.custom(RestoreInProgress.TYPE)__                if (restoreInProgress != null) {_                    _                    _                    _                    if (restoreInProgress.isEmpty() == false) {_                        throw new ConcurrentSnapshotExecutionException(snapshot, "cannot delete snapshot during a restore")__                    }_                }_                ClusterState.Builder clusterStateBuilder = ClusterState.builder(currentState)__                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                SnapshotsInProgress.Entry snapshotEntry = snapshots != null ? snapshots.snapshot(snapshot) : null__                if (snapshotEntry == null) {_                    _                    if (snapshots != null && !snapshots.entries().isEmpty()) {_                        _                        throw new ConcurrentSnapshotExecutionException(snapshot, "another snapshot is currently running cannot delete")__                    }_                    _                    SnapshotDeletionsInProgress.Entry entry = new SnapshotDeletionsInProgress.Entry(_                        snapshot,_                        System.currentTimeMillis(),_                        repositoryStateId_                    )__                    if (deletionsInProgress != null) {_                        deletionsInProgress = deletionsInProgress.withAddedEntry(entry)__                    } else {_                        deletionsInProgress = SnapshotDeletionsInProgress.newInstance(entry)__                    }_                    clusterStateBuilder.putCustom(SnapshotDeletionsInProgress.TYPE, deletionsInProgress)__                } else {_                    _                    waitForSnapshot = true___                    final ImmutableOpenMap<ShardId, ShardSnapshotStatus> shards___                    final State state = snapshotEntry.state()__                    final String failure__                    if (state == State.INIT) {_                        _                        shards = snapshotEntry.shards()__                        assert shards.isEmpty()__                        failure = "Snapshot was aborted during initialization"__                    } else if (state == State.STARTED) {_                        _                        final ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shardsBuilder = ImmutableOpenMap.builder()__                        for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshotEntry.shards()) {_                            ShardSnapshotStatus status = shardEntry.value__                            if (status.state().completed() == false) {_                                status = new ShardSnapshotStatus(status.nodeId(), State.ABORTED, "aborted by snapshot deletion")__                            }_                            shardsBuilder.put(shardEntry.key, status)__                        }_                        shards = shardsBuilder.build()__                        failure = "Snapshot was aborted by deletion"__                    } else {_                        boolean hasUncompletedShards = false__                        _                        for (ObjectCursor<ShardSnapshotStatus> shardStatus : snapshotEntry.shards().values()) {_                            _                            if (shardStatus.value.state().completed() == false && shardStatus.value.nodeId() != null_                                    && currentState.nodes().get(shardStatus.value.nodeId()) != null) {_                                hasUncompletedShards = true__                                break__                            }_                        }_                        if (hasUncompletedShards) {_                            _                            logger.debug("trying to delete completed snapshot - should wait for shards to finalize on all nodes")__                            return currentState__                        } else {_                            _                            _                            logger.debug("trying to delete completed snapshot with no finalizing shards - can delete immediately")__                            shards = snapshotEntry.shards()__                        }_                        failure = snapshotEntry.failure()__                    }_                    SnapshotsInProgress.Entry newSnapshot = new SnapshotsInProgress.Entry(snapshotEntry, State.ABORTED, shards, failure)__                    clusterStateBuilder.putCustom(SnapshotsInProgress.TYPE, new SnapshotsInProgress(newSnapshot))__                }_                return clusterStateBuilder.build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (waitForSnapshot) {_                    logger.trace("adding snapshot completion listener to wait for deleted snapshot to finish")__                    addListener(snapshot, ActionListener.wrap(_                        snapshotInfo -> {_                            logger.debug("deleted snapshot completed - deleting files")__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                    try {_                                        deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                    } catch (Exception ex) {_                                        logger.warn(() -> new ParameterizedMessage("[{}] failed to delete snapshot", snapshot), ex)__                                    }_                                }_                            )__                        },_                        e -> {_                            logger.warn("deleted snapshot failed - deleting files", e)__                            threadPool.executor(ThreadPool.Names.SNAPSHOT).execute(() -> {_                                try {_                                    deleteSnapshot(snapshot.getRepository(), snapshot.getSnapshotId().getName(), listener, true)__                                } catch (SnapshotMissingException smex) {_                                    logger.info(() -> new ParameterizedMessage(_                                        "Tried deleting in-progress snapshot [{}], but it could not be found after failing to abort.",_                                        smex.getSnapshotName()), e)__                                    listener.onFailure(new SnapshotException(snapshot,_                                        "Tried deleting in-progress snapshot [" + smex.getSnapshotName() + "], but it " +_                                            "could not be found after failing to abort.", smex))__                                }_                            })__                        }_                    ))__                } else {_                    logger.debug("deleted snapshot is not running - deleting files")__                    deleteSnapshotFromRepository(snapshot, listener, repositoryStateId)__                }_            }_        })__    };deletes,snapshot,from,repository,p,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,snapshot,snapshot,param,listener,listener,param,repository,state,id,the,unique,id,for,the,state,of,the,repository;private,void,delete,snapshot,final,snapshot,snapshot,final,action,listener,void,listener,final,long,repository,state,id,final,boolean,immediate,priority,priority,priority,immediate,priority,priority,immediate,priority,normal,cluster,service,submit,state,update,task,delete,snapshot,new,cluster,state,update,task,priority,boolean,wait,for,snapshot,false,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,another,snapshot,is,currently,being,deleted,restore,in,progress,restore,in,progress,current,state,custom,restore,in,progress,type,if,restore,in,progress,null,if,restore,in,progress,is,empty,false,throw,new,concurrent,snapshot,execution,exception,snapshot,cannot,delete,snapshot,during,a,restore,cluster,state,builder,cluster,state,builder,cluster,state,builder,current,state,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,snapshots,in,progress,entry,snapshot,entry,snapshots,null,snapshots,snapshot,snapshot,null,if,snapshot,entry,null,if,snapshots,null,snapshots,entries,is,empty,throw,new,concurrent,snapshot,execution,exception,snapshot,another,snapshot,is,currently,running,cannot,delete,snapshot,deletions,in,progress,entry,entry,new,snapshot,deletions,in,progress,entry,snapshot,system,current,time,millis,repository,state,id,if,deletions,in,progress,null,deletions,in,progress,deletions,in,progress,with,added,entry,entry,else,deletions,in,progress,snapshot,deletions,in,progress,new,instance,entry,cluster,state,builder,put,custom,snapshot,deletions,in,progress,type,deletions,in,progress,else,wait,for,snapshot,true,final,immutable,open,map,shard,id,shard,snapshot,status,shards,final,state,state,snapshot,entry,state,final,string,failure,if,state,state,init,shards,snapshot,entry,shards,assert,shards,is,empty,failure,snapshot,was,aborted,during,initialization,else,if,state,state,started,final,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,builder,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,entry,shards,shard,snapshot,status,status,shard,entry,value,if,status,state,completed,false,status,new,shard,snapshot,status,status,node,id,state,aborted,aborted,by,snapshot,deletion,shards,builder,put,shard,entry,key,status,shards,shards,builder,build,failure,snapshot,was,aborted,by,deletion,else,boolean,has,uncompleted,shards,false,for,object,cursor,shard,snapshot,status,shard,status,snapshot,entry,shards,values,if,shard,status,value,state,completed,false,shard,status,value,node,id,null,current,state,nodes,get,shard,status,value,node,id,null,has,uncompleted,shards,true,break,if,has,uncompleted,shards,logger,debug,trying,to,delete,completed,snapshot,should,wait,for,shards,to,finalize,on,all,nodes,return,current,state,else,logger,debug,trying,to,delete,completed,snapshot,with,no,finalizing,shards,can,delete,immediately,shards,snapshot,entry,shards,failure,snapshot,entry,failure,snapshots,in,progress,entry,new,snapshot,new,snapshots,in,progress,entry,snapshot,entry,state,aborted,shards,failure,cluster,state,builder,put,custom,snapshots,in,progress,type,new,snapshots,in,progress,new,snapshot,return,cluster,state,builder,build,override,public,void,on,failure,string,source,exception,e,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,wait,for,snapshot,logger,trace,adding,snapshot,completion,listener,to,wait,for,deleted,snapshot,to,finish,add,listener,snapshot,action,listener,wrap,snapshot,info,logger,debug,deleted,snapshot,completed,deleting,files,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,exception,ex,logger,warn,new,parameterized,message,failed,to,delete,snapshot,snapshot,ex,e,logger,warn,deleted,snapshot,failed,deleting,files,e,thread,pool,executor,thread,pool,names,snapshot,execute,try,delete,snapshot,snapshot,get,repository,snapshot,get,snapshot,id,get,name,listener,true,catch,snapshot,missing,exception,smex,logger,info,new,parameterized,message,tried,deleting,in,progress,snapshot,but,it,could,not,be,found,after,failing,to,abort,smex,get,snapshot,name,e,listener,on,failure,new,snapshot,exception,snapshot,tried,deleting,in,progress,snapshot,smex,get,snapshot,name,but,it,could,not,be,found,after,failing,to,abort,smex,else,logger,debug,deleted,snapshot,is,not,running,deleting,files,delete,snapshot,from,repository,snapshot,listener,repository,state,id
SnapshotsService -> DeleteSnapshotListener -> void onResponse()_;1524684173;Called if delete operation was successful;void onResponse()_;called,if,delete,operation,was,successful;void,on,response
SnapshotsService -> DeleteSnapshotListener -> void onResponse()_;1524839522;Called if delete operation was successful;void onResponse()_;called,if,delete,operation,was,successful;void,on,response
SnapshotsService -> DeleteSnapshotListener -> void onResponse()_;1542646292;Called if delete operation was successful;void onResponse()_;called,if,delete,operation,was,successful;void,on,response
SnapshotsService -> DeleteSnapshotListener -> void onResponse()_;1542826731;Called if delete operation was successful;void onResponse()_;called,if,delete,operation,was,successful;void,on,response
SnapshotsService -> DeleteSnapshotListener -> void onResponse()_;1544783963;Called if delete operation was successful;void onResponse()_;called,if,delete,operation,was,successful;void,on,response
SnapshotsService -> DeleteSnapshotListener -> void onResponse()_;1545215361;Called if delete operation was successful;void onResponse()_;called,if,delete,operation,was,successful;void,on,response
SnapshotsService -> DeleteSnapshotListener -> void onResponse()_;1547023537;Called if delete operation was successful;void onResponse()_;called,if,delete,operation,was,successful;void,on,response
SnapshotsService -> DeleteSnapshotListener -> void onResponse()_;1547625930;Called if delete operation was successful;void onResponse()_;called,if,delete,operation,was,successful;void,on,response
SnapshotsService -> DeleteSnapshotListener -> void onResponse()_;1547633328;Called if delete operation was successful;void onResponse()_;called,if,delete,operation,was,successful;void,on,response
SnapshotsService -> DeleteSnapshotListener -> void onResponse()_;1547760072;Called if delete operation was successful;void onResponse()_;called,if,delete,operation,was,successful;void,on,response
SnapshotsService -> DeleteSnapshotListener -> void onResponse()_;1548072633;Called if delete operation was successful;void onResponse()_;called,if,delete,operation,was,successful;void,on,response
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1524839522;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1542646292;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1542826731;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1544783963;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1545215361;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1547023537;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1547625930;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1547633328;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1547760072;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1548072633;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1548321078;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1548996340;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1549050374;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1549381458;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1549407419;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,                                                                  final RepositoryData repositoryData,                                                                  final SnapshotInfo snapshotInfo) throws IOException;1549637959;Returns status of shards  currently finished snapshots_<p>_This method is executed on master node and it's complimentary to the_{@link SnapshotShardsService#currentSnapshotShards(Snapshot)} because it_returns similar information but for already finished snapshots._</p>__@param repositoryName  repository name_@param snapshotInfo    snapshot info_@return map of shard id to snapshot status;public Map<ShardId, IndexShardSnapshotStatus> snapshotShards(final String repositoryName,_                                                                 final RepositoryData repositoryData,_                                                                 final SnapshotInfo snapshotInfo) throws IOException {_        final Repository repository = repositoriesService.repository(repositoryName)__        final Map<ShardId, IndexShardSnapshotStatus> shardStatus = new HashMap<>()__        for (String index : snapshotInfo.indices()) {_            IndexId indexId = repositoryData.resolveIndexId(index)__            IndexMetaData indexMetaData = repository.getSnapshotIndexMetaData(snapshotInfo.snapshotId(), indexId)__            if (indexMetaData != null) {_                int numberOfShards = indexMetaData.getNumberOfShards()__                for (int i = 0_ i < numberOfShards_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    SnapshotShardFailure shardFailure = findShardFailure(snapshotInfo.shardFailures(), shardId)__                    if (shardFailure != null) {_                        shardStatus.put(shardId, IndexShardSnapshotStatus.newFailed(shardFailure.reason()))__                    } else {_                        final IndexShardSnapshotStatus shardSnapshotStatus__                        if (snapshotInfo.state() == SnapshotState.FAILED) {_                            _                            _                            _                            _                            _                            _                            _                            shardSnapshotStatus = IndexShardSnapshotStatus.newFailed("skipped")__                        } else {_                            shardSnapshotStatus = repository.getShardSnapshotStatus(_                                snapshotInfo.snapshotId(),_                                snapshotInfo.version(),_                                indexId,_                                shardId)__                        }_                        shardStatus.put(shardId, shardSnapshotStatus)__                    }_                }_            }_        }_        return unmodifiableMap(shardStatus)__    };returns,status,of,shards,currently,finished,snapshots,p,this,method,is,executed,on,master,node,and,it,s,complimentary,to,the,link,snapshot,shards,service,current,snapshot,shards,snapshot,because,it,returns,similar,information,but,for,already,finished,snapshots,p,param,repository,name,repository,name,param,snapshot,info,snapshot,info,return,map,of,shard,id,to,snapshot,status;public,map,shard,id,index,shard,snapshot,status,snapshot,shards,final,string,repository,name,final,repository,data,repository,data,final,snapshot,info,snapshot,info,throws,ioexception,final,repository,repository,repositories,service,repository,repository,name,final,map,shard,id,index,shard,snapshot,status,shard,status,new,hash,map,for,string,index,snapshot,info,indices,index,id,index,id,repository,data,resolve,index,id,index,index,meta,data,index,meta,data,repository,get,snapshot,index,meta,data,snapshot,info,snapshot,id,index,id,if,index,meta,data,null,int,number,of,shards,index,meta,data,get,number,of,shards,for,int,i,0,i,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,snapshot,shard,failure,shard,failure,find,shard,failure,snapshot,info,shard,failures,shard,id,if,shard,failure,null,shard,status,put,shard,id,index,shard,snapshot,status,new,failed,shard,failure,reason,else,final,index,shard,snapshot,status,shard,snapshot,status,if,snapshot,info,state,snapshot,state,failed,shard,snapshot,status,index,shard,snapshot,status,new,failed,skipped,else,shard,snapshot,status,repository,get,shard,snapshot,status,snapshot,info,snapshot,id,snapshot,info,version,index,id,shard,id,shard,status,put,shard,id,shard,snapshot,status,return,unmodifiable,map,shard,status
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1524684173;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]", shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key, new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new DeleteSnapshotListener() {_                                @Override_                                public void onResponse() {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,delete,snapshot,listener,override,public,void,on,response,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1524839522;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]", shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key, new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new DeleteSnapshotListener() {_                                @Override_                                public void onResponse() {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,delete,snapshot,listener,override,public,void,on,response,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1542646292;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]", shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key, new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new DeleteSnapshotListener() {_                                @Override_                                public void onResponse() {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,delete,snapshot,listener,override,public,void,on,response,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1542826731;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]", shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key, new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new DeleteSnapshotListener() {_                                @Override_                                public void onResponse() {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,delete,snapshot,listener,override,public,void,on,response,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1544783963;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]", shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key, new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new DeleteSnapshotListener() {_                                @Override_                                public void onResponse() {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,delete,snapshot,listener,override,public,void,on,response,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1545215361;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                            shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key,_                                            new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new DeleteSnapshotListener() {_                                @Override_                                public void onResponse() {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,delete,snapshot,listener,override,public,void,on,response,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1547023537;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                            shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key,_                                            new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new DeleteSnapshotListener() {_                                @Override_                                public void onResponse() {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,delete,snapshot,listener,override,public,void,on,response,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1547625930;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                            shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key,_                                            new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new DeleteSnapshotListener() {_                                @Override_                                public void onResponse() {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,delete,snapshot,listener,override,public,void,on,response,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1547633328;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                            shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key,_                                            new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new DeleteSnapshotListener() {_                                @Override_                                public void onResponse() {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,delete,snapshot,listener,override,public,void,on,response,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1547760072;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                            shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key,_                                            new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new DeleteSnapshotListener() {_                                @Override_                                public void onResponse() {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,delete,snapshot,listener,override,public,void,on,response,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1548072633;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                            shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key,_                                            new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new DeleteSnapshotListener() {_                                @Override_                                public void onResponse() {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,delete,snapshot,listener,override,public,void,on,response,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1548321078;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                            shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key,_                                            new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new ActionListener<Void>() {_                                @Override_                                public void onResponse(Void aVoid) {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,action,listener,void,override,public,void,on,response,void,a,void,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1548996340;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                            shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key,_                                            new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new ActionListener<Void>() {_                                @Override_                                public void onResponse(Void aVoid) {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,action,listener,void,override,public,void,on,response,void,a,void,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event);1549050374;Cleans up shard snapshots that were running on removed nodes__@param event cluster changed event;private void processSnapshotsOnRemovedNodes(ClusterChangedEvent event) {_        if (removedNodesCleanupNeeded(event)) {_            _            final boolean newMaster = !event.previousState().nodes().isLocalNodeElectedMaster()__            clusterService.submitStateUpdateTask("update snapshot state after node removal", new ClusterStateUpdateTask() {_                @Override_                public ClusterState execute(ClusterState currentState) throws Exception {_                    DiscoveryNodes nodes = currentState.nodes()__                    SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                    if (snapshots == null) {_                        return currentState__                    }_                    boolean changed = false__                    ArrayList<SnapshotsInProgress.Entry> entries = new ArrayList<>()__                    for (final SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                        SnapshotsInProgress.Entry updatedSnapshot = snapshot__                        boolean snapshotChanged = false__                        if (snapshot.state() == State.STARTED || snapshot.state() == State.ABORTED) {_                            ImmutableOpenMap.Builder<ShardId, ShardSnapshotStatus> shards = ImmutableOpenMap.builder()__                            for (ObjectObjectCursor<ShardId, ShardSnapshotStatus> shardEntry : snapshot.shards()) {_                                ShardSnapshotStatus shardStatus = shardEntry.value__                                if (!shardStatus.state().completed() && shardStatus.nodeId() != null) {_                                    if (nodes.nodeExists(shardStatus.nodeId())) {_                                        shards.put(shardEntry.key, shardEntry.value)__                                    } else {_                                        _                                        snapshotChanged = true__                                        logger.warn("failing snapshot of shard [{}] on closed node [{}]",_                                            shardEntry.key, shardStatus.nodeId())__                                        shards.put(shardEntry.key,_                                            new ShardSnapshotStatus(shardStatus.nodeId(), State.FAILED, "node shutdown"))__                                    }_                                }_                            }_                            if (snapshotChanged) {_                                changed = true__                                ImmutableOpenMap<ShardId, ShardSnapshotStatus> shardsMap = shards.build()__                                if (!snapshot.state().completed() && completed(shardsMap.values())) {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.SUCCESS, shardsMap)__                                    endSnapshot(updatedSnapshot)__                                } else {_                                    updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, snapshot.state(), shardsMap)__                                }_                            }_                            entries.add(updatedSnapshot)__                        } else if (snapshot.state() == State.INIT && newMaster) {_                            changed = true__                            _                            updatedSnapshot = new SnapshotsInProgress.Entry(snapshot, State.ABORTED, snapshot.shards())__                            entries.add(updatedSnapshot)___                            _                            deleteSnapshot(snapshot.snapshot(), new ActionListener<Void>() {_                                @Override_                                public void onResponse(Void aVoid) {_                                    logger.debug("cleaned up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }__                                @Override_                                public void onFailure(Exception e) {_                                    logger.warn("failed to clean up abandoned snapshot {} in INIT state", snapshot.snapshot())__                                }_                            }, updatedSnapshot.getRepositoryStateId(), false)__                        }_                    }_                    if (changed) {_                        snapshots = new SnapshotsInProgress(entries.toArray(new SnapshotsInProgress.Entry[entries.size()]))__                        return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__                    }_                    return currentState__                }__                @Override_                public void onFailure(String source, Exception e) {_                    logger.warn("failed to update snapshot state after node removal")__                }_            })__        }_    };cleans,up,shard,snapshots,that,were,running,on,removed,nodes,param,event,cluster,changed,event;private,void,process,snapshots,on,removed,nodes,cluster,changed,event,event,if,removed,nodes,cleanup,needed,event,final,boolean,new,master,event,previous,state,nodes,is,local,node,elected,master,cluster,service,submit,state,update,task,update,snapshot,state,after,node,removal,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,throws,exception,discovery,nodes,nodes,current,state,nodes,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,return,current,state,boolean,changed,false,array,list,snapshots,in,progress,entry,entries,new,array,list,for,final,snapshots,in,progress,entry,snapshot,snapshots,entries,snapshots,in,progress,entry,updated,snapshot,snapshot,boolean,snapshot,changed,false,if,snapshot,state,state,started,snapshot,state,state,aborted,immutable,open,map,builder,shard,id,shard,snapshot,status,shards,immutable,open,map,builder,for,object,object,cursor,shard,id,shard,snapshot,status,shard,entry,snapshot,shards,shard,snapshot,status,shard,status,shard,entry,value,if,shard,status,state,completed,shard,status,node,id,null,if,nodes,node,exists,shard,status,node,id,shards,put,shard,entry,key,shard,entry,value,else,snapshot,changed,true,logger,warn,failing,snapshot,of,shard,on,closed,node,shard,entry,key,shard,status,node,id,shards,put,shard,entry,key,new,shard,snapshot,status,shard,status,node,id,state,failed,node,shutdown,if,snapshot,changed,changed,true,immutable,open,map,shard,id,shard,snapshot,status,shards,map,shards,build,if,snapshot,state,completed,completed,shards,map,values,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,success,shards,map,end,snapshot,updated,snapshot,else,updated,snapshot,new,snapshots,in,progress,entry,snapshot,snapshot,state,shards,map,entries,add,updated,snapshot,else,if,snapshot,state,state,init,new,master,changed,true,updated,snapshot,new,snapshots,in,progress,entry,snapshot,state,aborted,snapshot,shards,entries,add,updated,snapshot,delete,snapshot,snapshot,snapshot,new,action,listener,void,override,public,void,on,response,void,a,void,logger,debug,cleaned,up,abandoned,snapshot,in,init,state,snapshot,snapshot,override,public,void,on,failure,exception,e,logger,warn,failed,to,clean,up,abandoned,snapshot,in,init,state,snapshot,snapshot,updated,snapshot,get,repository,state,id,false,if,changed,snapshots,new,snapshots,in,progress,entries,to,array,new,snapshots,in,progress,entry,entries,size,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,failed,to,update,snapshot,state,after,node,removal
SnapshotsService -> SnapshotRequest -> public SnapshotRequest partial(boolean partial);1524684173;Set to true if partial snapshot should be allowed__@param partial true if partial snapshots should be allowed_@return this request;public SnapshotRequest partial(boolean partial) {_            this.partial = partial__            return this__        };set,to,true,if,partial,snapshot,should,be,allowed,param,partial,true,if,partial,snapshots,should,be,allowed,return,this,request;public,snapshot,request,partial,boolean,partial,this,partial,partial,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest partial(boolean partial);1524839522;Set to true if partial snapshot should be allowed__@param partial true if partial snapshots should be allowed_@return this request;public SnapshotRequest partial(boolean partial) {_            this.partial = partial__            return this__        };set,to,true,if,partial,snapshot,should,be,allowed,param,partial,true,if,partial,snapshots,should,be,allowed,return,this,request;public,snapshot,request,partial,boolean,partial,this,partial,partial,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest partial(boolean partial);1542646292;Set to true if partial snapshot should be allowed__@param partial true if partial snapshots should be allowed_@return this request;public SnapshotRequest partial(boolean partial) {_            this.partial = partial__            return this__        };set,to,true,if,partial,snapshot,should,be,allowed,param,partial,true,if,partial,snapshots,should,be,allowed,return,this,request;public,snapshot,request,partial,boolean,partial,this,partial,partial,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest partial(boolean partial);1542826731;Set to true if partial snapshot should be allowed__@param partial true if partial snapshots should be allowed_@return this request;public SnapshotRequest partial(boolean partial) {_            this.partial = partial__            return this__        };set,to,true,if,partial,snapshot,should,be,allowed,param,partial,true,if,partial,snapshots,should,be,allowed,return,this,request;public,snapshot,request,partial,boolean,partial,this,partial,partial,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest partial(boolean partial);1544783963;Set to true if partial snapshot should be allowed__@param partial true if partial snapshots should be allowed_@return this request;public SnapshotRequest partial(boolean partial) {_            this.partial = partial__            return this__        };set,to,true,if,partial,snapshot,should,be,allowed,param,partial,true,if,partial,snapshots,should,be,allowed,return,this,request;public,snapshot,request,partial,boolean,partial,this,partial,partial,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest partial(boolean partial);1545215361;Set to true if partial snapshot should be allowed__@param partial true if partial snapshots should be allowed_@return this request;public SnapshotRequest partial(boolean partial) {_            this.partial = partial__            return this__        };set,to,true,if,partial,snapshot,should,be,allowed,param,partial,true,if,partial,snapshots,should,be,allowed,return,this,request;public,snapshot,request,partial,boolean,partial,this,partial,partial,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest partial(boolean partial);1547023537;Set to true if partial snapshot should be allowed__@param partial true if partial snapshots should be allowed_@return this request;public SnapshotRequest partial(boolean partial) {_            this.partial = partial__            return this__        };set,to,true,if,partial,snapshot,should,be,allowed,param,partial,true,if,partial,snapshots,should,be,allowed,return,this,request;public,snapshot,request,partial,boolean,partial,this,partial,partial,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest partial(boolean partial);1547625930;Set to true if partial snapshot should be allowed__@param partial true if partial snapshots should be allowed_@return this request;public SnapshotRequest partial(boolean partial) {_            this.partial = partial__            return this__        };set,to,true,if,partial,snapshot,should,be,allowed,param,partial,true,if,partial,snapshots,should,be,allowed,return,this,request;public,snapshot,request,partial,boolean,partial,this,partial,partial,return,this
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1524684173;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1524839522;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1542646292;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1542826731;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1544783963;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1545215361;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1547023537;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1547625930;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1547633328;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new IllegalArgumentException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,illegal,argument,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1547760072;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1548072633;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1548321078;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1548996340;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1549050374;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1549381458;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1549407419;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices);1549637959;Check if any of the indices to be closed are currently being snapshotted. Fail as closing an index that is being_snapshotted (with partial == false) makes the snapshot fail.;public static void checkIndexClosing(ClusterState currentState, Set<IndexMetaData> indices) {_        Set<Index> indicesToFail = indicesToFailForCloseOrDeletion(currentState, indices)__        if (indicesToFail != null) {_            throw new SnapshotInProgressException("Cannot close indices that are being snapshotted: " + indicesToFail +_                ". Try again after snapshot finishes or cancel the currently running snapshot.")__        }_    };check,if,any,of,the,indices,to,be,closed,are,currently,being,snapshotted,fail,as,closing,an,index,that,is,being,snapshotted,with,partial,false,makes,the,snapshot,fail;public,static,void,check,index,closing,cluster,state,current,state,set,index,meta,data,indices,set,index,indices,to,fail,indices,to,fail,for,close,or,deletion,current,state,indices,if,indices,to,fail,null,throw,new,snapshot,in,progress,exception,cannot,close,indices,that,are,being,snapshotted,indices,to,fail,try,again,after,snapshot,finishes,or,cancel,the,currently,running,snapshot
SnapshotsService -> private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener);1548321078;Adds snapshot completion listener__@param snapshot Snapshot to listen for_@param listener listener;private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener) {_        snapshotCompletionListeners.computeIfAbsent(snapshot, k -> new CopyOnWriteArrayList<>()).add(listener)__    };adds,snapshot,completion,listener,param,snapshot,snapshot,to,listen,for,param,listener,listener;private,void,add,listener,snapshot,snapshot,action,listener,snapshot,info,listener,snapshot,completion,listeners,compute,if,absent,snapshot,k,new,copy,on,write,array,list,add,listener
SnapshotsService -> private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener);1548996340;Adds snapshot completion listener__@param snapshot Snapshot to listen for_@param listener listener;private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener) {_        snapshotCompletionListeners.computeIfAbsent(snapshot, k -> new CopyOnWriteArrayList<>()).add(listener)__    };adds,snapshot,completion,listener,param,snapshot,snapshot,to,listen,for,param,listener,listener;private,void,add,listener,snapshot,snapshot,action,listener,snapshot,info,listener,snapshot,completion,listeners,compute,if,absent,snapshot,k,new,copy,on,write,array,list,add,listener
SnapshotsService -> private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener);1549050374;Adds snapshot completion listener__@param snapshot Snapshot to listen for_@param listener listener;private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener) {_        snapshotCompletionListeners.computeIfAbsent(snapshot, k -> new CopyOnWriteArrayList<>()).add(listener)__    };adds,snapshot,completion,listener,param,snapshot,snapshot,to,listen,for,param,listener,listener;private,void,add,listener,snapshot,snapshot,action,listener,snapshot,info,listener,snapshot,completion,listeners,compute,if,absent,snapshot,k,new,copy,on,write,array,list,add,listener
SnapshotsService -> private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener);1549381458;Adds snapshot completion listener__@param snapshot Snapshot to listen for_@param listener listener;private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener) {_        snapshotCompletionListeners.computeIfAbsent(snapshot, k -> new CopyOnWriteArrayList<>()).add(listener)__    };adds,snapshot,completion,listener,param,snapshot,snapshot,to,listen,for,param,listener,listener;private,void,add,listener,snapshot,snapshot,action,listener,snapshot,info,listener,snapshot,completion,listeners,compute,if,absent,snapshot,k,new,copy,on,write,array,list,add,listener
SnapshotsService -> private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener);1549407419;Adds snapshot completion listener__@param snapshot Snapshot to listen for_@param listener listener;private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener) {_        snapshotCompletionListeners.computeIfAbsent(snapshot, k -> new CopyOnWriteArrayList<>()).add(listener)__    };adds,snapshot,completion,listener,param,snapshot,snapshot,to,listen,for,param,listener,listener;private,void,add,listener,snapshot,snapshot,action,listener,snapshot,info,listener,snapshot,completion,listeners,compute,if,absent,snapshot,k,new,copy,on,write,array,list,add,listener
SnapshotsService -> private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener);1549637959;Adds snapshot completion listener__@param snapshot Snapshot to listen for_@param listener listener;private void addListener(Snapshot snapshot, ActionListener<SnapshotInfo> listener) {_        snapshotCompletionListeners.computeIfAbsent(snapshot, k -> new CopyOnWriteArrayList<>()).add(listener)__    };adds,snapshot,completion,listener,param,snapshot,snapshot,to,listen,for,param,listener,listener;private,void,add,listener,snapshot,snapshot,action,listener,snapshot,info,listener,snapshot,completion,listeners,compute,if,absent,snapshot,k,new,copy,on,write,array,list,add,listener
SnapshotsService -> SnapshotRequest -> public SnapshotRequest includeGlobalState(boolean includeGlobalState);1524684173;Set to true if global state should be stored as part of the snapshot__@param includeGlobalState true if global state should be stored as part of the snapshot_@return this request;public SnapshotRequest includeGlobalState(boolean includeGlobalState) {_            this.includeGlobalState = includeGlobalState__            return this__        };set,to,true,if,global,state,should,be,stored,as,part,of,the,snapshot,param,include,global,state,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,this,request;public,snapshot,request,include,global,state,boolean,include,global,state,this,include,global,state,include,global,state,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest includeGlobalState(boolean includeGlobalState);1524839522;Set to true if global state should be stored as part of the snapshot__@param includeGlobalState true if global state should be stored as part of the snapshot_@return this request;public SnapshotRequest includeGlobalState(boolean includeGlobalState) {_            this.includeGlobalState = includeGlobalState__            return this__        };set,to,true,if,global,state,should,be,stored,as,part,of,the,snapshot,param,include,global,state,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,this,request;public,snapshot,request,include,global,state,boolean,include,global,state,this,include,global,state,include,global,state,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest includeGlobalState(boolean includeGlobalState);1542646292;Set to true if global state should be stored as part of the snapshot__@param includeGlobalState true if global state should be stored as part of the snapshot_@return this request;public SnapshotRequest includeGlobalState(boolean includeGlobalState) {_            this.includeGlobalState = includeGlobalState__            return this__        };set,to,true,if,global,state,should,be,stored,as,part,of,the,snapshot,param,include,global,state,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,this,request;public,snapshot,request,include,global,state,boolean,include,global,state,this,include,global,state,include,global,state,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest includeGlobalState(boolean includeGlobalState);1542826731;Set to true if global state should be stored as part of the snapshot__@param includeGlobalState true if global state should be stored as part of the snapshot_@return this request;public SnapshotRequest includeGlobalState(boolean includeGlobalState) {_            this.includeGlobalState = includeGlobalState__            return this__        };set,to,true,if,global,state,should,be,stored,as,part,of,the,snapshot,param,include,global,state,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,this,request;public,snapshot,request,include,global,state,boolean,include,global,state,this,include,global,state,include,global,state,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest includeGlobalState(boolean includeGlobalState);1544783963;Set to true if global state should be stored as part of the snapshot__@param includeGlobalState true if global state should be stored as part of the snapshot_@return this request;public SnapshotRequest includeGlobalState(boolean includeGlobalState) {_            this.includeGlobalState = includeGlobalState__            return this__        };set,to,true,if,global,state,should,be,stored,as,part,of,the,snapshot,param,include,global,state,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,this,request;public,snapshot,request,include,global,state,boolean,include,global,state,this,include,global,state,include,global,state,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest includeGlobalState(boolean includeGlobalState);1545215361;Set to true if global state should be stored as part of the snapshot__@param includeGlobalState true if global state should be stored as part of the snapshot_@return this request;public SnapshotRequest includeGlobalState(boolean includeGlobalState) {_            this.includeGlobalState = includeGlobalState__            return this__        };set,to,true,if,global,state,should,be,stored,as,part,of,the,snapshot,param,include,global,state,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,this,request;public,snapshot,request,include,global,state,boolean,include,global,state,this,include,global,state,include,global,state,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest includeGlobalState(boolean includeGlobalState);1547023537;Set to true if global state should be stored as part of the snapshot__@param includeGlobalState true if global state should be stored as part of the snapshot_@return this request;public SnapshotRequest includeGlobalState(boolean includeGlobalState) {_            this.includeGlobalState = includeGlobalState__            return this__        };set,to,true,if,global,state,should,be,stored,as,part,of,the,snapshot,param,include,global,state,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,this,request;public,snapshot,request,include,global,state,boolean,include,global,state,this,include,global,state,include,global,state,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest includeGlobalState(boolean includeGlobalState);1547625930;Set to true if global state should be stored as part of the snapshot__@param includeGlobalState true if global state should be stored as part of the snapshot_@return this request;public SnapshotRequest includeGlobalState(boolean includeGlobalState) {_            this.includeGlobalState = includeGlobalState__            return this__        };set,to,true,if,global,state,should,be,stored,as,part,of,the,snapshot,param,include,global,state,true,if,global,state,should,be,stored,as,part,of,the,snapshot,return,this,request;public,snapshot,request,include,global,state,boolean,include,global,state,this,include,global,state,include,global,state,return,this
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1524684173;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1524839522;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1542646292;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1542826731;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1544783963;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1545215361;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1547023537;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1547625930;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1547633328;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1547760072;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1548072633;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1548321078;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1548996340;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1549050374;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1549381458;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1549407419;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> public static boolean isRepositoryInUse(ClusterState clusterState, String repository);1549637959;Checks if a repository is currently in use by one of the snapshots__@param clusterState cluster state_@param repository   repository id_@return true if repository is currently in use by one of the running snapshots;public static boolean isRepositoryInUse(ClusterState clusterState, String repository) {_        SnapshotsInProgress snapshots = clusterState.custom(SnapshotsInProgress.TYPE)__        if (snapshots != null) {_            for (SnapshotsInProgress.Entry snapshot : snapshots.entries()) {_                if (repository.equals(snapshot.snapshot().getRepository())) {_                    return true__                }_            }_        }_        SnapshotDeletionsInProgress deletionsInProgress = clusterState.custom(SnapshotDeletionsInProgress.TYPE)__        if (deletionsInProgress != null) {_            for (SnapshotDeletionsInProgress.Entry entry : deletionsInProgress.getEntries()) {_                if (entry.getSnapshot().getRepository().equals(repository)) {_                    return true__                }_            }_        }_        return false__    };checks,if,a,repository,is,currently,in,use,by,one,of,the,snapshots,param,cluster,state,cluster,state,param,repository,repository,id,return,true,if,repository,is,currently,in,use,by,one,of,the,running,snapshots;public,static,boolean,is,repository,in,use,cluster,state,cluster,state,string,repository,snapshots,in,progress,snapshots,cluster,state,custom,snapshots,in,progress,type,if,snapshots,null,for,snapshots,in,progress,entry,snapshot,snapshots,entries,if,repository,equals,snapshot,snapshot,get,repository,return,true,snapshot,deletions,in,progress,deletions,in,progress,cluster,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,for,snapshot,deletions,in,progress,entry,entry,deletions,in,progress,get,entries,if,entry,get,snapshot,get,repository,equals,repository,return,true,return,false
SnapshotsService -> SnapshotRequest -> public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout);1524684173;Sets master node timeout__@param masterNodeTimeout master node timeout_@return this request;public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout) {_            this.masterNodeTimeout = masterNodeTimeout__            return this__        };sets,master,node,timeout,param,master,node,timeout,master,node,timeout,return,this,request;public,snapshot,request,master,node,timeout,time,value,master,node,timeout,this,master,node,timeout,master,node,timeout,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout);1524839522;Sets master node timeout__@param masterNodeTimeout master node timeout_@return this request;public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout) {_            this.masterNodeTimeout = masterNodeTimeout__            return this__        };sets,master,node,timeout,param,master,node,timeout,master,node,timeout,return,this,request;public,snapshot,request,master,node,timeout,time,value,master,node,timeout,this,master,node,timeout,master,node,timeout,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout);1542646292;Sets master node timeout__@param masterNodeTimeout master node timeout_@return this request;public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout) {_            this.masterNodeTimeout = masterNodeTimeout__            return this__        };sets,master,node,timeout,param,master,node,timeout,master,node,timeout,return,this,request;public,snapshot,request,master,node,timeout,time,value,master,node,timeout,this,master,node,timeout,master,node,timeout,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout);1542826731;Sets master node timeout__@param masterNodeTimeout master node timeout_@return this request;public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout) {_            this.masterNodeTimeout = masterNodeTimeout__            return this__        };sets,master,node,timeout,param,master,node,timeout,master,node,timeout,return,this,request;public,snapshot,request,master,node,timeout,time,value,master,node,timeout,this,master,node,timeout,master,node,timeout,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout);1544783963;Sets master node timeout__@param masterNodeTimeout master node timeout_@return this request;public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout) {_            this.masterNodeTimeout = masterNodeTimeout__            return this__        };sets,master,node,timeout,param,master,node,timeout,master,node,timeout,return,this,request;public,snapshot,request,master,node,timeout,time,value,master,node,timeout,this,master,node,timeout,master,node,timeout,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout);1545215361;Sets master node timeout__@param masterNodeTimeout master node timeout_@return this request;public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout) {_            this.masterNodeTimeout = masterNodeTimeout__            return this__        };sets,master,node,timeout,param,master,node,timeout,master,node,timeout,return,this,request;public,snapshot,request,master,node,timeout,time,value,master,node,timeout,this,master,node,timeout,master,node,timeout,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout);1547023537;Sets master node timeout__@param masterNodeTimeout master node timeout_@return this request;public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout) {_            this.masterNodeTimeout = masterNodeTimeout__            return this__        };sets,master,node,timeout,param,master,node,timeout,master,node,timeout,return,this,request;public,snapshot,request,master,node,timeout,time,value,master,node,timeout,this,master,node,timeout,master,node,timeout,return,this
SnapshotsService -> SnapshotRequest -> public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout);1547625930;Sets master node timeout__@param masterNodeTimeout master node timeout_@return this request;public SnapshotRequest masterNodeTimeout(TimeValue masterNodeTimeout) {_            this.masterNodeTimeout = masterNodeTimeout__            return this__        };sets,master,node,timeout,param,master,node,timeout,master,node,timeout,return,this,request;public,snapshot,request,master,node,timeout,time,value,master,node,timeout,this,master,node,timeout,master,node,timeout,return,this
SnapshotsService -> SnapshotRequest -> public boolean partial();1524684173;Returns true if partial snapshot should be allowed__@return true if partial snapshot should be allowed;public boolean partial() {_            return partial__        };returns,true,if,partial,snapshot,should,be,allowed,return,true,if,partial,snapshot,should,be,allowed;public,boolean,partial,return,partial
SnapshotsService -> SnapshotRequest -> public boolean partial();1524839522;Returns true if partial snapshot should be allowed__@return true if partial snapshot should be allowed;public boolean partial() {_            return partial__        };returns,true,if,partial,snapshot,should,be,allowed,return,true,if,partial,snapshot,should,be,allowed;public,boolean,partial,return,partial
SnapshotsService -> SnapshotRequest -> public boolean partial();1542646292;Returns true if partial snapshot should be allowed__@return true if partial snapshot should be allowed;public boolean partial() {_            return partial__        };returns,true,if,partial,snapshot,should,be,allowed,return,true,if,partial,snapshot,should,be,allowed;public,boolean,partial,return,partial
SnapshotsService -> SnapshotRequest -> public boolean partial();1542826731;Returns true if partial snapshot should be allowed__@return true if partial snapshot should be allowed;public boolean partial() {_            return partial__        };returns,true,if,partial,snapshot,should,be,allowed,return,true,if,partial,snapshot,should,be,allowed;public,boolean,partial,return,partial
SnapshotsService -> SnapshotRequest -> public boolean partial();1544783963;Returns true if partial snapshot should be allowed__@return true if partial snapshot should be allowed;public boolean partial() {_            return partial__        };returns,true,if,partial,snapshot,should,be,allowed,return,true,if,partial,snapshot,should,be,allowed;public,boolean,partial,return,partial
SnapshotsService -> SnapshotRequest -> public boolean partial();1545215361;Returns true if partial snapshot should be allowed__@return true if partial snapshot should be allowed;public boolean partial() {_            return partial__        };returns,true,if,partial,snapshot,should,be,allowed,return,true,if,partial,snapshot,should,be,allowed;public,boolean,partial,return,partial
SnapshotsService -> SnapshotRequest -> public boolean partial();1547023537;Returns true if partial snapshot should be allowed__@return true if partial snapshot should be allowed;public boolean partial() {_            return partial__        };returns,true,if,partial,snapshot,should,be,allowed,return,true,if,partial,snapshot,should,be,allowed;public,boolean,partial,return,partial
SnapshotsService -> SnapshotRequest -> public boolean partial();1547625930;Returns true if partial snapshot should be allowed__@return true if partial snapshot should be allowed;public boolean partial() {_            return partial__        };returns,true,if,partial,snapshot,should,be,allowed,return,true,if,partial,snapshot,should,be,allowed;public,boolean,partial,return,partial
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,                                final boolean immediatePriority);1524684173;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        if (matchedEntry.isPresent() == false) {_            matchedEntry = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .map(e -> e.snapshot().getSnapshotId()).filter(s -> s.getName().equals(snapshotName)).findFirst()__        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repositoryData.getGenId(), immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,delete,snapshot,listener,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,matched,entry,current,snapshots,repository,name,collections,empty,list,stream,map,e,e,snapshot,get,snapshot,id,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repository,data,get,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,                                final boolean immediatePriority);1524839522;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        if (matchedEntry.isPresent() == false) {_            matchedEntry = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .map(e -> e.snapshot().getSnapshotId()).filter(s -> s.getName().equals(snapshotName)).findFirst()__        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repositoryData.getGenId(), immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,delete,snapshot,listener,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,matched,entry,current,snapshots,repository,name,collections,empty,list,stream,map,e,e,snapshot,get,snapshot,id,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repository,data,get,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,                                final boolean immediatePriority);1542646292;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        if (matchedEntry.isPresent() == false) {_            matchedEntry = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .map(e -> e.snapshot().getSnapshotId()).filter(s -> s.getName().equals(snapshotName)).findFirst()__        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repositoryData.getGenId(), immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,delete,snapshot,listener,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,matched,entry,current,snapshots,repository,name,collections,empty,list,stream,map,e,e,snapshot,get,snapshot,id,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repository,data,get,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,                                final boolean immediatePriority);1542826731;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        if (matchedEntry.isPresent() == false) {_            matchedEntry = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .map(e -> e.snapshot().getSnapshotId()).filter(s -> s.getName().equals(snapshotName)).findFirst()__        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repositoryData.getGenId(), immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,delete,snapshot,listener,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,matched,entry,current,snapshots,repository,name,collections,empty,list,stream,map,e,e,snapshot,get,snapshot,id,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repository,data,get,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,                                final boolean immediatePriority);1544783963;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        if (matchedEntry.isPresent() == false) {_            matchedEntry = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .map(e -> e.snapshot().getSnapshotId()).filter(s -> s.getName().equals(snapshotName)).findFirst()__        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repositoryData.getGenId(), immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,delete,snapshot,listener,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,matched,entry,current,snapshots,repository,name,collections,empty,list,stream,map,e,e,snapshot,get,snapshot,id,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repository,data,get,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,                                final boolean immediatePriority);1545215361;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        if (matchedEntry.isPresent() == false) {_            matchedEntry = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .map(e -> e.snapshot().getSnapshotId()).filter(s -> s.getName().equals(snapshotName)).findFirst()__        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repositoryData.getGenId(), immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,delete,snapshot,listener,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,matched,entry,current,snapshots,repository,name,collections,empty,list,stream,map,e,e,snapshot,get,snapshot,id,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repository,data,get,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,                                final boolean immediatePriority);1547023537;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        if (matchedEntry.isPresent() == false) {_            matchedEntry = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .map(e -> e.snapshot().getSnapshotId()).filter(s -> s.getName().equals(snapshotName)).findFirst()__        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repositoryData.getGenId(), immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,delete,snapshot,listener,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,matched,entry,current,snapshots,repository,name,collections,empty,list,stream,map,e,e,snapshot,get,snapshot,id,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repository,data,get,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,                                final boolean immediatePriority);1547625930;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        if (matchedEntry.isPresent() == false) {_            matchedEntry = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .map(e -> e.snapshot().getSnapshotId()).filter(s -> s.getName().equals(snapshotName)).findFirst()__        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repositoryData.getGenId(), immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,delete,snapshot,listener,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,matched,entry,current,snapshots,repository,name,collections,empty,list,stream,map,e,e,snapshot,get,snapshot,id,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repository,data,get,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,                                final boolean immediatePriority);1547633328;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        if (matchedEntry.isPresent() == false) {_            matchedEntry = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .map(e -> e.snapshot().getSnapshotId()).filter(s -> s.getName().equals(snapshotName)).findFirst()__        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repositoryData.getGenId(), immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,delete,snapshot,listener,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,matched,entry,current,snapshots,repository,name,collections,empty,list,stream,map,e,e,snapshot,get,snapshot,id,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repository,data,get,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,                                final boolean immediatePriority);1547760072;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        if (matchedEntry.isPresent() == false) {_            matchedEntry = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .map(e -> e.snapshot().getSnapshotId()).filter(s -> s.getName().equals(snapshotName)).findFirst()__        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repositoryData.getGenId(), immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,delete,snapshot,listener,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,matched,entry,current,snapshots,repository,name,collections,empty,list,stream,map,e,e,snapshot,get,snapshot,id,filter,s,s,get,name,equals,snapshot,name,find,first,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repository,data,get,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,                                final boolean immediatePriority);1548072633;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final DeleteSnapshotListener listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        long repoGenId = repositoryData.getGenId()__        if (matchedEntry.isPresent() == false) {_            Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst()__            if (matchedInProgress.isPresent()) {_                matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId())__                _                repoGenId = matchedInProgress.get().getRepositoryStateId() + 1L__            }_        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repoGenId, immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,delete,snapshot,listener,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,long,repo,gen,id,repository,data,get,gen,id,if,matched,entry,is,present,false,optional,snapshots,in,progress,entry,matched,in,progress,current,snapshots,repository,name,collections,empty,list,stream,filter,s,s,snapshot,get,snapshot,id,get,name,equals,snapshot,name,find,first,if,matched,in,progress,is,present,matched,entry,matched,in,progress,map,s,s,snapshot,get,snapshot,id,repo,gen,id,matched,in,progress,get,get,repository,state,id,1l,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repo,gen,id,immediate,priority
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final ActionListener<Void> listener);1548321078;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final ActionListener<Void> listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse(null)__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,action,listener,void,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response,null
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final ActionListener<Void> listener);1548996340;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final ActionListener<Void> listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse(null)__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,action,listener,void,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response,null
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final ActionListener<Void> listener);1549050374;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final ActionListener<Void> listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse(null)__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,action,listener,void,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response,null
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final ActionListener<Void> listener);1549381458;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final ActionListener<Void> listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse(null)__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,action,listener,void,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response,null
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final ActionListener<Void> listener);1549407419;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final ActionListener<Void> listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse(null)__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,action,listener,void,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response,null
SnapshotsService -> private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,                                                         @Nullable final ActionListener<Void> listener);1549637959;Removes the snapshot deletion from {@link SnapshotDeletionsInProgress} in the cluster state.;private void removeSnapshotDeletionFromClusterState(final Snapshot snapshot, @Nullable final Exception failure,_                                                        @Nullable final ActionListener<Void> listener) {_        clusterService.submitStateUpdateTask("remove snapshot deletion metadata", new ClusterStateUpdateTask() {_            @Override_            public ClusterState execute(ClusterState currentState) {_                SnapshotDeletionsInProgress deletions = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletions != null) {_                    boolean changed = false__                    if (deletions.hasDeletionsInProgress()) {_                        assert deletions.getEntries().size() == 1 : "should have exactly one deletion in progress"__                        SnapshotDeletionsInProgress.Entry entry = deletions.getEntries().get(0)__                        deletions = deletions.withRemovedEntry(entry)__                        changed = true__                    }_                    if (changed) {_                        return ClusterState.builder(currentState).putCustom(SnapshotDeletionsInProgress.TYPE, deletions).build()__                    }_                }_                return currentState__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}] failed to remove snapshot deletion metadata", snapshot), e)__                if (listener != null) {_                    listener.onFailure(e)__                }_            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {_                if (listener != null) {_                    if (failure != null) {_                        listener.onFailure(failure)__                    } else {_                        listener.onResponse(null)__                    }_                }_            }_        })__    };removes,the,snapshot,deletion,from,link,snapshot,deletions,in,progress,in,the,cluster,state;private,void,remove,snapshot,deletion,from,cluster,state,final,snapshot,snapshot,nullable,final,exception,failure,nullable,final,action,listener,void,listener,cluster,service,submit,state,update,task,remove,snapshot,deletion,metadata,new,cluster,state,update,task,override,public,cluster,state,execute,cluster,state,current,state,snapshot,deletions,in,progress,deletions,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,null,boolean,changed,false,if,deletions,has,deletions,in,progress,assert,deletions,get,entries,size,1,should,have,exactly,one,deletion,in,progress,snapshot,deletions,in,progress,entry,entry,deletions,get,entries,get,0,deletions,deletions,with,removed,entry,entry,changed,true,if,changed,return,cluster,state,builder,current,state,put,custom,snapshot,deletions,in,progress,type,deletions,build,return,current,state,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,remove,snapshot,deletion,metadata,snapshot,e,if,listener,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,cluster,state,new,state,if,listener,null,if,failure,null,listener,on,failure,failure,else,listener,on,response,null
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,                                final boolean immediatePriority);1548321078;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        long repoGenId = repositoryData.getGenId()__        if (matchedEntry.isPresent() == false) {_            Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst()__            if (matchedInProgress.isPresent()) {_                matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId())__                _                repoGenId = matchedInProgress.get().getRepositoryStateId() + 1L__            }_        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repoGenId, immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,action,listener,void,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,long,repo,gen,id,repository,data,get,gen,id,if,matched,entry,is,present,false,optional,snapshots,in,progress,entry,matched,in,progress,current,snapshots,repository,name,collections,empty,list,stream,filter,s,s,snapshot,get,snapshot,id,get,name,equals,snapshot,name,find,first,if,matched,in,progress,is,present,matched,entry,matched,in,progress,map,s,s,snapshot,get,snapshot,id,repo,gen,id,matched,in,progress,get,get,repository,state,id,1l,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repo,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,                                final boolean immediatePriority);1548996340;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        long repoGenId = repositoryData.getGenId()__        if (matchedEntry.isPresent() == false) {_            Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst()__            if (matchedInProgress.isPresent()) {_                matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId())__                _                repoGenId = matchedInProgress.get().getRepositoryStateId() + 1L__            }_        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repoGenId, immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,action,listener,void,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,long,repo,gen,id,repository,data,get,gen,id,if,matched,entry,is,present,false,optional,snapshots,in,progress,entry,matched,in,progress,current,snapshots,repository,name,collections,empty,list,stream,filter,s,s,snapshot,get,snapshot,id,get,name,equals,snapshot,name,find,first,if,matched,in,progress,is,present,matched,entry,matched,in,progress,map,s,s,snapshot,get,snapshot,id,repo,gen,id,matched,in,progress,get,get,repository,state,id,1l,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repo,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,                                final boolean immediatePriority);1549050374;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        long repoGenId = repositoryData.getGenId()__        if (matchedEntry.isPresent() == false) {_            Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst()__            if (matchedInProgress.isPresent()) {_                matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId())__                _                repoGenId = matchedInProgress.get().getRepositoryStateId() + 1L__            }_        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repoGenId, immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,action,listener,void,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,long,repo,gen,id,repository,data,get,gen,id,if,matched,entry,is,present,false,optional,snapshots,in,progress,entry,matched,in,progress,current,snapshots,repository,name,collections,empty,list,stream,filter,s,s,snapshot,get,snapshot,id,get,name,equals,snapshot,name,find,first,if,matched,in,progress,is,present,matched,entry,matched,in,progress,map,s,s,snapshot,get,snapshot,id,repo,gen,id,matched,in,progress,get,get,repository,state,id,1l,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repo,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,                                final boolean immediatePriority);1549381458;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        long repoGenId = repositoryData.getGenId()__        if (matchedEntry.isPresent() == false) {_            Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst()__            if (matchedInProgress.isPresent()) {_                matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId())__                _                repoGenId = matchedInProgress.get().getRepositoryStateId() + 1L__            }_        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repoGenId, immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,action,listener,void,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,long,repo,gen,id,repository,data,get,gen,id,if,matched,entry,is,present,false,optional,snapshots,in,progress,entry,matched,in,progress,current,snapshots,repository,name,collections,empty,list,stream,filter,s,s,snapshot,get,snapshot,id,get,name,equals,snapshot,name,find,first,if,matched,in,progress,is,present,matched,entry,matched,in,progress,map,s,s,snapshot,get,snapshot,id,repo,gen,id,matched,in,progress,get,get,repository,state,id,1l,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repo,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,                                final boolean immediatePriority);1549407419;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        long repoGenId = repositoryData.getGenId()__        if (matchedEntry.isPresent() == false) {_            Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst()__            if (matchedInProgress.isPresent()) {_                matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId())__                _                repoGenId = matchedInProgress.get().getRepositoryStateId() + 1L__            }_        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repoGenId, immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,action,listener,void,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,long,repo,gen,id,repository,data,get,gen,id,if,matched,entry,is,present,false,optional,snapshots,in,progress,entry,matched,in,progress,current,snapshots,repository,name,collections,empty,list,stream,filter,s,s,snapshot,get,snapshot,id,get,name,equals,snapshot,name,find,first,if,matched,in,progress,is,present,matched,entry,matched,in,progress,map,s,s,snapshot,get,snapshot,id,repo,gen,id,matched,in,progress,get,get,repository,state,id,1l,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repo,gen,id,immediate,priority
SnapshotsService -> public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,                                final boolean immediatePriority);1549637959;Deletes a snapshot from the repository, looking up the {@link Snapshot} reference before deleting._If the snapshot is still running cancels the snapshot first and then deletes it from the repository.__@param repositoryName  repositoryName_@param snapshotName    snapshotName_@param listener        listener;public void deleteSnapshot(final String repositoryName, final String snapshotName, final ActionListener<Void> listener,_                               final boolean immediatePriority) {_        _        final Repository repository = repositoriesService.repository(repositoryName)__        final RepositoryData repositoryData = repository.getRepositoryData()__        final Optional<SnapshotId> incompatibleSnapshotId =_            repositoryData.getIncompatibleSnapshotIds().stream().filter(s -> snapshotName.equals(s.getName())).findFirst()__        if (incompatibleSnapshotId.isPresent()) {_            throw new SnapshotException(repositoryName, snapshotName, "cannot delete incompatible snapshot")__        }_        Optional<SnapshotId> matchedEntry = repositoryData.getSnapshotIds()_                                                .stream()_                                                .filter(s -> s.getName().equals(snapshotName))_                                                .findFirst()__        _        long repoGenId = repositoryData.getGenId()__        if (matchedEntry.isPresent() == false) {_            Optional<SnapshotsInProgress.Entry> matchedInProgress = currentSnapshots(repositoryName, Collections.emptyList()).stream()_                               .filter(s -> s.snapshot().getSnapshotId().getName().equals(snapshotName)).findFirst()__            if (matchedInProgress.isPresent()) {_                matchedEntry = matchedInProgress.map(s -> s.snapshot().getSnapshotId())__                _                repoGenId = matchedInProgress.get().getRepositoryStateId() + 1L__            }_        }_        if (matchedEntry.isPresent() == false) {_            throw new SnapshotMissingException(repositoryName, snapshotName)__        }_        deleteSnapshot(new Snapshot(repositoryName, matchedEntry.get()), listener, repoGenId, immediatePriority)__    };deletes,a,snapshot,from,the,repository,looking,up,the,link,snapshot,reference,before,deleting,if,the,snapshot,is,still,running,cancels,the,snapshot,first,and,then,deletes,it,from,the,repository,param,repository,name,repository,name,param,snapshot,name,snapshot,name,param,listener,listener;public,void,delete,snapshot,final,string,repository,name,final,string,snapshot,name,final,action,listener,void,listener,final,boolean,immediate,priority,final,repository,repository,repositories,service,repository,repository,name,final,repository,data,repository,data,repository,get,repository,data,final,optional,snapshot,id,incompatible,snapshot,id,repository,data,get,incompatible,snapshot,ids,stream,filter,s,snapshot,name,equals,s,get,name,find,first,if,incompatible,snapshot,id,is,present,throw,new,snapshot,exception,repository,name,snapshot,name,cannot,delete,incompatible,snapshot,optional,snapshot,id,matched,entry,repository,data,get,snapshot,ids,stream,filter,s,s,get,name,equals,snapshot,name,find,first,long,repo,gen,id,repository,data,get,gen,id,if,matched,entry,is,present,false,optional,snapshots,in,progress,entry,matched,in,progress,current,snapshots,repository,name,collections,empty,list,stream,filter,s,s,snapshot,get,snapshot,id,get,name,equals,snapshot,name,find,first,if,matched,in,progress,is,present,matched,entry,matched,in,progress,map,s,s,snapshot,get,snapshot,id,repo,gen,id,matched,in,progress,get,get,repository,state,id,1l,if,matched,entry,is,present,false,throw,new,snapshot,missing,exception,repository,name,snapshot,name,delete,snapshot,new,snapshot,repository,name,matched,entry,get,listener,repo,gen,id,immediate,priority
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1524684173;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) && metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1524839522;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) && metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1542646292;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) && metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1542826731;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) && metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> private Tuple<Set<String>, Set<String>> indicesWithMissingShards(ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData);1544783963;Returns list of indices with missing shards, and list of indices that are closed__@param shards list of shard statuses_@return list of failed and closed indices;private Tuple<Set<String>, Set<String>> indicesWithMissingShards(ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards, MetaData metaData) {_        Set<String> missing = new HashSet<>()__        Set<String> closed = new HashSet<>()__        for (ObjectObjectCursor<ShardId, SnapshotsInProgress.ShardSnapshotStatus> entry : shards) {_            if (entry.value.state() == State.MISSING) {_                if (metaData.hasIndex(entry.key.getIndex().getName()) && metaData.getIndexSafe(entry.key.getIndex()).getState() == IndexMetaData.State.CLOSE) {_                    closed.add(entry.key.getIndex().getName())__                } else {_                    missing.add(entry.key.getIndex().getName())__                }_            }_        }_        return new Tuple<>(missing, closed)__    };returns,list,of,indices,with,missing,shards,and,list,of,indices,that,are,closed,param,shards,list,of,shard,statuses,return,list,of,failed,and,closed,indices;private,tuple,set,string,set,string,indices,with,missing,shards,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,meta,data,meta,data,set,string,missing,new,hash,set,set,string,closed,new,hash,set,for,object,object,cursor,shard,id,snapshots,in,progress,shard,snapshot,status,entry,shards,if,entry,value,state,state,missing,if,meta,data,has,index,entry,key,get,index,get,name,meta,data,get,index,safe,entry,key,get,index,get,state,index,meta,data,state,close,closed,add,entry,key,get,index,get,name,else,missing,add,entry,key,get,index,get,name,return,new,tuple,missing,closed
SnapshotsService -> public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener);1548321078;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener) {_        final String repositoryName = request.repository()__        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot())__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask("create_snapshot [" + snapshotName + ']', new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(repositoryName, snapshotName, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    beginSnapshot(newState, newSnapshot, request.partial(), listener)__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,listener,final,string,repository,name,request,repository,final,string,snapshot,name,index,name,expression,resolver,resolve,date,math,expression,request,snapshot,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,snapshot,name,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,repository,name,snapshot,name,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener);1548996340;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener) {_        final String repositoryName = request.repository()__        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot())__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask("create_snapshot [" + snapshotName + ']', new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(repositoryName, snapshotName, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    beginSnapshot(newState, newSnapshot, request.partial(), listener)__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,listener,final,string,repository,name,request,repository,final,string,snapshot,name,index,name,expression,resolver,resolve,date,math,expression,request,snapshot,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,snapshot,name,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,repository,name,snapshot,name,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener);1549050374;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener) {_        final String repositoryName = request.repository()__        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot())__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask("create_snapshot [" + snapshotName + ']', new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(repositoryName, snapshotName, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    beginSnapshot(newState, newSnapshot, request.partial(), listener)__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,listener,final,string,repository,name,request,repository,final,string,snapshot,name,index,name,expression,resolver,resolve,date,math,expression,request,snapshot,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,snapshot,name,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,repository,name,snapshot,name,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,begin,snapshot,new,state,new,snapshot,request,partial,listener,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener);1549381458;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener) {_        final String repositoryName = request.repository()__        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot())__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask("create_snapshot [" + snapshotName + ']', new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(repositoryName, snapshotName, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    initializingSnapshots.add(newSnapshot.snapshot())__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                if (newSnapshot != null) {_                    initializingSnapshots.remove(newSnapshot.snapshot())__                }_                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    final Snapshot current = newSnapshot.snapshot()__                    assert initializingSnapshots.contains(current)__                    beginSnapshot(newState, newSnapshot, request.partial(), new ActionListener<Snapshot>() {_                        @Override_                        public void onResponse(final Snapshot snapshot) {_                            initializingSnapshots.remove(snapshot)__                            listener.onResponse(snapshot)__                        }__                        @Override_                        public void onFailure(final Exception e) {_                            initializingSnapshots.remove(current)__                            listener.onFailure(e)__                        }_                    })__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,listener,final,string,repository,name,request,repository,final,string,snapshot,name,index,name,expression,resolver,resolve,date,math,expression,request,snapshot,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,snapshot,name,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,repository,name,snapshot,name,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,initializing,snapshots,add,new,snapshot,snapshot,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,if,new,snapshot,null,initializing,snapshots,remove,new,snapshot,snapshot,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,final,snapshot,current,new,snapshot,snapshot,assert,initializing,snapshots,contains,current,begin,snapshot,new,state,new,snapshot,request,partial,new,action,listener,snapshot,override,public,void,on,response,final,snapshot,snapshot,initializing,snapshots,remove,snapshot,listener,on,response,snapshot,override,public,void,on,failure,final,exception,e,initializing,snapshots,remove,current,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener);1549407419;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener) {_        final String repositoryName = request.repository()__        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot())__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask("create_snapshot [" + snapshotName + ']', new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(repositoryName, snapshotName, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    initializingSnapshots.add(newSnapshot.snapshot())__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                if (newSnapshot != null) {_                    initializingSnapshots.remove(newSnapshot.snapshot())__                }_                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    final Snapshot current = newSnapshot.snapshot()__                    assert initializingSnapshots.contains(current)__                    beginSnapshot(newState, newSnapshot, request.partial(), new ActionListener<Snapshot>() {_                        @Override_                        public void onResponse(final Snapshot snapshot) {_                            initializingSnapshots.remove(snapshot)__                            listener.onResponse(snapshot)__                        }__                        @Override_                        public void onFailure(final Exception e) {_                            initializingSnapshots.remove(current)__                            listener.onFailure(e)__                        }_                    })__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }__        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,listener,final,string,repository,name,request,repository,final,string,snapshot,name,index,name,expression,resolver,resolve,date,math,expression,request,snapshot,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,snapshot,name,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,repository,name,snapshot,name,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,initializing,snapshots,add,new,snapshot,snapshot,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,if,new,snapshot,null,initializing,snapshots,remove,new,snapshot,snapshot,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,final,snapshot,current,new,snapshot,snapshot,assert,initializing,snapshots,contains,current,begin,snapshot,new,state,new,snapshot,request,partial,new,action,listener,snapshot,override,public,void,on,response,final,snapshot,snapshot,initializing,snapshots,remove,snapshot,listener,on,response,snapshot,override,public,void,on,failure,final,exception,e,initializing,snapshots,remove,current,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener);1549637959;Initializes the snapshotting process._<p>_This method is used by clients to start snapshot. It makes sure that there is no snapshots are currently running and_creates a snapshot record in cluster state metadata.__@param request  snapshot request_@param listener snapshot creation listener;public void createSnapshot(final CreateSnapshotRequest request, final ActionListener<Snapshot> listener) {_        final String repositoryName = request.repository()__        final String snapshotName = indexNameExpressionResolver.resolveDateMathExpression(request.snapshot())__        validate(repositoryName, snapshotName)__        final SnapshotId snapshotId = new SnapshotId(snapshotName, UUIDs.randomBase64UUID())_ _        final RepositoryData repositoryData = repositoriesService.repository(repositoryName).getRepositoryData()___        clusterService.submitStateUpdateTask("create_snapshot [" + snapshotName + ']', new ClusterStateUpdateTask() {__            private SnapshotsInProgress.Entry newSnapshot = null___            @Override_            public ClusterState execute(ClusterState currentState) {_                validate(repositoryName, snapshotName, currentState)__                SnapshotDeletionsInProgress deletionsInProgress = currentState.custom(SnapshotDeletionsInProgress.TYPE)__                if (deletionsInProgress != null && deletionsInProgress.hasDeletionsInProgress()) {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName,_                        "cannot snapshot while a snapshot deletion is in-progress")__                }_                SnapshotsInProgress snapshots = currentState.custom(SnapshotsInProgress.TYPE)__                if (snapshots == null || snapshots.entries().isEmpty()) {_                    _                    List<String> indices = Arrays.asList(indexNameExpressionResolver.concreteIndexNames(currentState,_                                                        request.indicesOptions(), request.indices()))__                    logger.trace("[{}][{}] creating snapshot for indices [{}]", repositoryName, snapshotName, indices)__                    List<IndexId> snapshotIndices = repositoryData.resolveNewIndices(indices)__                    newSnapshot = new SnapshotsInProgress.Entry(new Snapshot(repositoryName, snapshotId),_                                                                request.includeGlobalState(),_                                                                request.partial(),_                                                                State.INIT,_                                                                snapshotIndices,_                                                                System.currentTimeMillis(),_                                                                repositoryData.getGenId(),_                                                                null)__                    initializingSnapshots.add(newSnapshot.snapshot())__                    snapshots = new SnapshotsInProgress(newSnapshot)__                } else {_                    throw new ConcurrentSnapshotExecutionException(repositoryName, snapshotName, " a snapshot is already running")__                }_                return ClusterState.builder(currentState).putCustom(SnapshotsInProgress.TYPE, snapshots).build()__            }__            @Override_            public void onFailure(String source, Exception e) {_                logger.warn(() -> new ParameterizedMessage("[{}][{}] failed to create snapshot", repositoryName, snapshotName), e)__                if (newSnapshot != null) {_                    initializingSnapshots.remove(newSnapshot.snapshot())__                }_                newSnapshot = null__                listener.onFailure(e)__            }__            @Override_            public void clusterStateProcessed(String source, ClusterState oldState, final ClusterState newState) {_                if (newSnapshot != null) {_                    final Snapshot current = newSnapshot.snapshot()__                    assert initializingSnapshots.contains(current)__                    beginSnapshot(newState, newSnapshot, request.partial(), new ActionListener<Snapshot>() {_                        @Override_                        public void onResponse(final Snapshot snapshot) {_                            initializingSnapshots.remove(snapshot)__                            listener.onResponse(snapshot)__                        }__                        @Override_                        public void onFailure(final Exception e) {_                            initializingSnapshots.remove(current)__                            listener.onFailure(e)__                        }_                    })__                }_            }__            @Override_            public TimeValue timeout() {_                return request.masterNodeTimeout()__            }_        })__    };initializes,the,snapshotting,process,p,this,method,is,used,by,clients,to,start,snapshot,it,makes,sure,that,there,is,no,snapshots,are,currently,running,and,creates,a,snapshot,record,in,cluster,state,metadata,param,request,snapshot,request,param,listener,snapshot,creation,listener;public,void,create,snapshot,final,create,snapshot,request,request,final,action,listener,snapshot,listener,final,string,repository,name,request,repository,final,string,snapshot,name,index,name,expression,resolver,resolve,date,math,expression,request,snapshot,validate,repository,name,snapshot,name,final,snapshot,id,snapshot,id,new,snapshot,id,snapshot,name,uuids,random,base64uuid,final,repository,data,repository,data,repositories,service,repository,repository,name,get,repository,data,cluster,service,submit,state,update,task,snapshot,name,new,cluster,state,update,task,private,snapshots,in,progress,entry,new,snapshot,null,override,public,cluster,state,execute,cluster,state,current,state,validate,repository,name,snapshot,name,current,state,snapshot,deletions,in,progress,deletions,in,progress,current,state,custom,snapshot,deletions,in,progress,type,if,deletions,in,progress,null,deletions,in,progress,has,deletions,in,progress,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,cannot,snapshot,while,a,snapshot,deletion,is,in,progress,snapshots,in,progress,snapshots,current,state,custom,snapshots,in,progress,type,if,snapshots,null,snapshots,entries,is,empty,list,string,indices,arrays,as,list,index,name,expression,resolver,concrete,index,names,current,state,request,indices,options,request,indices,logger,trace,creating,snapshot,for,indices,repository,name,snapshot,name,indices,list,index,id,snapshot,indices,repository,data,resolve,new,indices,indices,new,snapshot,new,snapshots,in,progress,entry,new,snapshot,repository,name,snapshot,id,request,include,global,state,request,partial,state,init,snapshot,indices,system,current,time,millis,repository,data,get,gen,id,null,initializing,snapshots,add,new,snapshot,snapshot,snapshots,new,snapshots,in,progress,new,snapshot,else,throw,new,concurrent,snapshot,execution,exception,repository,name,snapshot,name,a,snapshot,is,already,running,return,cluster,state,builder,current,state,put,custom,snapshots,in,progress,type,snapshots,build,override,public,void,on,failure,string,source,exception,e,logger,warn,new,parameterized,message,failed,to,create,snapshot,repository,name,snapshot,name,e,if,new,snapshot,null,initializing,snapshots,remove,new,snapshot,snapshot,new,snapshot,null,listener,on,failure,e,override,public,void,cluster,state,processed,string,source,cluster,state,old,state,final,cluster,state,new,state,if,new,snapshot,null,final,snapshot,current,new,snapshot,snapshot,assert,initializing,snapshots,contains,current,begin,snapshot,new,state,new,snapshot,request,partial,new,action,listener,snapshot,override,public,void,on,response,final,snapshot,snapshot,initializing,snapshots,remove,snapshot,listener,on,response,snapshot,override,public,void,on,failure,final,exception,e,initializing,snapshots,remove,current,listener,on,failure,e,override,public,time,value,timeout,return,request,master,node,timeout
SnapshotsService -> public void removeListener(SnapshotCompletionListener listener);1524684173;Removes snapshot completion listener__@param listener listener;public void removeListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.remove(listener)__    };removes,snapshot,completion,listener,param,listener,listener;public,void,remove,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,remove,listener
SnapshotsService -> public void removeListener(SnapshotCompletionListener listener);1524839522;Removes snapshot completion listener__@param listener listener;public void removeListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.remove(listener)__    };removes,snapshot,completion,listener,param,listener,listener;public,void,remove,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,remove,listener
SnapshotsService -> public void removeListener(SnapshotCompletionListener listener);1542646292;Removes snapshot completion listener__@param listener listener;public void removeListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.remove(listener)__    };removes,snapshot,completion,listener,param,listener,listener;public,void,remove,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,remove,listener
SnapshotsService -> public void removeListener(SnapshotCompletionListener listener);1542826731;Removes snapshot completion listener__@param listener listener;public void removeListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.remove(listener)__    };removes,snapshot,completion,listener,param,listener,listener;public,void,remove,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,remove,listener
SnapshotsService -> public void removeListener(SnapshotCompletionListener listener);1544783963;Removes snapshot completion listener__@param listener listener;public void removeListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.remove(listener)__    };removes,snapshot,completion,listener,param,listener,listener;public,void,remove,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,remove,listener
SnapshotsService -> public void removeListener(SnapshotCompletionListener listener);1545215361;Removes snapshot completion listener__@param listener listener;public void removeListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.remove(listener)__    };removes,snapshot,completion,listener,param,listener,listener;public,void,remove,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,remove,listener
SnapshotsService -> public void removeListener(SnapshotCompletionListener listener);1547023537;Removes snapshot completion listener__@param listener listener;public void removeListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.remove(listener)__    };removes,snapshot,completion,listener,param,listener,listener;public,void,remove,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,remove,listener
SnapshotsService -> public void removeListener(SnapshotCompletionListener listener);1547625930;Removes snapshot completion listener__@param listener listener;public void removeListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.remove(listener)__    };removes,snapshot,completion,listener,param,listener,listener;public,void,remove,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,remove,listener
SnapshotsService -> public void removeListener(SnapshotCompletionListener listener);1547633328;Removes snapshot completion listener__@param listener listener;public void removeListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.remove(listener)__    };removes,snapshot,completion,listener,param,listener,listener;public,void,remove,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,remove,listener
SnapshotsService -> public void removeListener(SnapshotCompletionListener listener);1547760072;Removes snapshot completion listener__@param listener listener;public void removeListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.remove(listener)__    };removes,snapshot,completion,listener,param,listener,listener;public,void,remove,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,remove,listener
SnapshotsService -> public void removeListener(SnapshotCompletionListener listener);1548072633;Removes snapshot completion listener__@param listener listener;public void removeListener(SnapshotCompletionListener listener) {_        this.snapshotCompletionListeners.remove(listener)__    };removes,snapshot,completion,listener,param,listener,listener;public,void,remove,listener,snapshot,completion,listener,listener,this,snapshot,completion,listeners,remove,listener
SnapshotsService -> private static ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState,                                                                                              List<IndexId> indices);1549381458;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private static ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState,_                                                                                             List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,static,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private static ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState,                                                                                              List<IndexId> indices);1549407419;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private static ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState,_                                                                                             List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,static,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
SnapshotsService -> private static ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState,                                                                                              List<IndexId> indices);1549637959;Calculates the list of shards that should be included into the current snapshot__@param clusterState cluster state_@param indices      list of indices to be snapshotted_@return list of shard to be included into current snapshot;private static ImmutableOpenMap<ShardId, SnapshotsInProgress.ShardSnapshotStatus> shards(ClusterState clusterState,_                                                                                             List<IndexId> indices) {_        ImmutableOpenMap.Builder<ShardId, SnapshotsInProgress.ShardSnapshotStatus> builder = ImmutableOpenMap.builder()__        MetaData metaData = clusterState.metaData()__        for (IndexId index : indices) {_            final String indexName = index.getName()__            IndexMetaData indexMetaData = metaData.index(indexName)__            if (indexMetaData == null) {_                _                builder.put(new ShardId(indexName, IndexMetaData.INDEX_UUID_NA_VALUE, 0),_                    new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "missing index"))__            } else if (indexMetaData.getState() == IndexMetaData.State.CLOSE) {_                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "index is closed"))__                }_            } else {_                IndexRoutingTable indexRoutingTable = clusterState.getRoutingTable().index(indexName)__                for (int i = 0_ i < indexMetaData.getNumberOfShards()_ i++) {_                    ShardId shardId = new ShardId(indexMetaData.getIndex(), i)__                    if (indexRoutingTable != null) {_                        ShardRouting primary = indexRoutingTable.shard(i).primaryShard()__                        if (primary == null || !primary.assignedToNode()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING, "primary shard is not allocated"))__                        } else if (primary.relocating() || primary.initializing()) {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.WAITING))__                        } else if (!primary.started()) {_                            builder.put(shardId,_                                new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId(), State.MISSING,_                                    "primary shard hasn't been started yet"))__                        } else {_                            builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(primary.currentNodeId()))__                        }_                    } else {_                        builder.put(shardId, new SnapshotsInProgress.ShardSnapshotStatus(null, State.MISSING,_                            "missing routing table"))__                    }_                }_            }_        }__        return builder.build()__    };calculates,the,list,of,shards,that,should,be,included,into,the,current,snapshot,param,cluster,state,cluster,state,param,indices,list,of,indices,to,be,snapshotted,return,list,of,shard,to,be,included,into,current,snapshot;private,static,immutable,open,map,shard,id,snapshots,in,progress,shard,snapshot,status,shards,cluster,state,cluster,state,list,index,id,indices,immutable,open,map,builder,shard,id,snapshots,in,progress,shard,snapshot,status,builder,immutable,open,map,builder,meta,data,meta,data,cluster,state,meta,data,for,index,id,index,indices,final,string,index,name,index,get,name,index,meta,data,index,meta,data,meta,data,index,index,name,if,index,meta,data,null,builder,put,new,shard,id,index,name,index,meta,data,0,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,index,else,if,index,meta,data,get,state,index,meta,data,state,close,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,index,is,closed,else,index,routing,table,index,routing,table,cluster,state,get,routing,table,index,index,name,for,int,i,0,i,index,meta,data,get,number,of,shards,i,shard,id,shard,id,new,shard,id,index,meta,data,get,index,i,if,index,routing,table,null,shard,routing,primary,index,routing,table,shard,i,primary,shard,if,primary,null,primary,assigned,to,node,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,primary,shard,is,not,allocated,else,if,primary,relocating,primary,initializing,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,waiting,else,if,primary,started,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,state,missing,primary,shard,hasn,t,been,started,yet,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,primary,current,node,id,else,builder,put,shard,id,new,snapshots,in,progress,shard,snapshot,status,null,state,missing,missing,routing,table,return,builder,build
