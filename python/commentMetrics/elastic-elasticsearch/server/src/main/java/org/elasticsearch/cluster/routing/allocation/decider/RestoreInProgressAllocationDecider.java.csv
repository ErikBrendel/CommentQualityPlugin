commented;modifiers;parameterAmount;loc;comment;code
false;public;3;4;;@Override public Decision canAllocate(final ShardRouting shardRouting, final RoutingNode node, final RoutingAllocation allocation) {     return canAllocate(shardRouting, allocation). }
false;public;2;26;;@Override public Decision canAllocate(final ShardRouting shardRouting, final RoutingAllocation allocation) {     final RecoverySource recoverySource = shardRouting.recoverySource().     if (recoverySource == null || recoverySource.getType() != RecoverySource.Type.SNAPSHOT) {         return allocation.decision(Decision.YES, NAME, "ignored as shard is not being recovered from a snapshot").     }     RecoverySource.SnapshotRecoverySource source = (RecoverySource.SnapshotRecoverySource) recoverySource.     final RestoreInProgress restoresInProgress = allocation.custom(RestoreInProgress.TYPE).     if (restoresInProgress != null) {         RestoreInProgress.Entry restoreInProgress = restoresInProgress.get(source.restoreUUID()).         if (restoreInProgress != null) {             RestoreInProgress.ShardRestoreStatus shardRestoreStatus = restoreInProgress.shards().get(shardRouting.shardId()).             if (shardRestoreStatus != null && shardRestoreStatus.state().completed() == false) {                 assert shardRestoreStatus.state() != RestoreInProgress.State.SUCCESS : "expected shard [" + shardRouting + "] to be in initializing state but got [" + shardRestoreStatus.state() + "]".                 return allocation.decision(Decision.YES, NAME, "shard is currently being restored").             }         }     }     return allocation.decision(Decision.NO, NAME, "shard has failed to be restored from the snapshot [%s] because of [%s] - " + "manually close or delete the index [%s] in order to retry to restore the snapshot again or use the reroute API to force the " + "allocation of an empty primary shard", source.snapshot(), shardRouting.unassignedInfo().getDetails(), shardRouting.getIndexName()). }
false;public;3;5;;@Override public Decision canForceAllocatePrimary(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {     assert shardRouting.primary() : "must not call canForceAllocatePrimary on a non-primary shard " + shardRouting.     return canAllocate(shardRouting, node, allocation). }
