commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public ScoreMode scoreMode() {     return valuesSource != null && valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES. }
false;public;2;57;;@Override public void collect(int doc, long bucket) throws IOException {     if (bucket >= counts.size()) {         final long from = counts.size().         final long overSize = BigArrays.overSize(bucket + 1).         counts = bigArrays.resize(counts, overSize).         sums = bigArrays.resize(sums, overSize).         compensations = bigArrays.resize(compensations, overSize).         mins = bigArrays.resize(mins, overSize).         maxes = bigArrays.resize(maxes, overSize).         sumOfSqrs = bigArrays.resize(sumOfSqrs, overSize).         compensationOfSqrs = bigArrays.resize(compensationOfSqrs, overSize).         mins.fill(from, overSize, Double.POSITIVE_INFINITY).         maxes.fill(from, overSize, Double.NEGATIVE_INFINITY).     }     if (values.advanceExact(doc)) {         final int valuesCount = values.docValueCount().         counts.increment(bucket, valuesCount).         double min = mins.get(bucket).         double max = maxes.get(bucket).         // Compute the sum and sum of squires for double values with Kahan summation algorithm         // which is more accurate than naive summation.         double sum = sums.get(bucket).         double compensation = compensations.get(bucket).         double sumOfSqr = sumOfSqrs.get(bucket).         double compensationOfSqr = compensationOfSqrs.get(bucket).         for (int i = 0. i < valuesCount. i++) {             double value = values.nextValue().             if (Double.isFinite(value) == false) {                 sum += value.                 sumOfSqr += value * value.             } else {                 if (Double.isFinite(sum)) {                     double corrected = value - compensation.                     double newSum = sum + corrected.                     compensation = (newSum - sum) - corrected.                     sum = newSum.                 }                 if (Double.isFinite(sumOfSqr)) {                     double correctedOfSqr = value * value - compensationOfSqr.                     double newSumOfSqr = sumOfSqr + correctedOfSqr.                     compensationOfSqr = (newSumOfSqr - sumOfSqr) - correctedOfSqr.                     sumOfSqr = newSumOfSqr.                 }             }             min = Math.min(min, value).             max = Math.max(max, value).         }         sums.set(bucket, sum).         compensations.set(bucket, compensation).         sumOfSqrs.set(bucket, sumOfSqr).         compensationOfSqrs.set(bucket, compensationOfSqr).         mins.set(bucket, min).         maxes.set(bucket, max).     } }
false;public;2;70;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     if (valuesSource == null) {         return LeafBucketCollector.NO_OP_COLLECTOR.     }     final BigArrays bigArrays = context.bigArrays().     final SortedNumericDoubleValues values = valuesSource.doubleValues(ctx).     return new LeafBucketCollectorBase(sub, values) {          @Override         public void collect(int doc, long bucket) throws IOException {             if (bucket >= counts.size()) {                 final long from = counts.size().                 final long overSize = BigArrays.overSize(bucket + 1).                 counts = bigArrays.resize(counts, overSize).                 sums = bigArrays.resize(sums, overSize).                 compensations = bigArrays.resize(compensations, overSize).                 mins = bigArrays.resize(mins, overSize).                 maxes = bigArrays.resize(maxes, overSize).                 sumOfSqrs = bigArrays.resize(sumOfSqrs, overSize).                 compensationOfSqrs = bigArrays.resize(compensationOfSqrs, overSize).                 mins.fill(from, overSize, Double.POSITIVE_INFINITY).                 maxes.fill(from, overSize, Double.NEGATIVE_INFINITY).             }             if (values.advanceExact(doc)) {                 final int valuesCount = values.docValueCount().                 counts.increment(bucket, valuesCount).                 double min = mins.get(bucket).                 double max = maxes.get(bucket).                 // Compute the sum and sum of squires for double values with Kahan summation algorithm                 // which is more accurate than naive summation.                 double sum = sums.get(bucket).                 double compensation = compensations.get(bucket).                 double sumOfSqr = sumOfSqrs.get(bucket).                 double compensationOfSqr = compensationOfSqrs.get(bucket).                 for (int i = 0. i < valuesCount. i++) {                     double value = values.nextValue().                     if (Double.isFinite(value) == false) {                         sum += value.                         sumOfSqr += value * value.                     } else {                         if (Double.isFinite(sum)) {                             double corrected = value - compensation.                             double newSum = sum + corrected.                             compensation = (newSum - sum) - corrected.                             sum = newSum.                         }                         if (Double.isFinite(sumOfSqr)) {                             double correctedOfSqr = value * value - compensationOfSqr.                             double newSumOfSqr = sumOfSqr + correctedOfSqr.                             compensationOfSqr = (newSumOfSqr - sumOfSqr) - correctedOfSqr.                             sumOfSqr = newSumOfSqr.                         }                     }                     min = Math.min(min, value).                     max = Math.max(max, value).                 }                 sums.set(bucket, sum).                 compensations.set(bucket, compensation).                 sumOfSqrs.set(bucket, sumOfSqr).                 compensationOfSqrs.set(bucket, compensationOfSqr).                 mins.set(bucket, min).                 maxes.set(bucket, max).             }         }     }. }
false;public;1;9;;@Override public boolean hasMetric(String name) {     try {         InternalExtendedStats.Metrics.resolve(name).         return true.     } catch (IllegalArgumentException iae) {         return false.     } }
false;public;2;35;;@Override public double metric(String name, long owningBucketOrd) {     if (valuesSource == null || owningBucketOrd >= counts.size()) {         switch(InternalExtendedStats.Metrics.resolve(name)) {             case count:                 return 0.             case sum:                 return 0.             case min:                 return Double.POSITIVE_INFINITY.             case max:                 return Double.NEGATIVE_INFINITY.             case avg:                 return Double.NaN.             case sum_of_squares:                 return 0.             case variance:                 return Double.NaN.             case std_deviation:                 return Double.NaN.             case std_upper:                 return Double.NaN.             case std_lower:                 return Double.NaN.             default:                 throw new IllegalArgumentException("Unknown value [" + name + "] in common stats aggregation").         }     }     switch(InternalExtendedStats.Metrics.resolve(name)) {         case count:             return counts.get(owningBucketOrd).         case sum:             return sums.get(owningBucketOrd).         case min:             return mins.get(owningBucketOrd).         case max:             return maxes.get(owningBucketOrd).         case avg:             return sums.get(owningBucketOrd) / counts.get(owningBucketOrd).         case sum_of_squares:             return sumOfSqrs.get(owningBucketOrd).         case variance:             return variance(owningBucketOrd).         case std_deviation:             return Math.sqrt(variance(owningBucketOrd)).         case std_upper:             return (sums.get(owningBucketOrd) / counts.get(owningBucketOrd)) + (Math.sqrt(variance(owningBucketOrd)) * this.sigma).         case std_lower:             return (sums.get(owningBucketOrd) / counts.get(owningBucketOrd)) - (Math.sqrt(variance(owningBucketOrd)) * this.sigma).         default:             throw new IllegalArgumentException("Unknown value [" + name + "] in common stats aggregation").     } }
false;private;1;6;;private double variance(long owningBucketOrd) {     double sum = sums.get(owningBucketOrd).     long count = counts.get(owningBucketOrd).     double variance = (sumOfSqrs.get(owningBucketOrd) - ((sum * sum) / count)) / count.     return variance < 0 ? 0 : variance. }
false;public;1;9;;@Override public InternalAggregation buildAggregation(long bucket) {     if (valuesSource == null || bucket >= counts.size()) {         return buildEmptyAggregation().     }     return new InternalExtendedStats(name, counts.get(bucket), sums.get(bucket), mins.get(bucket), maxes.get(bucket), sumOfSqrs.get(bucket), sigma, format, pipelineAggregators(), metaData()). }
false;public;0;5;;@Override public InternalAggregation buildEmptyAggregation() {     return new InternalExtendedStats(name, 0, 0d, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, 0d, sigma, format, pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public void doClose() {     Releasables.close(counts, maxes, mins, sumOfSqrs, compensationOfSqrs, sums, compensations). }
