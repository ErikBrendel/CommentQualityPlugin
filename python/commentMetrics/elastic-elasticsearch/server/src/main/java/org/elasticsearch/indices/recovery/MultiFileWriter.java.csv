commented;modifiers;parameterAmount;loc;comment;code
false;public;4;5;;public void writeFileChunk(StoreFileMetaData fileMetaData, long position, BytesReference content, boolean lastChunk) throws IOException {     final FileChunkWriter writer = fileChunkWriters.computeIfAbsent(fileMetaData.name(), name -> new FileChunkWriter()).     writer.writeChunk(new FileChunk(fileMetaData, content, position, lastChunk)). }
true;;1;3;/**  * Get a temporary name for the provided file name.  */ ;/**  * Get a temporary name for the provided file name.  */ String getTempNameForFile(String origFile) {     return tempFilePrefix + origFile. }
false;public;1;4;;public IndexOutput getOpenIndexOutput(String key) {     ensureOpen.run().     return openIndexOutputs.get(key). }
true;public;1;4;/**  * remove and {@link IndexOutput} for a given file. It is the caller's responsibility to close it  */ ;/**  * remove and {@link IndexOutput} for a given file. It is the caller's responsibility to close it  */ public IndexOutput removeOpenIndexOutputs(String name) {     ensureOpen.run().     return openIndexOutputs.remove(name). }
true;public;3;12;/**  * Creates an {@link IndexOutput} for the given file name. Note that the  * IndexOutput actually point at a temporary file.  * <p>  * Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput  * at a later stage  */ ;/**  * Creates an {@link IndexOutput} for the given file name. Note that the  * IndexOutput actually point at a temporary file.  * <p>  * Note: You can use {@link #getOpenIndexOutput(String)} with the same filename to retrieve the same IndexOutput  * at a later stage  */ public IndexOutput openAndPutIndexOutput(String fileName, StoreFileMetaData metaData, Store store) throws IOException {     ensureOpen.run().     String tempFileName = getTempNameForFile(fileName).     if (tempFileNames.containsKey(tempFileName)) {         throw new IllegalStateException("output for file [" + fileName + "] has already been created").     }     // add first, before it's created     tempFileNames.put(tempFileName, fileName).     IndexOutput indexOutput = store.createVerifyingOutput(tempFileName, metaData, IOContext.DEFAULT).     openIndexOutputs.put(fileName, indexOutput).     return indexOutput. }
false;private;4;31;;private void innerWriteFileChunk(StoreFileMetaData fileMetaData, long position, BytesReference content, boolean lastChunk) throws IOException {     final String name = fileMetaData.name().     IndexOutput indexOutput.     if (position == 0) {         indexOutput = openAndPutIndexOutput(name, fileMetaData, store).     } else {         indexOutput = getOpenIndexOutput(name).     }     assert indexOutput.getFilePointer() == position : "file-pointer " + indexOutput.getFilePointer() + " != " + position.     BytesRefIterator iterator = content.iterator().     BytesRef scratch.     while ((scratch = iterator.next()) != null) {         // we iterate over all pages - this is a 0-copy for all core impls         indexOutput.writeBytes(scratch.bytes, scratch.offset, scratch.length).     }     indexState.addRecoveredBytesToFile(name, content.length()).     if (indexOutput.getFilePointer() >= fileMetaData.length() || lastChunk) {         try {             Store.verify(indexOutput).         } finally {             // we are done             indexOutput.close().         }         final String temporaryFileName = getTempNameForFile(name).         assert Arrays.asList(store.directory().listAll()).contains(temporaryFileName) : "expected: [" + temporaryFileName + "] in " + Arrays.toString(store.directory().listAll()).         store.directory().sync(Collections.singleton(temporaryFileName)).         IndexOutput remove = removeOpenIndexOutputs(name).         // remove maybe null if we got finished         assert remove == null || remove == indexOutput.     } }
false;public;0;23;;@Override public void close() {     fileChunkWriters.clear().     // clean open index outputs     Iterator<Map.Entry<String, IndexOutput>> iterator = openIndexOutputs.entrySet().iterator().     while (iterator.hasNext()) {         Map.Entry<String, IndexOutput> entry = iterator.next().         logger.trace("closing IndexOutput file [{}]", entry.getValue()).         try {             entry.getValue().close().         } catch (Exception e) {             logger.debug(() -> new ParameterizedMessage("error while closing recovery output [{}]", entry.getValue()), e).         }         iterator.remove().     }     if (Strings.hasText(tempFilePrefix)) {         // trash temporary files         for (String file : tempFileNames.keySet()) {             logger.trace("cleaning temporary file [{}]", file).             store.deleteQuiet(file).         }     } }
true;public;0;4;/**  * renames all temporary files to their true name, potentially overriding existing files  */ ;/**  * renames all temporary files to their true name, potentially overriding existing files  */ public void renameAllTempFiles() throws IOException {     ensureOpen.run().     store.renameTempFilesSafe(tempFileNames). }
false;;1;25;;void writeChunk(FileChunk newChunk) throws IOException {     synchronized (this) {         pendingChunks.add(newChunk).     }     while (true) {         final FileChunk chunk.         synchronized (this) {             chunk = pendingChunks.peek().             if (chunk == null || chunk.position != lastPosition) {                 return.             }             pendingChunks.remove().         }         innerWriteFileChunk(chunk.md, chunk.position, chunk.content, chunk.lastChunk).         synchronized (this) {             assert lastPosition == chunk.position : "last_position " + lastPosition + " != chunk_position " + chunk.position.             lastPosition += chunk.content.length().             if (chunk.lastChunk) {                 assert pendingChunks.isEmpty() == true : "still have pending chunks [" + pendingChunks + "]".                 fileChunkWriters.remove(chunk.md.name()).                 assert fileChunkWriters.containsValue(this) == false : "chunk writer [" + newChunk.md + "] was not removed".             }         }     } }
