commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> mappings() {     return mappings. }
false;public;0;3;;public ImmutableOpenMap<String, ImmutableOpenMap<String, MappingMetaData>> getMappings() {     return mappings(). }
false;public;1;16;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     int size = in.readVInt().     ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> indexMapBuilder = ImmutableOpenMap.builder().     for (int i = 0. i < size. i++) {         String key = in.readString().         int valueSize = in.readVInt().         ImmutableOpenMap.Builder<String, MappingMetaData> typeMapBuilder = ImmutableOpenMap.builder().         for (int j = 0. j < valueSize. j++) {             typeMapBuilder.put(in.readString(), new MappingMetaData(in)).         }         indexMapBuilder.put(key, typeMapBuilder.build()).     }     mappings = indexMapBuilder.build(). }
false;public;1;13;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVInt(mappings.size()).     for (ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexEntry : mappings) {         out.writeString(indexEntry.key).         out.writeVInt(indexEntry.value.size()).         for (ObjectObjectCursor<String, MappingMetaData> typeEntry : indexEntry.value) {             out.writeString(typeEntry.key).             typeEntry.value.writeTo(out).         }     } }
false;public,static;1;27;;public static GetMappingsResponse fromXContent(XContentParser parser) throws IOException {     if (parser.currentToken() == null) {         parser.nextToken().     }     assert parser.currentToken() == XContentParser.Token.START_OBJECT.     Map<String, Object> parts = parser.map().     ImmutableOpenMap.Builder<String, ImmutableOpenMap<String, MappingMetaData>> builder = new ImmutableOpenMap.Builder<>().     for (Map.Entry<String, Object> entry : parts.entrySet()) {         final String indexName = entry.getKey().         assert entry.getValue() instanceof Map : "expected a map as type mapping, but got: " + entry.getValue().getClass().         final Map<String, Object> mapping = (Map<String, Object>) ((Map) entry.getValue()).get(MAPPINGS.getPreferredName()).         ImmutableOpenMap.Builder<String, MappingMetaData> typeBuilder = new ImmutableOpenMap.Builder<>().         for (Map.Entry<String, Object> typeEntry : mapping.entrySet()) {             final String typeName = typeEntry.getKey().             assert typeEntry.getValue() instanceof Map : "expected a map as inner type mapping, but got: " + typeEntry.getValue().getClass().             final Map<String, Object> fieldMappings = (Map<String, Object>) typeEntry.getValue().             MappingMetaData mmd = new MappingMetaData(typeName, fieldMappings).             typeBuilder.put(typeName, mmd).         }         builder.put(indexName, typeBuilder.build()).     }     return new GetMappingsResponse(builder.build()). }
false;public;2;36;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     boolean includeTypeName = params.paramAsBoolean(BaseRestHandler.INCLUDE_TYPE_NAME_PARAMETER, DEFAULT_INCLUDE_TYPE_NAME_POLICY).     for (final ObjectObjectCursor<String, ImmutableOpenMap<String, MappingMetaData>> indexEntry : getMappings()) {         builder.startObject(indexEntry.key).         {             if (includeTypeName == false) {                 MappingMetaData mappings = null.                 for (final ObjectObjectCursor<String, MappingMetaData> typeEntry : indexEntry.value) {                     if (typeEntry.key.equals("_default_") == false) {                         assert mappings == null.                         mappings = typeEntry.value.                     }                 }                 if (mappings == null) {                     // no mappings yet                     builder.startObject(MAPPINGS.getPreferredName()).endObject().                 } else {                     builder.field(MAPPINGS.getPreferredName(), mappings.sourceAsMap()).                 }             } else {                 builder.startObject(MAPPINGS.getPreferredName()).                 {                     for (final ObjectObjectCursor<String, MappingMetaData> typeEntry : indexEntry.value) {                         builder.field(typeEntry.key, typeEntry.value.sourceAsMap()).                     }                 }                 builder.endObject().             }         }         builder.endObject().     }     return builder. }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
false;public;0;4;;@Override public int hashCode() {     return mappings.hashCode(). }
false;public;1;13;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     GetMappingsResponse other = (GetMappingsResponse) obj.     return this.mappings.equals(other.mappings). }
