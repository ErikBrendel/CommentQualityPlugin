commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "cat_tasks_action". }
false;protected;1;4;;@Override protected void documentation(StringBuilder sb) {     sb.append("/_cat/tasks\n"). }
false;public;1;4;;@Override public RestResponse buildResponse(ListTasksResponse listTasksResponse) throws Exception {     return RestTable.buildResponse(buildTable(request, listTasksResponse), channel). }
false;public;2;10;;@Override public RestChannelConsumer doCatRequest(final RestRequest request, final NodeClient client) {     return channel -> client.admin().cluster().listTasks(generateListTasksRequest(request), new RestResponseListener<ListTasksResponse>(channel) {          @Override         public RestResponse buildResponse(ListTasksResponse listTasksResponse) throws Exception {             return RestTable.buildResponse(buildTable(request, listTasksResponse), channel).         }     }). }
false;protected;0;4;;@Override protected Set<String> responseParams() {     return RESPONSE_PARAMS. }
false;protected;1;31;;@Override protected Table getTableWithHeader(final RestRequest request) {     boolean detailed = request.paramAsBoolean("detailed", false).     Table table = new Table().     table.startHeaders().     // Task main info     table.addCell("id", "default:false.desc:id of the task with the node").     table.addCell("action", "alias:ac.desc:task action").     table.addCell("task_id", "alias:ti.desc:unique task id").     table.addCell("parent_task_id", "alias:pti.desc:parent task id").     table.addCell("type", "alias:ty.desc:task type").     table.addCell("start_time", "alias:start.desc:start time in ms").     table.addCell("timestamp", "alias:ts,hms,hhmmss.desc:start time in HH:MM:SS").     table.addCell("running_time_ns", "default:false.alias:time.desc:running time ns").     table.addCell("running_time", "default:true.alias:time.desc:running time").     // Node info     table.addCell("node_id", "default:false.alias:ni.desc:unique node id").     table.addCell("ip", "default:true.alias:i.desc:ip address").     table.addCell("port", "default:false.alias:po.desc:bound transport port").     table.addCell("node", "default:true.alias:n.desc:node name").     table.addCell("version", "default:false.alias:v.desc:es version").     // Task detailed info     if (detailed) {         table.addCell("description", "default:true.alias:desc.desc:task action").     }     table.endHeaders().     return table. }
false;private;5;31;;private void buildRow(Table table, boolean fullId, boolean detailed, DiscoveryNodes discoveryNodes, TaskInfo taskInfo) {     table.startRow().     String nodeId = taskInfo.getTaskId().getNodeId().     DiscoveryNode node = discoveryNodes.get(nodeId).     table.addCell(taskInfo.getId()).     table.addCell(taskInfo.getAction()).     table.addCell(taskInfo.getTaskId().toString()).     if (taskInfo.getParentTaskId().isSet()) {         table.addCell(taskInfo.getParentTaskId().toString()).     } else {         table.addCell("-").     }     table.addCell(taskInfo.getType()).     table.addCell(taskInfo.getStartTime()).     table.addCell(FORMATTER.format(Instant.ofEpochMilli(taskInfo.getStartTime()))).     table.addCell(taskInfo.getRunningTimeNanos()).     table.addCell(TimeValue.timeValueNanos(taskInfo.getRunningTimeNanos()).toString()).     // Node information. Note that the node may be null because it has left the cluster between when we got this response and now.     table.addCell(fullId ? nodeId : Strings.substring(nodeId, 0, 4)).     table.addCell(node == null ? "-" : node.getHostAddress()).     table.addCell(node.getAddress().address().getPort()).     table.addCell(node == null ? "-" : node.getName()).     table.addCell(node == null ? "-" : node.getVersion().toString()).     if (detailed) {         table.addCell(taskInfo.getDescription()).     }     table.endRow(). }
false;private;4;9;;private void buildGroups(Table table, boolean fullId, boolean detailed, List<TaskGroup> taskGroups) {     DiscoveryNodes discoveryNodes = nodesInCluster.get().     List<TaskGroup> sortedGroups = new ArrayList<>(taskGroups).     sortedGroups.sort(Comparator.comparingLong(o -> o.getTaskInfo().getStartTime())).     for (TaskGroup taskGroup : sortedGroups) {         buildRow(table, fullId, detailed, discoveryNodes, taskGroup.getTaskInfo()).         buildGroups(table, fullId, detailed, taskGroup.getChildTasks()).     } }
false;private;2;7;;private Table buildTable(RestRequest request, ListTasksResponse listTasksResponse) {     boolean fullId = request.paramAsBoolean("full_id", false).     boolean detailed = request.paramAsBoolean("detailed", false).     Table table = getTableWithHeader(request).     buildGroups(table, fullId, detailed, listTasksResponse.getTaskGroups()).     return table. }
