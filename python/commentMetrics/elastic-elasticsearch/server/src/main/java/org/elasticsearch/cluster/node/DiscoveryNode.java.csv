commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;11;;public static boolean nodeRequiresLocalStorage(Settings settings) {     boolean localStorageEnable = Node.NODE_LOCAL_STORAGE_SETTING.get(settings).     if (localStorageEnable == false && (Node.NODE_DATA_SETTING.get(settings) || Node.NODE_MASTER_SETTING.get(settings))) {         // TODO: make this a proper setting validation logic, requiring multi-settings validation         throw new IllegalArgumentException("storage can not be disabled for master and data nodes").     }     return localStorageEnable. }
false;public,static;1;3;;public static boolean isMasterNode(Settings settings) {     return Node.NODE_MASTER_SETTING.get(settings). }
false;public,static;1;3;;public static boolean isDataNode(Settings settings) {     return Node.NODE_DATA_SETTING.get(settings). }
false;public,static;1;3;;public static boolean isIngestNode(Settings settings) {     return Node.NODE_INGEST_SETTING.get(settings). }
true;public,static;3;5;/**  * Creates a DiscoveryNode representing the local node.  */ ;/**  * Creates a DiscoveryNode representing the local node.  */ public static DiscoveryNode createLocal(Settings settings, TransportAddress publishAddress, String nodeId) {     Map<String, String> attributes = Node.NODE_ATTRIBUTES.getAsMap(settings).     Set<Role> roles = getRolesFromSettings(settings).     return new DiscoveryNode(Node.NODE_NAME_SETTING.get(settings), nodeId, publishAddress, attributes, roles, Version.CURRENT). }
true;public,static;1;13;/**  * extract node roles from the given settings  */ ;/**  * extract node roles from the given settings  */ public static Set<Role> getRolesFromSettings(Settings settings) {     Set<Role> roles = EnumSet.noneOf(Role.class).     if (Node.NODE_INGEST_SETTING.get(settings)) {         roles.add(Role.INGEST).     }     if (Node.NODE_MASTER_SETTING.get(settings)) {         roles.add(Role.MASTER).     }     if (Node.NODE_DATA_SETTING.get(settings)) {         roles.add(Role.DATA).     }     return roles. }
false;public;1;19;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(nodeName).     out.writeString(nodeId).     out.writeString(ephemeralId).     out.writeString(hostName).     out.writeString(hostAddress).     address.writeTo(out).     out.writeVInt(attributes.size()).     for (Map.Entry<String, String> entry : attributes.entrySet()) {         out.writeString(entry.getKey()).         out.writeString(entry.getValue()).     }     out.writeVInt(roles.size()).     for (Role role : roles) {         out.writeEnum(role).     }     Version.writeVersion(version, out). }
true;public;0;3;/**  * The address that the node can be communicated with.  */ ;/**  * The address that the node can be communicated with.  */ public TransportAddress getAddress() {     return address. }
true;public;0;3;/**  * The unique id of the node.  */ ;/**  * The unique id of the node.  */ public String getId() {     return nodeId. }
true;public;0;3;/**  * The unique ephemeral id of the node. Ephemeral ids are meant to be attached the life span  * of a node process. When ever a node is restarted, it's ephemeral id is required to change (while it's {@link #getId()}  * will be read from the data folder and will remain the same across restarts). Since all node attributes and addresses  * are maintained during the life span of a node process, we can (and are) using the ephemeralId in  * {@link DiscoveryNode#equals(Object)}.  */ ;/**  * The unique ephemeral id of the node. Ephemeral ids are meant to be attached the life span  * of a node process. When ever a node is restarted, it's ephemeral id is required to change (while it's {@link #getId()}  * will be read from the data folder and will remain the same across restarts). Since all node attributes and addresses  * are maintained during the life span of a node process, we can (and are) using the ephemeralId in  * {@link DiscoveryNode#equals(Object)}.  */ public String getEphemeralId() {     return ephemeralId. }
true;public;0;3;/**  * The name of the node.  */ ;/**  * The name of the node.  */ public String getName() {     return this.nodeName. }
true;public;0;3;/**  * The node attributes.  */ ;/**  * The node attributes.  */ public Map<String, String> getAttributes() {     return this.attributes. }
true;public;0;3;/**  * Should this node hold data (shards) or not.  */ ;/**  * Should this node hold data (shards) or not.  */ public boolean isDataNode() {     return roles.contains(Role.DATA). }
true;public;0;3;/**  * Can this node become master or not.  */ ;/**  * Can this node become master or not.  */ public boolean isMasterNode() {     return roles.contains(Role.MASTER). }
true;public;0;3;/**  * Returns a boolean that tells whether this an ingest node or not  */ ;/**  * Returns a boolean that tells whether this an ingest node or not  */ public boolean isIngestNode() {     return roles.contains(Role.INGEST). }
true;public;0;3;/**  * Returns a set of all the roles that the node fulfills.  * If the node doesn't have any specific role, the set is returned empty, which means that the node is a coordinating only node.  */ ;/**  * Returns a set of all the roles that the node fulfills.  * If the node doesn't have any specific role, the set is returned empty, which means that the node is a coordinating only node.  */ public Set<Role> getRoles() {     return roles. }
false;public;0;3;;public Version getVersion() {     return this.version. }
false;public;0;3;;public String getHostName() {     return this.hostName. }
false;public;0;3;;public String getHostAddress() {     return this.hostAddress. }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     DiscoveryNode that = (DiscoveryNode) o.     return ephemeralId.equals(that.ephemeralId). }
false;public;0;7;;@Override public int hashCode() {     // This is done so that this class can be used efficiently as a key in a map     return ephemeralId.hashCode(). }
false;public;0;15;;@Override public String toString() {     StringBuilder sb = new StringBuilder().     if (nodeName.length() > 0) {         sb.append('{').append(nodeName).append('}').     }     sb.append('{').append(nodeId).append('}').     sb.append('{').append(ephemeralId).append('}').     sb.append('{').append(hostName).append('}').     sb.append('{').append(address).append('}').     if (!attributes.isEmpty()) {         sb.append(attributes).     }     return sb.toString(). }
false;public;2;16;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(getId()).     builder.field("name", getName()).     builder.field("ephemeral_id", getEphemeralId()).     builder.field("transport_address", getAddress().toString()).     builder.startObject("attributes").     for (Map.Entry<String, String> entry : attributes.entrySet()) {         builder.field(entry.getKey(), entry.getValue()).     }     builder.endObject().     builder.endObject().     return builder. }
false;public;0;3;;public String getRoleName() {     return roleName. }
false;public;0;3;;public String getAbbreviation() {     return abbreviation. }
