commented;modifiers;parameterAmount;loc;comment;code
true;private,static;4;5;/**  * Puts the lower numberOfLongBytes from l into the array, starting index pos.  */ ;/**  * Puts the lower numberOfLongBytes from l into the array, starting index pos.  */ private static void putLong(byte[] array, long l, int pos, int numberOfLongBytes) {     for (int i = 0. i < numberOfLongBytes. ++i) {         array[pos + numberOfLongBytes - i - 1] = (byte) (l >>> (i * 8)).     } }
false;public;0;34;;@Override public String getBase64UUID() {     final int sequenceId = sequenceNumber.incrementAndGet() & 0xffffff.     long timestamp = System.currentTimeMillis().     synchronized (this) {         // Don't let timestamp go backwards, at least "on our watch" (while this JVM is running).  We are still vulnerable if we are         // shut down, clock goes backwards, and we restart... for this we randomize the sequenceNumber on init to decrease chance of         // collision:         timestamp = Math.max(lastTimestamp, timestamp).         if (sequenceId == 0) {             // Always force the clock to increment whenever sequence number is 0, in case we have a long time-slip backwards:             timestamp++.         }         lastTimestamp = timestamp.     }     final byte[] uuidBytes = new byte[15].     // Only use lower 6 bytes of the timestamp (this will suffice beyond the year 10000):     putLong(uuidBytes, timestamp, 0, 6).     // MAC address adds 6 bytes:     System.arraycopy(SECURE_MUNGED_ADDRESS, 0, uuidBytes, 6, SECURE_MUNGED_ADDRESS.length).     // Sequence number adds 3 bytes:     putLong(uuidBytes, sequenceId, 12, 3).     assert 9 + SECURE_MUNGED_ADDRESS.length == uuidBytes.length.     return Base64.getUrlEncoder().withoutPadding().encodeToString(uuidBytes). }
