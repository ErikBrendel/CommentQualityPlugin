commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;3;;public static PersistentTasksCustomMetaData getPersistentTasksCustomMetaData(ClusterState clusterState) {     return clusterState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE). }
false;private;1;4;;private TaskDescriptionBuilder setParams(Params params) {     this.params = params.     return this. }
false;private;1;4;;private TaskDescriptionBuilder setState(PersistentTaskState state) {     this.state = state.     return this. }
false;public;0;3;;public Collection<PersistentTask<?>> tasks() {     return this.tasks.values(). }
false;public;0;3;;public Map<String, PersistentTask<?>> taskMap() {     return this.tasks. }
false;public;1;3;;public PersistentTask<?> getTask(String id) {     return this.tasks.get(id). }
false;public;2;6;;public Collection<PersistentTask<?>> findTasks(String taskName, Predicate<PersistentTask<?>> predicate) {     return this.tasks().stream().filter(p -> taskName.equals(p.getTaskName())).filter(predicate).collect(Collectors.toList()). }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     PersistentTasksCustomMetaData that = (PersistentTasksCustomMetaData) o.     return lastAllocationId == that.lastAllocationId && Objects.equals(tasks, that.tasks). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(tasks, lastAllocationId). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
false;public;2;4;;public long getNumberOfTasksOnNode(String nodeId, String taskName) {     return tasks.values().stream().filter(task -> taskName.equals(task.taskName) && nodeId.equals(task.assignment.executorNode)).count(). }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return Version.CURRENT.minimumCompatibilityVersion(). }
false;public;0;4;;@Override public EnumSet<MetaData.XContentContext> context() {     return ALL_CONTEXTS. }
false;public,static;1;3;;public static PersistentTasksCustomMetaData fromXContent(XContentParser parser) {     return PERSISTENT_TASKS_PARSER.apply(parser, null).build(). }
false;public,static;2;8;;@SuppressWarnings("unchecked") public static <Params extends PersistentTaskParams> PersistentTask<Params> getTaskWithId(ClusterState clusterState, String taskId) {     PersistentTasksCustomMetaData tasks = clusterState.metaData().custom(PersistentTasksCustomMetaData.TYPE).     if (tasks != null) {         return (PersistentTask<Params>) tasks.getTask(taskId).     }     return null. }
true;public,static;1;22;/**  * Unassign any persistent tasks executing on nodes that are no longer in  * the cluster. If the task's assigment has a non-null executor node and that  * node is no longer in the cluster then the assignment is set to  * {@link #LOST_NODE_ASSIGNMENT}  *  * @param clusterState The clusterstate  * @return If no changes the argument {@code clusterState} is returned else  *          a copy with the modified tasks  */ ;/**  * Unassign any persistent tasks executing on nodes that are no longer in  * the cluster. If the task's assigment has a non-null executor node and that  * node is no longer in the cluster then the assignment is set to  * {@link #LOST_NODE_ASSIGNMENT}  *  * @param clusterState The clusterstate  * @return If no changes the argument {@code clusterState} is returned else  *          a copy with the modified tasks  */ public static ClusterState disassociateDeadNodes(ClusterState clusterState) {     PersistentTasksCustomMetaData tasks = getPersistentTasksCustomMetaData(clusterState).     if (tasks == null) {         return clusterState.     }     PersistentTasksCustomMetaData.Builder taskBuilder = PersistentTasksCustomMetaData.builder(tasks).     for (PersistentTask<?> task : tasks.tasks()) {         if (task.getAssignment().getExecutorNode() != null && clusterState.nodes().nodeExists(task.getAssignment().getExecutorNode()) == false) {             taskBuilder.reassignTask(task.getId(), LOST_NODE_ASSIGNMENT).         }     }     if (taskBuilder.isChanged() == false) {         return clusterState.     }     MetaData.Builder metaDataBuilder = MetaData.builder(clusterState.metaData()).     metaDataBuilder.putCustom(TYPE, taskBuilder.build()).     return ClusterState.builder(clusterState).metaData(metaDataBuilder).build(). }
false;public;0;4;;@Nullable public String getExecutorNode() {     return executorNode. }
false;public;0;3;;public String getExplanation() {     return explanation. }
false;public;1;8;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     Assignment that = (Assignment) o.     return Objects.equals(executorNode, that.executorNode) && Objects.equals(explanation, that.explanation). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(executorNode, explanation). }
false;public;0;3;;public boolean isAssigned() {     return executorNode != null. }
false;public;0;4;;@Override public String toString() {     return "node: [" + executorNode + "], explanation: [" + explanation + "]". }
false;public;1;15;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(id).     out.writeLong(allocationId).     out.writeString(taskName).     if (out.getVersion().onOrAfter(Version.V_6_3_0)) {         out.writeNamedWriteable(params).     } else {         out.writeOptionalNamedWriteable(params).     }     out.writeOptionalNamedWriteable(state).     out.writeOptionalString(assignment.executorNode).     out.writeString(assignment.explanation).     out.writeOptionalLong(allocationIdOnLastStatusUpdate). }
false;public;1;13;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     PersistentTask<?> that = (PersistentTask<?>) o.     return Objects.equals(id, that.id) && allocationId == that.allocationId && Objects.equals(taskName, that.taskName) && Objects.equals(params, that.params) && Objects.equals(state, that.state) && Objects.equals(assignment, that.assignment) && Objects.equals(allocationIdOnLastStatusUpdate, that.allocationIdOnLastStatusUpdate). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(id, allocationId, taskName, params, state, assignment, allocationIdOnLastStatusUpdate). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this). }
false;public;0;3;;public String getId() {     return id. }
false;public;0;3;;public long getAllocationId() {     return allocationId. }
false;public;0;3;;public String getTaskName() {     return taskName. }
false;public;0;4;;@Nullable public P getParams() {     return params. }
false;public;0;4;;@Nullable public String getExecutorNode() {     return assignment.executorNode. }
false;public;0;3;;public Assignment getAssignment() {     return assignment. }
false;public;0;3;;public boolean isAssigned() {     return assignment.isAssigned(). }
false;public;0;4;;@Nullable public PersistentTaskState getState() {     return state. }
false;public;2;37;;@Override public XContentBuilder toXContent(XContentBuilder builder, ToXContent.Params xParams) throws IOException {     builder.startObject().     {         builder.field("id", id).         builder.startObject("task").         {             builder.startObject(taskName).             {                 if (params != null) {                     builder.field("params", params, xParams).                 }                 if (state != null) {                     builder.field("state", state, xParams).                 }             }             builder.endObject().         }         builder.endObject().         if (API_CONTEXT.equals(xParams.param(MetaData.CONTEXT_MODE_PARAM, API_CONTEXT))) {             // These are transient values that shouldn't be persisted to gateway cluster state or snapshot             builder.field("allocation_id", allocationId).             builder.startObject("assignment").             {                 builder.field("executor_node", assignment.executorNode).                 builder.field("explanation", assignment.explanation).             }             builder.endObject().             if (allocationIdOnLastStatusUpdate != null) {                 builder.field("allocation_id_on_last_status_update", allocationIdOnLastStatusUpdate).             }         }     }     builder.endObject().     return builder. }
false;public;0;4;;@Override public boolean isFragment() {     return false. }
false;public;1;4;;public TaskBuilder<Params> setId(String id) {     this.id = id.     return this. }
false;public;1;4;;public TaskBuilder<Params> setAllocationId(long allocationId) {     this.allocationId = allocationId.     return this. }
false;public;1;4;;public TaskBuilder<Params> setTaskName(String taskName) {     this.taskName = taskName.     return this. }
false;public;1;4;;public TaskBuilder<Params> setParams(Params params) {     this.params = params.     return this. }
false;public;1;4;;public TaskBuilder<Params> setState(PersistentTaskState state) {     this.state = state.     return this. }
false;public;1;4;;public TaskBuilder<Params> setAssignment(Assignment assignment) {     this.assignment = assignment.     return this. }
false;public;1;4;;public TaskBuilder<Params> setAllocationIdOnLastStatusUpdate(Long allocationIdOnLastStatusUpdate) {     this.allocationIdOnLastStatusUpdate = allocationIdOnLastStatusUpdate.     return this. }
false;public;0;3;;public PersistentTask<Params> build() {     return new PersistentTask<>(id, allocationId, taskName, params, state, assignment, allocationIdOnLastStatusUpdate). }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeLong(lastAllocationId).     Map<String, PersistentTask<?>> filteredTasks = tasks.values().stream().filter(t -> ClusterState.FeatureAware.shouldSerialize(out, t.getParams())).collect(Collectors.toMap(PersistentTask::getId, Function.identity())).     out.writeMap(filteredTasks, StreamOutput::writeString, (stream, value) -> value.writeTo(stream)). }
false;public,static;1;3;;public static NamedDiff<MetaData.Custom> readDiffFrom(StreamInput in) throws IOException {     return readDiffFrom(MetaData.Custom.class, TYPE, in). }
false;public;2;12;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field("last_allocation_id", lastAllocationId).     builder.startArray("tasks").     {         for (PersistentTask<?> entry : tasks.values()) {             entry.toXContent(builder, params).         }     }     builder.endArray().     return builder. }
false;public,static;0;3;;public static Builder builder() {     return new Builder(). }
false;public,static;1;3;;public static Builder builder(PersistentTasksCustomMetaData tasks) {     return new Builder(tasks). }
false;public;0;3;;public long getLastAllocationId() {     return lastAllocationId. }
false;private;1;4;;private Builder setLastAllocationId(long currentId) {     this.lastAllocationId = currentId.     return this. }
false;private;1;7;;private <Params extends PersistentTaskParams> Builder setTasks(List<TaskBuilder<Params>> tasks) {     for (TaskBuilder builder : tasks) {         PersistentTask<?> task = builder.build().         this.tasks.put(task.getId(), task).     }     return this. }
false;private;0;4;;private long getNextAllocationId() {     lastAllocationId++.     return lastAllocationId. }
true;public;4;10;/**  * Adds a new task to the builder  * <p>  * After the task is added its id can be found by calling {{@link #getLastAllocationId()}} method.  */ ;/**  * Adds a new task to the builder  * <p>  * After the task is added its id can be found by calling {{@link #getLastAllocationId()}} method.  */ public <Params extends PersistentTaskParams> Builder addTask(String taskId, String taskName, Params params, Assignment assignment) {     changed = true.     PersistentTask<?> previousTask = tasks.put(taskId, new PersistentTask<>(taskId, taskName, params, getNextAllocationId(), assignment)).     if (previousTask != null) {         throw new ResourceAlreadyExistsException("Trying to override task with id {" + taskId + "}").     }     return this. }
true;public;2;10;/**  * Reassigns the task to another node  */ ;/**  * Reassigns the task to another node  */ public Builder reassignTask(String taskId, Assignment assignment) {     PersistentTask<?> taskInProgress = tasks.get(taskId).     if (taskInProgress != null) {         changed = true.         tasks.put(taskId, new PersistentTask<>(taskInProgress, getNextAllocationId(), assignment)).     } else {         throw new ResourceNotFoundException("cannot reassign task with id {" + taskId + "}, the task no longer exists").     }     return this. }
true;public;2;10;/**  * Updates the task state  */ ;/**  * Updates the task state  */ public Builder updateTaskState(final String taskId, final PersistentTaskState taskState) {     PersistentTask<?> taskInProgress = tasks.get(taskId).     if (taskInProgress != null) {         changed = true.         tasks.put(taskId, new PersistentTask<>(taskInProgress, taskState)).     } else {         throw new ResourceNotFoundException("cannot update task with id {" + taskId + "}, the task no longer exists").     }     return this. }
true;public;1;8;/**  * Removes the task  */ ;/**  * Removes the task  */ public Builder removeTask(String taskId) {     if (tasks.remove(taskId) != null) {         changed = true.     } else {         throw new ResourceNotFoundException("cannot remove task with id {" + taskId + "}, the task no longer exists").     }     return this. }
true;public;1;3;/**  * Checks if the task is currently present in the list  */ ;/**  * Checks if the task is currently present in the list  */ public boolean hasTask(String taskId) {     return tasks.containsKey(taskId). }
true;public;2;7;/**  * Checks if the task is currently present in the list and has the right allocation id  */ ;/**  * Checks if the task is currently present in the list and has the right allocation id  */ public boolean hasTask(String taskId, long allocationId) {     PersistentTask<?> taskInProgress = tasks.get(taskId).     if (taskInProgress != null) {         return taskInProgress.getAllocationId() == allocationId.     }     return false. }
false;;0;3;;Set<String> getCurrentTaskIds() {     return tasks.keySet(). }
true;public;0;3;/**  * Returns true if any the task list was changed since the builder was created  */ ;/**  * Returns true if any the task list was changed since the builder was created  */ public boolean isChanged() {     return changed. }
false;public;0;3;;public PersistentTasksCustomMetaData build() {     return new PersistentTasksCustomMetaData(lastAllocationId, Collections.unmodifiableMap(tasks)). }
