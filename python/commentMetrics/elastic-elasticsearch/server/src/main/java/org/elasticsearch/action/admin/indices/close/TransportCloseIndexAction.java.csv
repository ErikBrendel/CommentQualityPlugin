commented;modifiers;parameterAmount;loc;comment;code
false;private;1;3;;private void setCloseIndexEnabled(boolean closeIndexEnabled) {     this.closeIndexEnabled = closeIndexEnabled. }
false;protected;0;5;;@Override protected String executor() {     // no need to use a thread pool, we go async right away     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected CloseIndexResponse newResponse() {     return new CloseIndexResponse(). }
false;protected;3;9;;@Override protected void doExecute(Task task, CloseIndexRequest request, ActionListener<CloseIndexResponse> listener) {     destructiveOperations.failDestructive(request.indices()).     if (closeIndexEnabled == false) {         throw new IllegalStateException("closing indices is disabled - set [" + CLUSTER_INDICES_CLOSE_ENABLE_SETTING.getKey() + ": true] to enable it. NOTE: closed indices still consume a significant amount of diskspace").     }     super.doExecute(task, request, listener). }
false;protected;2;5;;@Override protected ClusterBlockException checkBlock(CloseIndexRequest request, ClusterState state) {     return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_WRITE, indexNameExpressionResolver.concreteIndexNames(state, request)). }
false;protected;3;6;;@Override protected void masterOperation(final CloseIndexRequest request, final ClusterState state, final ActionListener<CloseIndexResponse> listener) {     throw new UnsupportedOperationException("The task parameter is required"). }
false;public;1;4;;@Override public void onResponse(final CloseIndexResponse response) {     listener.onResponse(response). }
false;public;1;5;;@Override public void onFailure(final Exception t) {     logger.debug(() -> new ParameterizedMessage("failed to close indices [{}]", (Object) concreteIndices), t).     listener.onFailure(t). }
false;protected;4;31;;@Override protected void masterOperation(final Task task, final CloseIndexRequest request, final ClusterState state, final ActionListener<CloseIndexResponse> listener) throws Exception {     final Index[] concreteIndices = indexNameExpressionResolver.concreteIndices(state, request).     if (concreteIndices == null || concreteIndices.length == 0) {         listener.onResponse(new CloseIndexResponse(true, false)).         return.     }     final CloseIndexClusterStateUpdateRequest closeRequest = new CloseIndexClusterStateUpdateRequest(task.getId()).ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout()).waitForActiveShards(request.waitForActiveShards()).indices(concreteIndices).     indexStateService.closeIndices(closeRequest, new ActionListener<CloseIndexResponse>() {          @Override         public void onResponse(final CloseIndexResponse response) {             listener.onResponse(response).         }          @Override         public void onFailure(final Exception t) {             logger.debug(() -> new ParameterizedMessage("failed to close indices [{}]", (Object) concreteIndices), t).             listener.onFailure(t).         }     }). }
