commented;modifiers;parameterAmount;loc;comment;code
true;public;2;5;/**  * Add a new script to the existing stored scripts based on a user-specified id.  If  * a script with the same id already exists it will be overwritten.  * @param id The user-specified id to use for the look up.  * @param source The user-specified stored script data held in {@link StoredScriptSource}.  */ ;/**  * Add a new script to the existing stored scripts based on a user-specified id.  If  * a script with the same id already exists it will be overwritten.  * @param id The user-specified id to use for the look up.  * @param source The user-specified stored script data held in {@link StoredScriptSource}.  */ public Builder storeScript(String id, StoredScriptSource source) {     scripts.put(id, source).     return this. }
true;public;1;9;/**  * Delete a script from the existing stored scripts based on a user-specified id.  * @param id The user-specified id to use for the look up.  */ ;/**  * Delete a script from the existing stored scripts based on a user-specified id.  * @param id The user-specified id to use for the look up.  */ public Builder deleteScript(String id) {     StoredScriptSource deleted = scripts.remove(id).     if (deleted == null) {         throw new ResourceNotFoundException("stored script [" + id + "] does not exist and cannot be deleted").     }     return this. }
true;public;0;3;/**  * @return A {@link ScriptMetaData} with the updated {@link Map} of scripts.  */ ;/**  * @return A {@link ScriptMetaData} with the updated {@link Map} of scripts.  */ public ScriptMetaData build() {     return new ScriptMetaData(scripts). }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;public;1;4;;@Override public MetaData.Custom apply(MetaData.Custom part) {     return new ScriptMetaData(pipelines.apply(((ScriptMetaData) part).scripts)). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     pipelines.writeTo(out). }
true;static;3;6;/**  * Convenience method to build and return a new  * {@link ScriptMetaData} adding the specified stored script.  */ ;/**  * Convenience method to build and return a new  * {@link ScriptMetaData} adding the specified stored script.  */ static ScriptMetaData putStoredScript(ScriptMetaData previous, String id, StoredScriptSource source) {     Builder builder = new Builder(previous).     builder.storeScript(id, source).     return builder.build(). }
true;static;2;6;/**  * Convenience method to build and return a new  * {@link ScriptMetaData} deleting the specified stored script.  */ ;/**  * Convenience method to build and return a new  * {@link ScriptMetaData} deleting the specified stored script.  */ static ScriptMetaData deleteStoredScript(ScriptMetaData previous, String id) {     Builder builder = new ScriptMetaData.Builder(previous).     builder.deleteScript(id).     return builder.build(). }
true;public,static;1;90;/**  * This will parse XContent into {@link ScriptMetaData}.  *  * The following format will be parsed:  *  * {@code  * {  *     "<id>" : "<{@link StoredScriptSource#fromXContent(XContentParser, boolean)}>",  *     "<id>" : "<{@link StoredScriptSource#fromXContent(XContentParser, boolean)}>",  *     ...  * }  * }  *  * When loading from a source prior to 6.0, if multiple scripts  * using the old namespace id format of [lang#id] are found to have the  * same id but different languages an error will occur.  */ ;/**  * This will parse XContent into {@link ScriptMetaData}.  *  * The following format will be parsed:  *  * {@code  * {  *     "<id>" : "<{@link StoredScriptSource#fromXContent(XContentParser, boolean)}>",  *     "<id>" : "<{@link StoredScriptSource#fromXContent(XContentParser, boolean)}>",  *     ...  * }  * }  *  * When loading from a source prior to 6.0, if multiple scripts  * using the old namespace id format of [lang#id] are found to have the  * same id but different languages an error will occur.  */ public static ScriptMetaData fromXContent(XContentParser parser) throws IOException {     Map<String, StoredScriptSource> scripts = new HashMap<>().     String id = null.     StoredScriptSource source.     StoredScriptSource exists.     Token token = parser.currentToken().     if (token == null) {         token = parser.nextToken().     }     if (token != Token.START_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "unexpected token [" + token + "], expected [{]").     }     token = parser.nextToken().     while (token != Token.END_OBJECT) {         switch(token) {             case FIELD_NAME:                 id = parser.currentName().                 break.             case VALUE_STRING:                 if (id == null) {                     throw new ParsingException(parser.getTokenLocation(), "unexpected token [" + token + "], expected [<id>, <code>, {]").                 }                 int split = id.indexOf('#').                 String lang.                 if (split == -1) {                     throw new IllegalArgumentException("illegal stored script id [" + id + "], does not contain lang").                 } else {                     lang = id.substring(0, split).                     id = id.substring(split + 1).                     source = new StoredScriptSource(lang, parser.text(), Collections.emptyMap()).                     if (source.getSource().isEmpty()) {                         if (source.getLang().equals(Script.DEFAULT_TEMPLATE_LANG)) {                             deprecationLogger.deprecated("empty templates should no longer be used").                         } else {                             deprecationLogger.deprecated("empty scripts should no longer be used").                         }                     }                 }                 exists = scripts.get(id).                 if (exists == null) {                     scripts.put(id, source).                 } else if (exists.getLang().equals(lang) == false) {                     throw new IllegalArgumentException("illegal stored script, id [" + id + "] used for multiple scripts with " + "different languages [" + exists.getLang() + "] and [" + lang + "]. scripts using the old namespace " + "of [lang#id] as a stored script id will have to be updated to use only the new namespace of [id]").                 }                 id = null.                 break.             case START_OBJECT:                 if (id == null) {                     throw new ParsingException(parser.getTokenLocation(), "unexpected token [" + token + "], expected [<id>, <code>, {]").                 }                 exists = scripts.get(id).                 source = StoredScriptSource.fromXContent(parser, true).                 if (exists == null) {                     scripts.put(id, source).                 } else if (exists.getLang().equals(source.getLang()) == false) {                     throw new IllegalArgumentException("illegal stored script, id [" + id + "] used for multiple scripts with " + "different languages [" + exists.getLang() + "] and [" + source.getLang() + "]. scripts using the old " + "namespace of [lang#id] as a stored script id will have to be updated to use only the new namespace of [id]").                 }                 id = null.                 break.             default:                 throw new ParsingException(parser.getTokenLocation(), "unexpected token [" + token + "], expected [<id>, <code>, {]").         }         token = parser.nextToken().     }     return new ScriptMetaData(scripts). }
false;public,static;1;3;;public static NamedDiff<MetaData.Custom> readDiffFrom(StreamInput in) throws IOException {     return new ScriptMetadataDiff(in). }
false;public;1;9;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeVInt(scripts.size()).     for (Map.Entry<String, StoredScriptSource> entry : scripts.entrySet()) {         out.writeString(entry.getKey()).         entry.getValue().writeTo(out).     } }
true;public;2;9;/**  * This will write XContent from {@link ScriptMetaData}.  The following format will be written:  *  * {@code  * {  *     "<id>" : "<{@link StoredScriptSource#toXContent(XContentBuilder, Params)}>",  *     "<id>" : "<{@link StoredScriptSource#toXContent(XContentBuilder, Params)}>",  *     ...  * }  * }  */ ;/**  * This will write XContent from {@link ScriptMetaData}.  The following format will be written:  *  * {@code  * {  *     "<id>" : "<{@link StoredScriptSource#toXContent(XContentBuilder, Params)}>",  *     "<id>" : "<{@link StoredScriptSource#toXContent(XContentBuilder, Params)}>",  *     ...  * }  * }  */ @Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     for (Map.Entry<String, StoredScriptSource> entry : scripts.entrySet()) {         builder.field(entry.getKey()).         entry.getValue().toXContent(builder, params).     }     return builder. }
false;public;1;4;;@Override public Diff<MetaData.Custom> diff(MetaData.Custom before) {     return new ScriptMetadataDiff((ScriptMetaData) before, this). }
false;public;0;4;;@Override public String getWriteableName() {     return TYPE. }
false;public;0;4;;@Override public Version getMinimalSupportedVersion() {     return Version.CURRENT.minimumCompatibilityVersion(). }
false;public;0;4;;@Override public EnumSet<MetaData.XContentContext> context() {     return MetaData.ALL_CONTEXTS. }
true;;0;3;/**  * Returns the map of stored scripts.  */ ;/**  * Returns the map of stored scripts.  */ Map<String, StoredScriptSource> getStoredScripts() {     return scripts. }
true;;1;3;/**  * Retrieves a stored script based on a user-specified id.  */ ;/**  * Retrieves a stored script based on a user-specified id.  */ StoredScriptSource getStoredScript(String id) {     return scripts.get(id). }
false;public;1;10;;@Override public boolean equals(Object o) {     if (this == o)         return true.     if (o == null || getClass() != o.getClass())         return false.     ScriptMetaData that = (ScriptMetaData) o.     return scripts.equals(that.scripts). }
false;public;0;4;;@Override public int hashCode() {     return scripts.hashCode(). }
false;public;0;6;;@Override public String toString() {     return "ScriptMetaData{" + "scripts=" + scripts + '}'. }
