commented;modifiers;parameterAmount;loc;comment;code
false;public,static;1;5;;public static boolean discoveryIsConfigured(Settings settings) {     return Stream.of(DISCOVERY_SEED_PROVIDERS_SETTING, LEGACY_DISCOVERY_HOSTS_PROVIDER_SETTING, DISCOVERY_SEED_HOSTS_SETTING, LEGACY_DISCOVERY_ZEN_PING_UNICAST_HOSTS_SETTING, INITIAL_MASTER_NODES_SETTING).anyMatch(s -> s.exists(settings)). }
false;;0;31;;void onFoundPeersUpdated() {     final Set<DiscoveryNode> nodes = getDiscoveredNodes().     if (bootstrappingPermitted.get() && transportService.getLocalNode().isMasterNode() && bootstrapRequirements.isEmpty() == false && isBootstrappedSupplier.getAsBoolean() == false && nodes.stream().noneMatch(Coordinator::isZen1Node)) {         final Tuple<Set<DiscoveryNode>, List<String>> requirementMatchingResult.         try {             requirementMatchingResult = checkRequirements(nodes).         } catch (IllegalStateException e) {             logger.warn("bootstrapping cancelled", e).             bootstrappingPermitted.set(false).             return.         }         final Set<DiscoveryNode> nodesMatchingRequirements = requirementMatchingResult.v1().         final List<String> unsatisfiedRequirements = requirementMatchingResult.v2().         logger.trace("nodesMatchingRequirements={}, unsatisfiedRequirements={}, bootstrapRequirements={}", nodesMatchingRequirements, unsatisfiedRequirements, bootstrapRequirements).         if (nodesMatchingRequirements.contains(transportService.getLocalNode()) == false) {             logger.info("skipping cluster bootstrapping as local node does not match bootstrap requirements: {}", bootstrapRequirements).             bootstrappingPermitted.set(false).             return.         }         if (nodesMatchingRequirements.size() * 2 > bootstrapRequirements.size()) {             startBootstrap(nodesMatchingRequirements, unsatisfiedRequirements).         }     } }
false;public;0;11;;@Override public void run() {     final Set<DiscoveryNode> discoveredNodes = getDiscoveredNodes().     final List<DiscoveryNode> zen1Nodes = discoveredNodes.stream().filter(Coordinator::isZen1Node).collect(Collectors.toList()).     if (zen1Nodes.isEmpty()) {         logger.debug("performing best-effort cluster bootstrapping with {}", discoveredNodes).         startBootstrap(discoveredNodes, emptyList()).     } else {         logger.info("avoiding best-effort cluster bootstrapping due to discovery of pre-7.0 nodes {}", zen1Nodes).     } }
false;public;0;4;;@Override public String toString() {     return "unconfigured-discovery delayed bootstrap". }
false;;0;31;;void scheduleUnconfiguredBootstrap() {     if (unconfiguredBootstrapTimeout == null) {         return.     }     if (transportService.getLocalNode().isMasterNode() == false) {         return.     }     logger.info("no discovery configuration found, will perform best-effort cluster bootstrapping after [{}] " + "unless existing master is discovered", unconfiguredBootstrapTimeout).     transportService.getThreadPool().scheduleUnlessShuttingDown(unconfiguredBootstrapTimeout, Names.GENERIC, new Runnable() {          @Override         public void run() {             final Set<DiscoveryNode> discoveredNodes = getDiscoveredNodes().             final List<DiscoveryNode> zen1Nodes = discoveredNodes.stream().filter(Coordinator::isZen1Node).collect(Collectors.toList()).             if (zen1Nodes.isEmpty()) {                 logger.debug("performing best-effort cluster bootstrapping with {}", discoveredNodes).                 startBootstrap(discoveredNodes, emptyList()).             } else {                 logger.info("avoiding best-effort cluster bootstrapping due to discovery of pre-7.0 nodes {}", zen1Nodes).             }         }          @Override         public String toString() {             return "unconfigured-discovery delayed bootstrap".         }     }). }
false;private;0;4;;private Set<DiscoveryNode> getDiscoveredNodes() {     return Stream.concat(Stream.of(transportService.getLocalNode()), StreamSupport.stream(discoveredNodesSupplier.get().spliterator(), false)).collect(Collectors.toSet()). }
false;private;2;10;;private void startBootstrap(Set<DiscoveryNode> discoveryNodes, List<String> unsatisfiedRequirements) {     assert discoveryNodes.stream().allMatch(DiscoveryNode::isMasterNode) : discoveryNodes.     assert discoveryNodes.stream().noneMatch(Coordinator::isZen1Node) : discoveryNodes.     assert unsatisfiedRequirements.size() < discoveryNodes.size() : discoveryNodes + " smaller than " + unsatisfiedRequirements.     if (bootstrappingPermitted.compareAndSet(true, false)) {         doBootstrap(new VotingConfiguration(Stream.concat(discoveryNodes.stream().map(DiscoveryNode::getId), unsatisfiedRequirements.stream().map(s -> BOOTSTRAP_PLACEHOLDER_PREFIX + s)).collect(Collectors.toSet()))).     } }
false;public,static;1;3;;public static boolean isBootstrapPlaceholder(String nodeId) {     return nodeId.startsWith(BOOTSTRAP_PLACEHOLDER_PREFIX). }
false;public;0;4;;@Override public void run() {     doBootstrap(votingConfiguration). }
false;public;0;4;;@Override public String toString() {     return "retry of failed bootstrapping with " + votingConfiguration. }
false;private;1;22;;private void doBootstrap(VotingConfiguration votingConfiguration) {     assert transportService.getLocalNode().isMasterNode().     try {         votingConfigurationConsumer.accept(votingConfiguration).     } catch (Exception e) {         logger.warn(new ParameterizedMessage("exception when bootstrapping with {}, rescheduling", votingConfiguration), e).         transportService.getThreadPool().scheduleUnlessShuttingDown(TimeValue.timeValueSeconds(10), Names.GENERIC, new Runnable() {              @Override             public void run() {                 doBootstrap(votingConfiguration).             }              @Override             public String toString() {                 return "retry of failed bootstrapping with " + votingConfiguration.             }         }).     } }
false;private,static;2;5;;private static boolean matchesRequirement(DiscoveryNode discoveryNode, String requirement) {     return discoveryNode.getName().equals(requirement) || discoveryNode.getAddress().toString().equals(requirement) || discoveryNode.getAddress().getAddress().equals(requirement). }
false;private;1;25;;private Tuple<Set<DiscoveryNode>, List<String>> checkRequirements(Set<DiscoveryNode> nodes) {     final Set<DiscoveryNode> selectedNodes = new HashSet<>().     final List<String> unmatchedRequirements = new ArrayList<>().     for (final String bootstrapRequirement : bootstrapRequirements) {         final Set<DiscoveryNode> matchingNodes = nodes.stream().filter(n -> matchesRequirement(n, bootstrapRequirement)).collect(Collectors.toSet()).         if (matchingNodes.size() == 0) {             unmatchedRequirements.add(bootstrapRequirement).         }         if (matchingNodes.size() > 1) {             throw new IllegalStateException("requirement [" + bootstrapRequirement + "] matches multiple nodes: " + matchingNodes).         }         for (final DiscoveryNode matchingNode : matchingNodes) {             if (selectedNodes.add(matchingNode) == false) {                 throw new IllegalStateException("node [" + matchingNode + "] matches multiple requirements: " + bootstrapRequirements.stream().filter(r -> matchesRequirement(matchingNode, r)).collect(Collectors.toList())).             }         }     }     return Tuple.tuple(selectedNodes, unmatchedRequirements). }
