commented;modifiers;parameterAmount;loc;comment;code
false;public;0;18;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = targetIndexRequest == null ? null : targetIndexRequest.validate().     if (sourceIndex == null) {         validationException = addValidationError("source index is missing", validationException).     }     if (targetIndexRequest == null) {         validationException = addValidationError("target index request is missing", validationException).     }     if (targetIndexRequest.settings().getByPrefix("index.sort.").isEmpty() == false) {         validationException = addValidationError("can't override index sort when resizing an index", validationException).     }     if (type == ResizeType.SPLIT && IndexMetaData.INDEX_NUMBER_OF_SHARDS_SETTING.exists(targetIndexRequest.settings()) == false) {         validationException = addValidationError("index.number_of_shards is required for split operations", validationException).     }     assert copySettings == null || copySettings.     return validationException. }
false;public;1;3;;public void setSourceIndex(String index) {     this.sourceIndex = index. }
false;public;1;17;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     targetIndexRequest = new CreateIndexRequest().     targetIndexRequest.readFrom(in).     sourceIndex = in.readString().     if (in.getVersion().onOrAfter(ResizeAction.COMPATIBILITY_VERSION)) {         type = in.readEnum(ResizeType.class).     } else {         // BWC this used to be shrink only         type = ResizeType.SHRINK.     }     if (in.getVersion().before(Version.V_6_4_0)) {         copySettings = null.     } else {         copySettings = in.readOptionalBoolean().     } }
false;public;1;15;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     targetIndexRequest.writeTo(out).     out.writeString(sourceIndex).     if (out.getVersion().onOrAfter(ResizeAction.COMPATIBILITY_VERSION)) {         out.writeEnum(type).     }     // noinspection StatementWithEmptyBody     if (out.getVersion().before(Version.V_6_4_0)) {     } else {         out.writeOptionalBoolean(copySettings).     } }
false;public;0;4;;@Override public String[] indices() {     return new String[] { sourceIndex }. }
false;public;0;4;;@Override public IndicesOptions indicesOptions() {     return IndicesOptions.lenientExpandOpen(). }
false;public;1;3;;public void setTargetIndex(CreateIndexRequest targetIndexRequest) {     this.targetIndexRequest = Objects.requireNonNull(targetIndexRequest, "target index request must not be null"). }
true;public;0;3;/**  * Returns the {@link CreateIndexRequest} for the shrink index  */ ;/**  * Returns the {@link CreateIndexRequest} for the shrink index  */ public CreateIndexRequest getTargetIndexRequest() {     return targetIndexRequest. }
true;public;0;3;/**  * Returns the source index name  */ ;/**  * Returns the source index name  */ public String getSourceIndex() {     return sourceIndex. }
true;public;1;3;/**  * Sets the number of shard copies that should be active for creation of the  * new shrunken index to return. Defaults to {@link ActiveShardCount#DEFAULT}, which will  * wait for one shard copy (the primary) to become active. Set this value to  * {@link ActiveShardCount#ALL} to wait for all shards (primary and all replicas) to be active  * before returning. Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any  * non-negative integer, up to the number of copies per shard (number of replicas + 1),  * to wait for the desired amount of shard copies to become active before returning.  * Index creation will only wait up until the timeout value for the number of shard copies  * to be active before returning.  Check {@link ResizeResponse#isShardsAcknowledged()} to  * determine if the requisite shard copies were all started before returning or timing out.  *  * @param waitForActiveShards number of active shard copies to wait on  */ ;/**  * Sets the number of shard copies that should be active for creation of the  * new shrunken index to return. Defaults to {@link ActiveShardCount#DEFAULT}, which will  * wait for one shard copy (the primary) to become active. Set this value to  * {@link ActiveShardCount#ALL} to wait for all shards (primary and all replicas) to be active  * before returning. Otherwise, use {@link ActiveShardCount#from(int)} to set this value to any  * non-negative integer, up to the number of copies per shard (number of replicas + 1),  * to wait for the desired amount of shard copies to become active before returning.  * Index creation will only wait up until the timeout value for the number of shard copies  * to be active before returning.  Check {@link ResizeResponse#isShardsAcknowledged()} to  * determine if the requisite shard copies were all started before returning or timing out.  *  * @param waitForActiveShards number of active shard copies to wait on  */ public void setWaitForActiveShards(ActiveShardCount waitForActiveShards) {     this.getTargetIndexRequest().waitForActiveShards(waitForActiveShards). }
true;public;1;3;/**  * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ ;/**  * A shortcut for {@link #setWaitForActiveShards(ActiveShardCount)} where the numerical  * shard count is passed in, instead of having to first call {@link ActiveShardCount#from(int)}  * to get the ActiveShardCount.  */ public void setWaitForActiveShards(final int waitForActiveShards) {     setWaitForActiveShards(ActiveShardCount.from(waitForActiveShards)). }
true;public;1;3;/**  * The type of the resize operation  */ ;/**  * The type of the resize operation  */ public void setResizeType(ResizeType type) {     this.type = Objects.requireNonNull(type). }
true;public;0;3;/**  * Returns the type of the resize operation  */ ;/**  * Returns the type of the resize operation  */ public ResizeType getResizeType() {     return type. }
false;public;1;6;;public void setCopySettings(final Boolean copySettings) {     if (copySettings != null && copySettings == false) {         throw new IllegalArgumentException("[copySettings] can not be explicitly set to [false]").     }     this.copySettings = copySettings. }
false;public;0;3;;public Boolean getCopySettings() {     return copySettings. }
false;public;2;20;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     {         builder.startObject(CreateIndexRequest.SETTINGS.getPreferredName()).         {             targetIndexRequest.settings().toXContent(builder, params).         }         builder.endObject().         builder.startObject(CreateIndexRequest.ALIASES.getPreferredName()).         {             for (Alias alias : targetIndexRequest.aliases()) {                 alias.toXContent(builder, params).             }         }         builder.endObject().     }     builder.endObject().     return builder. }
false;public;1;3;;public void fromXContent(XContentParser parser) throws IOException {     PARSER.parse(parser, this, null). }
