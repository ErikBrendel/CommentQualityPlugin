commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Adds allocation commands to be applied to the cluster. Note, can be empty, in which case  * will simply run a simple "reroute".  */ ;/**  * Adds allocation commands to be applied to the cluster. Note, can be empty, in which case  * will simply run a simple "reroute".  */ public ClusterRerouteRequest add(AllocationCommand... commands) {     this.commands.add(commands).     return this. }
true;public;1;4;/**  * Sets a dry run flag (defaults to {@code false}) allowing to run the commands without  * actually applying them to the cluster state, and getting the resulting cluster state back.  */ ;/**  * Sets a dry run flag (defaults to {@code false}) allowing to run the commands without  * actually applying them to the cluster state, and getting the resulting cluster state back.  */ public ClusterRerouteRequest dryRun(boolean dryRun) {     this.dryRun = dryRun.     return this. }
true;public;0;3;/**  * Returns the current dry run flag which allows to run the commands without actually applying them,  * just to get back the resulting cluster state back.  */ ;/**  * Returns the current dry run flag which allows to run the commands without actually applying them,  * just to get back the resulting cluster state back.  */ public boolean dryRun() {     return this.dryRun. }
true;public;1;4;/**  * Sets the explain flag, which will collect information about the reroute  * request without executing the actions. Similar to dryRun,  * but human-readable.  */ ;/**  * Sets the explain flag, which will collect information about the reroute  * request without executing the actions. Similar to dryRun,  * but human-readable.  */ public ClusterRerouteRequest explain(boolean explain) {     this.explain = explain.     return this. }
true;public;1;4;/**  * Sets the retry failed flag (defaults to {@code false}). If true, the  * request will retry allocating shards that can't currently be allocated due to too many allocation failures.  */ ;/**  * Sets the retry failed flag (defaults to {@code false}). If true, the  * request will retry allocating shards that can't currently be allocated due to too many allocation failures.  */ public ClusterRerouteRequest setRetryFailed(boolean retryFailed) {     this.retryFailed = retryFailed.     return this. }
true;public;0;3;/**  * Returns the current explain flag  */ ;/**  * Returns the current explain flag  */ public boolean explain() {     return this.explain. }
true;public;0;3;/**  * Returns the current retry failed flag  */ ;/**  * Returns the current retry failed flag  */ public boolean isRetryFailed() {     return this.retryFailed. }
true;public;1;4;/**  * Set the allocation commands to execute.  */ ;/**  * Set the allocation commands to execute.  */ public ClusterRerouteRequest commands(AllocationCommands commands) {     this.commands = commands.     return this. }
true;public;0;3;/**  * Returns the allocation commands to execute  */ ;/**  * Returns the allocation commands to execute  */ public AllocationCommands getCommands() {     return commands. }
false;public;0;4;;@Override public ActionRequestValidationException validate() {     return null. }
false;public;1;8;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     commands = AllocationCommands.readFrom(in).     dryRun = in.readBoolean().     explain = in.readBoolean().     retryFailed = in.readBoolean(). }
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     AllocationCommands.writeTo(commands, out).     out.writeBoolean(dryRun).     out.writeBoolean(explain).     out.writeBoolean(retryFailed). }
false;public;1;14;;@Override public boolean equals(Object obj) {     if (obj == null || getClass() != obj.getClass()) {         return false.     }     ClusterRerouteRequest other = (ClusterRerouteRequest) obj.     // Override equals and hashCode for testing     return Objects.equals(commands, other.commands) && Objects.equals(dryRun, other.dryRun) && Objects.equals(explain, other.explain) && Objects.equals(timeout, other.timeout) && Objects.equals(retryFailed, other.retryFailed) && Objects.equals(masterNodeTimeout, other.masterNodeTimeout). }
false;public;0;5;;@Override public int hashCode() {     // Override equals and hashCode for testing     return Objects.hash(commands, dryRun, explain, timeout, retryFailed, masterNodeTimeout). }
