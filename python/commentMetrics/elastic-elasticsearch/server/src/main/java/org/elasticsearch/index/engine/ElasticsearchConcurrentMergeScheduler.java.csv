commented;modifiers;parameterAmount;loc;comment;code
false;public;0;3;;public Set<OnGoingMerge> onGoingMerges() {     return readOnlyOnGoingMerges. }
false;protected;2;64;;@Override protected void doMerge(IndexWriter writer, MergePolicy.OneMerge merge) throws IOException {     int totalNumDocs = merge.totalNumDocs().     long totalSizeInBytes = merge.totalBytesSize().     long timeNS = System.nanoTime().     currentMerges.inc().     currentMergesNumDocs.inc(totalNumDocs).     currentMergesSizeInBytes.inc(totalSizeInBytes).     OnGoingMerge onGoingMerge = new OnGoingMerge(merge).     onGoingMerges.add(onGoingMerge).     if (logger.isTraceEnabled()) {         logger.trace("merge [{}] starting..., merging [{}] segments, [{}] docs, [{}] size, into [{}] estimated_size", OneMergeHelper.getSegmentName(merge), merge.segments.size(), totalNumDocs, new ByteSizeValue(totalSizeInBytes), new ByteSizeValue(merge.estimatedMergeBytes)).     }     try {         beforeMerge(onGoingMerge).         super.doMerge(writer, merge).     } finally {         long tookMS = TimeValue.nsecToMSec(System.nanoTime() - timeNS).         onGoingMerges.remove(onGoingMerge).         afterMerge(onGoingMerge).         currentMerges.dec().         currentMergesNumDocs.dec(totalNumDocs).         currentMergesSizeInBytes.dec(totalSizeInBytes).         totalMergesNumDocs.inc(totalNumDocs).         totalMergesSizeInBytes.inc(totalSizeInBytes).         totalMerges.inc(tookMS).         long stoppedMS = TimeValue.nsecToMSec(merge.getMergeProgress().getPauseTimes().get(MergePolicy.OneMergeProgress.PauseReason.STOPPED)).         long throttledMS = TimeValue.nsecToMSec(merge.getMergeProgress().getPauseTimes().get(MergePolicy.OneMergeProgress.PauseReason.PAUSED)).         final Thread thread = Thread.currentThread().         long totalBytesWritten = OneMergeHelper.getTotalBytesWritten(thread, merge).         double mbPerSec = OneMergeHelper.getMbPerSec(thread, merge).         totalMergeStoppedTime.inc(stoppedMS).         totalMergeThrottledTime.inc(throttledMS).         String message = String.format(Locale.ROOT, "merge segment [%s] done: took [%s], [%,.1f MB], [%,d docs], [%s stopped], " + "[%s throttled], [%,.1f MB written], [%,.1f MB/sec throttle]", OneMergeHelper.getSegmentName(merge), TimeValue.timeValueMillis(tookMS), totalSizeInBytes / 1024f / 1024f, totalNumDocs, TimeValue.timeValueMillis(stoppedMS), TimeValue.timeValueMillis(throttledMS), totalBytesWritten / 1024f / 1024f, mbPerSec).         if (tookMS > 20000) {             // if more than 20 seconds, DEBUG log it             logger.debug("{}", message).         } else if (logger.isTraceEnabled()) {             logger.trace("{}", message).         }     } }
true;protected;1;1;/**  * A callback allowing for custom logic before an actual merge starts.  */ ;/**  * A callback allowing for custom logic before an actual merge starts.  */ protected void beforeMerge(OnGoingMerge merge) { }
true;protected;1;1;/**  * A callback allowing for custom logic before an actual merge starts.  */ ;/**  * A callback allowing for custom logic before an actual merge starts.  */ protected void afterMerge(OnGoingMerge merge) { }
false;public;0;6;;@Override public MergeScheduler clone() {     // the clone will just be the identity.     return this. }
false;protected;1;5;;@Override protected boolean maybeStall(IndexWriter writer) {     // Don't stall here, because we do our own index throttling (in InternalEngine.IndexThrottle) when merges can't keep up     return true. }
false;protected;2;7;;@Override protected MergeThread getMergeThread(IndexWriter writer, MergePolicy.OneMerge merge) throws IOException {     MergeThread thread = super.getMergeThread(writer, merge).     thread.setName(EsExecutors.threadName(indexSettings, "[" + shardId.getIndexName() + "][" + shardId.id() + "]: " + thread.getName())).     return thread. }
false;;0;9;;MergeStats stats() {     final MergeStats mergeStats = new MergeStats().     mergeStats.add(totalMerges.count(), totalMerges.sum(), totalMergesNumDocs.count(), totalMergesSizeInBytes.count(), currentMerges.count(), currentMergesNumDocs.count(), currentMergesSizeInBytes.count(), totalMergeStoppedTime.count(), totalMergeThrottledTime.count(), config.isAutoThrottle() ? getIORateLimitMBPerSec() : Double.POSITIVE_INFINITY).     return mergeStats. }
false;;0;11;;void refreshConfig() {     if (this.getMaxMergeCount() != config.getMaxMergeCount() || this.getMaxThreadCount() != config.getMaxThreadCount()) {         this.setMaxMergesAndThreads(config.getMaxMergeCount(), config.getMaxThreadCount()).     }     boolean isEnabled = getIORateLimitMBPerSec() != Double.POSITIVE_INFINITY.     if (config.isAutoThrottle() && isEnabled == false) {         enableAutoIOThrottle().     } else if (config.isAutoThrottle() == false && isEnabled) {         disableAutoIOThrottle().     } }
