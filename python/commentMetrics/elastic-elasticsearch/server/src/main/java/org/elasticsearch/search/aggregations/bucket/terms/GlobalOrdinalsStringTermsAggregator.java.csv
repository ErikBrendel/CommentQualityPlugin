commented;modifiers;parameterAmount;loc;comment;code
false;;1;1;;BytesRef apply(long ord) throws IOException.
false;;0;3;;boolean remapGlobalOrds() {     return bucketOrds != null. }
false;private;3;13;;private void collectGlobalOrd(int doc, long globalOrd, LeafBucketCollector sub) throws IOException {     if (bucketOrds == null) {         collectExistingBucket(sub, doc, globalOrd).     } else {         long bucketOrd = bucketOrds.add(globalOrd).         if (bucketOrd < 0) {             bucketOrd = -1 - bucketOrd.             collectExistingBucket(sub, doc, bucketOrd).         } else {             collectBucket(sub, doc, bucketOrd).         }     } }
false;private;1;4;;private SortedSetDocValues getGlobalOrds(LeafReaderContext ctx) throws IOException {     return acceptedGlobalOrdinals == null ? valuesSource.globalOrdinalsValues(ctx) : new FilteredOrdinals(valuesSource.globalOrdinalsValues(ctx), acceptedGlobalOrdinals). }
false;public;2;9;;@Override public void collect(int doc, long bucket) throws IOException {     assert bucket == 0.     if (globalOrds.advanceExact(doc)) {         for (long globalOrd = globalOrds.nextOrd(). globalOrd != NO_MORE_ORDS. globalOrd = globalOrds.nextOrd()) {             collectGlobalOrd(doc, globalOrd, sub).         }     } }
false;public;2;8;;@Override public void collect(int doc, long bucket) throws IOException {     assert bucket == 0.     if (singleValues.advanceExact(doc)) {         final int ord = singleValues.ordValue().         collectGlobalOrd(doc, ord, sub).     } }
false;public;2;32;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     final SortedSetDocValues globalOrds = getGlobalOrds(ctx).     if (bucketOrds == null) {         grow(globalOrds.getValueCount()).     }     final SortedDocValues singleValues = DocValues.unwrapSingleton(globalOrds).     if (singleValues != null) {         return new LeafBucketCollectorBase(sub, globalOrds) {              @Override             public void collect(int doc, long bucket) throws IOException {                 assert bucket == 0.                 if (singleValues.advanceExact(doc)) {                     final int ord = singleValues.ordValue().                     collectGlobalOrd(doc, ord, sub).                 }             }         }.     } else {         return new LeafBucketCollectorBase(sub, globalOrds) {              @Override             public void collect(int doc, long bucket) throws IOException {                 assert bucket == 0.                 if (globalOrds.advanceExact(doc)) {                     for (long globalOrd = globalOrds.nextOrd(). globalOrd != NO_MORE_ORDS. globalOrd = globalOrds.nextOrd()) {                         collectGlobalOrd(doc, globalOrd, sub).                     }                 }             }         }.     } }
false;protected,static;2;8;;protected static void copy(BytesRef from, BytesRef to) {     if (to.bytes.length < from.length) {         to.bytes = new byte[ArrayUtil.oversize(from.length, 1)].     }     to.offset = 0.     to.length = from.length.     System.arraycopy(from.bytes, from.offset, to.bytes, 0, from.length). }
false;public;1;75;;@Override public InternalAggregation buildAggregation(long owningBucketOrdinal) throws IOException {     if (valueCount == 0) {         // no context in this reader         return buildEmptyAggregation().     }     final int size.     if (bucketCountThresholds.getMinDocCount() == 0) {         // if minDocCount == 0 then we can end up with more buckets then maxBucketOrd() returns         size = (int) Math.min(valueCount, bucketCountThresholds.getShardSize()).     } else {         size = (int) Math.min(maxBucketOrd(), bucketCountThresholds.getShardSize()).     }     long otherDocCount = 0.     BucketPriorityQueue<OrdBucket> ordered = new BucketPriorityQueue<>(size, order.comparator(this)).     OrdBucket spare = new OrdBucket(-1, 0, null, showTermDocCountError, 0).     final boolean needsFullScan = bucketOrds == null || bucketCountThresholds.getMinDocCount() == 0.     final long maxId = needsFullScan ? valueCount : bucketOrds.size().     for (long ord = 0. ord < maxId. ord++) {         final long globalOrd.         final long bucketOrd.         if (needsFullScan) {             bucketOrd = bucketOrds == null ? ord : bucketOrds.find(ord).             globalOrd = ord.         } else {             assert bucketOrds != null.             bucketOrd = ord.             globalOrd = bucketOrds.get(ord).         }         if (includeExclude != null && !acceptedGlobalOrdinals.get(globalOrd)) {             continue.         }         final int bucketDocCount = bucketOrd < 0 ? 0 : bucketDocCount(bucketOrd).         if (bucketCountThresholds.getMinDocCount() > 0 && bucketDocCount == 0) {             continue.         }         otherDocCount += bucketDocCount.         spare.globalOrd = globalOrd.         spare.bucketOrd = bucketOrd.         spare.docCount = bucketDocCount.         if (bucketCountThresholds.getShardMinDocCount() <= spare.docCount) {             spare = ordered.insertWithOverflow(spare).             if (spare == null) {                 consumeBucketsAndMaybeBreak(1).                 spare = new OrdBucket(-1, 0, null, showTermDocCountError, 0).             }         }     }     // Get the top buckets     final StringTerms.Bucket[] list = new StringTerms.Bucket[ordered.size()].     long[] survivingBucketOrds = new long[ordered.size()].     for (int i = ordered.size() - 1. i >= 0. --i) {         final OrdBucket bucket = ordered.pop().         survivingBucketOrds[i] = bucket.bucketOrd.         BytesRef scratch = new BytesRef().         copy(lookupGlobalOrd.apply(bucket.globalOrd), scratch).         list[i] = new StringTerms.Bucket(scratch, bucket.docCount, null, showTermDocCountError, 0, format).         list[i].bucketOrd = bucket.bucketOrd.         otherDocCount -= list[i].docCount.     }     // replay any deferred collections     runDeferredCollections(survivingBucketOrds).     // Now build the aggs     for (int i = 0. i < list.length. i++) {         StringTerms.Bucket bucket = list[i].         bucket.aggregations = bucket.docCount == 0 ? bucketEmptyAggregations() : bucketAggregations(bucket.bucketOrd).         bucket.docCountError = 0.     }     return new StringTerms(name, order, bucketCountThresholds.getRequiredSize(), bucketCountThresholds.getMinDocCount(), pipelineAggregators(), metaData(), format, bucketCountThresholds.getShardSize(), showTermDocCountError, otherDocCount, Arrays.asList(list), 0). }
false;public;1;4;;@Override public int compareKey(OrdBucket other) {     return Long.compare(globalOrd, other.globalOrd). }
false;public;0;4;;@Override public String getKeyAsString() {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Object getKey() {     throw new UnsupportedOperationException(). }
false;;3;4;;@Override OrdBucket newBucket(long docCount, InternalAggregations aggs, long docCountError) {     throw new UnsupportedOperationException(). }
false;public;0;4;;@Override public Number getKeyAsNumber() {     throw new UnsupportedOperationException(). }
false;protected;1;4;;@Override protected void writeTermTo(StreamOutput out) throws IOException {     throw new UnsupportedOperationException(). }
false;protected,final;1;4;;@Override protected final XContentBuilder keyToXContent(XContentBuilder builder) throws IOException {     throw new UnsupportedOperationException(). }
false;protected;0;4;;@Override protected void doClose() {     Releasables.close(bucketOrds). }
false;public;2;9;;@Override public void collect(int doc, long bucket) throws IOException {     assert bucket == 0.     if (segmentOrds.advanceExact(doc)) {         for (long segmentOrd = segmentOrds.nextOrd(). segmentOrd != NO_MORE_ORDS. segmentOrd = segmentOrds.nextOrd()) {             segmentDocCounts.increment(segmentOrd + 1, 1).         }     } }
false;public;2;8;;@Override public void collect(int doc, long bucket) throws IOException {     assert bucket == 0.     if (singleValues.advanceExact(doc)) {         final int ord = singleValues.ordValue().         segmentDocCounts.increment(ord + 1, 1).     } }
false;public;2;36;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     if (mapping != null) {         mapSegmentCountsToGlobalCounts(mapping).     }     final SortedSetDocValues segmentOrds = valuesSource.ordinalsValues(ctx).     segmentDocCounts = context.bigArrays().grow(segmentDocCounts, 1 + segmentOrds.getValueCount()).     assert sub == LeafBucketCollector.NO_OP_COLLECTOR.     final SortedDocValues singleValues = DocValues.unwrapSingleton(segmentOrds).     mapping = valuesSource.globalOrdinalsMapping(ctx).     if (singleValues != null) {         return new LeafBucketCollectorBase(sub, segmentOrds) {              @Override             public void collect(int doc, long bucket) throws IOException {                 assert bucket == 0.                 if (singleValues.advanceExact(doc)) {                     final int ord = singleValues.ordValue().                     segmentDocCounts.increment(ord + 1, 1).                 }             }         }.     } else {         return new LeafBucketCollectorBase(sub, segmentOrds) {              @Override             public void collect(int doc, long bucket) throws IOException {                 assert bucket == 0.                 if (segmentOrds.advanceExact(doc)) {                     for (long segmentOrd = segmentOrds.nextOrd(). segmentOrd != NO_MORE_ORDS. segmentOrd = segmentOrds.nextOrd()) {                         segmentDocCounts.increment(segmentOrd + 1, 1).                     }                 }             }         }.     } }
false;protected;0;7;;@Override protected void doPostCollection() throws IOException {     if (mapping != null) {         mapSegmentCountsToGlobalCounts(mapping).         mapping = null.     } }
false;protected;0;4;;@Override protected void doClose() {     Releasables.close(segmentDocCounts). }
false;private;1;14;;private void mapSegmentCountsToGlobalCounts(LongUnaryOperator mapping) throws IOException {     for (long i = 1. i < segmentDocCounts.size(). i++) {         // We use set(...) here, because we need to reset the slow to 0.         // segmentDocCounts get reused over the segments and otherwise counts would be too high.         final int inc = segmentDocCounts.set(i, 0).         if (inc == 0) {             continue.         }         // remember we do +1 when counting         final long ord = i - 1.         final long globalOrd = mapping.applyAsLong(ord).         long bucketOrd = bucketOrds == null ? globalOrd : bucketOrds.find(globalOrd).         incrementBucketDocCount(bucketOrd, inc).     } }
false;public;0;4;;@Override public long getValueCount() {     return inner.getValueCount(). }
false;public;1;4;;@Override public BytesRef lookupOrd(long ord) throws IOException {     return inner.lookupOrd(ord). }
false;public;0;9;;@Override public long nextOrd() throws IOException {     for (long ord = inner.nextOrd(). ord != NO_MORE_ORDS. ord = inner.nextOrd()) {         if (accepted.get(ord)) {             return ord.         }     }     return NO_MORE_ORDS. }
false;public;1;14;;@Override public boolean advanceExact(int target) throws IOException {     if (inner.advanceExact(target)) {         for (long ord = inner.nextOrd(). ord != NO_MORE_ORDS. ord = inner.nextOrd()) {             if (accepted.get(ord)) {                 // reset the iterator                 boolean advanced = inner.advanceExact(target).                 assert advanced.                 return true.             }         }     }     return false. }
