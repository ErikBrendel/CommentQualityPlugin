commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String name() {     return NAME. }
false;public;0;4;;@Override public Optional<String> getMessage() {     return Optional.of("allocated an empty primary for [" + index + "][" + shardId + "] on node [" + node + "] from user command"). }
false;public,static;1;3;;public static AllocateEmptyPrimaryAllocationCommand fromXContent(XContentParser parser) throws IOException {     return new Builder().parse(parser).build(). }
false;public;1;4;;@Override public Builder parse(XContentParser parser) throws IOException {     return EMPTY_PRIMARY_PARSER.parse(parser, this, null). }
false;public;0;5;;@Override public AllocateEmptyPrimaryAllocationCommand build() {     validate().     return new AllocateEmptyPrimaryAllocationCommand(index, shard, node, acceptDataLoss). }
false;public;2;44;;@Override public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {     final DiscoveryNode discoNode.     try {         discoNode = allocation.nodes().resolveNode(node).     } catch (IllegalArgumentException e) {         return explainOrThrowRejectedCommand(explain, allocation, e).     }     final RoutingNodes routingNodes = allocation.routingNodes().     RoutingNode routingNode = routingNodes.node(discoNode.getId()).     if (routingNode == null) {         return explainOrThrowMissingRoutingNode(allocation, explain, discoNode).     }     final ShardRouting shardRouting.     try {         shardRouting = allocation.routingTable().shardRoutingTable(index, shardId).primaryShard().     } catch (IndexNotFoundException | ShardNotFoundException e) {         return explainOrThrowRejectedCommand(explain, allocation, e).     }     if (shardRouting.unassigned() == false) {         return explainOrThrowRejectedCommand(explain, allocation, "primary [" + index + "][" + shardId + "] is already assigned").     }     if (shardRouting.recoverySource().getType() != RecoverySource.Type.EMPTY_STORE && acceptDataLoss == false) {         String dataLossWarning = "allocating an empty primary for [" + index + "][" + shardId + "] can result in data loss. Please confirm by setting the accept_data_loss parameter to true".         return explainOrThrowRejectedCommand(explain, allocation, dataLossWarning).     }     UnassignedInfo unassignedInfoToUpdate = null.     if (shardRouting.unassignedInfo().getReason() != UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY) {         String unassignedInfoMessage = "force empty allocation from previous reason " + shardRouting.unassignedInfo().getReason() + ", " + shardRouting.unassignedInfo().getMessage().         unassignedInfoToUpdate = new UnassignedInfo(UnassignedInfo.Reason.FORCED_EMPTY_PRIMARY, unassignedInfoMessage, shardRouting.unassignedInfo().getFailure(), 0, System.nanoTime(), System.currentTimeMillis(), false, shardRouting.unassignedInfo().getLastAllocationStatus()).     }     initializeUnassignedShard(allocation, routingNodes, routingNode, shardRouting, unassignedInfoToUpdate, EmptyStoreRecoverySource.INSTANCE).     return new RerouteExplanation(this, allocation.decision(Decision.YES, name() + " (allocation command)", "ignore deciders")). }
