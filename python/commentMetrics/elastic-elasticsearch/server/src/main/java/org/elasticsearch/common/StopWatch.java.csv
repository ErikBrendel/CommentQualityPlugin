commented;modifiers;parameterAmount;loc;comment;code
true;public;1;4;/**  * Determine whether the TaskInfo array is built over time. Set this to  * "false" when using a StopWatch for millions of intervals, or the task  * info structure will consume excessive memory. Default is "true".  */ ;/**  * Determine whether the TaskInfo array is built over time. Set this to  * "false" when using a StopWatch for millions of intervals, or the task  * info structure will consume excessive memory. Default is "true".  */ public StopWatch keepTaskList(boolean keepTaskList) {     this.keepTaskList = keepTaskList.     return this. }
true;public;0;3;/**  * Start an unnamed task. The results are undefined if {@link #stop()}  * or timing methods are called without invoking this method.  *  * @see #stop()  */ ;/**  * Start an unnamed task. The results are undefined if {@link #stop()}  * or timing methods are called without invoking this method.  *  * @see #stop()  */ public StopWatch start() throws IllegalStateException {     return start(""). }
true;public;1;9;/**  * Start a named task. The results are undefined if {@link #stop()}  * or timing methods are called without invoking this method.  *  * @param taskName the name of the task to start  * @see #stop()  */ ;/**  * Start a named task. The results are undefined if {@link #stop()}  * or timing methods are called without invoking this method.  *  * @param taskName the name of the task to start  * @see #stop()  */ public StopWatch start(String taskName) throws IllegalStateException {     if (this.running) {         throw new IllegalStateException("Can't start StopWatch: it's already running").     }     this.startTimeNS = System.nanoTime().     this.running = true.     this.currentTaskName = taskName.     return this. }
true;public;0;15;/**  * Stop the current task. The results are undefined if timing  * methods are called without invoking at least one pair  * {@link #start()} / {@link #stop()} methods.  *  * @see #start()  */ ;/**  * Stop the current task. The results are undefined if timing  * methods are called without invoking at least one pair  * {@link #start()} / {@link #stop()} methods.  *  * @see #start()  */ public StopWatch stop() throws IllegalStateException {     if (!this.running) {         throw new IllegalStateException("Can't stop StopWatch: it's not running").     }     long lastTimeNS = System.nanoTime() - this.startTimeNS.     this.totalTimeNS += lastTimeNS.     this.lastTaskInfo = new TaskInfo(this.currentTaskName, TimeValue.nsecToMSec(lastTimeNS)).     if (this.keepTaskList) {         this.taskList.add(lastTaskInfo).     }     ++this.taskCount.     this.running = false.     this.currentTaskName = null.     return this. }
true;public;0;3;/**  * Return whether the stop watch is currently running.  */ ;/**  * Return whether the stop watch is currently running.  */ public boolean isRunning() {     return this.running. }
true;public;0;6;/**  * Return the time taken by the last task.  */ ;/**  * Return the time taken by the last task.  */ public TimeValue lastTaskTime() throws IllegalStateException {     if (this.lastTaskInfo == null) {         throw new IllegalStateException("No tests run: can't get last interval").     }     return this.lastTaskInfo.getTime(). }
true;public;0;6;/**  * Return the name of the last task.  */ ;/**  * Return the name of the last task.  */ public String lastTaskName() throws IllegalStateException {     if (this.lastTaskInfo == null) {         throw new IllegalStateException("No tests run: can't get last interval").     }     return this.lastTaskInfo.getTaskName(). }
true;public;0;3;/**  * Return the total time for all tasks.  */ ;/**  * Return the total time for all tasks.  */ public TimeValue totalTime() {     return new TimeValue(totalTimeNS, TimeUnit.NANOSECONDS). }
true;public;0;3;/**  * Return the number of tasks timed.  */ ;/**  * Return the number of tasks timed.  */ public int taskCount() {     return taskCount. }
true;public;0;6;/**  * Return an array of the data for tasks performed.  */ ;/**  * Return an array of the data for tasks performed.  */ public TaskInfo[] taskInfo() {     if (!this.keepTaskList) {         throw new UnsupportedOperationException("Task info is not being kept!").     }     return this.taskList.toArray(new TaskInfo[this.taskList.size()]). }
true;public;0;3;/**  * Return a short description of the total running time.  */ ;/**  * Return a short description of the total running time.  */ public String shortSummary() {     return "StopWatch '" + this.id + "': running time  = " + totalTime(). }
true;public;0;23;/**  * Return a string with a table describing all tasks performed.  * For custom reporting, call getTaskInfo() and use the task info directly.  */ ;/**  * Return a string with a table describing all tasks performed.  * For custom reporting, call getTaskInfo() and use the task info directly.  */ public String prettyPrint() {     StringBuilder sb = new StringBuilder(shortSummary()).     sb.append('\n').     if (!this.keepTaskList) {         sb.append("No task info kept").     } else {         sb.append("-----------------------------------------\n").         sb.append("ms     %     Task name\n").         sb.append("-----------------------------------------\n").         NumberFormat nf = NumberFormat.getNumberInstance(Locale.ROOT).         nf.setMinimumIntegerDigits(5).         nf.setGroupingUsed(false).         NumberFormat pf = NumberFormat.getPercentInstance(Locale.ROOT).         pf.setMinimumIntegerDigits(3).         pf.setGroupingUsed(false).         for (TaskInfo task : taskInfo()) {             sb.append(nf.format(task.getTime().millis())).append("  ").             sb.append(pf.format(task.getTime().secondsFrac() / totalTime().secondsFrac())).append("  ").             sb.append(task.getTaskName()).append("\n").         }     }     return sb.toString(). }
true;public;0;14;/**  * Return an informative string describing all tasks performed  * For custom reporting, call <code>getTaskInfo()</code> and use the task info directly.  */ ;/**  * Return an informative string describing all tasks performed  * For custom reporting, call <code>getTaskInfo()</code> and use the task info directly.  */ @Override public String toString() {     StringBuilder sb = new StringBuilder(shortSummary()).     if (this.keepTaskList) {         for (TaskInfo task : taskInfo()) {             sb.append(". [").append(task.getTaskName()).append("] took ").append(task.getTime()).             long percent = Math.round((100.0f * task.getTime().millis()) / totalTime().millis()).             sb.append(" = ").append(percent).append("%").         }     } else {         sb.append(". no task info kept").     }     return sb.toString(). }
true;public;0;3;/**  * Return the name of this task.  */ ;/**  * Return the name of this task.  */ public String getTaskName() {     return taskName. }
true;public;0;3;/**  * Return the time this task took.  */ ;/**  * Return the time this task took.  */ public TimeValue getTime() {     return timeValue. }
