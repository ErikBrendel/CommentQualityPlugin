commented;modifiers;parameterAmount;loc;comment;code
true;;1;1;/**  * Try to parse input to a java time TemporalAccessor  * @param input                   An arbitrary string resembling the string representation of a date or time  * @throws DateTimeParseException If parsing fails, this exception will be thrown.  *                                Note that it can contained suppressed exceptions when several formatters failed parse this value  * @return                        The java time object containing the parsed input  */ ;/**  * Try to parse input to a java time TemporalAccessor  * @param input                   An arbitrary string resembling the string representation of a date or time  * @throws DateTimeParseException If parsing fails, this exception will be thrown.  *                                Note that it can contained suppressed exceptions when several formatters failed parse this value  * @return                        The java time object containing the parsed input  */ TemporalAccessor parse(String input).
true;default;1;3;/**  * Parse the given input into millis-since-epoch.  */ ;/**  * Parse the given input into millis-since-epoch.  */ default long parseMillis(String input) {     return DateFormatters.from(parse(input)).toInstant().toEpochMilli(). }
true;default;1;4;/**  * Parse the given input into a Joda {@link DateTime}.  */ ;/**  * Parse the given input into a Joda {@link DateTime}.  */ default DateTime parseJoda(String input) {     ZonedDateTime dateTime = ZonedDateTime.from(parse(input)).     return new DateTime(dateTime.toInstant().toEpochMilli(), DateUtils.zoneIdToDateTimeZone(dateTime.getZone())). }
true;;1;1;/**  * Create a copy of this formatter that is configured to parse dates in the specified time zone  *  * @param zoneId The time zone to act on  * @return       A copy of the date formatter this has been called on  */ ;/**  * Create a copy of this formatter that is configured to parse dates in the specified time zone  *  * @param zoneId The time zone to act on  * @return       A copy of the date formatter this has been called on  */ DateFormatter withZone(ZoneId zoneId).
true;;1;1;/**  * Create a copy of this formatter that is configured to parse dates in the specified locale  *  * @param locale The local to use for the new formatter  * @return       A copy of the date formatter this has been called on  */ ;/**  * Create a copy of this formatter that is configured to parse dates in the specified locale  *  * @param locale The local to use for the new formatter  * @return       A copy of the date formatter this has been called on  */ DateFormatter withLocale(Locale locale).
true;;1;1;/**  * Print the supplied java time accessor in a string based representation according to this formatter  *  * @param accessor The temporal accessor used to format  * @return         The string result for the formatting  */ ;/**  * Print the supplied java time accessor in a string based representation according to this formatter  *  * @param accessor The temporal accessor used to format  * @return         The string result for the formatting  */ String format(TemporalAccessor accessor).
true;default;1;4;/**  * Return the given millis-since-epoch formatted with this format.  */ ;/**  * Return the given millis-since-epoch formatted with this format.  */ default String formatMillis(long millis) {     ZoneId zone = zone() != null ? zone() : ZoneOffset.UTC.     return format(Instant.ofEpochMilli(millis).atZone(zone)). }
true;default;1;4;/**  * Return the given Joda {@link DateTime} formatted with this format.  */ ;/**  * Return the given Joda {@link DateTime} formatted with this format.  */ default String formatJoda(DateTime dateTime) {     return format(ZonedDateTime.ofInstant(Instant.ofEpochMilli(dateTime.getMillis()), DateUtils.dateTimeZoneToZoneId(dateTime.getZone()))). }
true;;0;1;/**  * A name based format for this formatter. Can be one of the registered formatters like <code>epoch_millis</code> or  * a configured format like <code>HH:mm:ss</code>  *  * @return The name of this formatter  */ ;/**  * A name based format for this formatter. Can be one of the registered formatters like <code>epoch_millis</code> or  * a configured format like <code>HH:mm:ss</code>  *  * @return The name of this formatter  */ String pattern().
true;;0;1;/**  * Returns the configured locale of the date formatter  *  * @return The locale of this formatter  */ ;/**  * Returns the configured locale of the date formatter  *  * @return The locale of this formatter  */ Locale locale().
true;;0;1;/**  * Returns the configured time zone of the date formatter  *  * @return The time zone of this formatter  */ ;/**  * Returns the configured time zone of the date formatter  *  * @return The time zone of this formatter  */ ZoneId zone().
true;;0;1;/**  * Create a DateMathParser from the existing formatter  *  * @return The DateMathParser object  */ ;/**  * Create a DateMathParser from the existing formatter  *  * @return The DateMathParser object  */ DateMathParser toDateMathParser().
false;static;1;24;;static DateFormatter forPattern(String input) {     if (Strings.hasLength(input) == false) {         throw new IllegalArgumentException("No date pattern provided").     }     // support the 6.x BWC compatible way of parsing java 8 dates     if (input.startsWith("8")) {         input = input.substring(1).     }     List<DateFormatter> formatters = new ArrayList<>().     for (String pattern : Strings.delimitedListToStringArray(input, "||")) {         if (Strings.hasLength(pattern) == false) {             throw new IllegalArgumentException("Cannot have empty element in multi date format pattern: " + input).         }         formatters.add(DateFormatters.forPattern(pattern)).     }     if (formatters.size() == 1) {         return formatters.get(0).     }     return DateFormatters.merge(input, formatters). }
