commented;modifiers;parameterAmount;loc;comment;code
false;private,static;1;8;;private static AllocationStatus fromId(byte id) {     switch(id) {         case 0:             return PRIMARY.         case 1:             return REPLICA.         case 2:             return UNUSED.         default:             throw new IllegalArgumentException("unknown id for allocation status [" + id + "]").     } }
false;public;0;8;;public String value() {     switch(id) {         case 0:             return "primary".         case 1:             return "replica".         case 2:             return "unused".         default:             throw new IllegalArgumentException("unknown id for allocation status [" + id + "]").     } }
false;private,static;1;3;;private static AllocationStatus readFrom(StreamInput in) throws IOException {     return fromId(in.readByte()). }
false;private;1;3;;private void writeTo(StreamOutput out) throws IOException {     out.writeByte(id). }
true;public;0;3;/**  * Node the store belongs to  */ ;/**  * Node the store belongs to  */ public DiscoveryNode getNode() {     return node. }
true;public;0;3;/**  * AllocationStatus id of the store, used to select the store that will be  * used as a primary.  */ ;/**  * AllocationStatus id of the store, used to select the store that will be  * used as a primary.  */ public String getAllocationId() {     return allocationId. }
true;public;0;3;/**  * Exception while trying to open the  * shard index or from when the shard failed  */ ;/**  * Exception while trying to open the  * shard index or from when the shard failed  */ public Exception getStoreException() {     return storeException. }
true;public;0;3;/**  * The allocationStatus status of the store.  * {@link AllocationStatus#PRIMARY} indicates a primary shard copy  * {@link AllocationStatus#REPLICA} indicates a replica shard copy  * {@link AllocationStatus#UNUSED} indicates an unused shard copy  */ ;/**  * The allocationStatus status of the store.  * {@link AllocationStatus#PRIMARY} indicates a primary shard copy  * {@link AllocationStatus#REPLICA} indicates a replica shard copy  * {@link AllocationStatus#UNUSED} indicates an unused shard copy  */ public AllocationStatus getAllocationStatus() {     return allocationStatus. }
false;public,static;1;5;;public static StoreStatus readStoreStatus(StreamInput in) throws IOException {     StoreStatus storeStatus = new StoreStatus().     storeStatus.readFrom(in).     return storeStatus. }
false;public;1;13;;@Override public void readFrom(StreamInput in) throws IOException {     node = new DiscoveryNode(in).     if (in.getVersion().before(Version.V_6_0_0_alpha1)) {         // legacy version         in.readLong().     }     allocationId = in.readOptionalString().     allocationStatus = AllocationStatus.readFrom(in).     if (in.readBoolean()) {         storeException = in.readException().     } }
false;public;1;16;;@Override public void writeTo(StreamOutput out) throws IOException {     node.writeTo(out).     if (out.getVersion().before(Version.V_6_0_0_alpha1)) {         // legacy version         out.writeLong(-1L).     }     out.writeOptionalString(allocationId).     allocationStatus.writeTo(out).     if (storeException != null) {         out.writeBoolean(true).         out.writeException(storeException).     } else {         out.writeBoolean(false).     } }
false;public;2;14;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     node.toXContent(builder, params).     if (allocationId != null) {         builder.field(Fields.ALLOCATION_ID, allocationId).     }     builder.field(Fields.ALLOCATED, allocationStatus.value()).     if (storeException != null) {         builder.startObject(Fields.STORE_EXCEPTION).         ElasticsearchException.generateThrowableXContent(builder, params, storeException).         builder.endObject().     }     return builder. }
false;public;1;21;;@Override public int compareTo(StoreStatus other) {     if (storeException != null && other.storeException == null) {         return 1.     } else if (other.storeException != null && storeException == null) {         return -1.     }     if (allocationId != null && other.allocationId == null) {         return -1.     } else if (allocationId == null && other.allocationId != null) {         return 1.     } else if (allocationId == null && other.allocationId == null) {         return Integer.compare(allocationStatus.id, other.allocationStatus.id).     } else {         int compare = Integer.compare(allocationStatus.id, other.allocationStatus.id).         if (compare == 0) {             return allocationId.compareTo(other.allocationId).         }         return compare.     } }
false;public;0;3;;public String nodeId() {     return nodeId. }
false;static;1;5;;static Failure readFailure(StreamInput in) throws IOException {     Failure failure = new Failure().     failure.readFrom(in).     return failure. }
false;public;1;5;;@Override public void readFrom(StreamInput in) throws IOException {     nodeId = in.readString().     super.readFrom(in). }
false;public;1;5;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(nodeId).     super.writeTo(out). }
false;public;2;6;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.field("node", nodeId()).     super.toXContent(builder, params).     return builder. }
true;public;0;3;/**  * Returns {@link StoreStatus}s  * grouped by their index names and shard ids.  */ ;/**  * Returns {@link StoreStatus}s  * grouped by their index names and shard ids.  */ public ImmutableOpenMap<String, ImmutableOpenIntMap<List<StoreStatus>>> getStoreStatuses() {     return storeStatuses. }
true;public;0;3;/**  * Returns node {@link Failure}s encountered  * while executing the request  */ ;/**  * Returns node {@link Failure}s encountered  * while executing the request  */ public List<Failure> getFailures() {     return failures. }
false;public;1;28;;@Override public void readFrom(StreamInput in) throws IOException {     super.readFrom(in).     int numResponse = in.readVInt().     ImmutableOpenMap.Builder<String, ImmutableOpenIntMap<List<StoreStatus>>> storeStatusesBuilder = ImmutableOpenMap.builder().     for (int i = 0. i < numResponse. i++) {         String index = in.readString().         int indexEntries = in.readVInt().         ImmutableOpenIntMap.Builder<List<StoreStatus>> shardEntries = ImmutableOpenIntMap.builder().         for (int shardCount = 0. shardCount < indexEntries. shardCount++) {             int shardID = in.readInt().             int nodeEntries = in.readVInt().             List<StoreStatus> storeStatuses = new ArrayList<>(nodeEntries).             for (int nodeCount = 0. nodeCount < nodeEntries. nodeCount++) {                 storeStatuses.add(readStoreStatus(in)).             }             shardEntries.put(shardID, storeStatuses).         }         storeStatusesBuilder.put(index, shardEntries.build()).     }     int numFailure = in.readVInt().     List<Failure> failureBuilder = new ArrayList<>().     for (int i = 0. i < numFailure. i++) {         failureBuilder.add(Failure.readFailure(in)).     }     storeStatuses = storeStatusesBuilder.build().     failures = Collections.unmodifiableList(failureBuilder). }
false;public;1;20;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeVInt(storeStatuses.size()).     for (ObjectObjectCursor<String, ImmutableOpenIntMap<List<StoreStatus>>> indexShards : storeStatuses) {         out.writeString(indexShards.key).         out.writeVInt(indexShards.value.size()).         for (IntObjectCursor<List<StoreStatus>> shardStatusesEntry : indexShards.value) {             out.writeInt(shardStatusesEntry.key).             out.writeVInt(shardStatusesEntry.value.size()).             for (StoreStatus storeStatus : shardStatusesEntry.value) {                 storeStatus.writeTo(out).             }         }     }     out.writeVInt(failures.size()).     for (Failure failure : failures) {         failure.writeTo(out).     } }
false;public;2;36;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (failures.size() > 0) {         builder.startArray(Fields.FAILURES).         for (Failure failure : failures) {             builder.startObject().             failure.toXContent(builder, params).             builder.endObject().         }         builder.endArray().     }     builder.startObject(Fields.INDICES).     for (ObjectObjectCursor<String, ImmutableOpenIntMap<List<StoreStatus>>> indexShards : storeStatuses) {         builder.startObject(indexShards.key).         builder.startObject(Fields.SHARDS).         for (IntObjectCursor<List<StoreStatus>> shardStatusesEntry : indexShards.value) {             builder.startObject(String.valueOf(shardStatusesEntry.key)).             builder.startArray(Fields.STORES).             for (StoreStatus storeStatus : shardStatusesEntry.value) {                 builder.startObject().                 storeStatus.toXContent(builder, params).                 builder.endObject().             }             builder.endArray().             builder.endObject().         }         builder.endObject().         builder.endObject().     }     builder.endObject().     return builder. }
