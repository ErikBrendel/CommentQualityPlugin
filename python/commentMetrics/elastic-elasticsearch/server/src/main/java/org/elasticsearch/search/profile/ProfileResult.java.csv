commented;modifiers;parameterAmount;loc;comment;code
false;public;1;15;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeString(type).     out.writeString(description).     // not Vlong because can be negative     out.writeLong(nodeTime).     out.writeVInt(timings.size()).     for (Map.Entry<String, Long> entry : timings.entrySet()) {         out.writeString(entry.getKey()).         out.writeLong(entry.getValue()).     }     out.writeVInt(children.size()).     for (ProfileResult child : children) {         child.writeTo(out).     } }
true;public;0;3;/**  * Retrieve the lucene description of this query (e.g. the "explain" text)  */ ;/**  * Retrieve the lucene description of this query (e.g. the "explain" text)  */ public String getLuceneDescription() {     return description. }
true;public;0;3;/**  * Retrieve the name of the query (e.g. "TermQuery")  */ ;/**  * Retrieve the name of the query (e.g. "TermQuery")  */ public String getQueryName() {     return type. }
true;public;0;3;/**  * Returns the timing breakdown for this particular query node  */ ;/**  * Returns the timing breakdown for this particular query node  */ public Map<String, Long> getTimeBreakdown() {     return Collections.unmodifiableMap(timings). }
true;public;0;3;/**  * Returns the total time (inclusive of children) for this query node.  *  * @return  elapsed time in nanoseconds  */ ;/**  * Returns the total time (inclusive of children) for this query node.  *  * @return  elapsed time in nanoseconds  */ public long getTime() {     return nodeTime. }
true;public;0;3;/**  * Returns a list of all profiled children queries  */ ;/**  * Returns a list of all profiled children queries  */ public List<ProfileResult> getProfiledChildren() {     return Collections.unmodifiableList(children). }
false;public;2;22;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     builder.field(TYPE.getPreferredName(), type).     builder.field(DESCRIPTION.getPreferredName(), description).     if (builder.humanReadable()) {         builder.field(NODE_TIME.getPreferredName(), new TimeValue(getTime(), TimeUnit.NANOSECONDS).toString()).     }     builder.field(NODE_TIME_RAW.getPreferredName(), getTime()).     builder.field(BREAKDOWN.getPreferredName(), timings).     if (!children.isEmpty()) {         builder = builder.startArray(CHILDREN.getPreferredName()).         for (ProfileResult child : children) {             builder = child.toXContent(builder, params).         }         builder = builder.endArray().     }     builder = builder.endObject().     return builder. }
false;public,static;1;48;;public static ProfileResult fromXContent(XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     ensureExpectedToken(XContentParser.Token.START_OBJECT, token, parser::getTokenLocation).     String currentFieldName = null.     String type = null, description = null.     Map<String, Long> timings = new HashMap<>().     List<ProfileResult> children = new ArrayList<>().     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token.isValue()) {             if (TYPE.match(currentFieldName, parser.getDeprecationHandler())) {                 type = parser.text().             } else if (DESCRIPTION.match(currentFieldName, parser.getDeprecationHandler())) {                 description = parser.text().             } else if (NODE_TIME.match(currentFieldName, parser.getDeprecationHandler())) {                 // skip, total time is calculate by adding up 'timings' values in ProfileResult ctor                 parser.text().             } else if (NODE_TIME_RAW.match(currentFieldName, parser.getDeprecationHandler())) {                 // skip, total time is calculate by adding up 'timings' values in ProfileResult ctor                 parser.longValue().             } else {                 parser.skipChildren().             }         } else if (token == XContentParser.Token.START_OBJECT) {             if (BREAKDOWN.match(currentFieldName, parser.getDeprecationHandler())) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                     ensureExpectedToken(XContentParser.Token.FIELD_NAME, parser.currentToken(), parser::getTokenLocation).                     String name = parser.currentName().                     ensureExpectedToken(XContentParser.Token.VALUE_NUMBER, parser.nextToken(), parser::getTokenLocation).                     long value = parser.longValue().                     timings.put(name, value).                 }             } else {                 parser.skipChildren().             }         } else if (token == XContentParser.Token.START_ARRAY) {             if (CHILDREN.match(currentFieldName, parser.getDeprecationHandler())) {                 while ((token = parser.nextToken()) != XContentParser.Token.END_ARRAY) {                     children.add(ProfileResult.fromXContent(parser)).                 }             } else {                 parser.skipChildren().             }         }     }     return new ProfileResult(type, description, timings, children). }
true;private,static;1;7;/**  * @param timings a map of breakdown timing for the node  * @return The total time at this node  */ ;/**  * @param timings a map of breakdown timing for the node  * @return The total time at this node  */ private static long getTotalTime(Map<String, Long> timings) {     long nodeTime = 0.     for (long time : timings.values()) {         nodeTime += time.     }     return nodeTime. }
