commented;modifiers;parameterAmount;loc;comment;code
false;public,final;1;6;;@Override public final void writeTo(StreamOutput out) throws IOException {     out.writeFloat(boost).     out.writeOptionalString(queryName).     doWriteTo(out). }
false;protected,abstract;1;1;;protected abstract void doWriteTo(StreamOutput out) throws IOException.
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     doXContent(builder, params).     builder.endObject().     return builder. }
false;protected,abstract;2;1;;protected abstract void doXContent(XContentBuilder builder, Params params) throws IOException.
false;protected;1;6;;protected void printBoostAndQueryName(XContentBuilder builder) throws IOException {     builder.field(BOOST_FIELD.getPreferredName(), boost).     if (queryName != null) {         builder.field(NAME_FIELD.getPreferredName(), queryName).     } }
false;public,final;1;17;;@Override public final Query toQuery(QueryShardContext context) throws IOException {     Query query = doToQuery(context).     if (query != null) {         if (boost != DEFAULT_BOOST) {             if (query instanceof SpanQuery) {                 query = new SpanBoostQuery((SpanQuery) query, boost).             } else {                 query = new BoostQuery(query, boost).             }         }         if (queryName != null) {             context.addNamedQuery(queryName, query).         }     }     return query. }
false;protected,abstract;1;1;;protected abstract Query doToQuery(QueryShardContext context) throws IOException.
true;public,final;1;6;/**  * Sets the query name for the query.  */ ;/**  * Sets the query name for the query.  */ @SuppressWarnings("unchecked") @Override public final QB queryName(String queryName) {     this.queryName = queryName.     return (QB) this. }
true;public,final;0;4;/**  * Returns the query name for the query.  */ ;/**  * Returns the query name for the query.  */ @Override public final String queryName() {     return queryName. }
true;public,final;0;4;/**  * Returns the boost for this query.  */ ;/**  * Returns the boost for this query.  */ @Override public final float boost() {     return this.boost. }
false;protected,final;1;6;;protected final void checkNegativeBoost(float boost) {     if (Float.compare(boost, 0f) < 0) {         throw new IllegalArgumentException("negative [boost] are not allowed in [" + toString() + "], " + "use a value between 0 and 1 to deboost").     } }
true;public,final;1;7;/**  * Sets the boost for this query.  Documents matching this query will (in addition to the normal  * weightings) have their score multiplied by the boost provided.  */ ;/**  * Sets the boost for this query.  Documents matching this query will (in addition to the normal  * weightings) have their score multiplied by the boost provided.  */ @SuppressWarnings("unchecked") @Override public final QB boost(float boost) {     checkNegativeBoost(boost).     this.boost = boost.     return (QB) this. }
false;protected,final;2;3;;protected final QueryValidationException addValidationError(String validationError, QueryValidationException validationException) {     return QueryValidationException.addValidationError(getName(), validationError, validationException). }
false;public,final;1;14;;@Override public final boolean equals(Object obj) {     if (this == obj) {         return true.     }     if (obj == null || getClass() != obj.getClass()) {         return false.     }     @SuppressWarnings("unchecked")     QB other = (QB) obj.     return Objects.equals(queryName, other.queryName) && Objects.equals(boost, other.boost) && doEquals(other). }
true;protected,abstract;1;1;/**  * Indicates whether some other {@link QueryBuilder} object of the same type is "equal to" this one.  */ ;/**  * Indicates whether some other {@link QueryBuilder} object of the same type is "equal to" this one.  */ protected abstract boolean doEquals(QB other).
false;public,final;0;4;;@Override public final int hashCode() {     return Objects.hash(getClass(), queryName, boost, doHashCode()). }
false;protected,abstract;0;1;;protected abstract int doHashCode().
true;static;1;8;/**  * This helper method checks if the object passed in is a string or {@link CharBuffer},  * if so it converts it to a {@link BytesRef}.  * @param obj the input object  * @return the same input object or a {@link BytesRef} representation if input was of type string  */ ;/**  * This helper method checks if the object passed in is a string or {@link CharBuffer},  * if so it converts it to a {@link BytesRef}.  * @param obj the input object  * @return the same input object or a {@link BytesRef} representation if input was of type string  */ static Object maybeConvertToBytesRef(Object obj) {     if (obj instanceof String) {         return BytesRefs.toBytesRef(obj).     } else if (obj instanceof CharBuffer) {         return new BytesRef((CharBuffer) obj).     }     return obj. }
true;static;1;8;/**  * This helper method checks if the object passed in is a {@link BytesRef} or {@link CharBuffer},  * if so it converts it to a utf8 string.  * @param obj the input object  * @return the same input object or a utf8 string if input was of type {@link BytesRef} or {@link CharBuffer}  */ ;/**  * This helper method checks if the object passed in is a {@link BytesRef} or {@link CharBuffer},  * if so it converts it to a utf8 string.  * @param obj the input object  * @return the same input object or a utf8 string if input was of type {@link BytesRef} or {@link CharBuffer}  */ static Object maybeConvertToString(Object obj) {     if (obj instanceof BytesRef) {         return ((BytesRef) obj).utf8ToString().     } else if (obj instanceof CharBuffer) {         return new BytesRef((CharBuffer) obj).utf8ToString().     }     return obj. }
true;static;2;11;/**  * Helper method to convert collection of {@link QueryBuilder} instances to lucene  * {@link Query} instances. {@link QueryBuilder} that return {@code null} calling  * their {@link QueryBuilder#toQuery(QueryShardContext)} method are not added to the  * resulting collection.  */ ;/**  * Helper method to convert collection of {@link QueryBuilder} instances to lucene  * {@link Query} instances. {@link QueryBuilder} that return {@code null} calling  * their {@link QueryBuilder#toQuery(QueryShardContext)} method are not added to the  * resulting collection.  */ static Collection<Query> toQueries(Collection<QueryBuilder> queryBuilders, QueryShardContext context) throws QueryShardException, IOException {     List<Query> queries = new ArrayList<>(queryBuilders.size()).     for (QueryBuilder queryBuilder : queryBuilders) {         Query query = queryBuilder.toQuery(context).         if (query != null) {             queries.add(query).         }     }     return queries. }
false;public;0;5;;@Override public String getName() {     // default impl returns the same as writeable name, but we keep the distinction between the two just to make sure     return getWriteableName(). }
false;static;2;6;;static void writeQueries(StreamOutput out, List<? extends QueryBuilder> queries) throws IOException {     out.writeVInt(queries.size()).     for (QueryBuilder query : queries) {         out.writeNamedWriteable(query).     } }
false;static;1;8;;static List<QueryBuilder> readQueries(StreamInput in) throws IOException {     int size = in.readVInt().     List<QueryBuilder> queries = new ArrayList<>(size).     for (int i = 0. i < size. i++) {         queries.add(in.readNamedWriteable(QueryBuilder.class)).     }     return queries. }
false;public,final;1;14;;@Override public final QueryBuilder rewrite(QueryRewriteContext queryShardContext) throws IOException {     QueryBuilder rewritten = doRewrite(queryShardContext).     if (rewritten == this) {         return rewritten.     }     if (queryName() != null && rewritten.queryName() == null) {         // we inherit the name         rewritten.queryName(queryName()).     }     if (boost() != DEFAULT_BOOST && rewritten.boost() == DEFAULT_BOOST) {         rewritten.boost(boost()).     }     return rewritten. }
false;protected;1;3;;protected QueryBuilder doRewrite(QueryRewriteContext queryShardContext) throws IOException {     return this. }
true;protected;1;2;/**  * For internal usage only!  *  * Extracts the inner hits from the query tree.  * While it extracts inner hits, child inner hits are inlined into the inner hit builder they belong to.  */ ;/**  * For internal usage only!  *  * Extracts the inner hits from the query tree.  * While it extracts inner hits, child inner hits are inlined into the inner hit builder they belong to.  */ protected void extractInnerHitBuilders(Map<String, InnerHitContextBuilder> innerHits) { }
true;public,static;1;39;/**  * Parses a query excluding the query element that wraps it  */ ;/**  * Parses a query excluding the query element that wraps it  */ public static QueryBuilder parseInnerQueryBuilder(XContentParser parser) throws IOException {     if (parser.currentToken() != XContentParser.Token.START_OBJECT) {         if (parser.nextToken() != XContentParser.Token.START_OBJECT) {             throw new ParsingException(parser.getTokenLocation(), "[_na] query malformed, must start with start_object").         }     }     if (parser.nextToken() == XContentParser.Token.END_OBJECT) {         // we encountered '{}' for a query clause, it used to be supported, deprecated in 5.0 and removed in 6.0         throw new IllegalArgumentException("query malformed, empty clause found at [" + parser.getTokenLocation() + "]").     }     if (parser.currentToken() != XContentParser.Token.FIELD_NAME) {         throw new ParsingException(parser.getTokenLocation(), "[_na] query malformed, no field after start_object").     }     String queryName = parser.currentName().     // move to the next START_OBJECT     if (parser.nextToken() != XContentParser.Token.START_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "[" + queryName + "] query malformed, no start_object after query name").     }     QueryBuilder result.     try {         result = parser.namedObject(QueryBuilder.class, queryName, null).     } catch (NamedObjectNotFoundException e) {         // This intentionally doesn't include the causing exception because that'd change the "root_cause" of any unknown query errors         throw new ParsingException(new XContentLocation(e.getLineNumber(), e.getColumnNumber()), "no [query] registered for [" + queryName + "]").     }     // end_object of the specific query (e.g. match, multi_match etc.) element     if (parser.currentToken() != XContentParser.Token.END_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "[" + queryName + "] malformed query, expected [END_OBJECT] but found [" + parser.currentToken() + "]").     }     // end_object of the query object     if (parser.nextToken() != XContentParser.Token.END_OBJECT) {         throw new ParsingException(parser.getTokenLocation(), "[" + queryName + "] malformed query, expected [END_OBJECT] but found [" + parser.currentToken() + "]").     }     return result. }
true;protected,static;2;6;// Like Objects.requireNotNull(...) but instead throws a IllegalArgumentException ;// Like Objects.requireNotNull(...) but instead throws a IllegalArgumentException protected static <T> T requireValue(T value, String message) {     if (value == null) {         throw new IllegalArgumentException(message).     }     return value. }
false;protected,static;4;7;;protected static void throwParsingExceptionOnMultipleFields(String queryName, XContentLocation contentLocation, String processedFieldName, String currentFieldName) {     if (processedFieldName != null) {         throw new ParsingException(contentLocation, "[" + queryName + "] query doesn't support multiple fields, found [" + processedFieldName + "] and [" + currentFieldName + "]").     } }
true;protected,static;1;4;/**  * Adds {@code boost} and {@code query_name} parsing to the  * {@link AbstractObjectParser} passed in. All query builders except  * {@link MatchAllQueryBuilder} and {@link MatchNoneQueryBuilder} support these fields so they  * should use this method.  */ ;/**  * Adds {@code boost} and {@code query_name} parsing to the  * {@link AbstractObjectParser} passed in. All query builders except  * {@link MatchAllQueryBuilder} and {@link MatchNoneQueryBuilder} support these fields so they  * should use this method.  */ protected static void declareStandardFields(AbstractObjectParser<? extends QueryBuilder, ?> parser) {     parser.declareFloat(QueryBuilder::boost, AbstractQueryBuilder.BOOST_FIELD).     parser.declareString(QueryBuilder::queryName, AbstractQueryBuilder.NAME_FIELD). }
false;public,final;0;4;;@Override public final String toString() {     return Strings.toString(this, true, true). }
