commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getKey() {     return getKeyAsString(). }
false;public;0;4;;@Override public String getKeyAsString() {     return key. }
false;public;0;4;;@Override public Object getFrom() {     return from. }
false;public;0;4;;@Override public Object getTo() {     return to. }
false;public;0;3;;public boolean getKeyed() {     return keyed. }
false;public;0;3;;public DocValueFormat getFormat() {     return format. }
false;public;0;8;;@Override public String getFromAsString() {     if (Double.isInfinite(from)) {         return null.     } else {         return format.format(from).toString().     } }
false;public;0;8;;@Override public String getToAsString() {     if (Double.isInfinite(to)) {         return null.     } else {         return format.format(to).toString().     } }
false;public;0;4;;@Override public long getDocCount() {     return docCount. }
false;public;0;4;;@Override public Aggregations getAggregations() {     return aggregations. }
false;protected;0;3;;protected Factory<? extends Bucket, ?> getFactory() {     return FACTORY. }
false;;2;10;;Bucket reduce(List<Bucket> ranges, ReduceContext context) {     long docCount = 0.     List<InternalAggregations> aggregationsList = new ArrayList<>(ranges.size()).     for (Bucket range : ranges) {         docCount += range.docCount.         aggregationsList.add(range.aggregations).     }     final InternalAggregations aggs = InternalAggregations.reduce(aggregationsList, context).     return getFactory().createBucket(key, from, to, docCount, aggs, keyed, format). }
false;public;2;25;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (keyed) {         builder.startObject(key).     } else {         builder.startObject().         builder.field(CommonFields.KEY.getPreferredName(), key).     }     if (!Double.isInfinite(from)) {         builder.field(CommonFields.FROM.getPreferredName(), from).         if (format != DocValueFormat.RAW) {             builder.field(CommonFields.FROM_AS_STRING.getPreferredName(), format.format(from)).         }     }     if (!Double.isInfinite(to)) {         builder.field(CommonFields.TO.getPreferredName(), to).         if (format != DocValueFormat.RAW) {             builder.field(CommonFields.TO_AS_STRING.getPreferredName(), format.format(to)).         }     }     builder.field(CommonFields.DOC_COUNT.getPreferredName(), docCount).     aggregations.toXContentInternal(builder, params).     builder.endObject().     return builder. }
false;private,static;3;7;;private static String generateKey(double from, double to, DocValueFormat format) {     StringBuilder builder = new StringBuilder().append(Double.isInfinite(from) ? "*" : format.format(from)).append("-").append(Double.isInfinite(to) ? "*" : format.format(to)).     return builder.toString(). }
false;public;1;12;;@Override public void writeTo(StreamOutput out) throws IOException {     if (out.getVersion().onOrAfter(Version.V_6_4_0)) {         out.writeString(key).     } else {         out.writeOptionalString(key).     }     out.writeDouble(from).     out.writeDouble(to).     out.writeVLong(docCount).     aggregations.writeTo(out). }
false;public;1;15;;@Override public boolean equals(Object other) {     if (this == other) {         return true.     }     if (other == null || getClass() != other.getClass()) {         return false.     }     Bucket that = (Bucket) other.     return Objects.equals(from, that.from) && Objects.equals(to, that.to) && Objects.equals(docCount, that.docCount) && Objects.equals(aggregations, that.aggregations) && Objects.equals(key, that.key). }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(getClass(), from, to, docCount, aggregations, key). }
false;public;0;3;;public ValuesSourceType getValueSourceType() {     return ValuesSourceType.NUMERIC. }
false;public;0;3;;public ValueType getValueType() {     return ValueType.NUMERIC. }
false;public;6;5;;@SuppressWarnings("unchecked") public R create(String name, List<B> ranges, DocValueFormat format, boolean keyed, List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) {     return (R) new InternalRange<B, R>(name, ranges, format, keyed, pipelineAggregators, metaData). }
false;public;7;5;;@SuppressWarnings("unchecked") public B createBucket(String key, double from, double to, long docCount, InternalAggregations aggregations, boolean keyed, DocValueFormat format) {     return (B) new Bucket(key, from, to, docCount, aggregations, keyed, format). }
false;public;2;5;;@SuppressWarnings("unchecked") public R create(List<B> ranges, R prototype) {     return (R) new InternalRange<B, R>(prototype.name, ranges, prototype.format, prototype.keyed, prototype.pipelineAggregators(), prototype.metaData). }
false;public;2;5;;@SuppressWarnings("unchecked") public B createBucket(InternalAggregations aggregations, B prototype) {     return (B) new Bucket(prototype.getKey(), prototype.from, prototype.to, prototype.getDocCount(), aggregations, prototype.keyed, prototype.format). }
false;protected;1;9;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeNamedWriteable(format).     out.writeBoolean(keyed).     out.writeVInt(ranges.size()).     for (B bucket : ranges) {         bucket.writeTo(out).     } }
false;public;0;4;;@Override public String getWriteableName() {     return RangeAggregationBuilder.NAME. }
false;public;0;4;;@Override public List<B> getBuckets() {     return ranges. }
false;public;0;3;;public Factory<B, R> getFactory() {     return FACTORY. }
false;public;1;5;;@SuppressWarnings("unchecked") @Override public R create(List<B> buckets) {     return getFactory().create(buckets, (R) this). }
false;public;2;4;;@Override public B createBucket(InternalAggregations aggregations, B prototype) {     return getFactory().createBucket(aggregations, prototype). }
false;public;2;22;;@SuppressWarnings("unchecked") @Override public InternalAggregation doReduce(List<InternalAggregation> aggregations, ReduceContext reduceContext) {     reduceContext.consumeBucketsAndMaybeBreak(ranges.size()).     List<Bucket>[] rangeList = new List[ranges.size()].     for (int i = 0. i < rangeList.length. ++i) {         rangeList[i] = new ArrayList<>().     }     for (InternalAggregation aggregation : aggregations) {         InternalRange<B, R> ranges = (InternalRange<B, R>) aggregation.         int i = 0.         for (Bucket range : ranges.ranges) {             rangeList[i++].add(range).         }     }     final List<B> ranges = new ArrayList<>().     for (int i = 0. i < this.ranges.size(). ++i) {         ranges.add((B) rangeList[i].get(0).reduce(rangeList[i], reduceContext)).     }     return getFactory().create(name, ranges, format, keyed, pipelineAggregators(), getMetaData()). }
false;public;2;17;;@Override public XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     if (keyed) {         builder.startObject(CommonFields.BUCKETS.getPreferredName()).     } else {         builder.startArray(CommonFields.BUCKETS.getPreferredName()).     }     for (B range : ranges) {         range.toXContent(builder, params).     }     if (keyed) {         builder.endObject().     } else {         builder.endArray().     }     return builder. }
false;protected;0;4;;@Override protected int doHashCode() {     return Objects.hash(ranges, format, keyed). }
false;protected;1;7;;@Override protected boolean doEquals(Object obj) {     InternalRange<?, ?> that = (InternalRange<?, ?>) obj.     return Objects.equals(ranges, that.ranges) && Objects.equals(format, that.format) && Objects.equals(keyed, that.keyed). }
