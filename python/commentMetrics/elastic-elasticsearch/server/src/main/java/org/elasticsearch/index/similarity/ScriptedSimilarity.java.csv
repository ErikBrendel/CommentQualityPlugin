commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String toString() {     return getClass().getSimpleName() + "(weightScript=[" + weightScriptSource + "], script=[" + scriptSource + "])". }
false;public;1;5;;@Override public long computeNorm(FieldInvertState state) {     final int numTerms = discountOverlaps ? state.getLength() - state.getNumOverlap() : state.getLength().     return SmallFloat.intToByte4(numTerms). }
true;private;3;7;/**  * Compute the part of the score that does not depend on the current document using the init_script.  */ ;/**  * Compute the part of the score that does not depend on the current document using the init_script.  */ private double computeWeight(Query query, Field field, Term term) {     if (weightScriptFactory == null) {         return 1d.     }     SimilarityWeightScript weightScript = weightScriptFactory.newInstance().     return weightScript.execute(query, field, term). }
false;public;2;6;;@Override public float score(float freq, long norm) {     doc.freq = freq.     doc.norm = norm.     return (float) script.execute(scoreWeight, query, field, term, doc). }
false;public;2;15;;@Override public Explanation explain(Explanation freq, long norm) {     float score = score(freq.getValue().floatValue(), norm).     return Explanation.match(score, "score from " + ScriptedSimilarity.this.toString() + " computed from:", Explanation.match((float) scoreWeight, "weight"), Explanation.match(query.boost, "query.boost"), Explanation.match(field.docCount, "field.docCount"), Explanation.match(field.sumDocFreq, "field.sumDocFreq"), Explanation.match(field.sumTotalTermFreq, "field.sumTotalTermFreq"), Explanation.match(term.docFreq, "term.docFreq"), Explanation.match(term.totalTermFreq, "term.totalTermFreq"), Explanation.match(freq.getValue(), "doc.freq", freq.getDetails()), Explanation.match(doc.getLength(), "doc.length")). }
false;public;2;8;;@Override public float score(float freq, long norm) {     double sum = 0.     for (SimScorer scorer : scorers) {         sum += scorer.score(freq, norm).     }     return (float) sum. }
false;public;2;8;;@Override public Explanation explain(Explanation freq, long norm) {     Explanation[] subs = new Explanation[scorers.length].     for (int i = 0. i < subs.length. ++i) {         subs[i] = scorers[i].explain(freq, norm).     }     return Explanation.match(score(freq.getValue().floatValue(), norm), "Sum of:", subs). }
false;public;3;72;;@Override public SimScorer scorer(float boost, CollectionStatistics collectionStats, TermStatistics... termStats) {     Query query = new Query(boost).     long docCount = collectionStats.docCount().     if (docCount == -1) {         docCount = collectionStats.maxDoc().     }     Field field = new Field(docCount, collectionStats.sumDocFreq(), collectionStats.sumTotalTermFreq()).     Term[] terms = new Term[termStats.length].     for (int i = 0. i < termStats.length. ++i) {         terms[i] = new Term(termStats[i].docFreq(), termStats[i].totalTermFreq()).     }     SimScorer[] scorers = new SimScorer[terms.length].     for (int i = 0. i < terms.length. ++i) {         final Term term = terms[i].         final SimilarityScript script = scriptFactory.newInstance().         final Doc doc = new Doc().         final double scoreWeight = computeWeight(query, field, term).         scorers[i] = new SimScorer() {              @Override             public float score(float freq, long norm) {                 doc.freq = freq.                 doc.norm = norm.                 return (float) script.execute(scoreWeight, query, field, term, doc).             }              @Override             public Explanation explain(Explanation freq, long norm) {                 float score = score(freq.getValue().floatValue(), norm).                 return Explanation.match(score, "score from " + ScriptedSimilarity.this.toString() + " computed from:", Explanation.match((float) scoreWeight, "weight"), Explanation.match(query.boost, "query.boost"), Explanation.match(field.docCount, "field.docCount"), Explanation.match(field.sumDocFreq, "field.sumDocFreq"), Explanation.match(field.sumTotalTermFreq, "field.sumTotalTermFreq"), Explanation.match(term.docFreq, "term.docFreq"), Explanation.match(term.totalTermFreq, "term.totalTermFreq"), Explanation.match(freq.getValue(), "doc.freq", freq.getDetails()), Explanation.match(doc.getLength(), "doc.length")).             }         }.     }     if (scorers.length == 1) {         return scorers[0].     } else {         // Sum scores across terms like a BooleanQuery would do         return new SimScorer() {              @Override             public float score(float freq, long norm) {                 double sum = 0.                 for (SimScorer scorer : scorers) {                     sum += scorer.score(freq, norm).                 }                 return (float) sum.             }              @Override             public Explanation explain(Explanation freq, long norm) {                 Explanation[] subs = new Explanation[scorers.length].                 for (int i = 0. i < subs.length. ++i) {                     subs[i] = scorers[i].explain(freq, norm).                 }                 return Explanation.match(score(freq.getValue().floatValue(), norm), "Sum of:", subs).             }         }.     } }
true;public;0;3;/**  * The boost of the query. It should typically be incorporated into the score as a multiplicative factor.  */ ;/**  * The boost of the query. It should typically be incorporated into the score as a multiplicative factor.  */ public float getBoost() {     return boost. }
true;public;0;3;/**  * Return the number of documents that have a value for this field.  */ ;/**  * Return the number of documents that have a value for this field.  */ public long getDocCount() {     return docCount. }
true;public;0;3;/**  * Return the sum of {@link Term#getDocFreq()} for all terms that exist in this field,  *  or {@code -1} if this statistic is not available.  */ ;/**  * Return the sum of {@link Term#getDocFreq()} for all terms that exist in this field,  *  or {@code -1} if this statistic is not available.  */ public long getSumDocFreq() {     return sumDocFreq. }
true;public;0;3;/**  * Return the sum of {@link Term#getTotalTermFreq()} for all terms that exist in this field,  *  or {@code -1} if this statistic is not available.  */ ;/**  * Return the sum of {@link Term#getTotalTermFreq()} for all terms that exist in this field,  *  or {@code -1} if this statistic is not available.  */ public long getSumTotalTermFreq() {     return sumTotalTermFreq. }
true;public;0;3;/**  * Return the number of documents that contain this term in the index.  */ ;/**  * Return the number of documents that contain this term in the index.  */ public long getDocFreq() {     return docFreq. }
true;public;0;3;/**  * Return the total number of occurrences of this term in the index, or {@code -1} if this statistic is not available.  */ ;/**  * Return the total number of occurrences of this term in the index, or {@code -1} if this statistic is not available.  */ public long getTotalTermFreq() {     return totalTermFreq. }
true;public;0;5;/**  * Return the number of tokens that the current document has in the considered field.  */ ;/**  * Return the number of tokens that the current document has in the considered field.  */ public int getLength() {     // not penalized     return SmallFloat.byte4ToInt((byte) norm). }
true;public;0;3;/**  * Return the number of occurrences of the term in the current document for the considered field.  */ ;/**  * Return the number of occurrences of the term in the current document for the considered field.  */ public float getFreq() {     return freq. }
