commented;modifiers;parameterAmount;loc;comment;code
false;public;1;4;;public Builder ignoreMalformed(boolean ignoreMalformed) {     this.ignoreMalformed = ignoreMalformed.     return builder. }
false;protected;1;9;;protected Explicit<Boolean> ignoreMalformed(BuilderContext context) {     if (ignoreMalformed != null) {         return new Explicit<>(ignoreMalformed, true).     }     if (context.indexSettings() != null) {         return new Explicit<>(IGNORE_MALFORMED_SETTING.get(context.indexSettings()), false).     }     return Defaults.IGNORE_MALFORMED. }
false;public;1;6;;@Override public IpFieldMapper build(BuilderContext context) {     setupFieldType(context).     return new IpFieldMapper(name, fieldType, defaultFieldType, ignoreMalformed(context), context.indexSettings(), multiFieldsBuilder.build(this, context), copyTo). }
false;public;3;23;;@Override public Mapper.Builder<?, ?> parse(String name, Map<String, Object> node, ParserContext parserContext) throws MapperParsingException {     Builder builder = new Builder(name).     TypeParsers.parseField(builder, name, node, parserContext).     for (Iterator<Map.Entry<String, Object>> iterator = node.entrySet().iterator(). iterator.hasNext(). ) {         Map.Entry<String, Object> entry = iterator.next().         String propName = entry.getKey().         Object propNode = entry.getValue().         if (propName.equals("null_value")) {             if (propNode == null) {                 throw new MapperParsingException("Property [null_value] cannot be null.").             }             builder.nullValue(InetAddresses.forString(propNode.toString())).             iterator.remove().         } else if (propName.equals("ignore_malformed")) {             builder.ignoreMalformed(XContentMapValues.nodeBooleanValue(propNode, name + ".ignore_malformed")).             iterator.remove().         } else if (TypeParsers.parseMultiField(builder, name, parserContext, propName, propNode)) {             iterator.remove().         }     }     return builder. }
false;public;0;4;;@Override public MappedFieldType clone() {     return new IpFieldType(this). }
false;public;0;4;;@Override public String typeName() {     return CONTENT_TYPE. }
false;private;1;10;;private InetAddress parse(Object value) {     if (value instanceof InetAddress) {         return (InetAddress) value.     } else {         if (value instanceof BytesRef) {             value = ((BytesRef) value).utf8ToString().         }         return InetAddresses.forString(value.toString()).     } }
false;public;1;8;;@Override public Query existsQuery(QueryShardContext context) {     if (hasDocValues()) {         return new DocValuesFieldExistsQuery(name()).     } else {         return new TermQuery(new Term(FieldNamesFieldMapper.NAME, name())).     } }
false;public;2;18;;@Override public Query termQuery(Object value, @Nullable QueryShardContext context) {     failIfNotIndexed().     if (value instanceof InetAddress) {         return InetAddressPoint.newExactQuery(name(), (InetAddress) value).     } else {         if (value instanceof BytesRef) {             value = ((BytesRef) value).utf8ToString().         }         String term = value.toString().         if (term.contains("/")) {             final Tuple<InetAddress, Integer> cidr = InetAddresses.parseCidr(term).             return InetAddressPoint.newPrefixQuery(name(), cidr.v1(), cidr.v2()).         }         InetAddress address = InetAddresses.forString(term).         return InetAddressPoint.newExactQuery(name(), address).     } }
false;public;2;23;;@Override public Query termsQuery(List<?> values, QueryShardContext context) {     InetAddress[] addresses = new InetAddress[values.size()].     int i = 0.     for (Object value : values) {         InetAddress address.         if (value instanceof InetAddress) {             address = (InetAddress) value.         } else {             if (value instanceof BytesRef) {                 value = ((BytesRef) value).utf8ToString().             }             if (value.toString().contains("/")) {                 // and need to fall back to a disjunction of `term` queries                 return super.termsQuery(values, context).             }             address = InetAddresses.forString(value.toString()).         }         addresses[i++] = address.     }     return InetAddressPoint.newSetQuery(name(), addresses). }
false;public;5;31;;@Override public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, QueryShardContext context) {     failIfNotIndexed().     InetAddress lower.     if (lowerTerm == null) {         lower = InetAddressPoint.MIN_VALUE.     } else {         lower = parse(lowerTerm).         if (includeLower == false) {             if (lower.equals(InetAddressPoint.MAX_VALUE)) {                 return new MatchNoDocsQuery().             }             lower = InetAddressPoint.nextUp(lower).         }     }     InetAddress upper.     if (upperTerm == null) {         upper = InetAddressPoint.MAX_VALUE.     } else {         upper = parse(upperTerm).         if (includeUpper == false) {             if (upper.equals(InetAddressPoint.MIN_VALUE)) {                 return new MatchNoDocsQuery().             }             upper = InetAddressPoint.nextDown(upper).         }     }     return InetAddressPoint.newRangeQuery(name(), lower, upper). }
false;public;1;10;;@Override public void setNextDocId(int docId) throws IOException {     count = 0.     if (in.advanceExact(docId)) {         for (long ord = in.nextOrd(). ord != SortedSetDocValues.NO_MORE_ORDS. ord = in.nextOrd()) {             ords = ArrayUtil.grow(ords, count + 1).             ords[count++] = ord.         }     } }
false;public;0;7;;public String getValue() {     if (count == 0) {         return null.     } else {         return get(0).     } }
false;public;1;11;;@Override public String get(int index) {     try {         BytesRef encoded = in.lookupOrd(ords[index]).         InetAddress address = InetAddressPoint.decode(Arrays.copyOfRange(encoded.bytes, encoded.offset, encoded.offset + encoded.length)).         return InetAddresses.toAddrString(address).     } catch (IOException e) {         throw new RuntimeException(e).     } }
false;public;0;4;;@Override public int size() {     return count. }
false;public;1;5;;@Override public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     failIfNoDocValues().     return new DocValuesIndexFieldData.Builder().scriptFunction(IpScriptDocValues::new). }
false;public;1;7;;@Override public Object valueForDisplay(Object value) {     if (value == null) {         return null.     }     return DocValueFormat.IP.format((BytesRef) value). }
false;public;2;11;;@Override public DocValueFormat docValueFormat(@Nullable String format, ZoneId timeZone) {     if (format != null) {         throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats").     }     if (timeZone != null) {         throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones").     }     return DocValueFormat.IP. }
false;public;0;4;;@Override public IpFieldType fieldType() {     return (IpFieldType) super.fieldType(). }
false;protected;0;4;;@Override protected String contentType() {     return fieldType.typeName(). }
false;protected;0;4;;@Override protected IpFieldMapper clone() {     return (IpFieldMapper) super.clone(). }
false;protected;2;46;;@Override protected void parseCreateField(ParseContext context, List<IndexableField> fields) throws IOException {     Object addressAsObject.     if (context.externalValueSet()) {         addressAsObject = context.externalValue().     } else {         addressAsObject = context.parser().textOrNull().     }     if (addressAsObject == null) {         addressAsObject = fieldType().nullValue().     }     if (addressAsObject == null) {         return.     }     String addressAsString = addressAsObject.toString().     InetAddress address.     if (addressAsObject instanceof InetAddress) {         address = (InetAddress) addressAsObject.     } else {         try {             address = InetAddresses.forString(addressAsString).         } catch (IllegalArgumentException e) {             if (ignoreMalformed.value()) {                 context.addIgnoredField(fieldType.name()).                 return.             } else {                 throw e.             }         }     }     if (fieldType().indexOptions() != IndexOptions.NONE) {         fields.add(new InetAddressPoint(fieldType().name(), address)).     }     if (fieldType().hasDocValues()) {         fields.add(new SortedSetDocValuesField(fieldType().name(), new BytesRef(InetAddressPoint.encode(address)))).     } else if (fieldType().stored() || fieldType().indexOptions() != IndexOptions.NONE) {         createFieldNamesField(context, fields).     }     if (fieldType().stored()) {         fields.add(new StoredField(fieldType().name(), new BytesRef(InetAddressPoint.encode(address)))).     } }
false;protected;1;8;;@Override protected void doMerge(Mapper mergeWith) {     super.doMerge(mergeWith).     IpFieldMapper other = (IpFieldMapper) mergeWith.     if (other.ignoreMalformed.explicit()) {         this.ignoreMalformed = other.ignoreMalformed.     } }
false;protected;3;16;;@Override protected void doXContentBody(XContentBuilder builder, boolean includeDefaults, Params params) throws IOException {     super.doXContentBody(builder, includeDefaults, params).     if (includeDefaults || fieldType().nullValue() != null) {         Object nullValue = fieldType().nullValue().         if (nullValue != null) {             nullValue = InetAddresses.toAddrString((InetAddress) nullValue).         }         builder.field("null_value", nullValue).     }     if (includeDefaults || ignoreMalformed.explicit()) {         builder.field("ignore_malformed", ignoreMalformed.value()).     } }
