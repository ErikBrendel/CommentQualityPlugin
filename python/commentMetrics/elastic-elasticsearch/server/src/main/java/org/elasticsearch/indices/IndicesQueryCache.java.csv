commented;modifiers;parameterAmount;loc;comment;code
true;public;1;25;/**  * Get usage statistics for the given shard.  */ ;/**  * Get usage statistics for the given shard.  */ public QueryCacheStats getStats(ShardId shard) {     final Map<ShardId, QueryCacheStats> stats = new HashMap<>().     for (Map.Entry<ShardId, Stats> entry : shardStats.entrySet()) {         stats.put(entry.getKey(), entry.getValue().toQueryCacheStats()).     }     QueryCacheStats shardStats = new QueryCacheStats().     QueryCacheStats info = stats.get(shard).     if (info == null) {         info = new QueryCacheStats().     }     shardStats.add(info).     // We also have some shared ram usage that we try to distribute to     // proportionally to their number of cache entries of each shard     long totalSize = 0.     for (QueryCacheStats s : stats.values()) {         totalSize += s.getCacheSize().     }     final double weight = totalSize == 0 ? 1d / stats.size() : ((double) shardStats.getCacheSize()) / totalSize.     final long additionalRamBytesUsed = Math.round(weight * sharedRamBytesUsed).     shardStats.add(new QueryCacheStats(additionalRamBytesUsed, 0, 0, 0, 0)).     return shardStats. }
false;public;2;10;;@Override public Weight doCache(Weight weight, QueryCachingPolicy policy) {     while (weight instanceof CachingWeightWrapper) {         weight = ((CachingWeightWrapper) weight).in.     }     final Weight in = cache.doCache(weight, policy).     // the shards they belong to     return new CachingWeightWrapper(in). }
false;public;1;4;;@Override public void extractTerms(Set<Term> terms) {     in.extractTerms(terms). }
false;public;2;5;;@Override public Explanation explain(LeafReaderContext context, int doc) throws IOException {     shardKeyMap.add(context.reader()).     return in.explain(context, doc). }
false;public;1;5;;@Override public Scorer scorer(LeafReaderContext context) throws IOException {     shardKeyMap.add(context.reader()).     return in.scorer(context). }
false;public;1;5;;@Override public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {     shardKeyMap.add(context.reader()).     return in.scorerSupplier(context). }
false;public;1;5;;@Override public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {     shardKeyMap.add(context.reader()).     return in.bulkScorer(context). }
false;public;1;4;;@Override public boolean isCacheable(LeafReaderContext ctx) {     return in.isCacheable(ctx). }
true;public;1;14;/**  * Clear all entries that belong to the given index.  */ ;/**  * Clear all entries that belong to the given index.  */ public void clearIndex(String index) {     final Set<Object> coreCacheKeys = shardKeyMap.getCoreKeysForIndex(index).     for (Object coreKey : coreCacheKeys) {         cache.clearCoreCacheKey(coreKey).     }     // probably means that the user wanted to remove everything.     if (cache.getCacheSize() == 0) {         cache.clear().     } }
false;public;0;7;;@Override public void close() {     assert shardKeyMap.size() == 0 : shardKeyMap.size().     assert shardStats.isEmpty() : shardStats.keySet().     assert stats2.isEmpty() : stats2.     cache.clear(). }
false;;0;3;;QueryCacheStats toQueryCacheStats() {     return new QueryCacheStats(ramBytesUsed, hitCount, missCount, cacheCount, cacheSize). }
false;private;1;6;;private boolean empty(Stats stats) {     if (stats == null) {         return true.     }     return stats.cacheSize == 0 && stats.ramBytesUsed == 0. }
false;public;1;4;;public void onClose(ShardId shardId) {     assert empty(shardStats.get(shardId)).     shardStats.remove(shardId). }
false;private;1;7;;private Stats getStats(Object coreKey) {     final ShardId shardId = shardKeyMap.getShardId(coreKey).     if (shardId == null) {         return null.     }     return shardStats.get(shardId). }
false;private;1;9;;private Stats getOrCreateStats(Object coreKey) {     final ShardId shardId = shardKeyMap.getShardId(coreKey).     Stats stats = shardStats.get(shardId).     if (stats == null) {         stats = new Stats().         shardStats.put(shardId, stats).     }     return stats. }
true;protected;0;10;// done in LRUQueryCache ;// It's ok to not protect these callbacks by a lock since it is // done in LRUQueryCache @Override protected void onClear() {     super.onClear().     for (Stats stats : shardStats.values()) {         // don't throw away hit/miss         stats.cacheSize = 0.         stats.ramBytesUsed = 0.     }     sharedRamBytesUsed = 0. }
false;protected;2;5;;@Override protected void onQueryCache(Query filter, long ramBytesUsed) {     super.onQueryCache(filter, ramBytesUsed).     sharedRamBytesUsed += ramBytesUsed. }
false;protected;2;5;;@Override protected void onQueryEviction(Query filter, long ramBytesUsed) {     super.onQueryEviction(filter, ramBytesUsed).     sharedRamBytesUsed -= ramBytesUsed. }
false;protected;2;15;;@Override protected void onDocIdSetCache(Object readerCoreKey, long ramBytesUsed) {     super.onDocIdSetCache(readerCoreKey, ramBytesUsed).     final Stats shardStats = getOrCreateStats(readerCoreKey).     shardStats.cacheSize += 1.     shardStats.cacheCount += 1.     shardStats.ramBytesUsed += ramBytesUsed.     StatsAndCount statsAndCount = stats2.get(readerCoreKey).     if (statsAndCount == null) {         statsAndCount = new StatsAndCount(shardStats).         stats2.put(readerCoreKey, statsAndCount).     }     statsAndCount.count += 1. }
false;protected;3;22;;@Override protected void onDocIdSetEviction(Object readerCoreKey, int numEntries, long sumRamBytesUsed) {     super.onDocIdSetEviction(readerCoreKey, numEntries, sumRamBytesUsed).     // was already empty when the close listener was called     if (numEntries > 0) {         // We can't use ShardCoreKeyMap here because its core closed         // listener is called before the listener of the cache which         // triggers this eviction. So instead we use use stats2 that         // we only evict when nothing is cached anymore on the segment         // instead of relying on close listeners         final StatsAndCount statsAndCount = stats2.get(readerCoreKey).         final Stats shardStats = statsAndCount.stats.         shardStats.cacheSize -= numEntries.         shardStats.ramBytesUsed -= sumRamBytesUsed.         statsAndCount.count -= numEntries.         if (statsAndCount.count == 0) {             stats2.remove(readerCoreKey).         }     } }
false;protected;2;6;;@Override protected void onHit(Object readerCoreKey, Query filter) {     super.onHit(readerCoreKey, filter).     final Stats shardStats = getStats(readerCoreKey).     shardStats.hitCount += 1. }
false;protected;2;6;;@Override protected void onMiss(Object readerCoreKey, Query filter) {     super.onMiss(readerCoreKey, filter).     final Stats shardStats = getOrCreateStats(readerCoreKey).     shardStats.missCount += 1. }
