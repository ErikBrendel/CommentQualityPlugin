commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public void close() throws IOException {     threadLocal.close(). }
true;public;0;5;/**  * Removes the current context and resets a default context. The removed context can be  * restored by closing the returned {@link StoredContext}.  */ ;/**  * Removes the current context and resets a default context. The removed context can be  * restored by closing the returned {@link StoredContext}.  */ public StoredContext stashContext() {     final ThreadContextStruct context = threadLocal.get().     threadLocal.set(null).     return () -> threadLocal.set(context). }
true;public;1;5;/**  * Removes the current context and resets a default context marked with as  * originating from the supplied string. The removed context can be  * restored by closing the returned {@link StoredContext}. Callers should  * be careful to save the current context before calling this method and  * restore it any listeners, likely with  * {@link ContextPreservingActionListener}. Use {@link OriginSettingClient}  * which can be used to do this automatically.  * <p>  * Without security the origin is ignored, but security uses it to authorize  * actions that are made up of many sub-actions. These actions call  * {@link #stashWithOrigin} before performing on behalf of a user that  * should be allowed even if the user doesn't have permission to perform  * those actions on their own.  * <p>  * For example, a user might not have permission to GET from the tasks index  * but the tasks API will perform a get on their behalf using this method  * if it can't find the task in memory.  */ ;/**  * Removes the current context and resets a default context marked with as  * originating from the supplied string. The removed context can be  * restored by closing the returned {@link StoredContext}. Callers should  * be careful to save the current context before calling this method and  * restore it any listeners, likely with  * {@link ContextPreservingActionListener}. Use {@link OriginSettingClient}  * which can be used to do this automatically.  * <p>  * Without security the origin is ignored, but security uses it to authorize  * actions that are made up of many sub-actions. These actions call  * {@link #stashWithOrigin} before performing on behalf of a user that  * should be allowed even if the user doesn't have permission to perform  * those actions on their own.  * <p>  * For example, a user might not have permission to GET from the tasks index  * but the tasks API will perform a get on their behalf using this method  * if it can't find the task in memory.  */ public StoredContext stashWithOrigin(String origin) {     final ThreadContext.StoredContext storedContext = stashContext().     putTransient(ACTION_ORIGIN_TRANSIENT_NAME, origin).     return storedContext. }
true;public;1;7;/**  * Removes the current context and resets a new context that contains a merge of the current headers and the given headers.  * The removed context can be restored when closing the returned {@link StoredContext}. The merge strategy is that headers  * that are already existing are preserved unless they are defaults.  */ ;/**  * Removes the current context and resets a new context that contains a merge of the current headers and the given headers.  * The removed context can be restored when closing the returned {@link StoredContext}. The merge strategy is that headers  * that are already existing are preserved unless they are defaults.  */ public StoredContext stashAndMergeHeaders(Map<String, String> headers) {     final ThreadContextStruct context = threadLocal.get().     Map<String, String> newHeader = new HashMap<>(headers).     newHeader.putAll(context.requestHeaders).     threadLocal.set(DEFAULT_CONTEXT.putHeaders(newHeader)).     return () -> threadLocal.set(context). }
true;public;1;10;/**  * Just like {@link #stashContext()} but no default context is set.  * @param preserveResponseHeaders if set to <code>true</code> the response headers of the restore thread will be preserved.  */ ;/**  * Just like {@link #stashContext()} but no default context is set.  * @param preserveResponseHeaders if set to <code>true</code> the response headers of the restore thread will be preserved.  */ public StoredContext newStoredContext(boolean preserveResponseHeaders) {     final ThreadContextStruct context = threadLocal.get().     return () -> {         if (preserveResponseHeaders && threadLocal.get() != context) {             threadLocal.set(context.putResponseHeaders(threadLocal.get().responseHeaders)).         } else {             threadLocal.set(context).         }     }. }
true;public;1;3;/**  * Returns a supplier that gathers a {@link #newStoredContext(boolean)} and restores it once the  * returned supplier is invoked. The context returned from the supplier is a stored version of the  * suppliers callers context that should be restored once the originally gathered context is not needed anymore.  * For instance this method should be used like this:  *  * <pre>  *     Supplier&lt.ThreadContext.StoredContext&gt. restorable = context.newRestorableContext(true).  *     new Thread() {  *         public void run() {  *             try (ThreadContext.StoredContext ctx = restorable.get()) {  *                 // execute with the parents context and restore the threads context afterwards  *             }  *         }  *  *     }.start().  * </pre>  *  * @param preserveResponseHeaders if set to <code>true</code> the response headers of the restore thread will be preserved.  * @return a restorable context supplier  */ ;/**  * Returns a supplier that gathers a {@link #newStoredContext(boolean)} and restores it once the  * returned supplier is invoked. The context returned from the supplier is a stored version of the  * suppliers callers context that should be restored once the originally gathered context is not needed anymore.  * For instance this method should be used like this:  *  * <pre>  *     Supplier&lt.ThreadContext.StoredContext&gt. restorable = context.newRestorableContext(true).  *     new Thread() {  *         public void run() {  *             try (ThreadContext.StoredContext ctx = restorable.get()) {  *                 // execute with the parents context and restore the threads context afterwards  *             }  *         }  *  *     }.start().  * </pre>  *  * @param preserveResponseHeaders if set to <code>true</code> the response headers of the restore thread will be preserved.  * @return a restorable context supplier  */ public Supplier<StoredContext> newRestorableContext(boolean preserveResponseHeaders) {     return wrapRestorable(newStoredContext(preserveResponseHeaders)). }
true;public;1;7;/**  * Same as {@link #newRestorableContext(boolean)} but wraps an existing context to restore.  * @param storedContext the context to restore  */ ;/**  * Same as {@link #newRestorableContext(boolean)} but wraps an existing context to restore.  * @param storedContext the context to restore  */ public Supplier<StoredContext> wrapRestorable(StoredContext storedContext) {     return () -> {         StoredContext context = newStoredContext(false).         storedContext.restore().         return context.     }. }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     threadLocal.get().writeTo(out, defaultHeader). }
true;public;1;3;/**  * Reads the headers from the stream into the current context  */ ;/**  * Reads the headers from the stream into the current context  */ public void readHeaders(StreamInput in) throws IOException {     threadLocal.set(new ThreadContext.ThreadContextStruct(in)). }
true;public;1;7;/**  * Returns the header for the given key or <code>null</code> if not present  */ ;/**  * Returns the header for the given key or <code>null</code> if not present  */ public String getHeader(String key) {     String value = threadLocal.get().requestHeaders.get(key).     if (value == null) {         return defaultHeader.get(key).     }     return value. }
true;public;0;5;/**  * Returns all of the request contexts headers  */ ;/**  * Returns all of the request contexts headers  */ public Map<String, String> getHeaders() {     HashMap<String, String> map = new HashMap<>(defaultHeader).     map.putAll(threadLocal.get().requestHeaders).     return Collections.unmodifiableMap(map). }
true;public;0;10;/**  * Get a copy of all <em>response</em> headers.  *  * @return Never {@code null}.  */ ;/**  * Get a copy of all <em>response</em> headers.  *  * @return Never {@code null}.  */ public Map<String, List<String>> getResponseHeaders() {     Map<String, Set<String>> responseHeaders = threadLocal.get().responseHeaders.     HashMap<String, List<String>> map = new HashMap<>(responseHeaders.size()).     for (Map.Entry<String, Set<String>> entry : responseHeaders.entrySet()) {         map.put(entry.getKey(), Collections.unmodifiableList(new ArrayList<>(entry.getValue()))).     }     return Collections.unmodifiableMap(map). }
true;public;1;3;/**  * Copies all header key, value pairs into the current context  */ ;/**  * Copies all header key, value pairs into the current context  */ public void copyHeaders(Iterable<Map.Entry<String, String>> headers) {     threadLocal.set(threadLocal.get().copyHeaders(headers)). }
true;public;2;3;/**  * Puts a header into the context  */ ;/**  * Puts a header into the context  */ public void putHeader(String key, String value) {     threadLocal.set(threadLocal.get().putRequest(key, value)). }
true;public;1;3;/**  * Puts all of the given headers into this context  */ ;/**  * Puts all of the given headers into this context  */ public void putHeader(Map<String, String> header) {     threadLocal.set(threadLocal.get().putHeaders(header)). }
true;public;2;3;/**  * Puts a transient header object into this context  */ ;/**  * Puts a transient header object into this context  */ public void putTransient(String key, Object value) {     threadLocal.set(threadLocal.get().putTransient(key, value)). }
true;public;1;4;/**  * Returns a transient header object or <code>null</code> if there is no header for the given key  */ ;/**  * Returns a transient header object or <code>null</code> if there is no header for the given key  */ // (T)object @SuppressWarnings("unchecked") public <T> T getTransient(String key) {     return (T) threadLocal.get().transientHeaders.get(key). }
true;public;2;3;/**  * Add the {@code value} for the specified {@code key} Any duplicate {@code value} is ignored.  *  * @param key         the header name  * @param value       the header value  */ ;/**  * Add the {@code value} for the specified {@code key} Any duplicate {@code value} is ignored.  *  * @param key         the header name  * @param value       the header value  */ public void addResponseHeader(final String key, final String value) {     addResponseHeader(key, value, v -> v). }
true;public;3;13;/**  * Add the {@code value} for the specified {@code key} with the specified {@code uniqueValue} used for de-duplication. Any duplicate  * {@code value} after applying {@code uniqueValue} is ignored.  *  * @param key         the header name  * @param value       the header value  * @param uniqueValue the function that produces de-duplication values  */ ;/**  * Add the {@code value} for the specified {@code key} with the specified {@code uniqueValue} used for de-duplication. Any duplicate  * {@code value} after applying {@code uniqueValue} is ignored.  *  * @param key         the header name  * @param value       the header value  * @param uniqueValue the function that produces de-duplication values  */ public void addResponseHeader(final String key, final String value, final Function<String, String> uniqueValue) {     /*          * Updating the thread local is expensive due to a shared reference that we synchronize on, so we should only do it if the thread          * context struct changed. It will not change if we de-duplicate this value to an existing one, or if we don't add a new one because          * we have reached capacity.          */     final ThreadContextStruct current = threadLocal.get().     final ThreadContextStruct maybeNext = current.putResponse(key, value, uniqueValue, maxWarningHeaderCount, maxWarningHeaderSize).     if (current != maybeNext) {         threadLocal.set(maybeNext).     } }
true;public;1;12;/**  * Saves the current thread context and wraps command in a Runnable that restores that context before running command. If  * <code>command</code> has already been passed through this method then it is returned unaltered rather than wrapped twice.  */ ;/**  * Saves the current thread context and wraps command in a Runnable that restores that context before running command. If  * <code>command</code> has already been passed through this method then it is returned unaltered rather than wrapped twice.  */ public Runnable preserveContext(Runnable command) {     if (command instanceof ContextPreservingAbstractRunnable) {         return command.     }     if (command instanceof ContextPreservingRunnable) {         return command.     }     if (command instanceof AbstractRunnable) {         return new ContextPreservingAbstractRunnable((AbstractRunnable) command).     }     return new ContextPreservingRunnable(command). }
true;public;1;6;/**  * Unwraps a command that was previously wrapped by {@link #preserveContext(Runnable)}.  */ ;/**  * Unwraps a command that was previously wrapped by {@link #preserveContext(Runnable)}.  */ public Runnable unwrap(Runnable command) {     if (command instanceof WrappedRunnable) {         return ((WrappedRunnable) command).unwrap().     }     return command. }
true;;0;3;/**  * Returns true if the current context is the default context.  */ ;/**  * Returns true if the current context is the default context.  */ boolean isDefaultContext() {     return threadLocal.get() == DEFAULT_CONTEXT. }
true;public;0;3;/**  * Marks this thread context as an internal system context. This signals that actions in this context are issued  * by the system itself rather than by a user action.  */ ;/**  * Marks this thread context as an internal system context. This signals that actions in this context are issued  * by the system itself rather than by a user action.  */ public void markAsSystemContext() {     threadLocal.set(threadLocal.get().setSystemContext()). }
true;public;0;3;/**  * Returns <code>true</code> iff this context is a system context  */ ;/**  * Returns <code>true</code> iff this context is a system context  */ public boolean isSystemContext() {     return threadLocal.get().isSystemContext. }
true;;0;3;/**  * Returns <code>true</code> if the context is closed, otherwise <code>true</code>  */ ;/**  * Returns <code>true</code> if the context is closed, otherwise <code>true</code>  */ boolean isClosed() {     return threadLocal.closed.get(). }
false;;0;2;;@Override void close().
false;default;0;3;;default void restore() {     close(). }
false;private;0;6;;private ThreadContextStruct setSystemContext() {     if (isSystemContext) {         return this.     }     return new ThreadContextStruct(requestHeaders, responseHeaders, transientHeaders, true). }
false;private;2;5;;private ThreadContextStruct putRequest(String key, String value) {     Map<String, String> newRequestHeaders = new HashMap<>(this.requestHeaders).     putSingleHeader(key, value, newRequestHeaders).     return new ThreadContextStruct(newRequestHeaders, responseHeaders, transientHeaders, isSystemContext). }
false;private;3;5;;private void putSingleHeader(String key, String value, Map<String, String> newHeaders) {     if (newHeaders.putIfAbsent(key, value) != null) {         throw new IllegalArgumentException("value for key [" + key + "] already present").     } }
false;private;1;11;;private ThreadContextStruct putHeaders(Map<String, String> headers) {     if (headers.isEmpty()) {         return this.     } else {         final Map<String, String> newHeaders = new HashMap<>(this.requestHeaders).         for (Map.Entry<String, String> entry : headers.entrySet()) {             putSingleHeader(entry.getKey(), entry.getValue(), newHeaders).         }         return new ThreadContextStruct(newHeaders, responseHeaders, transientHeaders, isSystemContext).     } }
false;private;1;19;;private ThreadContextStruct putResponseHeaders(Map<String, Set<String>> headers) {     assert headers != null.     if (headers.isEmpty()) {         return this.     }     final Map<String, Set<String>> newResponseHeaders = new HashMap<>(this.responseHeaders).     for (Map.Entry<String, Set<String>> entry : headers.entrySet()) {         String key = entry.getKey().         final Set<String> existingValues = newResponseHeaders.get(key).         if (existingValues != null) {             final Set<String> newValues = Stream.concat(entry.getValue().stream(), existingValues.stream()).collect(LINKED_HASH_SET_COLLECTOR).             newResponseHeaders.put(key, Collections.unmodifiableSet(newValues)).         } else {             newResponseHeaders.put(key, entry.getValue()).         }     }     return new ThreadContextStruct(requestHeaders, newResponseHeaders, transientHeaders, isSystemContext). }
false;private;5;49;;private ThreadContextStruct putResponse(final String key, final String value, final Function<String, String> uniqueValue, final int maxWarningHeaderCount, final long maxWarningHeaderSize) {     assert value != null.     long newWarningHeaderSize = warningHeadersSize.     // check if we can add another warning header - if max size within limits     if (key.equals("Warning") && (maxWarningHeaderSize != -1)) {         // if size is NOT unbounded, check its limits         if (warningHeadersSize > maxWarningHeaderSize) {             // if max size has already been reached before             logger.warn("Dropping a warning header, as their total size reached the maximum allowed of [" + maxWarningHeaderSize + "] bytes set in [" + HttpTransportSettings.SETTING_HTTP_MAX_WARNING_HEADER_SIZE.getKey() + "]!").             return this.         }         newWarningHeaderSize += "Warning".getBytes(StandardCharsets.UTF_8).length + value.getBytes(StandardCharsets.UTF_8).length.         if (newWarningHeaderSize > maxWarningHeaderSize) {             logger.warn("Dropping a warning header, as their total size reached the maximum allowed of [" + maxWarningHeaderSize + "] bytes set in [" + HttpTransportSettings.SETTING_HTTP_MAX_WARNING_HEADER_SIZE.getKey() + "]!").             return new ThreadContextStruct(requestHeaders, responseHeaders, transientHeaders, isSystemContext, newWarningHeaderSize).         }     }     final Map<String, Set<String>> newResponseHeaders.     final Set<String> existingValues = responseHeaders.get(key).     if (existingValues != null) {         if (existingValues.contains(uniqueValue.apply(value))) {             return this.         }         // preserve insertion order         final Set<String> newValues = Stream.concat(existingValues.stream(), Stream.of(value)).collect(LINKED_HASH_SET_COLLECTOR).         newResponseHeaders = new HashMap<>(responseHeaders).         newResponseHeaders.put(key, Collections.unmodifiableSet(newValues)).     } else {         newResponseHeaders = new HashMap<>(responseHeaders).         newResponseHeaders.put(key, Collections.singleton(value)).     }     // check if we can add another warning header - if max count within limits     if ((key.equals("Warning")) && (maxWarningHeaderCount != -1)) {         // if count is NOT unbounded, check its limits         final int warningHeaderCount = newResponseHeaders.containsKey("Warning") ? newResponseHeaders.get("Warning").size() : 0.         if (warningHeaderCount > maxWarningHeaderCount) {             logger.warn("Dropping a warning header, as their total count reached the maximum allowed of [" + maxWarningHeaderCount + "] set in [" + HttpTransportSettings.SETTING_HTTP_MAX_WARNING_HEADER_COUNT.getKey() + "]!").             return this.         }     }     return new ThreadContextStruct(requestHeaders, newResponseHeaders, transientHeaders, isSystemContext, newWarningHeaderSize). }
false;private;2;7;;private ThreadContextStruct putTransient(String key, Object value) {     Map<String, Object> newTransient = new HashMap<>(this.transientHeaders).     if (newTransient.putIfAbsent(key, value) != null) {         throw new IllegalArgumentException("value for key [" + key + "] already present").     }     return new ThreadContextStruct(requestHeaders, responseHeaders, newTransient, isSystemContext). }
false;;0;3;;boolean isEmpty() {     return requestHeaders.isEmpty() && responseHeaders.isEmpty() && transientHeaders.isEmpty(). }
false;private;1;7;;private ThreadContextStruct copyHeaders(Iterable<Map.Entry<String, String>> headers) {     Map<String, String> newHeaders = new HashMap<>().     for (Map.Entry<String, String> header : headers) {         newHeaders.put(header.getKey(), header.getValue()).     }     return putHeaders(newHeaders). }
false;private;2;17;;private void writeTo(StreamOutput out, Map<String, String> defaultHeaders) throws IOException {     final Map<String, String> requestHeaders.     if (defaultHeaders.isEmpty()) {         requestHeaders = this.requestHeaders.     } else {         requestHeaders = new HashMap<>(defaultHeaders).         requestHeaders.putAll(this.requestHeaders).     }     out.writeVInt(requestHeaders.size()).     for (Map.Entry<String, String> entry : requestHeaders.entrySet()) {         out.writeString(entry.getKey()).         out.writeString(entry.getValue()).     }     out.writeMap(responseHeaders, StreamOutput::writeString, StreamOutput::writeStringCollection). }
false;public;1;15;;@Override public void set(ThreadContextStruct object) {     try {         if (object == DEFAULT_CONTEXT) {             super.set(null).         } else {             super.set(object).         }     } catch (NullPointerException ex) {         /* This is odd but CloseableThreadLocal throws a NPE if it was closed but still accessed.                    to get a real exception we call ensureOpen() to tell the user we are already closed.*/         ensureOpen().         throw ex.     } }
false;public;0;15;;@Override public ThreadContextStruct get() {     try {         ThreadContextStruct threadContextStruct = super.get().         if (threadContextStruct != null) {             return threadContextStruct.         }         return DEFAULT_CONTEXT.     } catch (NullPointerException ex) {         /* This is odd but CloseableThreadLocal throws a NPE if it was closed but still accessed.                    to get a real exception we call ensureOpen() to tell the user we are already closed.*/         ensureOpen().         throw ex.     } }
false;private;0;5;;private void ensureOpen() {     if (closed.get()) {         throw new IllegalStateException("threadcontext is already closed").     } }
false;public;0;6;;@Override public void close() {     if (closed.compareAndSet(false, true)) {         super.close().     } }
false;public;0;17;;@Override public void run() {     boolean whileRunning = false.     try (ThreadContext.StoredContext ignore = stashContext()) {         ctx.restore().         whileRunning = true.         in.run().         whileRunning = false.     } catch (IllegalStateException ex) {         if (whileRunning || threadLocal.closed.get() == false) {             throw ex.         }     // if we hit an ISE here we have been shutting down     // this comes from the threadcontext and barfs if     // our threadpool has been shutting down     } }
false;public;0;4;;@Override public String toString() {     return in.toString(). }
false;public;0;4;;@Override public Runnable unwrap() {     return in. }
false;public;0;4;;@Override public boolean isForceExecution() {     return in.isForceExecution(). }
false;public;0;10;;@Override public void onAfter() {     try {         in.onAfter().     } finally {         if (threadsOriginalContext != null) {             threadsOriginalContext.restore().         }     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     in.onFailure(e). }
false;public;1;4;;@Override public void onRejection(Exception e) {     in.onRejection(e). }
false;protected;0;18;;@Override protected void doRun() throws Exception {     boolean whileRunning = false.     threadsOriginalContext = stashContext().     try {         creatorsContext.restore().         whileRunning = true.         in.doRun().         whileRunning = false.     } catch (IllegalStateException ex) {         if (whileRunning || threadLocal.closed.get() == false) {             throw ex.         }     // if we hit an ISE here we have been shutting down     // this comes from the threadcontext and barfs if     // our threadpool has been shutting down     } }
false;public;0;4;;@Override public String toString() {     return in.toString(). }
false;public;0;4;;@Override public AbstractRunnable unwrap() {     return in. }
false;public;0;4;;@Override public Supplier<Set<T>> supplier() {     return LinkedHashSet::new. }
false;public;0;4;;@Override public BiConsumer<Set<T>, T> accumulator() {     return Set::add. }
false;public;0;7;;@Override public BinaryOperator<Set<T>> combiner() {     return (left, right) -> {         left.addAll(right).         return left.     }. }
false;public;0;4;;@Override public Function<Set<T>, Set<T>> finisher() {     return Function.identity(). }
false;public;0;4;;@Override public Set<Characteristics> characteristics() {     return CHARACTERISTICS. }
