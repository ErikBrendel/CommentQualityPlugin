# id;timestamp;commentText;codeText;commentWords;codeWords
GeoUtils -> public static double planeDistance(double lat1, double lon1, double lat2, double lon2);1524684173;Return the distance (in meters) between 2 lat,lon geo points using a simple tangential plane_this provides a faster alternative to {@link GeoUtils#arcDistance} but is inaccurate for distances greater than_4 decimal degrees;public static double planeDistance(double lat1, double lon1, double lat2, double lon2) {_        double x = (lon2 - lon1) * SloppyMath.TO_RADIANS * Math.cos((lat2 + lat1) / 2.0 * SloppyMath.TO_RADIANS)__        double y = (lat2 - lat1) * SloppyMath.TO_RADIANS__        return Math.sqrt(x * x + y * y) * EARTH_MEAN_RADIUS__    };return,the,distance,in,meters,between,2,lat,lon,geo,points,using,a,simple,tangential,plane,this,provides,a,faster,alternative,to,link,geo,utils,arc,distance,but,is,inaccurate,for,distances,greater,than,4,decimal,degrees;public,static,double,plane,distance,double,lat1,double,lon1,double,lat2,double,lon2,double,x,lon2,lon1,sloppy,math,math,cos,lat2,lat1,2,0,sloppy,math,double,y,lat2,lat1,sloppy,math,return,math,sqrt,x,x,y,y
GeoUtils -> public static double planeDistance(double lat1, double lon1, double lat2, double lon2);1527207653;Return the distance (in meters) between 2 lat,lon geo points using a simple tangential plane_this provides a faster alternative to {@link GeoUtils#arcDistance} but is inaccurate for distances greater than_4 decimal degrees;public static double planeDistance(double lat1, double lon1, double lat2, double lon2) {_        double x = (lon2 - lon1) * SloppyMath.TO_RADIANS * Math.cos((lat2 + lat1) / 2.0 * SloppyMath.TO_RADIANS)__        double y = (lat2 - lat1) * SloppyMath.TO_RADIANS__        return Math.sqrt(x * x + y * y) * EARTH_MEAN_RADIUS__    };return,the,distance,in,meters,between,2,lat,lon,geo,points,using,a,simple,tangential,plane,this,provides,a,faster,alternative,to,link,geo,utils,arc,distance,but,is,inaccurate,for,distances,greater,than,4,decimal,degrees;public,static,double,plane,distance,double,lat1,double,lon1,double,lat2,double,lon2,double,x,lon2,lon1,sloppy,math,math,cos,lat2,lat1,2,0,sloppy,math,double,y,lat2,lat1,sloppy,math,return,math,sqrt,x,x,y,y
GeoUtils -> public static double planeDistance(double lat1, double lon1, double lat2, double lon2);1542820501;Return the distance (in meters) between 2 lat,lon geo points using a simple tangential plane_this provides a faster alternative to {@link GeoUtils#arcDistance} but is inaccurate for distances greater than_4 decimal degrees;public static double planeDistance(double lat1, double lon1, double lat2, double lon2) {_        double x = (lon2 - lon1) * SloppyMath.TO_RADIANS * Math.cos((lat2 + lat1) / 2.0 * SloppyMath.TO_RADIANS)__        double y = (lat2 - lat1) * SloppyMath.TO_RADIANS__        return Math.sqrt(x * x + y * y) * EARTH_MEAN_RADIUS__    };return,the,distance,in,meters,between,2,lat,lon,geo,points,using,a,simple,tangential,plane,this,provides,a,faster,alternative,to,link,geo,utils,arc,distance,but,is,inaccurate,for,distances,greater,than,4,decimal,degrees;public,static,double,plane,distance,double,lat1,double,lon1,double,lat2,double,lon2,double,x,lon2,lon1,sloppy,math,math,cos,lat2,lat1,2,0,sloppy,math,double,y,lat2,lat1,sloppy,math,return,math,sqrt,x,x,y,y
GeoUtils -> public static double normalizeLat(double lat);1524684173;Normalize latitude to lie within the -90 to 90 (both inclusive) range._<p>_Note: You should not normalize longitude and latitude separately,_because when normalizing latitude it may be necessary to_add a shift of 180&deg_ in the longitude._For this purpose, you should call the_{@link #normalizePoint(GeoPoint)} function.__@param lat Latitude to normalize_@return The normalized latitude._@see #normalizePoint(GeoPoint);public static double normalizeLat(double lat) {_        lat = centeredModulus(lat, 360)__        if (lat < -90) {_            lat = -180 - lat__        } else if (lat > 90) {_            lat = 180 - lat__        }_        return lat__    };normalize,latitude,to,lie,within,the,90,to,90,both,inclusive,range,p,note,you,should,not,normalize,longitude,and,latitude,separately,because,when,normalizing,latitude,it,may,be,necessary,to,add,a,shift,of,180,deg,in,the,longitude,for,this,purpose,you,should,call,the,link,normalize,point,geo,point,function,param,lat,latitude,to,normalize,return,the,normalized,latitude,see,normalize,point,geo,point;public,static,double,normalize,lat,double,lat,lat,centered,modulus,lat,360,if,lat,90,lat,180,lat,else,if,lat,90,lat,180,lat,return,lat
GeoUtils -> public static double normalizeLat(double lat);1527207653;Normalize latitude to lie within the -90 to 90 (both inclusive) range._<p>_Note: You should not normalize longitude and latitude separately,_because when normalizing latitude it may be necessary to_add a shift of 180&deg_ in the longitude._For this purpose, you should call the_{@link #normalizePoint(GeoPoint)} function.__@param lat Latitude to normalize_@return The normalized latitude._@see #normalizePoint(GeoPoint);public static double normalizeLat(double lat) {_        lat = centeredModulus(lat, 360)__        if (lat < -90) {_            lat = -180 - lat__        } else if (lat > 90) {_            lat = 180 - lat__        }_        return lat__    };normalize,latitude,to,lie,within,the,90,to,90,both,inclusive,range,p,note,you,should,not,normalize,longitude,and,latitude,separately,because,when,normalizing,latitude,it,may,be,necessary,to,add,a,shift,of,180,deg,in,the,longitude,for,this,purpose,you,should,call,the,link,normalize,point,geo,point,function,param,lat,latitude,to,normalize,return,the,normalized,latitude,see,normalize,point,geo,point;public,static,double,normalize,lat,double,lat,lat,centered,modulus,lat,360,if,lat,90,lat,180,lat,else,if,lat,90,lat,180,lat,return,lat
GeoUtils -> public static double normalizeLat(double lat);1542820501;Normalize latitude to lie within the -90 to 90 (both inclusive) range._<p>_Note: You should not normalize longitude and latitude separately,_because when normalizing latitude it may be necessary to_add a shift of 180&deg_ in the longitude._For this purpose, you should call the_{@link #normalizePoint(GeoPoint)} function.__@param lat Latitude to normalize_@return The normalized latitude._@see #normalizePoint(GeoPoint);public static double normalizeLat(double lat) {_        if (lat > 90d || lat < -90d) {_            lat = centeredModulus(lat, 360)__            if (lat < -90) {_                lat = -180 - lat__            } else if (lat > 90) {_                lat = 180 - lat__            }_        }_        _        return lat + 0d__    };normalize,latitude,to,lie,within,the,90,to,90,both,inclusive,range,p,note,you,should,not,normalize,longitude,and,latitude,separately,because,when,normalizing,latitude,it,may,be,necessary,to,add,a,shift,of,180,deg,in,the,longitude,for,this,purpose,you,should,call,the,link,normalize,point,geo,point,function,param,lat,latitude,to,normalize,return,the,normalized,latitude,see,normalize,point,geo,point;public,static,double,normalize,lat,double,lat,if,lat,90d,lat,90d,lat,centered,modulus,lat,360,if,lat,90,lat,180,lat,else,if,lat,90,lat,180,lat,return,lat,0d
GeoUtils -> public static GeoPoint parseGeoPoint(Object value, final boolean ignoreZValue) throws ElasticsearchParseException;1524684173;Parses the value as a geopoint. The following types of values are supported:_<p>_Object: has to contain either lat and lon or geohash fields_<p>_String: expected to be in "latitude, longitude" format or a geohash_<p>_Array: two or more elements, the first element is longitude, the second is latitude, the rest is ignored if ignoreZValue is true;public static GeoPoint parseGeoPoint(Object value, final boolean ignoreZValue) throws ElasticsearchParseException {_        try {_            XContentBuilder content = JsonXContent.contentBuilder()__            content.startObject()__            content.field("null_value", value)__            content.endObject()___            try (InputStream stream = BytesReference.bytes(content).streamInput()__                 XContentParser parser = JsonXContent.jsonXContent.createParser(_                     NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {_                parser.nextToken()_ _                parser.nextToken()_ _                parser.nextToken()_ _                return parseGeoPoint(parser, new GeoPoint(), ignoreZValue)__            }__        } catch (IOException ex) {_            throw new ElasticsearchParseException("error parsing geopoint", ex)__        }_    };parses,the,value,as,a,geopoint,the,following,types,of,values,are,supported,p,object,has,to,contain,either,lat,and,lon,or,geohash,fields,p,string,expected,to,be,in,latitude,longitude,format,or,a,geohash,p,array,two,or,more,elements,the,first,element,is,longitude,the,second,is,latitude,the,rest,is,ignored,if,ignore,zvalue,is,true;public,static,geo,point,parse,geo,point,object,value,final,boolean,ignore,zvalue,throws,elasticsearch,parse,exception,try,xcontent,builder,content,json,xcontent,content,builder,content,start,object,content,field,value,content,end,object,try,input,stream,stream,bytes,reference,bytes,content,stream,input,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,logging,deprecation,handler,instance,stream,parser,next,token,parser,next,token,parser,next,token,return,parse,geo,point,parser,new,geo,point,ignore,zvalue,catch,ioexception,ex,throw,new,elasticsearch,parse,exception,error,parsing,geopoint,ex
GeoUtils -> public static GeoPoint parseGeoPoint(Object value, final boolean ignoreZValue) throws ElasticsearchParseException;1527207653;Parses the value as a geopoint. The following types of values are supported:_<p>_Object: has to contain either lat and lon or geohash fields_<p>_String: expected to be in "latitude, longitude" format or a geohash_<p>_Array: two or more elements, the first element is longitude, the second is latitude, the rest is ignored if ignoreZValue is true;public static GeoPoint parseGeoPoint(Object value, final boolean ignoreZValue) throws ElasticsearchParseException {_        try {_            XContentBuilder content = JsonXContent.contentBuilder()__            content.startObject()__            content.field("null_value", value)__            content.endObject()___            try (InputStream stream = BytesReference.bytes(content).streamInput()__                 XContentParser parser = JsonXContent.jsonXContent.createParser(_                     NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {_                parser.nextToken()_ _                parser.nextToken()_ _                parser.nextToken()_ _                return parseGeoPoint(parser, new GeoPoint(), ignoreZValue)__            }__        } catch (IOException ex) {_            throw new ElasticsearchParseException("error parsing geopoint", ex)__        }_    };parses,the,value,as,a,geopoint,the,following,types,of,values,are,supported,p,object,has,to,contain,either,lat,and,lon,or,geohash,fields,p,string,expected,to,be,in,latitude,longitude,format,or,a,geohash,p,array,two,or,more,elements,the,first,element,is,longitude,the,second,is,latitude,the,rest,is,ignored,if,ignore,zvalue,is,true;public,static,geo,point,parse,geo,point,object,value,final,boolean,ignore,zvalue,throws,elasticsearch,parse,exception,try,xcontent,builder,content,json,xcontent,content,builder,content,start,object,content,field,value,content,end,object,try,input,stream,stream,bytes,reference,bytes,content,stream,input,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,logging,deprecation,handler,instance,stream,parser,next,token,parser,next,token,parser,next,token,return,parse,geo,point,parser,new,geo,point,ignore,zvalue,catch,ioexception,ex,throw,new,elasticsearch,parse,exception,error,parsing,geopoint,ex
GeoUtils -> public static GeoPoint parseGeoPoint(Object value, final boolean ignoreZValue) throws ElasticsearchParseException;1542820501;Parses the value as a geopoint. The following types of values are supported:_<p>_Object: has to contain either lat and lon or geohash fields_<p>_String: expected to be in "latitude, longitude" format or a geohash_<p>_Array: two or more elements, the first element is longitude, the second is latitude, the rest is ignored if ignoreZValue is true;public static GeoPoint parseGeoPoint(Object value, final boolean ignoreZValue) throws ElasticsearchParseException {_        try {_            XContentBuilder content = JsonXContent.contentBuilder()__            content.startObject()__            content.field("null_value", value)__            content.endObject()___            try (InputStream stream = BytesReference.bytes(content).streamInput()__                 XContentParser parser = JsonXContent.jsonXContent.createParser(_                     NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {_                parser.nextToken()_ _                parser.nextToken()_ _                parser.nextToken()_ _                return parseGeoPoint(parser, new GeoPoint(), ignoreZValue)__            }__        } catch (IOException ex) {_            throw new ElasticsearchParseException("error parsing geopoint", ex)__        }_    };parses,the,value,as,a,geopoint,the,following,types,of,values,are,supported,p,object,has,to,contain,either,lat,and,lon,or,geohash,fields,p,string,expected,to,be,in,latitude,longitude,format,or,a,geohash,p,array,two,or,more,elements,the,first,element,is,longitude,the,second,is,latitude,the,rest,is,ignored,if,ignore,zvalue,is,true;public,static,geo,point,parse,geo,point,object,value,final,boolean,ignore,zvalue,throws,elasticsearch,parse,exception,try,xcontent,builder,content,json,xcontent,content,builder,content,start,object,content,field,value,content,end,object,try,input,stream,stream,bytes,reference,bytes,content,stream,input,xcontent,parser,parser,json,xcontent,json,xcontent,create,parser,named,xcontent,registry,empty,logging,deprecation,handler,instance,stream,parser,next,token,parser,next,token,parser,next,token,return,parse,geo,point,parser,new,geo,point,ignore,zvalue,catch,ioexception,ex,throw,new,elasticsearch,parse,exception,error,parsing,geopoint,ex
GeoUtils -> public static void normalizePoint(GeoPoint point, boolean normLat, boolean normLon);1524684173;Normalize the geo {@code Point} for the given coordinates to lie within_their respective normalized ranges._<p>_You can control which coordinate gets normalized with the two flags._<p>_Note: A shift of 180&deg_ is applied in the longitude if necessary,_in order to normalize properly the latitude._If normalizing latitude but not longitude, it is assumed that_the longitude is in the form x+k*360, with x in ]-180_180],_and k is meaningful to the application._Therefore x will be adjusted while keeping k preserved.__@param point   The point to normalize in-place._@param normLat Whether to normalize latitude or leave it as is._@param normLon Whether to normalize longitude.;public static void normalizePoint(GeoPoint point, boolean normLat, boolean normLon) {_        double[] pt = {point.lon(), point.lat()}__        normalizePoint(pt, normLon, normLat)__        point.reset(pt[1], pt[0])__    };normalize,the,geo,code,point,for,the,given,coordinates,to,lie,within,their,respective,normalized,ranges,p,you,can,control,which,coordinate,gets,normalized,with,the,two,flags,p,note,a,shift,of,180,deg,is,applied,in,the,longitude,if,necessary,in,order,to,normalize,properly,the,latitude,if,normalizing,latitude,but,not,longitude,it,is,assumed,that,the,longitude,is,in,the,form,x,k,360,with,x,in,180,180,and,k,is,meaningful,to,the,application,therefore,x,will,be,adjusted,while,keeping,k,preserved,param,point,the,point,to,normalize,in,place,param,norm,lat,whether,to,normalize,latitude,or,leave,it,as,is,param,norm,lon,whether,to,normalize,longitude;public,static,void,normalize,point,geo,point,point,boolean,norm,lat,boolean,norm,lon,double,pt,point,lon,point,lat,normalize,point,pt,norm,lon,norm,lat,point,reset,pt,1,pt,0
GeoUtils -> public static void normalizePoint(GeoPoint point, boolean normLat, boolean normLon);1527207653;Normalize the geo {@code Point} for the given coordinates to lie within_their respective normalized ranges._<p>_You can control which coordinate gets normalized with the two flags._<p>_Note: A shift of 180&deg_ is applied in the longitude if necessary,_in order to normalize properly the latitude._If normalizing latitude but not longitude, it is assumed that_the longitude is in the form x+k*360, with x in ]-180_180],_and k is meaningful to the application._Therefore x will be adjusted while keeping k preserved.__@param point   The point to normalize in-place._@param normLat Whether to normalize latitude or leave it as is._@param normLon Whether to normalize longitude.;public static void normalizePoint(GeoPoint point, boolean normLat, boolean normLon) {_        double[] pt = {point.lon(), point.lat()}__        normalizePoint(pt, normLon, normLat)__        point.reset(pt[1], pt[0])__    };normalize,the,geo,code,point,for,the,given,coordinates,to,lie,within,their,respective,normalized,ranges,p,you,can,control,which,coordinate,gets,normalized,with,the,two,flags,p,note,a,shift,of,180,deg,is,applied,in,the,longitude,if,necessary,in,order,to,normalize,properly,the,latitude,if,normalizing,latitude,but,not,longitude,it,is,assumed,that,the,longitude,is,in,the,form,x,k,360,with,x,in,180,180,and,k,is,meaningful,to,the,application,therefore,x,will,be,adjusted,while,keeping,k,preserved,param,point,the,point,to,normalize,in,place,param,norm,lat,whether,to,normalize,latitude,or,leave,it,as,is,param,norm,lon,whether,to,normalize,longitude;public,static,void,normalize,point,geo,point,point,boolean,norm,lat,boolean,norm,lon,double,pt,point,lon,point,lat,normalize,point,pt,norm,lon,norm,lat,point,reset,pt,1,pt,0
GeoUtils -> public static void normalizePoint(GeoPoint point, boolean normLat, boolean normLon);1542820501;Normalize the geo {@code Point} for the given coordinates to lie within_their respective normalized ranges._<p>_You can control which coordinate gets normalized with the two flags._<p>_Note: A shift of 180&deg_ is applied in the longitude if necessary,_in order to normalize properly the latitude._If normalizing latitude but not longitude, it is assumed that_the longitude is in the form x+k*360, with x in ]-180_180],_and k is meaningful to the application._Therefore x will be adjusted while keeping k preserved.__@param point   The point to normalize in-place._@param normLat Whether to normalize latitude or leave it as is._@param normLon Whether to normalize longitude.;public static void normalizePoint(GeoPoint point, boolean normLat, boolean normLon) {_        double[] pt = {point.lon(), point.lat()}__        normalizePoint(pt, normLon, normLat)__        point.reset(pt[1], pt[0])__    };normalize,the,geo,code,point,for,the,given,coordinates,to,lie,within,their,respective,normalized,ranges,p,you,can,control,which,coordinate,gets,normalized,with,the,two,flags,p,note,a,shift,of,180,deg,is,applied,in,the,longitude,if,necessary,in,order,to,normalize,properly,the,latitude,if,normalizing,latitude,but,not,longitude,it,is,assumed,that,the,longitude,is,in,the,form,x,k,360,with,x,in,180,180,and,k,is,meaningful,to,the,application,therefore,x,will,be,adjusted,while,keeping,k,preserved,param,point,the,point,to,normalize,in,place,param,norm,lat,whether,to,normalize,latitude,or,leave,it,as,is,param,norm,lon,whether,to,normalize,longitude;public,static,void,normalize,point,geo,point,point,boolean,norm,lat,boolean,norm,lon,double,pt,point,lon,point,lat,normalize,point,pt,norm,lon,norm,lat,point,reset,pt,1,pt,0
GeoUtils -> public static boolean isValidLongitude(double longitude);1524684173;Returns true if longitude is actually a valid longitude value.;public static boolean isValidLongitude(double longitude) {_        if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < GeoUtils.MIN_LON || longitude > GeoUtils.MAX_LON) {_            return false__        }_        return true__    };returns,true,if,longitude,is,actually,a,valid,longitude,value;public,static,boolean,is,valid,longitude,double,longitude,if,double,is,na,n,longitude,double,is,infinite,longitude,longitude,geo,utils,longitude,geo,utils,return,false,return,true
GeoUtils -> public static boolean isValidLongitude(double longitude);1527207653;Returns true if longitude is actually a valid longitude value.;public static boolean isValidLongitude(double longitude) {_        if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < GeoUtils.MIN_LON || longitude > GeoUtils.MAX_LON) {_            return false__        }_        return true__    };returns,true,if,longitude,is,actually,a,valid,longitude,value;public,static,boolean,is,valid,longitude,double,longitude,if,double,is,na,n,longitude,double,is,infinite,longitude,longitude,geo,utils,longitude,geo,utils,return,false,return,true
GeoUtils -> public static boolean isValidLongitude(double longitude);1542820501;Returns true if longitude is actually a valid longitude value.;public static boolean isValidLongitude(double longitude) {_        if (Double.isNaN(longitude) || Double.isInfinite(longitude) || longitude < GeoUtils.MIN_LON || longitude > GeoUtils.MAX_LON) {_            return false__        }_        return true__    };returns,true,if,longitude,is,actually,a,valid,longitude,value;public,static,boolean,is,valid,longitude,double,longitude,if,double,is,na,n,longitude,double,is,infinite,longitude,longitude,geo,utils,longitude,geo,utils,return,false,return,true
GeoUtils -> public static double geoHashCellSize(int level);1524684173;Calculate the size (in meters) of geohash cells at a specific level_@param level geohash level must be greater or equal to zero_@return the size of cells at level in meters;public static double geoHashCellSize(int level) {_        assert level>=0__        final double w = geoHashCellWidth(level)__        final double h = geoHashCellHeight(level)__        return Math.sqrt(w*w + h*h)__    };calculate,the,size,in,meters,of,geohash,cells,at,a,specific,level,param,level,geohash,level,must,be,greater,or,equal,to,zero,return,the,size,of,cells,at,level,in,meters;public,static,double,geo,hash,cell,size,int,level,assert,level,0,final,double,w,geo,hash,cell,width,level,final,double,h,geo,hash,cell,height,level,return,math,sqrt,w,w,h,h
GeoUtils -> public static double geoHashCellSize(int level);1527207653;Calculate the size (in meters) of geohash cells at a specific level_@param level geohash level must be greater or equal to zero_@return the size of cells at level in meters;public static double geoHashCellSize(int level) {_        assert level>=0__        final double w = geoHashCellWidth(level)__        final double h = geoHashCellHeight(level)__        return Math.sqrt(w*w + h*h)__    };calculate,the,size,in,meters,of,geohash,cells,at,a,specific,level,param,level,geohash,level,must,be,greater,or,equal,to,zero,return,the,size,of,cells,at,level,in,meters;public,static,double,geo,hash,cell,size,int,level,assert,level,0,final,double,w,geo,hash,cell,width,level,final,double,h,geo,hash,cell,height,level,return,math,sqrt,w,w,h,h
GeoUtils -> public static double geoHashCellSize(int level);1542820501;Calculate the size (in meters) of geohash cells at a specific level_@param level geohash level must be greater or equal to zero_@return the size of cells at level in meters;public static double geoHashCellSize(int level) {_        assert level>=0__        final double w = geoHashCellWidth(level)__        final double h = geoHashCellHeight(level)__        return Math.sqrt(w*w + h*h)__    };calculate,the,size,in,meters,of,geohash,cells,at,a,specific,level,param,level,geohash,level,must,be,greater,or,equal,to,zero,return,the,size,of,cells,at,level,in,meters;public,static,double,geo,hash,cell,size,int,level,assert,level,0,final,double,w,geo,hash,cell,width,level,final,double,h,geo,hash,cell,height,level,return,math,sqrt,w,w,h,h
GeoUtils -> public static int parsePrecision(XContentParser parser) throws IOException, ElasticsearchParseException;1524684173;Parse a precision that can be expressed as an integer or a distance measure like "1km", "10m".__The precision is expressed as a number between 1 and 12 and indicates the length of geohash_used to represent geo points.__@param parser {@link XContentParser} to parse the value from_@return int representing precision;public static int parsePrecision(XContentParser parser) throws IOException, ElasticsearchParseException {_        XContentParser.Token token = parser.currentToken()__        if (token.equals(XContentParser.Token.VALUE_NUMBER)) {_            return XContentMapValues.nodeIntegerValue(parser.intValue())__        } else {_            String precision = parser.text()__            try {_                _                return XContentMapValues.nodeIntegerValue(precision)__            } catch (NumberFormatException e) {_                _                final int parsedPrecision = GeoUtils.geoHashLevelsForPrecision(precision)__                try {_                    return checkPrecisionRange(parsedPrecision)__                } catch (IllegalArgumentException e2) {_                    _                    throw new IllegalArgumentException("precision too high [" + precision + "]", e2)__                }_            }_        }_    };parse,a,precision,that,can,be,expressed,as,an,integer,or,a,distance,measure,like,1km,10m,the,precision,is,expressed,as,a,number,between,1,and,12,and,indicates,the,length,of,geohash,used,to,represent,geo,points,param,parser,link,xcontent,parser,to,parse,the,value,from,return,int,representing,precision;public,static,int,parse,precision,xcontent,parser,parser,throws,ioexception,elasticsearch,parse,exception,xcontent,parser,token,token,parser,current,token,if,token,equals,xcontent,parser,token,return,xcontent,map,values,node,integer,value,parser,int,value,else,string,precision,parser,text,try,return,xcontent,map,values,node,integer,value,precision,catch,number,format,exception,e,final,int,parsed,precision,geo,utils,geo,hash,levels,for,precision,precision,try,return,check,precision,range,parsed,precision,catch,illegal,argument,exception,e2,throw,new,illegal,argument,exception,precision,too,high,precision,e2
GeoUtils -> public static int parsePrecision(XContentParser parser) throws IOException, ElasticsearchParseException;1527207653;Parse a precision that can be expressed as an integer or a distance measure like "1km", "10m".__The precision is expressed as a number between 1 and 12 and indicates the length of geohash_used to represent geo points.__@param parser {@link XContentParser} to parse the value from_@return int representing precision;public static int parsePrecision(XContentParser parser) throws IOException, ElasticsearchParseException {_        XContentParser.Token token = parser.currentToken()__        if (token.equals(XContentParser.Token.VALUE_NUMBER)) {_            return XContentMapValues.nodeIntegerValue(parser.intValue())__        } else {_            String precision = parser.text()__            try {_                _                return XContentMapValues.nodeIntegerValue(precision)__            } catch (NumberFormatException e) {_                _                final int parsedPrecision = GeoUtils.geoHashLevelsForPrecision(precision)__                try {_                    return checkPrecisionRange(parsedPrecision)__                } catch (IllegalArgumentException e2) {_                    _                    throw new IllegalArgumentException("precision too high [" + precision + "]", e2)__                }_            }_        }_    };parse,a,precision,that,can,be,expressed,as,an,integer,or,a,distance,measure,like,1km,10m,the,precision,is,expressed,as,a,number,between,1,and,12,and,indicates,the,length,of,geohash,used,to,represent,geo,points,param,parser,link,xcontent,parser,to,parse,the,value,from,return,int,representing,precision;public,static,int,parse,precision,xcontent,parser,parser,throws,ioexception,elasticsearch,parse,exception,xcontent,parser,token,token,parser,current,token,if,token,equals,xcontent,parser,token,return,xcontent,map,values,node,integer,value,parser,int,value,else,string,precision,parser,text,try,return,xcontent,map,values,node,integer,value,precision,catch,number,format,exception,e,final,int,parsed,precision,geo,utils,geo,hash,levels,for,precision,precision,try,return,check,precision,range,parsed,precision,catch,illegal,argument,exception,e2,throw,new,illegal,argument,exception,precision,too,high,precision,e2
GeoUtils -> public static int parsePrecision(XContentParser parser) throws IOException, ElasticsearchParseException;1542820501;Parse a precision that can be expressed as an integer or a distance measure like "1km", "10m".__The precision is expressed as a number between 1 and 12 and indicates the length of geohash_used to represent geo points.__@param parser {@link XContentParser} to parse the value from_@return int representing precision;public static int parsePrecision(XContentParser parser) throws IOException, ElasticsearchParseException {_        XContentParser.Token token = parser.currentToken()__        if (token.equals(XContentParser.Token.VALUE_NUMBER)) {_            return XContentMapValues.nodeIntegerValue(parser.intValue())__        } else {_            String precision = parser.text()__            try {_                _                return XContentMapValues.nodeIntegerValue(precision)__            } catch (NumberFormatException e) {_                _                final int parsedPrecision = GeoUtils.geoHashLevelsForPrecision(precision)__                try {_                    return checkPrecisionRange(parsedPrecision)__                } catch (IllegalArgumentException e2) {_                    _                    throw new IllegalArgumentException("precision too high [" + precision + "]", e2)__                }_            }_        }_    };parse,a,precision,that,can,be,expressed,as,an,integer,or,a,distance,measure,like,1km,10m,the,precision,is,expressed,as,a,number,between,1,and,12,and,indicates,the,length,of,geohash,used,to,represent,geo,points,param,parser,link,xcontent,parser,to,parse,the,value,from,return,int,representing,precision;public,static,int,parse,precision,xcontent,parser,parser,throws,ioexception,elasticsearch,parse,exception,xcontent,parser,token,token,parser,current,token,if,token,equals,xcontent,parser,token,return,xcontent,map,values,node,integer,value,parser,int,value,else,string,precision,parser,text,try,return,xcontent,map,values,node,integer,value,precision,catch,number,format,exception,e,final,int,parsed,precision,geo,utils,geo,hash,levels,for,precision,precision,try,return,check,precision,range,parsed,precision,catch,illegal,argument,exception,e2,throw,new,illegal,argument,exception,precision,too,high,precision,e2
GeoUtils -> public static double quadTreeCellWidth(int level);1524684173;Calculate the width (in meters) of quadtree cells at a specific level_@param level quadtree level must be greater or equal to zero_@return the width of cells at level in meters;public static double quadTreeCellWidth(int level) {_        assert level >=0__        return EARTH_EQUATOR / (1L<<level)__    };calculate,the,width,in,meters,of,quadtree,cells,at,a,specific,level,param,level,quadtree,level,must,be,greater,or,equal,to,zero,return,the,width,of,cells,at,level,in,meters;public,static,double,quad,tree,cell,width,int,level,assert,level,0,return,1l,level
GeoUtils -> public static double quadTreeCellWidth(int level);1527207653;Calculate the width (in meters) of quadtree cells at a specific level_@param level quadtree level must be greater or equal to zero_@return the width of cells at level in meters;public static double quadTreeCellWidth(int level) {_        assert level >=0__        return EARTH_EQUATOR / (1L<<level)__    };calculate,the,width,in,meters,of,quadtree,cells,at,a,specific,level,param,level,quadtree,level,must,be,greater,or,equal,to,zero,return,the,width,of,cells,at,level,in,meters;public,static,double,quad,tree,cell,width,int,level,assert,level,0,return,1l,level
GeoUtils -> public static double quadTreeCellWidth(int level);1542820501;Calculate the width (in meters) of quadtree cells at a specific level_@param level quadtree level must be greater or equal to zero_@return the width of cells at level in meters;public static double quadTreeCellWidth(int level) {_        assert level >=0__        return EARTH_EQUATOR / (1L<<level)__    };calculate,the,width,in,meters,of,quadtree,cells,at,a,specific,level,param,level,quadtree,level,must,be,greater,or,equal,to,zero,return,the,width,of,cells,at,level,in,meters;public,static,double,quad,tree,cell,width,int,level,assert,level,0,return,1l,level
GeoUtils -> public static boolean rectangleContainsPoint(Rectangle r, double lat, double lon);1524684173;check if point is within a rectangle_todo: move this to lucene Rectangle class;public static boolean rectangleContainsPoint(Rectangle r, double lat, double lon) {_        if (lat >= r.minLat && lat <= r.maxLat) {_            _            return r.crossesDateline() ? lon >= r.minLon || lon <= r.maxLon : lon >= r.minLon && lon <= r.maxLon__        }_        return false__    };check,if,point,is,within,a,rectangle,todo,move,this,to,lucene,rectangle,class;public,static,boolean,rectangle,contains,point,rectangle,r,double,lat,double,lon,if,lat,r,min,lat,lat,r,max,lat,return,r,crosses,dateline,lon,r,min,lon,lon,r,max,lon,lon,r,min,lon,lon,r,max,lon,return,false
GeoUtils -> public static boolean rectangleContainsPoint(Rectangle r, double lat, double lon);1527207653;check if point is within a rectangle_todo: move this to lucene Rectangle class;public static boolean rectangleContainsPoint(Rectangle r, double lat, double lon) {_        if (lat >= r.minLat && lat <= r.maxLat) {_            _            return r.crossesDateline() ? lon >= r.minLon || lon <= r.maxLon : lon >= r.minLon && lon <= r.maxLon__        }_        return false__    };check,if,point,is,within,a,rectangle,todo,move,this,to,lucene,rectangle,class;public,static,boolean,rectangle,contains,point,rectangle,r,double,lat,double,lon,if,lat,r,min,lat,lat,r,max,lat,return,r,crosses,dateline,lon,r,min,lon,lon,r,max,lon,lon,r,min,lon,lon,r,max,lon,return,false
GeoUtils -> public static boolean rectangleContainsPoint(Rectangle r, double lat, double lon);1542820501;check if point is within a rectangle_todo: move this to lucene Rectangle class;public static boolean rectangleContainsPoint(Rectangle r, double lat, double lon) {_        if (lat >= r.minLat && lat <= r.maxLat) {_            _            return r.crossesDateline() ? lon >= r.minLon || lon <= r.maxLon : lon >= r.minLon && lon <= r.maxLon__        }_        return false__    };check,if,point,is,within,a,rectangle,todo,move,this,to,lucene,rectangle,class;public,static,boolean,rectangle,contains,point,rectangle,r,double,lat,double,lon,if,lat,r,min,lat,lat,r,max,lat,return,r,crosses,dateline,lon,r,min,lon,lon,r,max,lon,lon,r,min,lon,lon,r,max,lon,return,false
GeoUtils -> public static double quadTreeCellHeight(int level);1524684173;Calculate the height (in meters) of quadtree cells at a specific level_@param level quadtree level must be greater or equal to zero_@return the height of cells at level in meters;public static double quadTreeCellHeight(int level) {_        assert level>=0__        return EARTH_POLAR_DISTANCE / (1L<<level)__    };calculate,the,height,in,meters,of,quadtree,cells,at,a,specific,level,param,level,quadtree,level,must,be,greater,or,equal,to,zero,return,the,height,of,cells,at,level,in,meters;public,static,double,quad,tree,cell,height,int,level,assert,level,0,return,1l,level
GeoUtils -> public static double quadTreeCellHeight(int level);1527207653;Calculate the height (in meters) of quadtree cells at a specific level_@param level quadtree level must be greater or equal to zero_@return the height of cells at level in meters;public static double quadTreeCellHeight(int level) {_        assert level>=0__        return EARTH_POLAR_DISTANCE / (1L<<level)__    };calculate,the,height,in,meters,of,quadtree,cells,at,a,specific,level,param,level,quadtree,level,must,be,greater,or,equal,to,zero,return,the,height,of,cells,at,level,in,meters;public,static,double,quad,tree,cell,height,int,level,assert,level,0,return,1l,level
GeoUtils -> public static double quadTreeCellHeight(int level);1542820501;Calculate the height (in meters) of quadtree cells at a specific level_@param level quadtree level must be greater or equal to zero_@return the height of cells at level in meters;public static double quadTreeCellHeight(int level) {_        assert level>=0__        return EARTH_POLAR_DISTANCE / (1L<<level)__    };calculate,the,height,in,meters,of,quadtree,cells,at,a,specific,level,param,level,quadtree,level,must,be,greater,or,equal,to,zero,return,the,height,of,cells,at,level,in,meters;public,static,double,quad,tree,cell,height,int,level,assert,level,0,return,1l,level
GeoUtils -> public static int checkPrecisionRange(int precision);1524684173;Checks that the precision is within range supported by elasticsearch - between 1 and 12__Returns the precision value if it is in the range and throws an IllegalArgumentException if it_is outside the range.;public static int checkPrecisionRange(int precision) {_        if ((precision < 1) || (precision > 12)) {_            throw new IllegalArgumentException("Invalid geohash aggregation precision of " + precision_                + ". Must be between 1 and 12.")__        }_        return precision__    };checks,that,the,precision,is,within,range,supported,by,elasticsearch,between,1,and,12,returns,the,precision,value,if,it,is,in,the,range,and,throws,an,illegal,argument,exception,if,it,is,outside,the,range;public,static,int,check,precision,range,int,precision,if,precision,1,precision,12,throw,new,illegal,argument,exception,invalid,geohash,aggregation,precision,of,precision,must,be,between,1,and,12,return,precision
GeoUtils -> public static int checkPrecisionRange(int precision);1527207653;Checks that the precision is within range supported by elasticsearch - between 1 and 12__Returns the precision value if it is in the range and throws an IllegalArgumentException if it_is outside the range.;public static int checkPrecisionRange(int precision) {_        if ((precision < 1) || (precision > 12)) {_            throw new IllegalArgumentException("Invalid geohash aggregation precision of " + precision_                + ". Must be between 1 and 12.")__        }_        return precision__    };checks,that,the,precision,is,within,range,supported,by,elasticsearch,between,1,and,12,returns,the,precision,value,if,it,is,in,the,range,and,throws,an,illegal,argument,exception,if,it,is,outside,the,range;public,static,int,check,precision,range,int,precision,if,precision,1,precision,12,throw,new,illegal,argument,exception,invalid,geohash,aggregation,precision,of,precision,must,be,between,1,and,12,return,precision
GeoUtils -> public static int checkPrecisionRange(int precision);1542820501;Checks that the precision is within range supported by elasticsearch - between 1 and 12__Returns the precision value if it is in the range and throws an IllegalArgumentException if it_is outside the range.;public static int checkPrecisionRange(int precision) {_        if ((precision < 1) || (precision > 12)) {_            throw new IllegalArgumentException("Invalid geohash aggregation precision of " + precision_                + ". Must be between 1 and 12.")__        }_        return precision__    };checks,that,the,precision,is,within,range,supported,by,elasticsearch,between,1,and,12,returns,the,precision,value,if,it,is,in,the,range,and,throws,an,illegal,argument,exception,if,it,is,outside,the,range;public,static,int,check,precision,range,int,precision,if,precision,1,precision,12,throw,new,illegal,argument,exception,invalid,geohash,aggregation,precision,of,precision,must,be,between,1,and,12,return,precision
GeoUtils -> public static double arcDistance(double lat1, double lon1, double lat2, double lon2);1524684173;Return the distance (in meters) between 2 lat,lon geo points using the haversine method implemented by lucene;public static double arcDistance(double lat1, double lon1, double lat2, double lon2) {_        return SloppyMath.haversinMeters(lat1, lon1, lat2, lon2)__    };return,the,distance,in,meters,between,2,lat,lon,geo,points,using,the,haversine,method,implemented,by,lucene;public,static,double,arc,distance,double,lat1,double,lon1,double,lat2,double,lon2,return,sloppy,math,haversin,meters,lat1,lon1,lat2,lon2
GeoUtils -> public static double arcDistance(double lat1, double lon1, double lat2, double lon2);1527207653;Return the distance (in meters) between 2 lat,lon geo points using the haversine method implemented by lucene;public static double arcDistance(double lat1, double lon1, double lat2, double lon2) {_        return SloppyMath.haversinMeters(lat1, lon1, lat2, lon2)__    };return,the,distance,in,meters,between,2,lat,lon,geo,points,using,the,haversine,method,implemented,by,lucene;public,static,double,arc,distance,double,lat1,double,lon1,double,lat2,double,lon2,return,sloppy,math,haversin,meters,lat1,lon1,lat2,lon2
GeoUtils -> public static double arcDistance(double lat1, double lon1, double lat2, double lon2);1542820501;Return the distance (in meters) between 2 lat,lon geo points using the haversine method implemented by lucene;public static double arcDistance(double lat1, double lon1, double lat2, double lon2) {_        return SloppyMath.haversinMeters(lat1, lon1, lat2, lon2)__    };return,the,distance,in,meters,between,2,lat,lon,geo,points,using,the,haversine,method,implemented,by,lucene;public,static,double,arc,distance,double,lat1,double,lon1,double,lat2,double,lon2,return,sloppy,math,haversin,meters,lat1,lon1,lat2,lon2
GeoUtils -> public static double normalizeLon(double lon);1524684173;Normalize longitude to lie within the -180 (exclusive) to 180 (inclusive) range.__@param lon Longitude to normalize_@return The normalized longitude.;public static double normalizeLon(double lon) {_        return centeredModulus(lon, 360)__    };normalize,longitude,to,lie,within,the,180,exclusive,to,180,inclusive,range,param,lon,longitude,to,normalize,return,the,normalized,longitude;public,static,double,normalize,lon,double,lon,return,centered,modulus,lon,360
GeoUtils -> public static double normalizeLon(double lon);1527207653;Normalize longitude to lie within the -180 (exclusive) to 180 (inclusive) range.__@param lon Longitude to normalize_@return The normalized longitude.;public static double normalizeLon(double lon) {_        return centeredModulus(lon, 360)__    };normalize,longitude,to,lie,within,the,180,exclusive,to,180,inclusive,range,param,lon,longitude,to,normalize,return,the,normalized,longitude;public,static,double,normalize,lon,double,lon,return,centered,modulus,lon,360
GeoUtils -> public static double normalizeLon(double lon);1542820501;Normalize longitude to lie within the -180 (exclusive) to 180 (inclusive) range.__@param lon Longitude to normalize_@return The normalized longitude.;public static double normalizeLon(double lon) {_        if (lon > 180d || lon <= -180d) {_            lon = centeredModulus(lon, 360)__        }_        _        return lon + 0d__    };normalize,longitude,to,lie,within,the,180,exclusive,to,180,inclusive,range,param,lon,longitude,to,normalize,return,the,normalized,longitude;public,static,double,normalize,lon,double,lon,if,lon,180d,lon,180d,lon,centered,modulus,lon,360,return,lon,0d
GeoUtils -> public static GeoPoint parseGeoPoint(XContentParser parser, GeoPoint point, final boolean ignoreZValue)             throws IOException, ElasticsearchParseException;1524684173;Parse a {@link GeoPoint} with a {@link XContentParser}. A geopoint has one of the following forms:__<ul>_<li>Object: <pre>{&quot_lat&quot_: <i>&lt_latitude&gt_</i>, &quot_lon&quot_: <i>&lt_longitude&gt_</i>}</pre></li>_<li>String: <pre>&quot_<i>&lt_latitude&gt_</i>,<i>&lt_longitude&gt_</i>&quot_</pre></li>_<li>Geohash: <pre>&quot_<i>&lt_geohash&gt_</i>&quot_</pre></li>_<li>Array: <pre>[<i>&lt_longitude&gt_</i>,<i>&lt_latitude&gt_</i>]</pre></li>_</ul>__@param parser {@link XContentParser} to parse the value from_@param point A {@link GeoPoint} that will be reset by the values parsed_@return new {@link GeoPoint} parsed from the parse;public static GeoPoint parseGeoPoint(XContentParser parser, GeoPoint point, final boolean ignoreZValue)_            throws IOException, ElasticsearchParseException {_        double lat = Double.NaN__        double lon = Double.NaN__        String geohash = null__        NumberFormatException numberFormatException = null___        if(parser.currentToken() == Token.START_OBJECT) {_            while(parser.nextToken() != Token.END_OBJECT) {_                if(parser.currentToken() == Token.FIELD_NAME) {_                    String field = parser.currentName()__                    if(LATITUDE.equals(field)) {_                        parser.nextToken()__                        switch (parser.currentToken()) {_                            case VALUE_NUMBER:_                            case VALUE_STRING:_                                try {_                                    lat = parser.doubleValue(true)__                                } catch (NumberFormatException e) {_                                    numberFormatException = e__                                }_                                break__                            default:_                                throw new ElasticsearchParseException("latitude must be a number")__                        }_                    } else if (LONGITUDE.equals(field)) {_                        parser.nextToken()__                        switch (parser.currentToken()) {_                            case VALUE_NUMBER:_                            case VALUE_STRING:_                                try {_                                    lon = parser.doubleValue(true)__                                } catch (NumberFormatException e) {_                                    numberFormatException = e__                                }_                                break__                            default:_                                throw new ElasticsearchParseException("longitude must be a number")__                        }_                    } else if (GEOHASH.equals(field)) {_                        if(parser.nextToken() == Token.VALUE_STRING) {_                            geohash = parser.text()__                        } else {_                            throw new ElasticsearchParseException("geohash must be a string")__                        }_                    } else {_                        throw new ElasticsearchParseException("field must be either [{}], [{}] or [{}]", LATITUDE, LONGITUDE, GEOHASH)__                    }_                } else {_                    throw new ElasticsearchParseException("token [{}] not allowed", parser.currentToken())__                }_            }__            if (geohash != null) {_                if(!Double.isNaN(lat) || !Double.isNaN(lon)) {_                    throw new ElasticsearchParseException("field must be either lat/lon or geohash")__                } else {_                    return point.resetFromGeoHash(geohash)__                }_            } else if (numberFormatException != null) {_                throw new ElasticsearchParseException("[{}] and [{}] must be valid double values", numberFormatException, LATITUDE,_                    LONGITUDE)__            } else if (Double.isNaN(lat)) {_                throw new ElasticsearchParseException("field [{}] missing", LATITUDE)__            } else if (Double.isNaN(lon)) {_                throw new ElasticsearchParseException("field [{}] missing", LONGITUDE)__            } else {_                return point.reset(lat, lon)__            }__        } else if(parser.currentToken() == Token.START_ARRAY) {_            int element = 0__            while(parser.nextToken() != Token.END_ARRAY) {_                if(parser.currentToken() == Token.VALUE_NUMBER) {_                    element++__                    if(element == 1) {_                        lon = parser.doubleValue()__                    } else if(element == 2) {_                        lat = parser.doubleValue()__                    } else {_                        GeoPoint.assertZValue(ignoreZValue, parser.doubleValue())__                    }_                } else {_                    throw new ElasticsearchParseException("numeric value expected")__                }_            }_            return point.reset(lat, lon)__        } else if(parser.currentToken() == Token.VALUE_STRING) {_            return point.resetFromString(parser.text(), ignoreZValue)__        } else {_            throw new ElasticsearchParseException("geo_point expected")__        }_    };parse,a,link,geo,point,with,a,link,xcontent,parser,a,geopoint,has,one,of,the,following,forms,ul,li,object,pre,quot,lat,quot,i,lt,latitude,gt,i,quot,lon,quot,i,lt,longitude,gt,i,pre,li,li,string,pre,quot,i,lt,latitude,gt,i,i,lt,longitude,gt,i,quot,pre,li,li,geohash,pre,quot,i,lt,geohash,gt,i,quot,pre,li,li,array,pre,i,lt,longitude,gt,i,i,lt,latitude,gt,i,pre,li,ul,param,parser,link,xcontent,parser,to,parse,the,value,from,param,point,a,link,geo,point,that,will,be,reset,by,the,values,parsed,return,new,link,geo,point,parsed,from,the,parse;public,static,geo,point,parse,geo,point,xcontent,parser,parser,geo,point,point,final,boolean,ignore,zvalue,throws,ioexception,elasticsearch,parse,exception,double,lat,double,na,n,double,lon,double,na,n,string,geohash,null,number,format,exception,number,format,exception,null,if,parser,current,token,token,while,parser,next,token,token,if,parser,current,token,token,string,field,parser,current,name,if,latitude,equals,field,parser,next,token,switch,parser,current,token,case,case,try,lat,parser,double,value,true,catch,number,format,exception,e,number,format,exception,e,break,default,throw,new,elasticsearch,parse,exception,latitude,must,be,a,number,else,if,longitude,equals,field,parser,next,token,switch,parser,current,token,case,case,try,lon,parser,double,value,true,catch,number,format,exception,e,number,format,exception,e,break,default,throw,new,elasticsearch,parse,exception,longitude,must,be,a,number,else,if,geohash,equals,field,if,parser,next,token,token,geohash,parser,text,else,throw,new,elasticsearch,parse,exception,geohash,must,be,a,string,else,throw,new,elasticsearch,parse,exception,field,must,be,either,or,latitude,longitude,geohash,else,throw,new,elasticsearch,parse,exception,token,not,allowed,parser,current,token,if,geohash,null,if,double,is,na,n,lat,double,is,na,n,lon,throw,new,elasticsearch,parse,exception,field,must,be,either,lat,lon,or,geohash,else,return,point,reset,from,geo,hash,geohash,else,if,number,format,exception,null,throw,new,elasticsearch,parse,exception,and,must,be,valid,double,values,number,format,exception,latitude,longitude,else,if,double,is,na,n,lat,throw,new,elasticsearch,parse,exception,field,missing,latitude,else,if,double,is,na,n,lon,throw,new,elasticsearch,parse,exception,field,missing,longitude,else,return,point,reset,lat,lon,else,if,parser,current,token,token,int,element,0,while,parser,next,token,token,if,parser,current,token,token,element,if,element,1,lon,parser,double,value,else,if,element,2,lat,parser,double,value,else,geo,point,assert,zvalue,ignore,zvalue,parser,double,value,else,throw,new,elasticsearch,parse,exception,numeric,value,expected,return,point,reset,lat,lon,else,if,parser,current,token,token,return,point,reset,from,string,parser,text,ignore,zvalue,else,throw,new,elasticsearch,parse,exception,expected
GeoUtils -> public static GeoPoint parseGeoPoint(XContentParser parser, GeoPoint point, final boolean ignoreZValue)             throws IOException, ElasticsearchParseException;1527207653;Parse a geopoint represented as an object, string or an array. If the geopoint is represented as a geohash,_the left bottom corner of the geohash cell is used as the geopoint coordinates.GeoBoundingBoxQueryBuilder.java;public static GeoPoint parseGeoPoint(XContentParser parser, GeoPoint point, final boolean ignoreZValue)_            throws IOException, ElasticsearchParseException {_        return parseGeoPoint(parser, point, ignoreZValue, EffectivePoint.BOTTOM_LEFT)__    };parse,a,geopoint,represented,as,an,object,string,or,an,array,if,the,geopoint,is,represented,as,a,geohash,the,left,bottom,corner,of,the,geohash,cell,is,used,as,the,geopoint,coordinates,geo,bounding,box,query,builder,java;public,static,geo,point,parse,geo,point,xcontent,parser,parser,geo,point,point,final,boolean,ignore,zvalue,throws,ioexception,elasticsearch,parse,exception,return,parse,geo,point,parser,point,ignore,zvalue,effective,point
GeoUtils -> public static GeoPoint parseGeoPoint(XContentParser parser, GeoPoint point, final boolean ignoreZValue)             throws IOException, ElasticsearchParseException;1542820501;Parse a geopoint represented as an object, string or an array. If the geopoint is represented as a geohash,_the left bottom corner of the geohash cell is used as the geopoint coordinates.GeoBoundingBoxQueryBuilder.java;public static GeoPoint parseGeoPoint(XContentParser parser, GeoPoint point, final boolean ignoreZValue)_            throws IOException, ElasticsearchParseException {_        return parseGeoPoint(parser, point, ignoreZValue, EffectivePoint.BOTTOM_LEFT)__    };parse,a,geopoint,represented,as,an,object,string,or,an,array,if,the,geopoint,is,represented,as,a,geohash,the,left,bottom,corner,of,the,geohash,cell,is,used,as,the,geopoint,coordinates,geo,bounding,box,query,builder,java;public,static,geo,point,parse,geo,point,xcontent,parser,parser,geo,point,point,final,boolean,ignore,zvalue,throws,ioexception,elasticsearch,parse,exception,return,parse,geo,point,parser,point,ignore,zvalue,effective,point
GeoUtils -> public static SortedNumericDoubleValues distanceValues(final GeoDistance distance,                                                            final DistanceUnit unit,                                                            final MultiGeoPointValues geoPointValues,                                                            final GeoPoint... fromPoints);1524684173;Return a {@link SortedNumericDoubleValues} instance that returns the distances to a list of geo-points_for each document.;public static SortedNumericDoubleValues distanceValues(final GeoDistance distance,_                                                           final DistanceUnit unit,_                                                           final MultiGeoPointValues geoPointValues,_                                                           final GeoPoint... fromPoints) {_        final GeoPointValues singleValues = FieldData.unwrapSingleton(geoPointValues)__        if (singleValues != null && fromPoints.length == 1) {_            return FieldData.singleton(new NumericDoubleValues() {__                @Override_                public boolean advanceExact(int doc) throws IOException {_                    return singleValues.advanceExact(doc)__                }__                @Override_                public double doubleValue() throws IOException {_                    final GeoPoint from = fromPoints[0]__                    final GeoPoint to = singleValues.geoPointValue()__                    return distance.calculate(from.lat(), from.lon(), to.lat(), to.lon(), unit)__                }__            })__        } else {_            return new SortingNumericDoubleValues() {_                @Override_                public boolean advanceExact(int target) throws IOException {_                    if (geoPointValues.advanceExact(target)) {_                        resize(geoPointValues.docValueCount() * fromPoints.length)__                        int v = 0__                        for (int i = 0_ i < geoPointValues.docValueCount()_ ++i) {_                            final GeoPoint point = geoPointValues.nextValue()__                            for (GeoPoint from : fromPoints) {_                                values[v] = distance.calculate(from.lat(), from.lon(), point.lat(), point.lon(), unit)__                                v++__                            }_                        }_                        sort()__                        return true__                    } else {_                        return false__                    }_                }_            }__        }_    };return,a,link,sorted,numeric,double,values,instance,that,returns,the,distances,to,a,list,of,geo,points,for,each,document;public,static,sorted,numeric,double,values,distance,values,final,geo,distance,distance,final,distance,unit,unit,final,multi,geo,point,values,geo,point,values,final,geo,point,from,points,final,geo,point,values,single,values,field,data,unwrap,singleton,geo,point,values,if,single,values,null,from,points,length,1,return,field,data,singleton,new,numeric,double,values,override,public,boolean,advance,exact,int,doc,throws,ioexception,return,single,values,advance,exact,doc,override,public,double,double,value,throws,ioexception,final,geo,point,from,from,points,0,final,geo,point,to,single,values,geo,point,value,return,distance,calculate,from,lat,from,lon,to,lat,to,lon,unit,else,return,new,sorting,numeric,double,values,override,public,boolean,advance,exact,int,target,throws,ioexception,if,geo,point,values,advance,exact,target,resize,geo,point,values,doc,value,count,from,points,length,int,v,0,for,int,i,0,i,geo,point,values,doc,value,count,i,final,geo,point,point,geo,point,values,next,value,for,geo,point,from,from,points,values,v,distance,calculate,from,lat,from,lon,point,lat,point,lon,unit,v,sort,return,true,else,return,false
GeoUtils -> public static SortedNumericDoubleValues distanceValues(final GeoDistance distance,                                                            final DistanceUnit unit,                                                            final MultiGeoPointValues geoPointValues,                                                            final GeoPoint... fromPoints);1527207653;Return a {@link SortedNumericDoubleValues} instance that returns the distances to a list of geo-points_for each document.;public static SortedNumericDoubleValues distanceValues(final GeoDistance distance,_                                                           final DistanceUnit unit,_                                                           final MultiGeoPointValues geoPointValues,_                                                           final GeoPoint... fromPoints) {_        final GeoPointValues singleValues = FieldData.unwrapSingleton(geoPointValues)__        if (singleValues != null && fromPoints.length == 1) {_            return FieldData.singleton(new NumericDoubleValues() {__                @Override_                public boolean advanceExact(int doc) throws IOException {_                    return singleValues.advanceExact(doc)__                }__                @Override_                public double doubleValue() throws IOException {_                    final GeoPoint from = fromPoints[0]__                    final GeoPoint to = singleValues.geoPointValue()__                    return distance.calculate(from.lat(), from.lon(), to.lat(), to.lon(), unit)__                }__            })__        } else {_            return new SortingNumericDoubleValues() {_                @Override_                public boolean advanceExact(int target) throws IOException {_                    if (geoPointValues.advanceExact(target)) {_                        resize(geoPointValues.docValueCount() * fromPoints.length)__                        int v = 0__                        for (int i = 0_ i < geoPointValues.docValueCount()_ ++i) {_                            final GeoPoint point = geoPointValues.nextValue()__                            for (GeoPoint from : fromPoints) {_                                values[v] = distance.calculate(from.lat(), from.lon(), point.lat(), point.lon(), unit)__                                v++__                            }_                        }_                        sort()__                        return true__                    } else {_                        return false__                    }_                }_            }__        }_    };return,a,link,sorted,numeric,double,values,instance,that,returns,the,distances,to,a,list,of,geo,points,for,each,document;public,static,sorted,numeric,double,values,distance,values,final,geo,distance,distance,final,distance,unit,unit,final,multi,geo,point,values,geo,point,values,final,geo,point,from,points,final,geo,point,values,single,values,field,data,unwrap,singleton,geo,point,values,if,single,values,null,from,points,length,1,return,field,data,singleton,new,numeric,double,values,override,public,boolean,advance,exact,int,doc,throws,ioexception,return,single,values,advance,exact,doc,override,public,double,double,value,throws,ioexception,final,geo,point,from,from,points,0,final,geo,point,to,single,values,geo,point,value,return,distance,calculate,from,lat,from,lon,to,lat,to,lon,unit,else,return,new,sorting,numeric,double,values,override,public,boolean,advance,exact,int,target,throws,ioexception,if,geo,point,values,advance,exact,target,resize,geo,point,values,doc,value,count,from,points,length,int,v,0,for,int,i,0,i,geo,point,values,doc,value,count,i,final,geo,point,point,geo,point,values,next,value,for,geo,point,from,from,points,values,v,distance,calculate,from,lat,from,lon,point,lat,point,lon,unit,v,sort,return,true,else,return,false
GeoUtils -> public static SortedNumericDoubleValues distanceValues(final GeoDistance distance,                                                            final DistanceUnit unit,                                                            final MultiGeoPointValues geoPointValues,                                                            final GeoPoint... fromPoints);1542820501;Return a {@link SortedNumericDoubleValues} instance that returns the distances to a list of geo-points_for each document.;public static SortedNumericDoubleValues distanceValues(final GeoDistance distance,_                                                           final DistanceUnit unit,_                                                           final MultiGeoPointValues geoPointValues,_                                                           final GeoPoint... fromPoints) {_        final GeoPointValues singleValues = FieldData.unwrapSingleton(geoPointValues)__        if (singleValues != null && fromPoints.length == 1) {_            return FieldData.singleton(new NumericDoubleValues() {__                @Override_                public boolean advanceExact(int doc) throws IOException {_                    return singleValues.advanceExact(doc)__                }__                @Override_                public double doubleValue() throws IOException {_                    final GeoPoint from = fromPoints[0]__                    final GeoPoint to = singleValues.geoPointValue()__                    return distance.calculate(from.lat(), from.lon(), to.lat(), to.lon(), unit)__                }__            })__        } else {_            return new SortingNumericDoubleValues() {_                @Override_                public boolean advanceExact(int target) throws IOException {_                    if (geoPointValues.advanceExact(target)) {_                        resize(geoPointValues.docValueCount() * fromPoints.length)__                        int v = 0__                        for (int i = 0_ i < geoPointValues.docValueCount()_ ++i) {_                            final GeoPoint point = geoPointValues.nextValue()__                            for (GeoPoint from : fromPoints) {_                                values[v] = distance.calculate(from.lat(), from.lon(), point.lat(), point.lon(), unit)__                                v++__                            }_                        }_                        sort()__                        return true__                    } else {_                        return false__                    }_                }_            }__        }_    };return,a,link,sorted,numeric,double,values,instance,that,returns,the,distances,to,a,list,of,geo,points,for,each,document;public,static,sorted,numeric,double,values,distance,values,final,geo,distance,distance,final,distance,unit,unit,final,multi,geo,point,values,geo,point,values,final,geo,point,from,points,final,geo,point,values,single,values,field,data,unwrap,singleton,geo,point,values,if,single,values,null,from,points,length,1,return,field,data,singleton,new,numeric,double,values,override,public,boolean,advance,exact,int,doc,throws,ioexception,return,single,values,advance,exact,doc,override,public,double,double,value,throws,ioexception,final,geo,point,from,from,points,0,final,geo,point,to,single,values,geo,point,value,return,distance,calculate,from,lat,from,lon,to,lat,to,lon,unit,else,return,new,sorting,numeric,double,values,override,public,boolean,advance,exact,int,target,throws,ioexception,if,geo,point,values,advance,exact,target,resize,geo,point,values,doc,value,count,from,points,length,int,v,0,for,int,i,0,i,geo,point,values,doc,value,count,i,final,geo,point,point,geo,point,values,next,value,for,geo,point,from,from,points,values,v,distance,calculate,from,lat,from,lon,point,lat,point,lon,unit,v,sort,return,true,else,return,false
GeoUtils -> public static boolean isValidLatitude(double latitude);1524684173;Returns true if latitude is actually a valid latitude value.;public static boolean isValidLatitude(double latitude) {_        if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < GeoUtils.MIN_LAT || latitude > GeoUtils.MAX_LAT) {_            return false__        }_        return true__    };returns,true,if,latitude,is,actually,a,valid,latitude,value;public,static,boolean,is,valid,latitude,double,latitude,if,double,is,na,n,latitude,double,is,infinite,latitude,latitude,geo,utils,latitude,geo,utils,return,false,return,true
GeoUtils -> public static boolean isValidLatitude(double latitude);1527207653;Returns true if latitude is actually a valid latitude value.;public static boolean isValidLatitude(double latitude) {_        if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < GeoUtils.MIN_LAT || latitude > GeoUtils.MAX_LAT) {_            return false__        }_        return true__    };returns,true,if,latitude,is,actually,a,valid,latitude,value;public,static,boolean,is,valid,latitude,double,latitude,if,double,is,na,n,latitude,double,is,infinite,latitude,latitude,geo,utils,latitude,geo,utils,return,false,return,true
GeoUtils -> public static boolean isValidLatitude(double latitude);1542820501;Returns true if latitude is actually a valid latitude value.;public static boolean isValidLatitude(double latitude) {_        if (Double.isNaN(latitude) || Double.isInfinite(latitude) || latitude < GeoUtils.MIN_LAT || latitude > GeoUtils.MAX_LAT) {_            return false__        }_        return true__    };returns,true,if,latitude,is,actually,a,valid,latitude,value;public,static,boolean,is,valid,latitude,double,latitude,if,double,is,na,n,latitude,double,is,infinite,latitude,latitude,geo,utils,latitude,geo,utils,return,false,return,true
GeoUtils -> public static int quadTreeLevelsForPrecision(String distance);1524684173;Calculate the number of levels needed for a specific precision. QuadTree_cells will not exceed the specified size (diagonal) of the precision._@param distance Maximum size of cells as unit string (must greater or equal to zero)_@return levels need to achieve precision;public static int quadTreeLevelsForPrecision(String distance) {_        return quadTreeLevelsForPrecision(DistanceUnit.METERS.parse(distance, DistanceUnit.DEFAULT))__    };calculate,the,number,of,levels,needed,for,a,specific,precision,quad,tree,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,distance,maximum,size,of,cells,as,unit,string,must,greater,or,equal,to,zero,return,levels,need,to,achieve,precision;public,static,int,quad,tree,levels,for,precision,string,distance,return,quad,tree,levels,for,precision,distance,unit,meters,parse,distance,distance,unit,default
GeoUtils -> public static int quadTreeLevelsForPrecision(String distance);1527207653;Calculate the number of levels needed for a specific precision. QuadTree_cells will not exceed the specified size (diagonal) of the precision._@param distance Maximum size of cells as unit string (must greater or equal to zero)_@return levels need to achieve precision;public static int quadTreeLevelsForPrecision(String distance) {_        return quadTreeLevelsForPrecision(DistanceUnit.METERS.parse(distance, DistanceUnit.DEFAULT))__    };calculate,the,number,of,levels,needed,for,a,specific,precision,quad,tree,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,distance,maximum,size,of,cells,as,unit,string,must,greater,or,equal,to,zero,return,levels,need,to,achieve,precision;public,static,int,quad,tree,levels,for,precision,string,distance,return,quad,tree,levels,for,precision,distance,unit,meters,parse,distance,distance,unit,default
GeoUtils -> public static int quadTreeLevelsForPrecision(String distance);1542820501;Calculate the number of levels needed for a specific precision. QuadTree_cells will not exceed the specified size (diagonal) of the precision._@param distance Maximum size of cells as unit string (must greater or equal to zero)_@return levels need to achieve precision;public static int quadTreeLevelsForPrecision(String distance) {_        return quadTreeLevelsForPrecision(DistanceUnit.METERS.parse(distance, DistanceUnit.DEFAULT))__    };calculate,the,number,of,levels,needed,for,a,specific,precision,quad,tree,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,distance,maximum,size,of,cells,as,unit,string,must,greater,or,equal,to,zero,return,levels,need,to,achieve,precision;public,static,int,quad,tree,levels,for,precision,string,distance,return,quad,tree,levels,for,precision,distance,unit,meters,parse,distance,distance,unit,default
GeoUtils -> public static double geoHashCellHeight(int level);1524684173;Calculate the height (in meters) of geohash cells at a specific level_@param level geohash level must be greater or equal to zero_@return the height of cells at level in meters;public static double geoHashCellHeight(int level) {_        assert level>=0__        _        _        return EARTH_POLAR_DISTANCE / (1L<<((((level+1)/2)*2) + ((level/2)*3)))__    };calculate,the,height,in,meters,of,geohash,cells,at,a,specific,level,param,level,geohash,level,must,be,greater,or,equal,to,zero,return,the,height,of,cells,at,level,in,meters;public,static,double,geo,hash,cell,height,int,level,assert,level,0,return,1l,level,1,2,2,level,2,3
GeoUtils -> public static double geoHashCellHeight(int level);1527207653;Calculate the height (in meters) of geohash cells at a specific level_@param level geohash level must be greater or equal to zero_@return the height of cells at level in meters;public static double geoHashCellHeight(int level) {_        assert level>=0__        _        _        return EARTH_POLAR_DISTANCE / (1L<<((((level+1)/2)*2) + ((level/2)*3)))__    };calculate,the,height,in,meters,of,geohash,cells,at,a,specific,level,param,level,geohash,level,must,be,greater,or,equal,to,zero,return,the,height,of,cells,at,level,in,meters;public,static,double,geo,hash,cell,height,int,level,assert,level,0,return,1l,level,1,2,2,level,2,3
GeoUtils -> public static double geoHashCellHeight(int level);1542820501;Calculate the height (in meters) of geohash cells at a specific level_@param level geohash level must be greater or equal to zero_@return the height of cells at level in meters;public static double geoHashCellHeight(int level) {_        assert level>=0__        _        _        return EARTH_POLAR_DISTANCE / (1L<<((((level+1)/2)*2) + ((level/2)*3)))__    };calculate,the,height,in,meters,of,geohash,cells,at,a,specific,level,param,level,geohash,level,must,be,greater,or,equal,to,zero,return,the,height,of,cells,at,level,in,meters;public,static,double,geo,hash,cell,height,int,level,assert,level,0,return,1l,level,1,2,2,level,2,3
GeoUtils -> public static int geoHashLevelsForPrecision(String distance);1524684173;Calculate the number of levels needed for a specific precision. GeoHash_cells will not exceed the specified size (diagonal) of the precision._@param distance Maximum size of cells as unit string (must greater or equal to zero)_@return levels need to achieve precision;public static int geoHashLevelsForPrecision(String distance) {_        return geoHashLevelsForPrecision(DistanceUnit.METERS.parse(distance, DistanceUnit.DEFAULT))__    };calculate,the,number,of,levels,needed,for,a,specific,precision,geo,hash,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,distance,maximum,size,of,cells,as,unit,string,must,greater,or,equal,to,zero,return,levels,need,to,achieve,precision;public,static,int,geo,hash,levels,for,precision,string,distance,return,geo,hash,levels,for,precision,distance,unit,meters,parse,distance,distance,unit,default
GeoUtils -> public static int geoHashLevelsForPrecision(String distance);1527207653;Calculate the number of levels needed for a specific precision. GeoHash_cells will not exceed the specified size (diagonal) of the precision._@param distance Maximum size of cells as unit string (must greater or equal to zero)_@return levels need to achieve precision;public static int geoHashLevelsForPrecision(String distance) {_        return geoHashLevelsForPrecision(DistanceUnit.METERS.parse(distance, DistanceUnit.DEFAULT))__    };calculate,the,number,of,levels,needed,for,a,specific,precision,geo,hash,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,distance,maximum,size,of,cells,as,unit,string,must,greater,or,equal,to,zero,return,levels,need,to,achieve,precision;public,static,int,geo,hash,levels,for,precision,string,distance,return,geo,hash,levels,for,precision,distance,unit,meters,parse,distance,distance,unit,default
GeoUtils -> public static int geoHashLevelsForPrecision(String distance);1542820501;Calculate the number of levels needed for a specific precision. GeoHash_cells will not exceed the specified size (diagonal) of the precision._@param distance Maximum size of cells as unit string (must greater or equal to zero)_@return levels need to achieve precision;public static int geoHashLevelsForPrecision(String distance) {_        return geoHashLevelsForPrecision(DistanceUnit.METERS.parse(distance, DistanceUnit.DEFAULT))__    };calculate,the,number,of,levels,needed,for,a,specific,precision,geo,hash,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,distance,maximum,size,of,cells,as,unit,string,must,greater,or,equal,to,zero,return,levels,need,to,achieve,precision;public,static,int,geo,hash,levels,for,precision,string,distance,return,geo,hash,levels,for,precision,distance,unit,meters,parse,distance,distance,unit,default
GeoUtils -> public static GeoPoint parseGeoPoint(XContentParser parser, GeoPoint point, final boolean ignoreZValue, EffectivePoint effectivePoint)             throws IOException, ElasticsearchParseException;1527207653;Parse a {@link GeoPoint} with a {@link XContentParser}. A geopoint has one of the following forms:__<ul>_<li>Object: <pre>{&quot_lat&quot_: <i>&lt_latitude&gt_</i>, &quot_lon&quot_: <i>&lt_longitude&gt_</i>}</pre></li>_<li>String: <pre>&quot_<i>&lt_latitude&gt_</i>,<i>&lt_longitude&gt_</i>&quot_</pre></li>_<li>Geohash: <pre>&quot_<i>&lt_geohash&gt_</i>&quot_</pre></li>_<li>Array: <pre>[<i>&lt_longitude&gt_</i>,<i>&lt_latitude&gt_</i>]</pre></li>_</ul>__@param parser {@link XContentParser} to parse the value from_@param point A {@link GeoPoint} that will be reset by the values parsed_@return new {@link GeoPoint} parsed from the parse;public static GeoPoint parseGeoPoint(XContentParser parser, GeoPoint point, final boolean ignoreZValue, EffectivePoint effectivePoint)_            throws IOException, ElasticsearchParseException {_        double lat = Double.NaN__        double lon = Double.NaN__        String geohash = null__        NumberFormatException numberFormatException = null___        if(parser.currentToken() == Token.START_OBJECT) {_            while(parser.nextToken() != Token.END_OBJECT) {_                if(parser.currentToken() == Token.FIELD_NAME) {_                    String field = parser.currentName()__                    if(LATITUDE.equals(field)) {_                        parser.nextToken()__                        switch (parser.currentToken()) {_                            case VALUE_NUMBER:_                            case VALUE_STRING:_                                try {_                                    lat = parser.doubleValue(true)__                                } catch (NumberFormatException e) {_                                    numberFormatException = e__                                }_                                break__                            default:_                                throw new ElasticsearchParseException("latitude must be a number")__                        }_                    } else if (LONGITUDE.equals(field)) {_                        parser.nextToken()__                        switch (parser.currentToken()) {_                            case VALUE_NUMBER:_                            case VALUE_STRING:_                                try {_                                    lon = parser.doubleValue(true)__                                } catch (NumberFormatException e) {_                                    numberFormatException = e__                                }_                                break__                            default:_                                throw new ElasticsearchParseException("longitude must be a number")__                        }_                    } else if (GEOHASH.equals(field)) {_                        if(parser.nextToken() == Token.VALUE_STRING) {_                            geohash = parser.text()__                        } else {_                            throw new ElasticsearchParseException("geohash must be a string")__                        }_                    } else {_                        throw new ElasticsearchParseException("field must be either [{}], [{}] or [{}]", LATITUDE, LONGITUDE, GEOHASH)__                    }_                } else {_                    throw new ElasticsearchParseException("token [{}] not allowed", parser.currentToken())__                }_            }__            if (geohash != null) {_                if(!Double.isNaN(lat) || !Double.isNaN(lon)) {_                    throw new ElasticsearchParseException("field must be either lat/lon or geohash")__                } else {_                    return parseGeoHash(point, geohash, effectivePoint)__                }_            } else if (numberFormatException != null) {_                throw new ElasticsearchParseException("[{}] and [{}] must be valid double values", numberFormatException, LATITUDE,_                    LONGITUDE)__            } else if (Double.isNaN(lat)) {_                throw new ElasticsearchParseException("field [{}] missing", LATITUDE)__            } else if (Double.isNaN(lon)) {_                throw new ElasticsearchParseException("field [{}] missing", LONGITUDE)__            } else {_                return point.reset(lat, lon)__            }__        } else if(parser.currentToken() == Token.START_ARRAY) {_            int element = 0__            while(parser.nextToken() != Token.END_ARRAY) {_                if(parser.currentToken() == Token.VALUE_NUMBER) {_                    element++__                    if(element == 1) {_                        lon = parser.doubleValue()__                    } else if(element == 2) {_                        lat = parser.doubleValue()__                    } else {_                        GeoPoint.assertZValue(ignoreZValue, parser.doubleValue())__                    }_                } else {_                    throw new ElasticsearchParseException("numeric value expected")__                }_            }_            return point.reset(lat, lon)__        } else if(parser.currentToken() == Token.VALUE_STRING) {_            String val = parser.text()__            if (val.contains(",")) {_                return point.resetFromString(val, ignoreZValue)__            } else {_                return parseGeoHash(point, val, effectivePoint)__            }__        } else {_            throw new ElasticsearchParseException("geo_point expected")__        }_    };parse,a,link,geo,point,with,a,link,xcontent,parser,a,geopoint,has,one,of,the,following,forms,ul,li,object,pre,quot,lat,quot,i,lt,latitude,gt,i,quot,lon,quot,i,lt,longitude,gt,i,pre,li,li,string,pre,quot,i,lt,latitude,gt,i,i,lt,longitude,gt,i,quot,pre,li,li,geohash,pre,quot,i,lt,geohash,gt,i,quot,pre,li,li,array,pre,i,lt,longitude,gt,i,i,lt,latitude,gt,i,pre,li,ul,param,parser,link,xcontent,parser,to,parse,the,value,from,param,point,a,link,geo,point,that,will,be,reset,by,the,values,parsed,return,new,link,geo,point,parsed,from,the,parse;public,static,geo,point,parse,geo,point,xcontent,parser,parser,geo,point,point,final,boolean,ignore,zvalue,effective,point,effective,point,throws,ioexception,elasticsearch,parse,exception,double,lat,double,na,n,double,lon,double,na,n,string,geohash,null,number,format,exception,number,format,exception,null,if,parser,current,token,token,while,parser,next,token,token,if,parser,current,token,token,string,field,parser,current,name,if,latitude,equals,field,parser,next,token,switch,parser,current,token,case,case,try,lat,parser,double,value,true,catch,number,format,exception,e,number,format,exception,e,break,default,throw,new,elasticsearch,parse,exception,latitude,must,be,a,number,else,if,longitude,equals,field,parser,next,token,switch,parser,current,token,case,case,try,lon,parser,double,value,true,catch,number,format,exception,e,number,format,exception,e,break,default,throw,new,elasticsearch,parse,exception,longitude,must,be,a,number,else,if,geohash,equals,field,if,parser,next,token,token,geohash,parser,text,else,throw,new,elasticsearch,parse,exception,geohash,must,be,a,string,else,throw,new,elasticsearch,parse,exception,field,must,be,either,or,latitude,longitude,geohash,else,throw,new,elasticsearch,parse,exception,token,not,allowed,parser,current,token,if,geohash,null,if,double,is,na,n,lat,double,is,na,n,lon,throw,new,elasticsearch,parse,exception,field,must,be,either,lat,lon,or,geohash,else,return,parse,geo,hash,point,geohash,effective,point,else,if,number,format,exception,null,throw,new,elasticsearch,parse,exception,and,must,be,valid,double,values,number,format,exception,latitude,longitude,else,if,double,is,na,n,lat,throw,new,elasticsearch,parse,exception,field,missing,latitude,else,if,double,is,na,n,lon,throw,new,elasticsearch,parse,exception,field,missing,longitude,else,return,point,reset,lat,lon,else,if,parser,current,token,token,int,element,0,while,parser,next,token,token,if,parser,current,token,token,element,if,element,1,lon,parser,double,value,else,if,element,2,lat,parser,double,value,else,geo,point,assert,zvalue,ignore,zvalue,parser,double,value,else,throw,new,elasticsearch,parse,exception,numeric,value,expected,return,point,reset,lat,lon,else,if,parser,current,token,token,string,val,parser,text,if,val,contains,return,point,reset,from,string,val,ignore,zvalue,else,return,parse,geo,hash,point,val,effective,point,else,throw,new,elasticsearch,parse,exception,expected
GeoUtils -> public static GeoPoint parseGeoPoint(XContentParser parser, GeoPoint point, final boolean ignoreZValue, EffectivePoint effectivePoint)             throws IOException, ElasticsearchParseException;1542820501;Parse a {@link GeoPoint} with a {@link XContentParser}. A geopoint has one of the following forms:__<ul>_<li>Object: <pre>{&quot_lat&quot_: <i>&lt_latitude&gt_</i>, &quot_lon&quot_: <i>&lt_longitude&gt_</i>}</pre></li>_<li>String: <pre>&quot_<i>&lt_latitude&gt_</i>,<i>&lt_longitude&gt_</i>&quot_</pre></li>_<li>Geohash: <pre>&quot_<i>&lt_geohash&gt_</i>&quot_</pre></li>_<li>Array: <pre>[<i>&lt_longitude&gt_</i>,<i>&lt_latitude&gt_</i>]</pre></li>_</ul>__@param parser {@link XContentParser} to parse the value from_@param point A {@link GeoPoint} that will be reset by the values parsed_@return new {@link GeoPoint} parsed from the parse;public static GeoPoint parseGeoPoint(XContentParser parser, GeoPoint point, final boolean ignoreZValue, EffectivePoint effectivePoint)_            throws IOException, ElasticsearchParseException {_        double lat = Double.NaN__        double lon = Double.NaN__        String geohash = null__        NumberFormatException numberFormatException = null___        if(parser.currentToken() == Token.START_OBJECT) {_            while(parser.nextToken() != Token.END_OBJECT) {_                if(parser.currentToken() == Token.FIELD_NAME) {_                    String field = parser.currentName()__                    if(LATITUDE.equals(field)) {_                        parser.nextToken()__                        switch (parser.currentToken()) {_                            case VALUE_NUMBER:_                            case VALUE_STRING:_                                try {_                                    lat = parser.doubleValue(true)__                                } catch (NumberFormatException e) {_                                    numberFormatException = e__                                }_                                break__                            default:_                                throw new ElasticsearchParseException("latitude must be a number")__                        }_                    } else if (LONGITUDE.equals(field)) {_                        parser.nextToken()__                        switch (parser.currentToken()) {_                            case VALUE_NUMBER:_                            case VALUE_STRING:_                                try {_                                    lon = parser.doubleValue(true)__                                } catch (NumberFormatException e) {_                                    numberFormatException = e__                                }_                                break__                            default:_                                throw new ElasticsearchParseException("longitude must be a number")__                        }_                    } else if (GEOHASH.equals(field)) {_                        if(parser.nextToken() == Token.VALUE_STRING) {_                            geohash = parser.text()__                        } else {_                            throw new ElasticsearchParseException("geohash must be a string")__                        }_                    } else {_                        throw new ElasticsearchParseException("field must be either [{}], [{}] or [{}]", LATITUDE, LONGITUDE, GEOHASH)__                    }_                } else {_                    throw new ElasticsearchParseException("token [{}] not allowed", parser.currentToken())__                }_            }__            if (geohash != null) {_                if(!Double.isNaN(lat) || !Double.isNaN(lon)) {_                    throw new ElasticsearchParseException("field must be either lat/lon or geohash")__                } else {_                    return parseGeoHash(point, geohash, effectivePoint)__                }_            } else if (numberFormatException != null) {_                throw new ElasticsearchParseException("[{}] and [{}] must be valid double values", numberFormatException, LATITUDE,_                    LONGITUDE)__            } else if (Double.isNaN(lat)) {_                throw new ElasticsearchParseException("field [{}] missing", LATITUDE)__            } else if (Double.isNaN(lon)) {_                throw new ElasticsearchParseException("field [{}] missing", LONGITUDE)__            } else {_                return point.reset(lat, lon)__            }__        } else if(parser.currentToken() == Token.START_ARRAY) {_            int element = 0__            while(parser.nextToken() != Token.END_ARRAY) {_                if(parser.currentToken() == Token.VALUE_NUMBER) {_                    element++__                    if(element == 1) {_                        lon = parser.doubleValue()__                    } else if(element == 2) {_                        lat = parser.doubleValue()__                    } else {_                        GeoPoint.assertZValue(ignoreZValue, parser.doubleValue())__                    }_                } else {_                    throw new ElasticsearchParseException("numeric value expected")__                }_            }_            return point.reset(lat, lon)__        } else if(parser.currentToken() == Token.VALUE_STRING) {_            String val = parser.text()__            if (val.contains(",")) {_                return point.resetFromString(val, ignoreZValue)__            } else {_                return parseGeoHash(point, val, effectivePoint)__            }__        } else {_            throw new ElasticsearchParseException("geo_point expected")__        }_    };parse,a,link,geo,point,with,a,link,xcontent,parser,a,geopoint,has,one,of,the,following,forms,ul,li,object,pre,quot,lat,quot,i,lt,latitude,gt,i,quot,lon,quot,i,lt,longitude,gt,i,pre,li,li,string,pre,quot,i,lt,latitude,gt,i,i,lt,longitude,gt,i,quot,pre,li,li,geohash,pre,quot,i,lt,geohash,gt,i,quot,pre,li,li,array,pre,i,lt,longitude,gt,i,i,lt,latitude,gt,i,pre,li,ul,param,parser,link,xcontent,parser,to,parse,the,value,from,param,point,a,link,geo,point,that,will,be,reset,by,the,values,parsed,return,new,link,geo,point,parsed,from,the,parse;public,static,geo,point,parse,geo,point,xcontent,parser,parser,geo,point,point,final,boolean,ignore,zvalue,effective,point,effective,point,throws,ioexception,elasticsearch,parse,exception,double,lat,double,na,n,double,lon,double,na,n,string,geohash,null,number,format,exception,number,format,exception,null,if,parser,current,token,token,while,parser,next,token,token,if,parser,current,token,token,string,field,parser,current,name,if,latitude,equals,field,parser,next,token,switch,parser,current,token,case,case,try,lat,parser,double,value,true,catch,number,format,exception,e,number,format,exception,e,break,default,throw,new,elasticsearch,parse,exception,latitude,must,be,a,number,else,if,longitude,equals,field,parser,next,token,switch,parser,current,token,case,case,try,lon,parser,double,value,true,catch,number,format,exception,e,number,format,exception,e,break,default,throw,new,elasticsearch,parse,exception,longitude,must,be,a,number,else,if,geohash,equals,field,if,parser,next,token,token,geohash,parser,text,else,throw,new,elasticsearch,parse,exception,geohash,must,be,a,string,else,throw,new,elasticsearch,parse,exception,field,must,be,either,or,latitude,longitude,geohash,else,throw,new,elasticsearch,parse,exception,token,not,allowed,parser,current,token,if,geohash,null,if,double,is,na,n,lat,double,is,na,n,lon,throw,new,elasticsearch,parse,exception,field,must,be,either,lat,lon,or,geohash,else,return,parse,geo,hash,point,geohash,effective,point,else,if,number,format,exception,null,throw,new,elasticsearch,parse,exception,and,must,be,valid,double,values,number,format,exception,latitude,longitude,else,if,double,is,na,n,lat,throw,new,elasticsearch,parse,exception,field,missing,latitude,else,if,double,is,na,n,lon,throw,new,elasticsearch,parse,exception,field,missing,longitude,else,return,point,reset,lat,lon,else,if,parser,current,token,token,int,element,0,while,parser,next,token,token,if,parser,current,token,token,element,if,element,1,lon,parser,double,value,else,if,element,2,lat,parser,double,value,else,geo,point,assert,zvalue,ignore,zvalue,parser,double,value,else,throw,new,elasticsearch,parse,exception,numeric,value,expected,return,point,reset,lat,lon,else,if,parser,current,token,token,string,val,parser,text,if,val,contains,return,point,reset,from,string,val,ignore,zvalue,else,return,parse,geo,hash,point,val,effective,point,else,throw,new,elasticsearch,parse,exception,expected
GeoUtils -> public static int quadTreeLevelsForPrecision(double meters);1524684173;Calculate the number of levels needed for a specific precision. Quadtree_cells will not exceed the specified size (diagonal) of the precision._@param meters Maximum size of cells in meters (must greater than zero)_@return levels need to achieve precision;public static int quadTreeLevelsForPrecision(double meters) {_        assert meters >= 0__        if(meters == 0) {_            return QuadPrefixTree.MAX_LEVELS_POSSIBLE__        } else {_            final double ratio = 1+(EARTH_POLAR_DISTANCE / EARTH_EQUATOR)_ _            final double width = Math.sqrt((meters*meters)/(ratio*ratio))_ _            final long part = Math.round(Math.ceil(EARTH_EQUATOR / width))__            final int level = Long.SIZE - Long.numberOfLeadingZeros(part)-1_ _            return (part<=(1L<<level)) ?level :(level+1)_ _        }_    };calculate,the,number,of,levels,needed,for,a,specific,precision,quadtree,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,meters,maximum,size,of,cells,in,meters,must,greater,than,zero,return,levels,need,to,achieve,precision;public,static,int,quad,tree,levels,for,precision,double,meters,assert,meters,0,if,meters,0,return,quad,prefix,tree,else,final,double,ratio,1,final,double,width,math,sqrt,meters,meters,ratio,ratio,final,long,part,math,round,math,ceil,width,final,int,level,long,size,long,number,of,leading,zeros,part,1,return,part,1l,level,level,level,1
GeoUtils -> public static int quadTreeLevelsForPrecision(double meters);1527207653;Calculate the number of levels needed for a specific precision. Quadtree_cells will not exceed the specified size (diagonal) of the precision._@param meters Maximum size of cells in meters (must greater than zero)_@return levels need to achieve precision;public static int quadTreeLevelsForPrecision(double meters) {_        assert meters >= 0__        if(meters == 0) {_            return QuadPrefixTree.MAX_LEVELS_POSSIBLE__        } else {_            final double ratio = 1+(EARTH_POLAR_DISTANCE / EARTH_EQUATOR)_ _            final double width = Math.sqrt((meters*meters)/(ratio*ratio))_ _            final long part = Math.round(Math.ceil(EARTH_EQUATOR / width))__            final int level = Long.SIZE - Long.numberOfLeadingZeros(part)-1_ _            return (part<=(1L<<level)) ?level :(level+1)_ _        }_    };calculate,the,number,of,levels,needed,for,a,specific,precision,quadtree,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,meters,maximum,size,of,cells,in,meters,must,greater,than,zero,return,levels,need,to,achieve,precision;public,static,int,quad,tree,levels,for,precision,double,meters,assert,meters,0,if,meters,0,return,quad,prefix,tree,else,final,double,ratio,1,final,double,width,math,sqrt,meters,meters,ratio,ratio,final,long,part,math,round,math,ceil,width,final,int,level,long,size,long,number,of,leading,zeros,part,1,return,part,1l,level,level,level,1
GeoUtils -> public static int quadTreeLevelsForPrecision(double meters);1542820501;Calculate the number of levels needed for a specific precision. Quadtree_cells will not exceed the specified size (diagonal) of the precision._@param meters Maximum size of cells in meters (must greater than zero)_@return levels need to achieve precision;public static int quadTreeLevelsForPrecision(double meters) {_        assert meters >= 0__        if(meters == 0) {_            return QuadPrefixTree.MAX_LEVELS_POSSIBLE__        } else {_            final double ratio = 1+(EARTH_POLAR_DISTANCE / EARTH_EQUATOR)_ _            final double width = Math.sqrt((meters*meters)/(ratio*ratio))_ _            final long part = Math.round(Math.ceil(EARTH_EQUATOR / width))__            final int level = Long.SIZE - Long.numberOfLeadingZeros(part)-1_ _            return (part<=(1L<<level)) ?level :(level+1)_ _        }_    };calculate,the,number,of,levels,needed,for,a,specific,precision,quadtree,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,meters,maximum,size,of,cells,in,meters,must,greater,than,zero,return,levels,need,to,achieve,precision;public,static,int,quad,tree,levels,for,precision,double,meters,assert,meters,0,if,meters,0,return,quad,prefix,tree,else,final,double,ratio,1,final,double,width,math,sqrt,meters,meters,ratio,ratio,final,long,part,math,round,math,ceil,width,final,int,level,long,size,long,number,of,leading,zeros,part,1,return,part,1l,level,level,level,1
GeoUtils -> public static double maxRadialDistanceMeters(final double centerLat, final double centerLon);1524684173;Returns the maximum distance/radius (in meters) from the point 'center' before overlapping;public static double maxRadialDistanceMeters(final double centerLat, final double centerLon) {_      if (Math.abs(centerLat) == MAX_LAT) {_        return SloppyMath.haversinMeters(centerLat, centerLon, 0, centerLon)__      }_      return SloppyMath.haversinMeters(centerLat, centerLon, centerLat, (MAX_LON + centerLon) % 360)__    };returns,the,maximum,distance,radius,in,meters,from,the,point,center,before,overlapping;public,static,double,max,radial,distance,meters,final,double,center,lat,final,double,center,lon,if,math,abs,center,lat,return,sloppy,math,haversin,meters,center,lat,center,lon,0,center,lon,return,sloppy,math,haversin,meters,center,lat,center,lon,center,lat,center,lon,360
GeoUtils -> public static double maxRadialDistanceMeters(final double centerLat, final double centerLon);1527207653;Returns the maximum distance/radius (in meters) from the point 'center' before overlapping;public static double maxRadialDistanceMeters(final double centerLat, final double centerLon) {_      if (Math.abs(centerLat) == MAX_LAT) {_        return SloppyMath.haversinMeters(centerLat, centerLon, 0, centerLon)__      }_      return SloppyMath.haversinMeters(centerLat, centerLon, centerLat, (MAX_LON + centerLon) % 360)__    };returns,the,maximum,distance,radius,in,meters,from,the,point,center,before,overlapping;public,static,double,max,radial,distance,meters,final,double,center,lat,final,double,center,lon,if,math,abs,center,lat,return,sloppy,math,haversin,meters,center,lat,center,lon,0,center,lon,return,sloppy,math,haversin,meters,center,lat,center,lon,center,lat,center,lon,360
GeoUtils -> public static double maxRadialDistanceMeters(final double centerLat, final double centerLon);1542820501;Returns the maximum distance/radius (in meters) from the point 'center' before overlapping;public static double maxRadialDistanceMeters(final double centerLat, final double centerLon) {_      if (Math.abs(centerLat) == MAX_LAT) {_        return SloppyMath.haversinMeters(centerLat, centerLon, 0, centerLon)__      }_      return SloppyMath.haversinMeters(centerLat, centerLon, centerLat, (MAX_LON + centerLon) % 360)__    };returns,the,maximum,distance,radius,in,meters,from,the,point,center,before,overlapping;public,static,double,max,radial,distance,meters,final,double,center,lat,final,double,center,lon,if,math,abs,center,lat,return,sloppy,math,haversin,meters,center,lat,center,lon,0,center,lon,return,sloppy,math,haversin,meters,center,lat,center,lon,center,lat,center,lon,360
GeoUtils -> public static int geoHashLevelsForPrecision(double meters);1524684173;Calculate the number of levels needed for a specific precision. GeoHash_cells will not exceed the specified size (diagonal) of the precision._@param meters Maximum size of cells in meters (must greater or equal to zero)_@return levels need to achieve precision;public static int geoHashLevelsForPrecision(double meters) {_        assert meters >= 0___        if(meters == 0) {_            return GeohashPrefixTree.getMaxLevelsPossible()__        } else {_            final double ratio = 1+(EARTH_POLAR_DISTANCE / EARTH_EQUATOR)_ _            final double width = Math.sqrt((meters*meters)/(ratio*ratio))_ _            final double part = Math.ceil(EARTH_EQUATOR / width)__            if(part == 1)_                return 1__            final int bits = (int)Math.round(Math.ceil(Math.log(part) / Math.log(2)))__            final int full = bits / 5_                _            final int left = bits - full*5_           _            final int even = full + (left>0?1:0)_     _            final int odd = full + (left>3?1:0)_      _            return even+odd__        }_    };calculate,the,number,of,levels,needed,for,a,specific,precision,geo,hash,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,meters,maximum,size,of,cells,in,meters,must,greater,or,equal,to,zero,return,levels,need,to,achieve,precision;public,static,int,geo,hash,levels,for,precision,double,meters,assert,meters,0,if,meters,0,return,geohash,prefix,tree,get,max,levels,possible,else,final,double,ratio,1,final,double,width,math,sqrt,meters,meters,ratio,ratio,final,double,part,math,ceil,width,if,part,1,return,1,final,int,bits,int,math,round,math,ceil,math,log,part,math,log,2,final,int,full,bits,5,final,int,left,bits,full,5,final,int,even,full,left,0,1,0,final,int,odd,full,left,3,1,0,return,even,odd
GeoUtils -> public static int geoHashLevelsForPrecision(double meters);1527207653;Calculate the number of levels needed for a specific precision. GeoHash_cells will not exceed the specified size (diagonal) of the precision._@param meters Maximum size of cells in meters (must greater or equal to zero)_@return levels need to achieve precision;public static int geoHashLevelsForPrecision(double meters) {_        assert meters >= 0___        if(meters == 0) {_            return GeohashPrefixTree.getMaxLevelsPossible()__        } else {_            final double ratio = 1+(EARTH_POLAR_DISTANCE / EARTH_EQUATOR)_ _            final double width = Math.sqrt((meters*meters)/(ratio*ratio))_ _            final double part = Math.ceil(EARTH_EQUATOR / width)__            if(part == 1)_                return 1__            final int bits = (int)Math.round(Math.ceil(Math.log(part) / Math.log(2)))__            final int full = bits / 5_                _            final int left = bits - full*5_           _            final int even = full + (left>0?1:0)_     _            final int odd = full + (left>3?1:0)_      _            return even+odd__        }_    };calculate,the,number,of,levels,needed,for,a,specific,precision,geo,hash,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,meters,maximum,size,of,cells,in,meters,must,greater,or,equal,to,zero,return,levels,need,to,achieve,precision;public,static,int,geo,hash,levels,for,precision,double,meters,assert,meters,0,if,meters,0,return,geohash,prefix,tree,get,max,levels,possible,else,final,double,ratio,1,final,double,width,math,sqrt,meters,meters,ratio,ratio,final,double,part,math,ceil,width,if,part,1,return,1,final,int,bits,int,math,round,math,ceil,math,log,part,math,log,2,final,int,full,bits,5,final,int,left,bits,full,5,final,int,even,full,left,0,1,0,final,int,odd,full,left,3,1,0,return,even,odd
GeoUtils -> public static int geoHashLevelsForPrecision(double meters);1542820501;Calculate the number of levels needed for a specific precision. GeoHash_cells will not exceed the specified size (diagonal) of the precision._@param meters Maximum size of cells in meters (must greater or equal to zero)_@return levels need to achieve precision;public static int geoHashLevelsForPrecision(double meters) {_        assert meters >= 0___        if(meters == 0) {_            return GeohashPrefixTree.getMaxLevelsPossible()__        } else {_            final double ratio = 1+(EARTH_POLAR_DISTANCE / EARTH_EQUATOR)_ _            final double width = Math.sqrt((meters*meters)/(ratio*ratio))_ _            final double part = Math.ceil(EARTH_EQUATOR / width)__            if(part == 1)_                return 1__            final int bits = (int)Math.round(Math.ceil(Math.log(part) / Math.log(2)))__            final int full = bits / 5_                _            final int left = bits - full*5_           _            final int even = full + (left>0?1:0)_     _            final int odd = full + (left>3?1:0)_      _            return even+odd__        }_    };calculate,the,number,of,levels,needed,for,a,specific,precision,geo,hash,cells,will,not,exceed,the,specified,size,diagonal,of,the,precision,param,meters,maximum,size,of,cells,in,meters,must,greater,or,equal,to,zero,return,levels,need,to,achieve,precision;public,static,int,geo,hash,levels,for,precision,double,meters,assert,meters,0,if,meters,0,return,geohash,prefix,tree,get,max,levels,possible,else,final,double,ratio,1,final,double,width,math,sqrt,meters,meters,ratio,ratio,final,double,part,math,ceil,width,if,part,1,return,1,final,int,bits,int,math,round,math,ceil,math,log,part,math,log,2,final,int,full,bits,5,final,int,left,bits,full,5,final,int,even,full,left,0,1,0,final,int,odd,full,left,3,1,0,return,even,odd
GeoUtils -> public static double quadTreeCellSize(int level);1524684173;Calculate the size (in meters) of quadtree cells at a specific level_@param level quadtree level must be greater or equal to zero_@return the size of cells at level in meters;public static double quadTreeCellSize(int level) {_        assert level>=0__        return Math.sqrt(EARTH_POLAR_DISTANCE*EARTH_POLAR_DISTANCE + EARTH_EQUATOR*EARTH_EQUATOR) / (1L<<level)__    };calculate,the,size,in,meters,of,quadtree,cells,at,a,specific,level,param,level,quadtree,level,must,be,greater,or,equal,to,zero,return,the,size,of,cells,at,level,in,meters;public,static,double,quad,tree,cell,size,int,level,assert,level,0,return,math,sqrt,1l,level
GeoUtils -> public static double quadTreeCellSize(int level);1527207653;Calculate the size (in meters) of quadtree cells at a specific level_@param level quadtree level must be greater or equal to zero_@return the size of cells at level in meters;public static double quadTreeCellSize(int level) {_        assert level>=0__        return Math.sqrt(EARTH_POLAR_DISTANCE*EARTH_POLAR_DISTANCE + EARTH_EQUATOR*EARTH_EQUATOR) / (1L<<level)__    };calculate,the,size,in,meters,of,quadtree,cells,at,a,specific,level,param,level,quadtree,level,must,be,greater,or,equal,to,zero,return,the,size,of,cells,at,level,in,meters;public,static,double,quad,tree,cell,size,int,level,assert,level,0,return,math,sqrt,1l,level
GeoUtils -> public static double quadTreeCellSize(int level);1542820501;Calculate the size (in meters) of quadtree cells at a specific level_@param level quadtree level must be greater or equal to zero_@return the size of cells at level in meters;public static double quadTreeCellSize(int level) {_        assert level>=0__        return Math.sqrt(EARTH_POLAR_DISTANCE*EARTH_POLAR_DISTANCE + EARTH_EQUATOR*EARTH_EQUATOR) / (1L<<level)__    };calculate,the,size,in,meters,of,quadtree,cells,at,a,specific,level,param,level,quadtree,level,must,be,greater,or,equal,to,zero,return,the,size,of,cells,at,level,in,meters;public,static,double,quad,tree,cell,size,int,level,assert,level,0,return,math,sqrt,1l,level
GeoUtils -> public static void normalizePoint(GeoPoint point);1524684173;Normalize the geo {@code Point} for its coordinates to lie within their_respective normalized ranges._<p>_Note: A shift of 180&deg_ is applied in the longitude if necessary,_in order to normalize properly the latitude.__@param point The point to normalize in-place.;public static void normalizePoint(GeoPoint point) {_        normalizePoint(point, true, true)__    };normalize,the,geo,code,point,for,its,coordinates,to,lie,within,their,respective,normalized,ranges,p,note,a,shift,of,180,deg,is,applied,in,the,longitude,if,necessary,in,order,to,normalize,properly,the,latitude,param,point,the,point,to,normalize,in,place;public,static,void,normalize,point,geo,point,point,normalize,point,point,true,true
GeoUtils -> public static void normalizePoint(GeoPoint point);1527207653;Normalize the geo {@code Point} for its coordinates to lie within their_respective normalized ranges._<p>_Note: A shift of 180&deg_ is applied in the longitude if necessary,_in order to normalize properly the latitude.__@param point The point to normalize in-place.;public static void normalizePoint(GeoPoint point) {_        normalizePoint(point, true, true)__    };normalize,the,geo,code,point,for,its,coordinates,to,lie,within,their,respective,normalized,ranges,p,note,a,shift,of,180,deg,is,applied,in,the,longitude,if,necessary,in,order,to,normalize,properly,the,latitude,param,point,the,point,to,normalize,in,place;public,static,void,normalize,point,geo,point,point,normalize,point,point,true,true
GeoUtils -> public static void normalizePoint(GeoPoint point);1542820501;Normalize the geo {@code Point} for its coordinates to lie within their_respective normalized ranges._<p>_Note: A shift of 180&deg_ is applied in the longitude if necessary,_in order to normalize properly the latitude.__@param point The point to normalize in-place.;public static void normalizePoint(GeoPoint point) {_        normalizePoint(point, true, true)__    };normalize,the,geo,code,point,for,its,coordinates,to,lie,within,their,respective,normalized,ranges,p,note,a,shift,of,180,deg,is,applied,in,the,longitude,if,necessary,in,order,to,normalize,properly,the,latitude,param,point,the,point,to,normalize,in,place;public,static,void,normalize,point,geo,point,point,normalize,point,point,true,true
GeoUtils -> public static double geoHashCellWidth(int level);1524684173;Calculate the width (in meters) of geohash cells at a specific level_@param level geohash level must be greater or equal to zero_@return the width of cells at level in meters;public static double geoHashCellWidth(int level) {_        assert level>=0__        _        _        return EARTH_EQUATOR / (1L<<((((level+1)/2)*3) + ((level/2)*2)))__    };calculate,the,width,in,meters,of,geohash,cells,at,a,specific,level,param,level,geohash,level,must,be,greater,or,equal,to,zero,return,the,width,of,cells,at,level,in,meters;public,static,double,geo,hash,cell,width,int,level,assert,level,0,return,1l,level,1,2,3,level,2,2
GeoUtils -> public static double geoHashCellWidth(int level);1527207653;Calculate the width (in meters) of geohash cells at a specific level_@param level geohash level must be greater or equal to zero_@return the width of cells at level in meters;public static double geoHashCellWidth(int level) {_        assert level>=0__        _        _        return EARTH_EQUATOR / (1L<<((((level+1)/2)*3) + ((level/2)*2)))__    };calculate,the,width,in,meters,of,geohash,cells,at,a,specific,level,param,level,geohash,level,must,be,greater,or,equal,to,zero,return,the,width,of,cells,at,level,in,meters;public,static,double,geo,hash,cell,width,int,level,assert,level,0,return,1l,level,1,2,3,level,2,2
GeoUtils -> public static double geoHashCellWidth(int level);1542820501;Calculate the width (in meters) of geohash cells at a specific level_@param level geohash level must be greater or equal to zero_@return the width of cells at level in meters;public static double geoHashCellWidth(int level) {_        assert level>=0__        _        _        return EARTH_EQUATOR / (1L<<((((level+1)/2)*3) + ((level/2)*2)))__    };calculate,the,width,in,meters,of,geohash,cells,at,a,specific,level,param,level,geohash,level,must,be,greater,or,equal,to,zero,return,the,width,of,cells,at,level,in,meters;public,static,double,geo,hash,cell,width,int,level,assert,level,0,return,1l,level,1,2,3,level,2,2
GeoUtils -> public static GeoPoint parseGeoPoint(XContentParser parser) throws IOException, ElasticsearchParseException;1524684173;Parse a {@link GeoPoint} with a {@link XContentParser}:__@param parser {@link XContentParser} to parse the value from_@return new {@link GeoPoint} parsed from the parse;public static GeoPoint parseGeoPoint(XContentParser parser) throws IOException, ElasticsearchParseException {_        return parseGeoPoint(parser, new GeoPoint())__    };parse,a,link,geo,point,with,a,link,xcontent,parser,param,parser,link,xcontent,parser,to,parse,the,value,from,return,new,link,geo,point,parsed,from,the,parse;public,static,geo,point,parse,geo,point,xcontent,parser,parser,throws,ioexception,elasticsearch,parse,exception,return,parse,geo,point,parser,new,geo,point
GeoUtils -> public static GeoPoint parseGeoPoint(XContentParser parser) throws IOException, ElasticsearchParseException;1527207653;Parse a {@link GeoPoint} with a {@link XContentParser}:__@param parser {@link XContentParser} to parse the value from_@return new {@link GeoPoint} parsed from the parse;public static GeoPoint parseGeoPoint(XContentParser parser) throws IOException, ElasticsearchParseException {_        return parseGeoPoint(parser, new GeoPoint())__    };parse,a,link,geo,point,with,a,link,xcontent,parser,param,parser,link,xcontent,parser,to,parse,the,value,from,return,new,link,geo,point,parsed,from,the,parse;public,static,geo,point,parse,geo,point,xcontent,parser,parser,throws,ioexception,elasticsearch,parse,exception,return,parse,geo,point,parser,new,geo,point
GeoUtils -> public static GeoPoint parseGeoPoint(XContentParser parser) throws IOException, ElasticsearchParseException;1542820501;Parse a {@link GeoPoint} with a {@link XContentParser}:__@param parser {@link XContentParser} to parse the value from_@return new {@link GeoPoint} parsed from the parse;public static GeoPoint parseGeoPoint(XContentParser parser) throws IOException, ElasticsearchParseException {_        return parseGeoPoint(parser, new GeoPoint())__    };parse,a,link,geo,point,with,a,link,xcontent,parser,param,parser,link,xcontent,parser,to,parse,the,value,from,return,new,link,geo,point,parsed,from,the,parse;public,static,geo,point,parse,geo,point,xcontent,parser,parser,throws,ioexception,elasticsearch,parse,exception,return,parse,geo,point,parser,new,geo,point
