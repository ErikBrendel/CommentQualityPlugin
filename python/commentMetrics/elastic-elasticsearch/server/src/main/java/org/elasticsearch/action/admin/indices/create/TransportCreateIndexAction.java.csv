commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;5;;@Override protected String executor() {     // we go async right away     return ThreadPool.Names.SAME. }
false;protected;0;4;;@Override protected CreateIndexResponse newResponse() {     return new CreateIndexResponse(). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(CreateIndexRequest request, ClusterState state) {     return state.blocks().indexBlockedException(ClusterBlockLevel.METADATA_WRITE, request.index()). }
false;protected;3;20;;@Override protected void masterOperation(final CreateIndexRequest request, final ClusterState state, final ActionListener<CreateIndexResponse> listener) {     String cause = request.cause().     if (cause.length() == 0) {         cause = "api".     }     final String indexName = indexNameExpressionResolver.resolveDateMathExpression(request.index()).     final CreateIndexClusterStateUpdateRequest updateRequest = new CreateIndexClusterStateUpdateRequest(request, cause, indexName, request.index()).ackTimeout(request.timeout()).masterNodeTimeout(request.masterNodeTimeout()).settings(request.settings()).mappings(request.mappings()).aliases(request.aliases()).waitForActiveShards(request.waitForActiveShards()).     createIndexService.createIndex(updateRequest, ActionListener.wrap(response -> listener.onResponse(new CreateIndexResponse(response.isAcknowledged(), response.isShardsAcknowledged(), indexName)), listener::onFailure)). }
