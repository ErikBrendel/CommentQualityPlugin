commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;7;/**  * Provides a reproducible source of randomness seeded by a long  * seed in the settings with the key setting.  *  * @param settings the settings containing the seed  * @param setting  the setting to access the seed  * @return a reproducible source of randomness  */ ;/**  * Provides a reproducible source of randomness seeded by a long  * seed in the settings with the key setting.  *  * @param settings the settings containing the seed  * @param setting  the setting to access the seed  * @return a reproducible source of randomness  */ public static Random get(Settings settings, Setting<Long> setting) {     if (setting.exists(settings)) {         return new Random(setting.get(settings)).     } else {         return get().     } }
true;public,static;0;13;/**  * Provides a source of randomness that is reproducible when  * running under the Elasticsearch test suite, and otherwise  * produces a non-reproducible source of randomness. Reproducible  * sources of randomness are created when the system property  * "tests.seed" is set and the security policy allows reading this  * system property. Otherwise, non-reproducible sources of  * randomness are created.  *  * @return a source of randomness  * @throws IllegalStateException if running tests but was not able  *                               to acquire an instance of Random from  *                               RandomizedContext or tests are  *                               running but tests.seed is not set  */ ;/**  * Provides a source of randomness that is reproducible when  * running under the Elasticsearch test suite, and otherwise  * produces a non-reproducible source of randomness. Reproducible  * sources of randomness are created when the system property  * "tests.seed" is set and the security policy allows reading this  * system property. Otherwise, non-reproducible sources of  * randomness are created.  *  * @return a source of randomness  * @throws IllegalStateException if running tests but was not able  *                               to acquire an instance of Random from  *                               RandomizedContext or tests are  *                               running but tests.seed is not set  */ public static Random get() {     if (currentMethod != null && getRandomMethod != null) {         try {             Object randomizedContext = currentMethod.invoke(null).             return (Random) getRandomMethod.invoke(randomizedContext).         } catch (ReflectiveOperationException e) {             // unexpected, bail             throw new IllegalStateException("running tests but failed to invoke RandomizedContext#getRandom", e).         }     } else {         return getWithoutSeed().     } }
true;public,static;0;10;/**  * Provides a secure source of randomness.  *  * This acts exactly similar to {@link #get()}, but returning a new {@link SecureRandom}.  */ ;/**  * Provides a secure source of randomness.  *  * This acts exactly similar to {@link #get()}, but returning a new {@link SecureRandom}.  */ public static SecureRandom createSecure() {     if (currentMethod != null && getRandomMethod != null) {         // tests, so just use a seed from the non secure random         byte[] seed = new byte[16].         get().nextBytes(seed).         return new SecureRandom(seed).     } else {         return new SecureRandom().     } }
false;private,static;0;5;;@SuppressForbidden(reason = "ThreadLocalRandom is okay when not running tests") private static Random getWithoutSeed() {     assert currentMethod == null && getRandomMethod == null : "running under tests but tried to create non-reproducible random".     return ThreadLocalRandom.current(). }
false;public,static;1;3;;public static void shuffle(List<?> list) {     Collections.shuffle(list, get()). }
