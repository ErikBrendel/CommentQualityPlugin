commented;modifiers;parameterAmount;loc;comment;code
false;protected;3;37;;@Override protected void doExecute(Task task, ValidateQueryRequest request, ActionListener<ValidateQueryResponse> listener) {     request.nowInMillis = System.currentTimeMillis().     LongSupplier timeProvider = () -> request.nowInMillis.     ActionListener<org.elasticsearch.index.query.QueryBuilder> rewriteListener = ActionListener.wrap(rewrittenQuery -> {         request.query(rewrittenQuery).         super.doExecute(task, request, listener).     }, ex -> {         if (ex instanceof IndexNotFoundException || ex instanceof IndexClosedException) {             listener.onFailure(ex).         }         List<QueryExplanation> explanations = new ArrayList<>().         explanations.add(new QueryExplanation(null, QueryExplanation.RANDOM_SHARD, false, null, ex.getMessage())).         listener.onResponse(new ValidateQueryResponse(false, explanations, // which is 0 since the failure is happening on the coordinating node.         0, 0, 0, null)).     }).     if (request.query() == null) {         rewriteListener.onResponse(request.query()).     } else {         Rewriteable.rewriteAndFetch(request.query(), searchService.getRewriteContext(timeProvider), rewriteListener).     } }
false;protected;3;6;;@Override protected ShardValidateQueryRequest newShardRequest(int numShards, ShardRouting shard, ValidateQueryRequest request) {     final AliasFilter aliasFilter = searchService.buildAliasFilter(clusterService.state(), shard.getIndexName(), request.indices()).     return new ShardValidateQueryRequest(shard.shardId(), aliasFilter, request). }
false;protected;0;4;;@Override protected ShardValidateQueryResponse newShardResponse() {     return new ShardValidateQueryResponse(). }
false;protected;3;12;;@Override protected GroupShardsIterator shards(ClusterState clusterState, ValidateQueryRequest request, String[] concreteIndices) {     final String routing.     if (request.allShards()) {         routing = null.     } else {         // Random routing to limit request to a single shard         routing = Integer.toString(Randomness.get().nextInt(1000)).     }     Map<String, Set<String>> routingMap = indexNameExpressionResolver.resolveSearchRouting(clusterState, routing, request.indices()).     return clusterService.operationRouting().searchShards(clusterState, concreteIndices, routingMap, "_local"). }
false;protected;2;4;;@Override protected ClusterBlockException checkGlobalBlock(ClusterState state, ValidateQueryRequest request) {     return state.blocks().globalBlockedException(ClusterBlockLevel.READ). }
false;protected;3;4;;@Override protected ClusterBlockException checkRequestBlock(ClusterState state, ValidateQueryRequest countRequest, String[] concreteIndices) {     return state.blocks().indicesBlockedException(ClusterBlockLevel.READ, concreteIndices). }
false;protected;3;38;;@Override protected ValidateQueryResponse newResponse(ValidateQueryRequest request, AtomicReferenceArray shardsResponses, ClusterState clusterState) {     int successfulShards = 0.     int failedShards = 0.     boolean valid = true.     List<DefaultShardOperationFailedException> shardFailures = null.     List<QueryExplanation> queryExplanations = null.     for (int i = 0. i < shardsResponses.length(). i++) {         Object shardResponse = shardsResponses.get(i).         if (shardResponse == null) {         // simply ignore non active shards         } else if (shardResponse instanceof BroadcastShardOperationFailedException) {             failedShards++.             if (shardFailures == null) {                 shardFailures = new ArrayList<>().             }             shardFailures.add(new DefaultShardOperationFailedException((BroadcastShardOperationFailedException) shardResponse)).         } else {             ShardValidateQueryResponse validateQueryResponse = (ShardValidateQueryResponse) shardResponse.             valid = valid && validateQueryResponse.isValid().             if (request.explain() || request.rewrite() || request.allShards()) {                 if (queryExplanations == null) {                     queryExplanations = new ArrayList<>().                 }                 queryExplanations.add(new QueryExplanation(validateQueryResponse.getIndex(), request.allShards() ? validateQueryResponse.getShardId().getId() : QueryExplanation.RANDOM_SHARD, validateQueryResponse.isValid(), validateQueryResponse.getExplanation(), validateQueryResponse.getError())).             }             successfulShards++.         }     }     return new ValidateQueryResponse(valid, queryExplanations, shardsResponses.length(), successfulShards, failedShards, shardFailures). }
false;protected;2;26;;@Override protected ShardValidateQueryResponse shardOperation(ShardValidateQueryRequest request, Task task) throws IOException {     boolean valid.     String explanation = null.     String error = null.     ShardSearchLocalRequest shardSearchLocalRequest = new ShardSearchLocalRequest(request.shardId(), request.types(), request.nowInMillis(), request.filteringAliases()).     SearchContext searchContext = searchService.createSearchContext(shardSearchLocalRequest, SearchService.NO_TIMEOUT).     try {         ParsedQuery parsedQuery = searchContext.getQueryShardContext().toQuery(request.query()).         searchContext.parsedQuery(parsedQuery).         searchContext.preProcess(request.rewrite()).         valid = true.         explanation = explain(searchContext, request.rewrite()).     } catch (QueryShardException | ParsingException e) {         valid = false.         error = e.getDetailedMessage().     } catch (AssertionError e) {         valid = false.         error = e.getMessage().     } finally {         Releasables.close(searchContext).     }     return new ShardValidateQueryResponse(request.shardId(), valid, explanation, error). }
false;private;2;8;;private String explain(SearchContext context, boolean rewritten) {     Query query = context.query().     if (rewritten && query instanceof MatchNoDocsQuery) {         return context.parsedQuery().query().toString().     } else {         return query.toString().     } }
