commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "cluster_get_settings_action". }
false;public;2;4;;@Override public RestResponse buildResponse(ClusterStateResponse response, XContentBuilder builder) throws Exception {     return new BytesRestResponse(RestStatus.OK, renderResponse(response.getState(), renderDefaults, builder, request)). }
false;public;2;15;;@Override public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {     ClusterStateRequest clusterStateRequest = Requests.clusterStateRequest().routingTable(false).nodes(false).     final boolean renderDefaults = request.paramAsBoolean("include_defaults", false).     clusterStateRequest.local(request.paramAsBoolean("local", clusterStateRequest.local())).     clusterStateRequest.masterNodeTimeout(request.paramAsTime("master_timeout", clusterStateRequest.masterNodeTimeout())).     return channel -> client.admin().cluster().state(clusterStateRequest, new RestBuilderListener<ClusterStateResponse>(channel) {          @Override         public RestResponse buildResponse(ClusterStateResponse response, XContentBuilder builder) throws Exception {             return new BytesRestResponse(RestStatus.OK, renderResponse(response.getState(), renderDefaults, builder, request)).         }     }). }
false;protected;0;4;;@Override protected Set<String> responseParams() {     return Settings.FORMAT_PARAMS. }
false;public;0;4;;@Override public boolean canTripCircuitBreaker() {     return false. }
false;private;4;4;;private XContentBuilder renderResponse(ClusterState state, boolean renderDefaults, XContentBuilder builder, ToXContent.Params params) throws IOException {     return response(state, renderDefaults, settingsFilter, clusterSettings, settings).toXContent(builder, params). }
false;static;5;11;;static ClusterGetSettingsResponse response(final ClusterState state, final boolean renderDefaults, final SettingsFilter settingsFilter, final ClusterSettings clusterSettings, final Settings settings) {     return new ClusterGetSettingsResponse(settingsFilter.filter(state.metaData().persistentSettings()), settingsFilter.filter(state.metaData().transientSettings()), renderDefaults ? settingsFilter.filter(clusterSettings.diff(state.metaData().settings(), settings)) : Settings.EMPTY). }
