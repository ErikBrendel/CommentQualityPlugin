commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;13;;public static DiscoveryNodeFilters buildFromKeyValue(OpType opType, Map<String, String> filters) {     Map<String, String[]> bFilters = new HashMap<>().     for (Map.Entry<String, String> entry : filters.entrySet()) {         String[] values = Strings.tokenizeToStringArray(entry.getValue(), ",").         if (values.length > 0) {             bFilters.put(entry.getKey(), values).         }     }     if (bFilters.isEmpty()) {         return null.     }     return new DiscoveryNodeFilters(opType, bFilters). }
false;private;3;9;;private boolean matchByIP(String[] values, @Nullable String hostIp, @Nullable String publishIp) {     for (String value : values) {         boolean matchIp = Regex.simpleMatch(value, hostIp) || Regex.simpleMatch(value, publishIp).         if (matchIp) {             return matchIp.         }     }     return false. }
false;public;1;121;;public boolean match(DiscoveryNode node) {     for (Map.Entry<String, String[]> entry : filters.entrySet()) {         String attr = entry.getKey().         String[] values = entry.getValue().         if ("_ip".equals(attr)) {             // We check both the host_ip or the publish_ip             String publishAddress = null.             if (node.getAddress() instanceof TransportAddress) {                 publishAddress = NetworkAddress.format(node.getAddress().address().getAddress()).             }             boolean match = matchByIP(values, node.getHostAddress(), publishAddress).             if (opType == OpType.AND) {                 if (match) {                     // If we match, we can check to the next filter                     continue.                 }                 return false.             }             if (match && opType == OpType.OR) {                 return true.             }         } else if ("_host_ip".equals(attr)) {             // We check explicitly only the host_ip             boolean match = matchByIP(values, node.getHostAddress(), null).             if (opType == OpType.AND) {                 if (match) {                     // If we match, we can check to the next filter                     continue.                 }                 return false.             }             if (match && opType == OpType.OR) {                 return true.             }         } else if ("_publish_ip".equals(attr)) {             // We check explicitly only the publish_ip             String address = null.             if (node.getAddress() instanceof TransportAddress) {                 address = NetworkAddress.format(node.getAddress().address().getAddress()).             }             boolean match = matchByIP(values, address, null).             if (opType == OpType.AND) {                 if (match) {                     // If we match, we can check to the next filter                     continue.                 }                 return false.             }             if (match && opType == OpType.OR) {                 return true.             }         } else if ("_host".equals(attr)) {             for (String value : values) {                 if (Regex.simpleMatch(value, node.getHostName()) || Regex.simpleMatch(value, node.getHostAddress())) {                     if (opType == OpType.OR) {                         return true.                     }                 } else {                     if (opType == OpType.AND) {                         return false.                     }                 }             }         } else if ("_id".equals(attr)) {             for (String value : values) {                 if (node.getId().equals(value)) {                     if (opType == OpType.OR) {                         return true.                     }                 } else {                     if (opType == OpType.AND) {                         return false.                     }                 }             }         } else if ("_name".equals(attr) || "name".equals(attr)) {             for (String value : values) {                 if (Regex.simpleMatch(value, node.getName())) {                     if (opType == OpType.OR) {                         return true.                     }                 } else {                     if (opType == OpType.AND) {                         return false.                     }                 }             }         } else {             String nodeAttributeValue = node.getAttributes().get(attr).             if (nodeAttributeValue == null) {                 if (opType == OpType.AND) {                     return false.                 } else {                     continue.                 }             }             for (String value : values) {                 if (Regex.simpleMatch(value, nodeAttributeValue)) {                     if (opType == OpType.OR) {                         return true.                     }                 } else {                     if (opType == OpType.AND) {                         return false.                     }                 }             }         }     }     if (opType == OpType.OR) {         return false.     } else {         return true.     } }
true;public;0;25;/**  * Generates a human-readable string for the DiscoverNodeFilters.  * Example: {@code _id:"id1 OR blah",name:"blah OR name2"}  */ ;/**  * Generates a human-readable string for the DiscoverNodeFilters.  * Example: {@code _id:"id1 OR blah",name:"blah OR name2"}  */ @Override public String toString() {     StringBuilder sb = new StringBuilder().     int entryCount = filters.size().     for (Map.Entry<String, String[]> entry : filters.entrySet()) {         String attr = entry.getKey().         String[] values = entry.getValue().         sb.append(attr).         sb.append(":\"").         int valueCount = values.length.         for (String value : values) {             sb.append(value).             if (valueCount > 1) {                 sb.append(" ").append(opType.toString()).append(" ").             }             valueCount--.         }         sb.append("\"").         if (entryCount > 1) {             sb.append(",").         }         entryCount--.     }     return sb.toString(). }
