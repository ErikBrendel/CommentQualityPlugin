commented;modifiers;parameterAmount;loc;comment;code
true;public,static;3;8;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with no binding annotation.  */ ;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with no binding annotation.  */ public static <K, V> MapBinder<K, V> newMapBinder(Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType) {     binder = binder.skipSources(MapBinder.class, RealMapBinder.class).     return newMapBinder(binder, valueType, Key.get(mapOf(keyType, valueType)), Key.get(mapOfProviderOf(keyType, valueType)), Multibinder.newSetBinder(binder, entryOfProviderOf(keyType, valueType))). }
true;public,static;3;4;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with no binding annotation.  */ ;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with no binding annotation.  */ public static <K, V> MapBinder<K, V> newMapBinder(Binder binder, Class<K> keyType, Class<V> valueType) {     return newMapBinder(binder, TypeLiteral.get(keyType), TypeLiteral.get(valueType)). }
true;public,static;4;8;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with {@code annotation}.  */ ;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with {@code annotation}.  */ public static <K, V> MapBinder<K, V> newMapBinder(Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType, Annotation annotation) {     binder = binder.skipSources(MapBinder.class, RealMapBinder.class).     return newMapBinder(binder, valueType, Key.get(mapOf(keyType, valueType), annotation), Key.get(mapOfProviderOf(keyType, valueType), annotation), Multibinder.newSetBinder(binder, entryOfProviderOf(keyType, valueType), annotation)). }
true;public,static;4;4;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with {@code annotation}.  */ ;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with {@code annotation}.  */ public static <K, V> MapBinder<K, V> newMapBinder(Binder binder, Class<K> keyType, Class<V> valueType, Annotation annotation) {     return newMapBinder(binder, TypeLiteral.get(keyType), TypeLiteral.get(valueType), annotation). }
true;public,static;4;8;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with {@code annotationType}.  */ ;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with {@code annotationType}.  */ public static <K, V> MapBinder<K, V> newMapBinder(Binder binder, TypeLiteral<K> keyType, TypeLiteral<V> valueType, Class<? extends Annotation> annotationType) {     binder = binder.skipSources(MapBinder.class, RealMapBinder.class).     return newMapBinder(binder, valueType, Key.get(mapOf(keyType, valueType), annotationType), Key.get(mapOfProviderOf(keyType, valueType), annotationType), Multibinder.newSetBinder(binder, entryOfProviderOf(keyType, valueType), annotationType)). }
true;public,static;4;5;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with {@code annotationType}.  */ ;/**  * Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in a  * {@link Map} that is itself bound with {@code annotationType}.  */ public static <K, V> MapBinder<K, V> newMapBinder(Binder binder, Class<K> keyType, Class<V> valueType, Class<? extends Annotation> annotationType) {     return newMapBinder(binder, TypeLiteral.get(keyType), TypeLiteral.get(valueType), annotationType). }
false;private,static;2;6;;// a map of <K, V> is safely a Map<K, V> @SuppressWarnings("unchecked") private static <K, V> TypeLiteral<Map<K, V>> mapOf(TypeLiteral<K> keyType, TypeLiteral<V> valueType) {     return (TypeLiteral<Map<K, V>>) TypeLiteral.get(Types.mapOf(keyType.getType(), valueType.getType())). }
false;private,static;2;6;;// a provider map <K, V> is safely a Map<K, Provider<V>> @SuppressWarnings("unchecked") private static <K, V> TypeLiteral<Map<K, Provider<V>>> mapOfProviderOf(TypeLiteral<K> keyType, TypeLiteral<V> valueType) {     return (TypeLiteral<Map<K, Provider<V>>>) TypeLiteral.get(Types.mapOf(keyType.getType(), newParameterizedType(Provider.class, valueType.getType()))). }
false;private,static;2;6;;// a provider entry <K, V> is safely a Map.Entry<K, Provider<V>> @SuppressWarnings("unchecked") private static <K, V> TypeLiteral<Map.Entry<K, Provider<V>>> entryOfProviderOf(TypeLiteral<K> keyType, TypeLiteral<V> valueType) {     return (TypeLiteral<Entry<K, Provider<V>>>) TypeLiteral.get(newParameterizedTypeWithOwner(Map.class, Entry.class, keyType.getType(), Types.providerOf(valueType.getType()))). }
false;private,static;5;8;;private static <K, V> MapBinder<K, V> newMapBinder(Binder binder, TypeLiteral<V> valueType, Key<Map<K, V>> mapKey, Key<Map<K, Provider<V>>> providerMapKey, Multibinder<Entry<K, Provider<V>>> entrySetBinder) {     RealMapBinder<K, V> mapBinder = new RealMapBinder<>(binder, valueType, mapKey, providerMapKey, entrySetBinder).     binder.install(mapBinder).     return mapBinder. }
true;public,abstract;1;1;/**  * Returns a binding builder used to add a new entry in the map. Each  * key must be distinct (and non-null). Bound providers will be evaluated each  * time the map is injected.  * <p>  * It is an error to call this method without also calling one of the  * {@code to} methods on the returned binding builder.  * <p>  * Scoping elements independently is supported. Use the {@code in} method  * to specify a binding scope.  */ ;/**  * Returns a binding builder used to add a new entry in the map. Each  * key must be distinct (and non-null). Bound providers will be evaluated each  * time the map is injected.  * <p>  * It is an error to call this method without also calling one of the  * {@code to} methods on the returned binding builder.  * <p>  * Scoping elements independently is supported. Use the {@code in} method  * to specify a binding scope.  */ public abstract LinkedBindingBuilder<V> addBinding(K key).
true;public;1;10;/**  * This creates two bindings. One for the {@code Map.Entry<K, Provider<V>>}  * and another for {@code V}.  */ ;/**  * This creates two bindings. One for the {@code Map.Entry<K, Provider<V>>}  * and another for {@code V}.  */ @Override public LinkedBindingBuilder<V> addBinding(K key) {     Multibinder.checkNotNull(key, "key").     Multibinder.checkConfiguration(!isInitialized(), "MapBinder was already initialized").     Key<V> valueKey = Key.get(valueType, new RealElement(entrySetBinder.getSetName())).     entrySetBinder.addBinding().toInstance(new MapEntry<>(key, binder.getProvider(valueKey))).     return binder.bind(valueKey). }
false;public;0;13;;// code is silly stupid with generics @SuppressWarnings({ "unchecked", "unused" }) @Inject public void initialize() {     binder.binder = null.     Map<K, Provider<V>> providerMapMutable = new LinkedHashMap<>().     for (Entry<K, Provider<V>> entry : provider.get()) {         Multibinder.checkConfiguration(providerMapMutable.put(entry.getKey(), entry.getValue()) == null, "Map injection failed due to duplicated key \"%s\"", entry.getKey()).     }     providerMap = Collections.unmodifiableMap(providerMapMutable). }
false;public;0;4;;@Override public Map<K, Provider<V>> get() {     return providerMap. }
false;public;0;4;;@Override public Set<Dependency<?>> getDependencies() {     return dependencies. }
false;public;0;12;;@Override public Map<K, V> get() {     Map<K, V> map = new LinkedHashMap<>().     for (Entry<K, Provider<V>> entry : mapProvider.get().entrySet()) {         V value = entry.getValue().get().         K key = entry.getKey().         Multibinder.checkConfiguration(value != null, "Map injection failed due to null value for key \"%s\"", key).         map.put(key, value).     }     return Collections.unmodifiableMap(map). }
false;public;0;4;;@Override public Set<Dependency<?>> getDependencies() {     return dependencies. }
false;public;1;33;;// code is silly stupid with generics @Override // code is silly stupid with generics @SuppressWarnings({ "rawtypes", "unchecked" }) public void configure(Binder binder) {     Multibinder.checkConfiguration(!isInitialized(), "MapBinder was already initialized").     final Set<Dependency<?>> dependencies = singleton(Dependency.get(entrySetBinder.getSetKey())).     // binds a Map<K, Provider<V>> from a collection of Map<Entry<K, Provider<V>>     final Provider<Set<Entry<K, Provider<V>>>> entrySetProvider = binder.getProvider(entrySetBinder.getSetKey()).     binder.bind(providerMapKey).toProvider(new MapBinderProviderWithDependencies(RealMapBinder.this, dependencies, entrySetProvider)).     final Provider<Map<K, Provider<V>>> mapProvider = binder.getProvider(providerMapKey).     binder.bind(mapKey).toProvider(new ProviderWithDependencies<Map<K, V>>() {          @Override         public Map<K, V> get() {             Map<K, V> map = new LinkedHashMap<>().             for (Entry<K, Provider<V>> entry : mapProvider.get().entrySet()) {                 V value = entry.getValue().get().                 K key = entry.getKey().                 Multibinder.checkConfiguration(value != null, "Map injection failed due to null value for key \"%s\"", key).                 map.put(key, value).             }             return Collections.unmodifiableMap(map).         }          @Override         public Set<Dependency<?>> getDependencies() {             return dependencies.         }     }). }
false;private;0;3;;private boolean isInitialized() {     return binder == null. }
false;public;1;5;;@Override public boolean equals(Object o) {     return o instanceof RealMapBinder && ((RealMapBinder<?, ?>) o).mapKey.equals(mapKey). }
false;public;0;4;;@Override public int hashCode() {     return mapKey.hashCode(). }
false;public;0;4;;@Override public K getKey() {     return key. }
false;public;0;4;;@Override public V getValue() {     return value. }
false;public;1;4;;@Override public V setValue(V value) {     throw new UnsupportedOperationException(). }
false;public;1;6;;@Override public boolean equals(Object obj) {     return obj instanceof Map.Entry && key.equals(((Map.Entry<?, ?>) obj).getKey()) && value.equals(((Map.Entry<?, ?>) obj).getValue()). }
false;public;0;5;;@Override public int hashCode() {     return 127 * ("key".hashCode() ^ key.hashCode()) + 127 * ("value".hashCode() ^ value.hashCode()). }
false;public;0;4;;@Override public String toString() {     return "MapEntry(" + key + ", " + value + ")". }
