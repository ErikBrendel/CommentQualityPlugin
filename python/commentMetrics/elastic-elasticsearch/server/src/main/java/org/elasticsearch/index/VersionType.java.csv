commented;modifiers;parameterAmount;loc;comment;code
false;public;3;4;;@Override public boolean isVersionConflictForWrites(long currentVersion, long expectedVersion, boolean deleted) {     return isVersionConflict(currentVersion, expectedVersion, deleted). }
false;public;3;10;;@Override public String explainConflictForWrites(long currentVersion, long expectedVersion, boolean deleted) {     if (expectedVersion == Versions.MATCH_DELETED) {         return "document already exists (current version [" + currentVersion + "])".     }     if (currentVersion == Versions.NOT_FOUND) {         return "document does not exist (expected version [" + expectedVersion + "])".     }     return "current version [" + currentVersion + "] is different than the one provided [" + expectedVersion + "]". }
false;public;2;4;;@Override public boolean isVersionConflictForReads(long currentVersion, long expectedVersion) {     return isVersionConflict(currentVersion, expectedVersion, false). }
false;public;2;7;;@Override public String explainConflictForReads(long currentVersion, long expectedVersion) {     if (currentVersion == Versions.NOT_FOUND) {         return "document does not exist (expected version [" + expectedVersion + "])".     }     return "current version [" + currentVersion + "] is different than the one provided [" + expectedVersion + "]". }
false;private;3;12;;private boolean isVersionConflict(long currentVersion, long expectedVersion, boolean deleted) {     if (expectedVersion == Versions.MATCH_ANY) {         return false.     }     if (expectedVersion == Versions.MATCH_DELETED) {         return deleted == false.     }     if (currentVersion != expectedVersion) {         return true.     }     return false. }
false;public;2;4;;@Override public long updateVersion(long currentVersion, long expectedVersion) {     return currentVersion == Versions.NOT_FOUND ? 1 : currentVersion + 1. }
false;public;1;4;;@Override public boolean validateVersionForWrites(long version) {     return version > 0L || version == Versions.MATCH_ANY || version == Versions.MATCH_DELETED. }
false;public;1;5;;@Override public boolean validateVersionForReads(long version) {     // not allowing Versions.NOT_FOUND as it is not a valid input value.     return version > 0L || version == Versions.MATCH_ANY. }
false;public;3;13;;@Override public boolean isVersionConflictForWrites(long currentVersion, long expectedVersion, boolean deleted) {     if (currentVersion == Versions.NOT_FOUND) {         return false.     }     if (expectedVersion == Versions.MATCH_ANY) {         return true.     }     if (currentVersion >= expectedVersion) {         return true.     }     return false. }
false;public;3;4;;@Override public String explainConflictForWrites(long currentVersion, long expectedVersion, boolean deleted) {     return "current version [" + currentVersion + "] is higher or equal to the one provided [" + expectedVersion + "]". }
false;public;2;13;;@Override public boolean isVersionConflictForReads(long currentVersion, long expectedVersion) {     if (expectedVersion == Versions.MATCH_ANY) {         return false.     }     if (currentVersion == Versions.NOT_FOUND) {         return true.     }     if (currentVersion != expectedVersion) {         return true.     }     return false. }
false;public;2;7;;@Override public String explainConflictForReads(long currentVersion, long expectedVersion) {     if (currentVersion == Versions.NOT_FOUND) {         return "document does not exist (expected version [" + expectedVersion + "])".     }     return "current version [" + currentVersion + "] is different than the one provided [" + expectedVersion + "]". }
false;public;2;4;;@Override public long updateVersion(long currentVersion, long expectedVersion) {     return expectedVersion. }
false;public;1;4;;@Override public boolean validateVersionForWrites(long version) {     return version >= 0L. }
false;public;1;4;;@Override public boolean validateVersionForReads(long version) {     return version >= 0L || version == Versions.MATCH_ANY. }
false;public;3;13;;@Override public boolean isVersionConflictForWrites(long currentVersion, long expectedVersion, boolean deleted) {     if (currentVersion == Versions.NOT_FOUND) {         return false.     }     if (expectedVersion == Versions.MATCH_ANY) {         return true.     }     if (currentVersion > expectedVersion) {         return true.     }     return false. }
false;public;3;4;;@Override public String explainConflictForWrites(long currentVersion, long expectedVersion, boolean deleted) {     return "current version [" + currentVersion + "] is higher than the one provided [" + expectedVersion + "]". }
false;public;2;13;;@Override public boolean isVersionConflictForReads(long currentVersion, long expectedVersion) {     if (expectedVersion == Versions.MATCH_ANY) {         return false.     }     if (currentVersion == Versions.NOT_FOUND) {         return true.     }     if (currentVersion != expectedVersion) {         return true.     }     return false. }
false;public;2;7;;@Override public String explainConflictForReads(long currentVersion, long expectedVersion) {     if (currentVersion == Versions.NOT_FOUND) {         return "document does not exist (expected version [" + expectedVersion + "])".     }     return "current version [" + currentVersion + "] is different than the one provided [" + expectedVersion + "]". }
false;public;2;4;;@Override public long updateVersion(long currentVersion, long expectedVersion) {     return expectedVersion. }
false;public;1;4;;@Override public boolean validateVersionForWrites(long version) {     return version >= 0L. }
false;public;1;4;;@Override public boolean validateVersionForReads(long version) {     return version >= 0L || version == Versions.MATCH_ANY. }
false;public;3;10;;@Override public boolean isVersionConflictForWrites(long currentVersion, long expectedVersion, boolean deleted) {     if (currentVersion == Versions.NOT_FOUND) {         return false.     }     if (expectedVersion == Versions.MATCH_ANY) {         throw new IllegalStateException("you must specify a version when use VersionType.FORCE").     }     return false. }
false;public;3;4;;@Override public String explainConflictForWrites(long currentVersion, long expectedVersion, boolean deleted) {     throw new AssertionError("VersionType.FORCE should never result in a write conflict"). }
false;public;2;4;;@Override public boolean isVersionConflictForReads(long currentVersion, long expectedVersion) {     return false. }
false;public;2;4;;@Override public String explainConflictForReads(long currentVersion, long expectedVersion) {     throw new AssertionError("VersionType.FORCE should never result in a read conflict"). }
false;public;2;4;;@Override public long updateVersion(long currentVersion, long expectedVersion) {     return expectedVersion. }
false;public;1;4;;@Override public boolean validateVersionForWrites(long version) {     return version >= 0L. }
false;public;1;4;;@Override public boolean validateVersionForReads(long version) {     return version >= 0L || version == Versions.MATCH_ANY. }
false;public;0;3;;public byte getValue() {     return value. }
true;public,abstract;3;1;/**  * Checks whether the current version conflicts with the expected version, based on the current version type.  *  * @param currentVersion  the current version for the document  * @param expectedVersion the version specified for the write operation  * @param deleted         true if the document is currently deleted (note that #currentVersion will typically be  *                        {@link Versions#NOT_FOUND}, but may be something else if the document was recently deleted  * @return true if versions conflict false o.w.  */ ;/**  * Checks whether the current version conflicts with the expected version, based on the current version type.  *  * @param currentVersion  the current version for the document  * @param expectedVersion the version specified for the write operation  * @param deleted         true if the document is currently deleted (note that #currentVersion will typically be  *                        {@link Versions#NOT_FOUND}, but may be something else if the document was recently deleted  * @return true if versions conflict false o.w.  */ public abstract boolean isVersionConflictForWrites(long currentVersion, long expectedVersion, boolean deleted).
true;public,abstract;3;1;/**  * Returns a human readable explanation for a version conflict on write.  *  * Note that this method is only called if {@link #isVersionConflictForWrites(long, long, boolean)} returns true.  *  * @param currentVersion  the current version for the document  * @param expectedVersion the version specified for the write operation  * @param deleted         true if the document is currently deleted (note that #currentVersion will typically be  *                        {@link Versions#NOT_FOUND}, but may be something else if the document was recently deleted  */ ;/**  * Returns a human readable explanation for a version conflict on write.  *  * Note that this method is only called if {@link #isVersionConflictForWrites(long, long, boolean)} returns true.  *  * @param currentVersion  the current version for the document  * @param expectedVersion the version specified for the write operation  * @param deleted         true if the document is currently deleted (note that #currentVersion will typically be  *                        {@link Versions#NOT_FOUND}, but may be something else if the document was recently deleted  */ public abstract String explainConflictForWrites(long currentVersion, long expectedVersion, boolean deleted).
true;public,abstract;2;1;/**  * Checks whether the current version conflicts with the expected version, based on the current version type.  *  * @param currentVersion  the current version for the document  * @param expectedVersion the version specified for the read operation  * @return true if versions conflict false o.w.  */ ;/**  * Checks whether the current version conflicts with the expected version, based on the current version type.  *  * @param currentVersion  the current version for the document  * @param expectedVersion the version specified for the read operation  * @return true if versions conflict false o.w.  */ public abstract boolean isVersionConflictForReads(long currentVersion, long expectedVersion).
true;public,abstract;2;1;/**  * Returns a human readable explanation for a version conflict on read.  *  * Note that this method is only called if {@link #isVersionConflictForReads(long, long)} returns true.  *  * @param currentVersion  the current version for the document  * @param expectedVersion the version specified for the read operation  */ ;/**  * Returns a human readable explanation for a version conflict on read.  *  * Note that this method is only called if {@link #isVersionConflictForReads(long, long)} returns true.  *  * @param currentVersion  the current version for the document  * @param expectedVersion the version specified for the read operation  */ public abstract String explainConflictForReads(long currentVersion, long expectedVersion).
true;public,abstract;2;1;/**  * Returns the new version for a document, based on its current one and the specified in the request  *  * @return new version  */ ;/**  * Returns the new version for a document, based on its current one and the specified in the request  *  * @return new version  */ public abstract long updateVersion(long currentVersion, long expectedVersion).
true;public,abstract;1;1;/**  * validate the version is a valid value for this type when writing.  *  * @return true if valid, false o.w  */ ;/**  * validate the version is a valid value for this type when writing.  *  * @return true if valid, false o.w  */ public abstract boolean validateVersionForWrites(long version).
true;public,abstract;1;1;/**  * validate the version is a valid value for this type when reading.  *  * @return true if valid, false o.w  */ ;/**  * validate the version is a valid value for this type when reading.  *  * @return true if valid, false o.w  */ public abstract boolean validateVersionForReads(long version).
false;public,static;1;14;;public static VersionType fromString(String versionType) {     if ("internal".equals(versionType)) {         return INTERNAL.     } else if ("external".equals(versionType)) {         return EXTERNAL.     } else if ("external_gt".equals(versionType)) {         return EXTERNAL.     } else if ("external_gte".equals(versionType)) {         return EXTERNAL_GTE.     } else if ("force".equals(versionType)) {         return FORCE.     }     throw new IllegalArgumentException("No version type match [" + versionType + "]"). }
false;public,static;2;6;;public static VersionType fromString(String versionType, VersionType defaultVersionType) {     if (versionType == null) {         return defaultVersionType.     }     return fromString(versionType). }
false;public,static;1;3;;public static String toString(VersionType versionType) {     return versionType.name().toLowerCase(Locale.ROOT). }
false;public,static;1;12;;public static VersionType fromValue(byte value) {     if (value == 0) {         return INTERNAL.     } else if (value == 1) {         return EXTERNAL.     } else if (value == 2) {         return EXTERNAL_GTE.     } else if (value == 3) {         return FORCE.     }     throw new IllegalArgumentException("No version type match [" + value + "]"). }
false;public,static;1;3;;public static VersionType readFromStream(StreamInput in) throws IOException {     return in.readEnum(VersionType.class). }
false;public;1;4;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeEnum(this). }
