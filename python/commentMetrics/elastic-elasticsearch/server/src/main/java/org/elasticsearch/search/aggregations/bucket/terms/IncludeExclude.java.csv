commented;modifiers;parameterAmount;loc;comment;code
true;public,static;2;22;// TODO: move all aggs to the same package so that this stuff could be pkg-private ;// for parsing purposes only // TODO: move all aggs to the same package so that this stuff could be pkg-private public static IncludeExclude merge(IncludeExclude include, IncludeExclude exclude) {     if (include == null) {         return exclude.     }     if (exclude == null) {         return include.     }     if (include.isPartitionBased()) {         throw new IllegalArgumentException("Cannot specify any excludes when using a partition-based include").     }     String includeMethod = include.isRegexBased() ? "regex" : "set".     String excludeMethod = exclude.isRegexBased() ? "regex" : "set".     if (includeMethod.equals(excludeMethod) == false) {         throw new IllegalArgumentException("Cannot mix a " + includeMethod + "-based include with a " + excludeMethod + "-based method").     }     if (include.isRegexBased()) {         return new IncludeExclude(include.include, exclude.exclude).     } else {         return new IncludeExclude(include.includeValues, exclude.excludeValues).     } }
false;public,static;1;34;;public static IncludeExclude parseInclude(XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     if (token == XContentParser.Token.VALUE_STRING) {         return new IncludeExclude(parser.text(), null).     } else if (token == XContentParser.Token.START_ARRAY) {         return new IncludeExclude(new TreeSet<>(parseArrayToSet(parser)), null).     } else if (token == XContentParser.Token.START_OBJECT) {         String currentFieldName = null.         Integer partition = null, numPartitions = null.         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {             if (token == XContentParser.Token.FIELD_NAME) {                 currentFieldName = parser.currentName().             } else if (NUM_PARTITIONS_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 numPartitions = parser.intValue().             } else if (PARTITION_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 partition = parser.intValue().             } else {                 throw new ElasticsearchParseException("Unknown parameter in Include/Exclude clause: " + currentFieldName).             }         }         if (partition == null) {             throw new IllegalArgumentException("Missing [" + PARTITION_FIELD.getPreferredName() + "] parameter for partition-based include").         }         if (numPartitions == null) {             throw new IllegalArgumentException("Missing [" + NUM_PARTITIONS_FIELD.getPreferredName() + "] parameter for partition-based include").         }         return new IncludeExclude(partition, numPartitions).     } else {         throw new IllegalArgumentException("Unrecognized token for an include [" + token + "]").     } }
false;public,static;1;10;;public static IncludeExclude parseExclude(XContentParser parser) throws IOException {     XContentParser.Token token = parser.currentToken().     if (token == XContentParser.Token.VALUE_STRING) {         return new IncludeExclude(null, parser.text()).     } else if (token == XContentParser.Token.START_ARRAY) {         return new IncludeExclude(null, new TreeSet<>(parseArrayToSet(parser))).     } else {         throw new IllegalArgumentException("Unrecognized token for an exclude [" + token + "]").     } }
false;public,abstract;1;1;;public abstract boolean accept(long value).
false;public;1;6;;@Override public boolean accept(long value) {     // hash the value to keep even distributions     final long hashCode = BitMixer.mix64(value).     return Math.floorMod(hashCode, incNumPartitions) == incZeroBasedPartition. }
false;public;1;4;;@Override public boolean accept(long value) {     return ((valids == null) || (valids.contains(value))) && ((invalids == null) || (!invalids.contains(value))). }
false;private;1;3;;private void addAccept(long val) {     valids.add(val). }
false;private;1;3;;private void addReject(long val) {     invalids.add(val). }
false;public,abstract;1;1;;public abstract boolean accept(BytesRef value).
false;public;1;4;;@Override public boolean accept(BytesRef value) {     return Math.floorMod(StringHelper.murmurhash3_x86_32(value, HASH_PARTITIONING_SEED), incNumPartitions) == incZeroBasedPartition. }
true;public;1;4;/**  * Returns whether the given value is accepted based on the {@code include} &amp. {@code exclude} patterns.  */ ;/**  * Returns whether the given value is accepted based on the {@code include} &amp. {@code exclude} patterns.  */ @Override public boolean accept(BytesRef value) {     return runAutomaton.run(value.bytes, value.offset, value.length). }
true;public;1;4;/**  * Returns whether the given value is accepted based on the  * {@code include} &amp. {@code exclude} sets.  */ ;/**  * Returns whether the given value is accepted based on the  * {@code include} &amp. {@code exclude} sets.  */ @Override public boolean accept(BytesRef value) {     return ((valids == null) || (valids.contains(value))) && ((invalids == null) || (!invalids.contains(value))). }
false;public,abstract;1;1;;public abstract LongBitSet acceptedGlobalOrdinals(SortedSetDocValues globalOrdinals) throws IOException.
false;public;1;16;;@Override public LongBitSet acceptedGlobalOrdinals(SortedSetDocValues globalOrdinals) throws IOException {     final long numOrds = globalOrdinals.getValueCount().     final LongBitSet acceptedGlobalOrdinals = new LongBitSet(numOrds).     final TermsEnum termEnum = globalOrdinals.termsEnum().     BytesRef term = termEnum.next().     while (term != null) {         if (Math.floorMod(StringHelper.murmurhash3_x86_32(term, HASH_PARTITIONING_SEED), incNumPartitions) == incZeroBasedPartition) {             acceptedGlobalOrdinals.set(termEnum.ord()).         }         term = termEnum.next().     }     return acceptedGlobalOrdinals. }
true;public;1;12;/**  * Computes which global ordinals are accepted by this IncludeExclude instance.  */ ;/**  * Computes which global ordinals are accepted by this IncludeExclude instance.  */ @Override public LongBitSet acceptedGlobalOrdinals(SortedSetDocValues globalOrdinals) throws IOException {     LongBitSet acceptedGlobalOrdinals = new LongBitSet(globalOrdinals.getValueCount()).     TermsEnum globalTermsEnum.     Terms globalTerms = new DocValuesTerms(globalOrdinals).     // TODO: specialize based on compiled.type: for ALL and prefixes (sinkState >= 0 ) we can avoid i/o and just set bits.     globalTermsEnum = compiled.getTermsEnum(globalTerms).     for (BytesRef term = globalTermsEnum.next(). term != null. term = globalTermsEnum.next()) {         acceptedGlobalOrdinals.set(globalTermsEnum.ord()).     }     return acceptedGlobalOrdinals. }
false;public;1;24;;@Override public LongBitSet acceptedGlobalOrdinals(SortedSetDocValues globalOrdinals) throws IOException {     LongBitSet acceptedGlobalOrdinals = new LongBitSet(globalOrdinals.getValueCount()).     if (includeValues != null) {         for (BytesRef term : includeValues) {             long ord = globalOrdinals.lookupTerm(term).             if (ord >= 0) {                 acceptedGlobalOrdinals.set(ord).             }         }     } else if (acceptedGlobalOrdinals.length() > 0) {         // default to all terms being acceptable         acceptedGlobalOrdinals.set(0, acceptedGlobalOrdinals.length()).     }     if (excludeValues != null) {         for (BytesRef term : excludeValues) {             long ord = globalOrdinals.lookupTerm(term).             if (ord >= 0) {                 acceptedGlobalOrdinals.clear(ord).             }         }     }     return acceptedGlobalOrdinals. }
false;public;1;28;;@Override public void writeTo(StreamOutput out) throws IOException {     boolean regexBased = isRegexBased().     out.writeBoolean(regexBased).     if (regexBased) {         out.writeOptionalString(include == null ? null : include.getOriginalString()).         out.writeOptionalString(exclude == null ? null : exclude.getOriginalString()).     } else {         boolean hasIncludes = includeValues != null.         out.writeBoolean(hasIncludes).         if (hasIncludes) {             out.writeVInt(includeValues.size()).             for (BytesRef value : includeValues) {                 out.writeBytesRef(value).             }         }         boolean hasExcludes = excludeValues != null.         out.writeBoolean(hasExcludes).         if (hasExcludes) {             out.writeVInt(excludeValues.size()).             for (BytesRef value : excludeValues) {                 out.writeBytesRef(value).             }         }         out.writeVInt(incNumPartitions).         out.writeVInt(incZeroBasedPartition).     } }
false;private,static;1;10;;private static SortedSet<BytesRef> convertToBytesRefSet(String[] values) {     SortedSet<BytesRef> returnSet = null.     if (values != null) {         returnSet = new TreeSet<>().         for (String value : values) {             returnSet.add(new BytesRef(value)).         }     }     return returnSet. }
false;private,static;1;10;;private static SortedSet<BytesRef> convertToBytesRefSet(double[] values) {     SortedSet<BytesRef> returnSet = null.     if (values != null) {         returnSet = new TreeSet<>().         for (double value : values) {             returnSet.add(new BytesRef(String.valueOf(value))).         }     }     return returnSet. }
false;private,static;1;10;;private static SortedSet<BytesRef> convertToBytesRefSet(long[] values) {     SortedSet<BytesRef> returnSet = null.     if (values != null) {         returnSet = new TreeSet<>().         for (long value : values) {             returnSet.add(new BytesRef(String.valueOf(value))).         }     }     return returnSet. }
false;public;0;4;;@Override public TermsEnum iterator() throws IOException {     return values.termsEnum(). }
false;public;0;4;;@Override public long size() throws IOException {     return -1. }
false;public;0;4;;@Override public long getSumTotalTermFreq() throws IOException {     return -1. }
false;public;0;4;;@Override public long getSumDocFreq() throws IOException {     return -1. }
false;public;0;4;;@Override public int getDocCount() throws IOException {     return -1. }
false;public;0;4;;@Override public boolean hasFreqs() {     return false. }
false;public;0;4;;@Override public boolean hasOffsets() {     return false. }
false;public;0;4;;@Override public boolean hasPositions() {     return false. }
false;public;0;4;;@Override public boolean hasPayloads() {     return false. }
false;private,static;1;13;;private static Set<BytesRef> parseArrayToSet(XContentParser parser) throws IOException {     final Set<BytesRef> set = new HashSet<>().     if (parser.currentToken() != XContentParser.Token.START_ARRAY) {         throw new ElasticsearchParseException("Missing start of array in include/exclude clause").     }     while (parser.nextToken() != XContentParser.Token.END_ARRAY) {         if (!parser.currentToken().isValue()) {             throw new ElasticsearchParseException("Array elements in include/exclude clauses should be string values").         }         set.add(new BytesRef(parser.text())).     }     return set. }
false;public;0;3;;public boolean isRegexBased() {     return include != null || exclude != null. }
false;public;0;3;;public boolean isPartitionBased() {     return incNumPartitions > 0. }
false;private;0;16;;private Automaton toAutomaton() {     Automaton a = null.     if (include != null) {         a = include.toAutomaton().     } else if (includeValues != null) {         a = Automata.makeStringUnion(includeValues).     } else {         a = Automata.makeAnyString().     }     if (exclude != null) {         a = Operations.minus(a, exclude.toAutomaton(), Operations.DEFAULT_MAX_DETERMINIZED_STATES).     } else if (excludeValues != null) {         a = Operations.minus(a, Automata.makeStringUnion(excludeValues), Operations.DEFAULT_MAX_DETERMINIZED_STATES).     }     return a. }
false;public;1;9;;public StringFilter convertToStringFilter(DocValueFormat format) {     if (isRegexBased()) {         return new AutomatonBackedStringFilter(toAutomaton()).     }     if (isPartitionBased()) {         return new PartitionedStringFilter().     }     return new TermListBackedStringFilter(parseForDocValues(includeValues, format), parseForDocValues(excludeValues, format)). }
false;private,static;2;12;;private static SortedSet<BytesRef> parseForDocValues(SortedSet<BytesRef> endUserFormattedValues, DocValueFormat format) {     SortedSet<BytesRef> result = endUserFormattedValues.     if (endUserFormattedValues != null) {         if (format != DocValueFormat.RAW) {             result = new TreeSet<>().             for (BytesRef formattedVal : endUserFormattedValues) {                 result.add(format.parseBytesRef(formattedVal.utf8ToString())).             }         }     }     return result. }
false;public;1;11;;public OrdinalsFilter convertToOrdinalsFilter(DocValueFormat format) {     if (isRegexBased()) {         return new AutomatonBackedOrdinalsFilter(toAutomaton()).     }     if (isPartitionBased()) {         return new PartitionedOrdinalsFilter().     }     return new TermListBackedOrdinalsFilter(parseForDocValues(includeValues, format), parseForDocValues(excludeValues, format)). }
false;public;1;21;;public LongFilter convertToLongFilter(DocValueFormat format) {     if (isPartitionBased()) {         return new PartitionedLongFilter().     }     int numValids = includeValues == null ? 0 : includeValues.size().     int numInvalids = excludeValues == null ? 0 : excludeValues.size().     SetBackedLongFilter result = new SetBackedLongFilter(numValids, numInvalids).     if (includeValues != null) {         for (BytesRef val : includeValues) {             result.addAccept(format.parseLong(val.utf8ToString(), false, null)).         }     }     if (excludeValues != null) {         for (BytesRef val : excludeValues) {             result.addReject(format.parseLong(val.utf8ToString(), false, null)).         }     }     return result. }
false;public;0;22;;public LongFilter convertToDoubleFilter() {     if (isPartitionBased()) {         return new PartitionedLongFilter().     }     int numValids = includeValues == null ? 0 : includeValues.size().     int numInvalids = excludeValues == null ? 0 : excludeValues.size().     SetBackedLongFilter result = new SetBackedLongFilter(numValids, numInvalids).     if (includeValues != null) {         for (BytesRef val : includeValues) {             double dval = Double.parseDouble(val.utf8ToString()).             result.addAccept(NumericUtils.doubleToSortableLong(dval)).         }     }     if (excludeValues != null) {         for (BytesRef val : excludeValues) {             double dval = Double.parseDouble(val.utf8ToString()).             result.addReject(NumericUtils.doubleToSortableLong(dval)).         }     }     return result. }
false;public;2;27;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     if (include != null) {         builder.field(INCLUDE_FIELD.getPreferredName(), include.getOriginalString()).     } else if (includeValues != null) {         builder.startArray(INCLUDE_FIELD.getPreferredName()).         for (BytesRef value : includeValues) {             builder.value(value.utf8ToString()).         }         builder.endArray().     } else if (isPartitionBased()) {         builder.startObject(INCLUDE_FIELD.getPreferredName()).         builder.field(PARTITION_FIELD.getPreferredName(), incZeroBasedPartition).         builder.field(NUM_PARTITIONS_FIELD.getPreferredName(), incNumPartitions).         builder.endObject().     }     if (exclude != null) {         builder.field(EXCLUDE_FIELD.getPreferredName(), exclude.getOriginalString()).     } else if (excludeValues != null) {         builder.startArray(EXCLUDE_FIELD.getPreferredName()).         for (BytesRef value : excludeValues) {             builder.value(value.utf8ToString()).         }         builder.endArray().     }     return builder. }
false;public;0;7;;@Override public int hashCode() {     return Objects.hash(include == null ? null : include.getOriginalString(), exclude == null ? null : exclude.getOriginalString(), includeValues, excludeValues, incZeroBasedPartition, incNumPartitions). }
false;public;1;16;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     IncludeExclude other = (IncludeExclude) obj.     return Objects.equals(include == null ? null : include.getOriginalString(), other.include == null ? null : other.include.getOriginalString()) && Objects.equals(exclude == null ? null : exclude.getOriginalString(), other.exclude == null ? null : other.exclude.getOriginalString()) && Objects.equals(includeValues, other.includeValues) && Objects.equals(excludeValues, other.excludeValues) && Objects.equals(incZeroBasedPartition, other.incZeroBasedPartition) && Objects.equals(incNumPartitions, other.incNumPartitions). }
