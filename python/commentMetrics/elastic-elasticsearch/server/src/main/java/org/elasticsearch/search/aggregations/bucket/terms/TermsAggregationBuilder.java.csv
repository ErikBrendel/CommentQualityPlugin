commented;modifiers;parameterAmount;loc;comment;code
false;public,static;2;3;;public static AggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {     return PARSER.parse(parser, new TermsAggregationBuilder(aggregationName, null), null). }
false;protected;2;4;;@Override protected AggregationBuilder shallowCopy(Builder factoriesBuilder, Map<String, Object> metaData) {     return new TermsAggregationBuilder(this, factoriesBuilder, metaData). }
false;protected;0;4;;@Override protected boolean serializeTargetValueType() {     return true. }
false;protected;1;9;;@Override protected void innerWriteTo(StreamOutput out) throws IOException {     bucketCountThresholds.writeTo(out).     out.writeOptionalWriteable(collectMode).     out.writeOptionalString(executionHint).     out.writeOptionalWriteable(includeExclude).     order.writeTo(out).     out.writeBoolean(showTermDocCountError). }
true;public;1;7;/**  * Sets the size - indicating how many term buckets should be returned  * (defaults to 10)  */ ;/**  * Sets the size - indicating how many term buckets should be returned  * (defaults to 10)  */ public TermsAggregationBuilder size(int size) {     if (size <= 0) {         throw new IllegalArgumentException("[size] must be greater than 0. Found [" + size + "] in [" + name + "]").     }     bucketCountThresholds.setRequiredSize(size).     return this. }
true;public;0;3;/**  * Returns the number of term buckets currently configured  */ ;/**  * Returns the number of term buckets currently configured  */ public int size() {     return bucketCountThresholds.getRequiredSize(). }
true;public;1;8;/**  * Sets the shard_size - indicating the number of term buckets each shard  * will return to the coordinating node (the node that coordinates the  * search execution). The higher the shard size is, the more accurate the  * results are.  */ ;/**  * Sets the shard_size - indicating the number of term buckets each shard  * will return to the coordinating node (the node that coordinates the  * search execution). The higher the shard size is, the more accurate the  * results are.  */ public TermsAggregationBuilder shardSize(int shardSize) {     if (shardSize <= 0) {         throw new IllegalArgumentException("[shardSize] must be greater than 0. Found [" + shardSize + "] in [" + name + "]").     }     bucketCountThresholds.setShardSize(shardSize).     return this. }
true;public;0;3;/**  * Returns the number of term buckets per shard that are currently configured  */ ;/**  * Returns the number of term buckets per shard that are currently configured  */ public int shardSize() {     return bucketCountThresholds.getShardSize(). }
true;public;1;8;/**  * Set the minimum document count terms should have in order to appear in  * the response.  */ ;/**  * Set the minimum document count terms should have in order to appear in  * the response.  */ public TermsAggregationBuilder minDocCount(long minDocCount) {     if (minDocCount < 0) {         throw new IllegalArgumentException("[minDocCount] must be greater than or equal to 0. Found [" + minDocCount + "] in [" + name + "]").     }     bucketCountThresholds.setMinDocCount(minDocCount).     return this. }
true;public;0;3;/**  * Returns the minimum document count required per term  */ ;/**  * Returns the minimum document count required per term  */ public long minDocCount() {     return bucketCountThresholds.getMinDocCount(). }
true;public;1;8;/**  * Set the minimum document count terms should have on the shard in order to  * appear in the response.  */ ;/**  * Set the minimum document count terms should have on the shard in order to  * appear in the response.  */ public TermsAggregationBuilder shardMinDocCount(long shardMinDocCount) {     if (shardMinDocCount < 0) {         throw new IllegalArgumentException("[shardMinDocCount] must be greater than or equal to 0. Found [" + shardMinDocCount + "] in [" + name + "]").     }     bucketCountThresholds.setShardMinDocCount(shardMinDocCount).     return this. }
true;public;0;3;/**  * Returns the minimum document count required per term, per shard  */ ;/**  * Returns the minimum document count required per term, per shard  */ public long shardMinDocCount() {     return bucketCountThresholds.getShardMinDocCount(). }
true;public;1;11;/**  * Set a new order on this builder and return the builder so that calls  *  can be chained. A tie-breaker may be added to avoid non-deterministic ordering.  */ ;/**  * Set a new order on this builder and return the builder so that calls  *  can be chained. A tie-breaker may be added to avoid non-deterministic ordering.  */ public TermsAggregationBuilder order(BucketOrder order) {     if (order == null) {         throw new IllegalArgumentException("[order] must not be null: [" + name + "]").     }     if (order instanceof CompoundOrder || InternalOrder.isKeyOrder(order)) {         // if order already contains a tie-breaker we are good to go         this.order = order.     } else {         // otherwise add a tie-breaker by using a compound order         this.order = BucketOrder.compound(order).     }     return this. }
true;public;1;8;/**  * Sets the order in which the buckets will be returned. A tie-breaker may be added to avoid non-deterministic  * ordering.  */ ;/**  * Sets the order in which the buckets will be returned. A tie-breaker may be added to avoid non-deterministic  * ordering.  */ public TermsAggregationBuilder order(List<BucketOrder> orders) {     if (orders == null) {         throw new IllegalArgumentException("[orders] must not be null: [" + name + "]").     }     // if the list only contains one order use that to avoid inconsistent xcontent     order(orders.size() > 1 ? BucketOrder.compound(orders) : orders.get(0)).     return this. }
true;public;0;3;/**  * Gets the order in which the buckets will be returned.  */ ;/**  * Gets the order in which the buckets will be returned.  */ public BucketOrder order() {     return order. }
true;public;1;4;/**  * Expert: sets an execution hint to the aggregation.  */ ;/**  * Expert: sets an execution hint to the aggregation.  */ public TermsAggregationBuilder executionHint(String executionHint) {     this.executionHint = executionHint.     return this. }
true;public;0;3;/**  * Expert: gets an execution hint to the aggregation.  */ ;/**  * Expert: gets an execution hint to the aggregation.  */ public String executionHint() {     return executionHint. }
true;public;1;7;/**  * Expert: set the collection mode.  */ ;/**  * Expert: set the collection mode.  */ public TermsAggregationBuilder collectMode(SubAggCollectionMode collectMode) {     if (collectMode == null) {         throw new IllegalArgumentException("[collectMode] must not be null: [" + name + "]").     }     this.collectMode = collectMode.     return this. }
true;public;0;3;/**  * Expert: get the collection mode.  */ ;/**  * Expert: get the collection mode.  */ public SubAggCollectionMode collectMode() {     return collectMode. }
true;public;1;4;/**  * Set terms to include and exclude from the aggregation results  */ ;/**  * Set terms to include and exclude from the aggregation results  */ public TermsAggregationBuilder includeExclude(IncludeExclude includeExclude) {     this.includeExclude = includeExclude.     return this. }
true;public;0;3;/**  * Get terms to include and exclude from the aggregation results  */ ;/**  * Get terms to include and exclude from the aggregation results  */ public IncludeExclude includeExclude() {     return includeExclude. }
true;public;0;3;/**  * Get whether doc count error will be return for individual terms  */ ;/**  * Get whether doc count error will be return for individual terms  */ public boolean showTermDocCountError() {     return showTermDocCountError. }
true;public;1;4;/**  * Set whether doc count error will be return for individual terms  */ ;/**  * Set whether doc count error will be return for individual terms  */ public TermsAggregationBuilder showTermDocCountError(boolean showTermDocCountError) {     this.showTermDocCountError = showTermDocCountError.     return this. }
false;protected;4;6;;@Override protected ValuesSourceAggregatorFactory<ValuesSource, ?> innerBuild(SearchContext context, ValuesSourceConfig<ValuesSource> config, AggregatorFactory<?> parent, Builder subFactoriesBuilder) throws IOException {     return new TermsAggregatorFactory(name, config, order, includeExclude, executionHint, collectMode, bucketCountThresholds, showTermDocCountError, context, parent, subFactoriesBuilder, metaData). }
false;protected;2;17;;@Override protected XContentBuilder doXContentBody(XContentBuilder builder, Params params) throws IOException {     bucketCountThresholds.toXContent(builder, params).     builder.field(SHOW_TERM_DOC_COUNT_ERROR.getPreferredName(), showTermDocCountError).     if (executionHint != null) {         builder.field(TermsAggregationBuilder.EXECUTION_HINT_FIELD_NAME.getPreferredName(), executionHint).     }     builder.field(ORDER_FIELD.getPreferredName()).     order.toXContent(builder, params).     if (collectMode != null) {         builder.field(SubAggCollectionMode.KEY.getPreferredName(), collectMode.parseField().getPreferredName()).     }     if (includeExclude != null) {         includeExclude.toXContent(builder, params).     }     return builder. }
false;protected;0;4;;@Override protected int innerHashCode() {     return Objects.hash(bucketCountThresholds, collectMode, executionHint, includeExclude, order, showTermDocCountError). }
false;protected;1;10;;@Override protected boolean innerEquals(Object obj) {     TermsAggregationBuilder other = (TermsAggregationBuilder) obj.     return Objects.equals(bucketCountThresholds, other.bucketCountThresholds) && Objects.equals(collectMode, other.collectMode) && Objects.equals(executionHint, other.executionHint) && Objects.equals(includeExclude, other.includeExclude) && Objects.equals(order, other.order) && Objects.equals(showTermDocCountError, other.showTermDocCountError). }
false;public;0;4;;@Override public String getType() {     return NAME. }
