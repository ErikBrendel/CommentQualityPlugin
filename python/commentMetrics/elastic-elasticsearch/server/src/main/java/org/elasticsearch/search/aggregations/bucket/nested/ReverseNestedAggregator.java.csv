commented;modifiers;parameterAmount;loc;comment;code
false;public;2;18;;@Override public void collect(int childDoc, long bucket) throws IOException {     // fast forward to retrieve the parentDoc this childDoc belongs to     final int parentDoc = parentDocs.nextSetBit(childDoc).     assert childDoc <= parentDoc && parentDoc != DocIdSetIterator.NO_MORE_DOCS.     int keySlot = bucketOrdToLastCollectedParentDoc.indexOf(bucket).     if (bucketOrdToLastCollectedParentDoc.indexExists(keySlot)) {         int lastCollectedParentDoc = bucketOrdToLastCollectedParentDoc.indexGet(keySlot).         if (parentDoc > lastCollectedParentDoc) {             collectBucket(sub, parentDoc, bucket).             bucketOrdToLastCollectedParentDoc.indexReplace(keySlot, parentDoc).         }     } else {         collectBucket(sub, parentDoc, bucket).         bucketOrdToLastCollectedParentDoc.indexInsert(keySlot, bucket, parentDoc).     } }
false;protected;2;30;;@Override protected LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     // In ES if parent is deleted, then also the children are deleted, so the child docs this agg receives     // must belong to parent docs that is alive. For this reason acceptedDocs can be null here.     final BitSet parentDocs = parentBitsetProducer.getBitSet(ctx).     if (parentDocs == null) {         return LeafBucketCollector.NO_OP_COLLECTOR.     }     final LongIntHashMap bucketOrdToLastCollectedParentDoc = new LongIntHashMap(32).     return new LeafBucketCollectorBase(sub, null) {          @Override         public void collect(int childDoc, long bucket) throws IOException {             // fast forward to retrieve the parentDoc this childDoc belongs to             final int parentDoc = parentDocs.nextSetBit(childDoc).             assert childDoc <= parentDoc && parentDoc != DocIdSetIterator.NO_MORE_DOCS.             int keySlot = bucketOrdToLastCollectedParentDoc.indexOf(bucket).             if (bucketOrdToLastCollectedParentDoc.indexExists(keySlot)) {                 int lastCollectedParentDoc = bucketOrdToLastCollectedParentDoc.indexGet(keySlot).                 if (parentDoc > lastCollectedParentDoc) {                     collectBucket(sub, parentDoc, bucket).                     bucketOrdToLastCollectedParentDoc.indexReplace(keySlot, parentDoc).                 }             } else {                 collectBucket(sub, parentDoc, bucket).                 bucketOrdToLastCollectedParentDoc.indexInsert(keySlot, bucket, parentDoc).             }         }     }. }
false;public;1;5;;@Override public InternalAggregation buildAggregation(long owningBucketOrdinal) throws IOException {     return new InternalReverseNested(name, bucketDocCount(owningBucketOrdinal), bucketAggregations(owningBucketOrdinal), pipelineAggregators(), metaData()). }
false;public;0;4;;@Override public InternalAggregation buildEmptyAggregation() {     return new InternalReverseNested(name, 0, buildEmptySubAggregations(), pipelineAggregators(), metaData()). }
false;;0;3;;Query getParentFilter() {     return parentFilter. }
