commented;modifiers;parameterAmount;loc;comment;code
true;public,synchronized;0;3;/**  * Issue the next sequence number.  *  * @return the next assigned sequence number  */ ;/**  * Issue the next sequence number.  *  * @return the next assigned sequence number  */ public synchronized long generateSeqNo() {     return nextSeqNo++. }
true;public,synchronized;1;5;/**  * Marks the provided sequence number as seen and updates the max_seq_no if needed.  */ ;/**  * Marks the provided sequence number as seen and updates the max_seq_no if needed.  */ public synchronized void advanceMaxSeqNo(long seqNo) {     if (seqNo >= nextSeqNo) {         nextSeqNo = seqNo + 1.     } }
true;public,synchronized;1;16;/**  * Marks the processing of the provided sequence number as completed as updates the checkpoint if possible.  *  * @param seqNo the sequence number to mark as completed  */ ;/**  * Marks the processing of the provided sequence number as completed as updates the checkpoint if possible.  *  * @param seqNo the sequence number to mark as completed  */ public synchronized void markSeqNoAsCompleted(final long seqNo) {     // make sure we track highest seen sequence number     if (seqNo >= nextSeqNo) {         nextSeqNo = seqNo + 1.     }     if (seqNo <= checkpoint) {         // this is possible during recovery where we might replay an operation that was also replicated         return.     }     final CountedBitSet bitSet = getBitSetForSeqNo(seqNo).     final int offset = seqNoToBitSetOffset(seqNo).     bitSet.set(offset).     if (seqNo == checkpoint + 1) {         updateCheckpoint().     } }
true;public;0;3;/**  * The current checkpoint which can be advanced by {@link #markSeqNoAsCompleted(long)}.  *  * @return the current checkpoint  */ ;/**  * The current checkpoint which can be advanced by {@link #markSeqNoAsCompleted(long)}.  *  * @return the current checkpoint  */ public long getCheckpoint() {     return checkpoint. }
true;public;0;3;/**  * The maximum sequence number issued so far.  *  * @return the maximum sequence number  */ ;/**  * The maximum sequence number issued so far.  *  * @return the maximum sequence number  */ public long getMaxSeqNo() {     return nextSeqNo - 1. }
true;public,synchronized;1;3;/**  * constructs a {@link SeqNoStats} object, using local state and the supplied global checkpoint  *  * This is needed to make sure the local checkpoint and max seq no are consistent  */ ;/**  * constructs a {@link SeqNoStats} object, using local state and the supplied global checkpoint  *  * This is needed to make sure the local checkpoint and max seq no are consistent  */ public synchronized SeqNoStats getStats(final long globalCheckpoint) {     return new SeqNoStats(getMaxSeqNo(), getCheckpoint(), globalCheckpoint). }
true;public,synchronized;1;7;/**  * Waits for all operations up to the provided sequence number to complete.  *  * @param seqNo the sequence number that the checkpoint must advance to before this method returns  * @throws InterruptedException if the thread was interrupted while blocking on the condition  */ ;/**  * Waits for all operations up to the provided sequence number to complete.  *  * @param seqNo the sequence number that the checkpoint must advance to before this method returns  * @throws InterruptedException if the thread was interrupted while blocking on the condition  */ @SuppressForbidden(reason = "Object#wait") public synchronized void waitForOpsToComplete(final long seqNo) throws InterruptedException {     while (checkpoint < seqNo) {         // notified by updateCheckpoint         this.wait().     } }
true;public;1;15;/**  * Checks if the given sequence number was marked as completed in this tracker.  */ ;/**  * Checks if the given sequence number was marked as completed in this tracker.  */ public boolean contains(final long seqNo) {     assert seqNo >= 0 : "invalid seq_no=" + seqNo.     if (seqNo >= nextSeqNo) {         return false.     }     if (seqNo <= checkpoint) {         return true.     }     final long bitSetKey = getBitSetKey(seqNo).     final int bitSetOffset = seqNoToBitSetOffset(seqNo).     synchronized (this) {         final CountedBitSet bitSet = processedSeqNo.get(bitSetKey).         return bitSet != null && bitSet.get(bitSetOffset).     } }
true;private;0;32;/**  * Moves the checkpoint to the last consecutively processed sequence number. This method assumes that the sequence number following the  * current checkpoint is processed.  */ ;/**  * Moves the checkpoint to the last consecutively processed sequence number. This method assumes that the sequence number following the  * current checkpoint is processed.  */ @SuppressForbidden(reason = "Object#notifyAll") private void updateCheckpoint() {     assert Thread.holdsLock(this).     assert getBitSetForSeqNo(checkpoint + 1).get(seqNoToBitSetOffset(checkpoint + 1)) : "updateCheckpoint is called but the bit following the checkpoint is not set".     try {         // keep it simple for now, get the checkpoint one by one. in the future we can optimize and read words         long bitSetKey = getBitSetKey(checkpoint).         CountedBitSet current = processedSeqNo.get(bitSetKey).         if (current == null) {             // the bit set corresponding to the checkpoint has already been removed, set ourselves up for the next bit set             assert checkpoint % BIT_SET_SIZE == BIT_SET_SIZE - 1.             current = processedSeqNo.get(++bitSetKey).         }         do {             checkpoint++.             /*                  * The checkpoint always falls in the current bit set or we have already cleaned it. if it falls on the last bit of the                  * current bit set, we can clean it.                  */             if (checkpoint == lastSeqNoInBitSet(bitSetKey)) {                 assert current != null.                 final CountedBitSet removed = processedSeqNo.remove(bitSetKey).                 assert removed == current.                 current = processedSeqNo.get(++bitSetKey).             }         } while (current != null && current.get(seqNoToBitSetOffset(checkpoint + 1))).     } finally {         // notifies waiters in waitForOpsToComplete         this.notifyAll().     } }
false;private;1;3;;private long lastSeqNoInBitSet(final long bitSetKey) {     return (1 + bitSetKey) * BIT_SET_SIZE - 1. }
true;private;1;3;/**  * Return the bit set for the provided sequence number, possibly allocating a new set if needed.  *  * @param seqNo the sequence number to obtain the bit set for  * @return the bit set corresponding to the provided sequence number  */ ;/**  * Return the bit set for the provided sequence number, possibly allocating a new set if needed.  *  * @param seqNo the sequence number to obtain the bit set for  * @return the bit set corresponding to the provided sequence number  */ private long getBitSetKey(final long seqNo) {     return seqNo / BIT_SET_SIZE. }
false;private;1;13;;private CountedBitSet getBitSetForSeqNo(final long seqNo) {     assert Thread.holdsLock(this).     final long bitSetKey = getBitSetKey(seqNo).     final int index = processedSeqNo.indexOf(bitSetKey).     final CountedBitSet bitSet.     if (processedSeqNo.indexExists(index)) {         bitSet = processedSeqNo.indexGet(index).     } else {         bitSet = new CountedBitSet(BIT_SET_SIZE).         processedSeqNo.indexInsert(index, bitSetKey, bitSet).     }     return bitSet. }
true;private;1;3;/**  * Obtain the position in the bit set corresponding to the provided sequence number. The bit set corresponding to the sequence number  * can be obtained via {@link #getBitSetForSeqNo(long)}.  *  * @param seqNo the sequence number to obtain the position for  * @return the position in the bit set corresponding to the provided sequence number  */ ;/**  * Obtain the position in the bit set corresponding to the provided sequence number. The bit set corresponding to the sequence number  * can be obtained via {@link #getBitSetForSeqNo(long)}.  *  * @param seqNo the sequence number to obtain the position for  * @return the position in the bit set corresponding to the provided sequence number  */ private int seqNoToBitSetOffset(final long seqNo) {     return Math.toIntExact(seqNo % BIT_SET_SIZE). }
