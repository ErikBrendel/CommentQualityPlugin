commented;modifiers;parameterAmount;loc;comment;code
true;public;1;64;/**  * Register a {@link LeafReader}. This is necessary so that the core cache  * key of this reader can be found later using {@link #getCoreKeysForIndex(String)}.  */ ;/**  * Register a {@link LeafReader}. This is necessary so that the core cache  * key of this reader can be found later using {@link #getCoreKeysForIndex(String)}.  */ public void add(LeafReader reader) {     final ShardId shardId = ShardUtils.extractShardId(reader).     if (shardId == null) {         throw new IllegalArgumentException("Could not extract shard id from " + reader).     }     final IndexReader.CacheHelper cacheHelper = reader.getCoreCacheHelper().     if (cacheHelper == null) {         throw new IllegalArgumentException("Reader " + reader + " does not support caching").     }     final IndexReader.CacheKey coreKey = cacheHelper.getKey().     if (coreKeyToShard.containsKey(coreKey)) {         // the time).         return.     }     final String index = shardId.getIndexName().     synchronized (this) {         if (coreKeyToShard.containsKey(coreKey) == false) {             Set<IndexReader.CacheKey> objects = indexToCoreKey.get(index).             if (objects == null) {                 objects = new HashSet<>().                 indexToCoreKey.put(index, objects).             }             final boolean added = objects.add(coreKey).             assert added.             IndexReader.ClosedListener listener = ownerCoreCacheKey -> {                 assert coreKey == ownerCoreCacheKey.                 synchronized (ShardCoreKeyMap.this) {                     coreKeyToShard.remove(ownerCoreCacheKey).                     final Set<IndexReader.CacheKey> coreKeys = indexToCoreKey.get(index).                     final boolean removed = coreKeys.remove(coreKey).                     assert removed.                     if (coreKeys.isEmpty()) {                         indexToCoreKey.remove(index).                     }                 }             }.             boolean addedListener = false.             try {                 cacheHelper.addClosedListener(listener).                 addedListener = true.                 // Only add the core key to the map as a last operation so that                 // if another thread sees that the core key is already in the                 // map (like the check just before this synchronized block),                 // then it means that the closed listener has already been                 // registered.                 ShardId previous = coreKeyToShard.put(coreKey, shardId).                 assert previous == null.             } finally {                 if (false == addedListener) {                     try {                         listener.onClose(coreKey).                     } catch (IOException e) {                         throw new RuntimeException("Blow up trying to recover from failure to add listener", e).                     }                 }             }         }     } }
true;public,synchronized;1;3;/**  * Return the {@link ShardId} that holds the given segment, or {@code null}  * if this segment is not tracked.  */ ;/**  * Return the {@link ShardId} that holds the given segment, or {@code null}  * if this segment is not tracked.  */ public synchronized ShardId getShardId(Object coreKey) {     return coreKeyToShard.get(coreKey). }
true;public,synchronized;1;8;/**  * Get the set of core cache keys associated with the given index.  */ ;/**  * Get the set of core cache keys associated with the given index.  */ public synchronized Set<Object> getCoreKeysForIndex(String index) {     final Set<IndexReader.CacheKey> objects = indexToCoreKey.get(index).     if (objects == null) {         return Collections.emptySet().     }     // we have to copy otherwise we risk ConcurrentModificationException     return Collections.unmodifiableSet(new HashSet<>(objects)). }
true;public,synchronized;0;4;/**  * Return the number of tracked segments.  */ ;/**  * Return the number of tracked segments.  */ public synchronized int size() {     assert assertSize().     return coreKeyToShard.size(). }
false;private,synchronized;0;11;;private synchronized boolean assertSize() {     if (!Assertions.ENABLED) {         throw new AssertionError("only run this if assertions are enabled").     }     Collection<Set<IndexReader.CacheKey>> values = indexToCoreKey.values().     int size = 0.     for (Set<IndexReader.CacheKey> value : values) {         size += value.size().     }     return size == coreKeyToShard.size(). }
