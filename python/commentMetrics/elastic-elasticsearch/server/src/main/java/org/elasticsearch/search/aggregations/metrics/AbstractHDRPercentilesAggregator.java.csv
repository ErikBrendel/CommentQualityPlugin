commented;modifiers;parameterAmount;loc;comment;code
false;private,static;2;3;;private static int indexOfKey(double[] keys, double key) {     return ArrayUtils.binarySearch(keys, key, 0.001). }
false;public;0;4;;@Override public ScoreMode scoreMode() {     return valuesSource != null && valuesSource.needsScores() ? ScoreMode.COMPLETE : ScoreMode.COMPLETE_NO_SCORES. }
false;public;2;24;;@Override public void collect(int doc, long bucket) throws IOException {     states = bigArrays.grow(states, bucket + 1).     DoubleHistogram state = states.get(bucket).     if (state == null) {         state = new DoubleHistogram(numberOfSignificantValueDigits).         // Set the histogram to autosize so it can resize itself as         // the data range increases. Resize operations should be         // rare as the histogram buckets are exponential (on the top         // level). In the future we could expose the range as an         // option on the request so the histogram can be fixed at         // initialisation and doesn't need resizing.         state.setAutoResize(true).         states.set(bucket, state).     }     if (values.advanceExact(doc)) {         final int valueCount = values.docValueCount().         for (int i = 0. i < valueCount. i++) {             state.recordValue(values.nextValue()).         }     } }
false;public;2;35;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     if (valuesSource == null) {         return LeafBucketCollector.NO_OP_COLLECTOR.     }     final BigArrays bigArrays = context.bigArrays().     final SortedNumericDoubleValues values = valuesSource.doubleValues(ctx).     return new LeafBucketCollectorBase(sub, values) {          @Override         public void collect(int doc, long bucket) throws IOException {             states = bigArrays.grow(states, bucket + 1).             DoubleHistogram state = states.get(bucket).             if (state == null) {                 state = new DoubleHistogram(numberOfSignificantValueDigits).                 // Set the histogram to autosize so it can resize itself as                 // the data range increases. Resize operations should be                 // rare as the histogram buckets are exponential (on the top                 // level). In the future we could expose the range as an                 // option on the request so the histogram can be fixed at                 // initialisation and doesn't need resizing.                 state.setAutoResize(true).                 states.set(bucket, state).             }             if (values.advanceExact(doc)) {                 final int valueCount = values.docValueCount().                 for (int i = 0. i < valueCount. i++) {                     state.recordValue(values.nextValue()).                 }             }         }     }. }
false;public;1;4;;@Override public boolean hasMetric(String name) {     return indexOfKey(keys, Double.parseDouble(name)) >= 0. }
false;protected;1;7;;protected DoubleHistogram getState(long bucketOrd) {     if (bucketOrd >= states.size()) {         return null.     }     final DoubleHistogram state = states.get(bucketOrd).     return state. }
false;protected;0;4;;@Override protected void doClose() {     Releasables.close(states). }
