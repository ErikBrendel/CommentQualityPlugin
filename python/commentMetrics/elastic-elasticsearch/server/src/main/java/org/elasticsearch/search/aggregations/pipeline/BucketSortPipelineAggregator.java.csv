commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;7;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     out.writeList(sorts).     out.writeVInt(from).     out.writeOptionalVInt(size).     gapPolicy.writeTo(out). }
false;public;0;4;;@Override public String getWriteableName() {     return BucketSortPipelineAggregationBuilder.NAME. }
false;public;2;36;;@Override public InternalAggregation reduce(InternalAggregation aggregation, ReduceContext reduceContext) {     InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket> originalAgg = (InternalMultiBucketAggregation<InternalMultiBucketAggregation, InternalMultiBucketAggregation.InternalBucket>) aggregation.     List<? extends InternalMultiBucketAggregation.InternalBucket> buckets = originalAgg.getBuckets().     int bucketsCount = buckets.size().     int currentSize = size == null ? bucketsCount : size.     if (from >= bucketsCount) {         return originalAgg.create(Collections.emptyList()).     }     // If no sorting needs to take place, we just truncate and return     if (sorts.size() == 0) {         return originalAgg.create(new ArrayList<>(buckets.subList(from, Math.min(from + currentSize, bucketsCount)))).     }     List<ComparableBucket> ordered = new ArrayList<>().     for (InternalMultiBucketAggregation.InternalBucket bucket : buckets) {         ComparableBucket comparableBucket = new ComparableBucket(originalAgg, bucket).         if (comparableBucket.skip() == false) {             ordered.add(comparableBucket).         }     }     Collections.sort(ordered).     // We just have to get as many elements as we expect in results and store them in the same order starting from     // the specified offset and taking currentSize into consideration.     int limit = Math.min(from + currentSize, ordered.size()).     List<InternalMultiBucketAggregation.InternalBucket> newBuckets = new ArrayList<>().     for (int i = from. i < limit. ++i) {         newBuckets.add(ordered.get(i).internalBucket).     }     return originalAgg.create(newBuckets). }
false;private;0;16;;private Map<FieldSortBuilder, Comparable<Object>> resolveAndCacheSortValues() {     Map<FieldSortBuilder, Comparable<Object>> resolved = new HashMap<>().     for (FieldSortBuilder sort : sorts) {         String sortField = sort.getFieldName().         if ("_key".equals(sortField)) {             resolved.put(sort, (Comparable<Object>) internalBucket.getKey()).         } else {             Double bucketValue = BucketHelpers.resolveBucketValue(parentAgg, internalBucket, sortField, gapPolicy).             if (GapPolicy.SKIP == gapPolicy && Double.isNaN(bucketValue)) {                 continue.             }             resolved.put(sort, (Comparable<Object>) (Object) bucketValue).         }     }     return resolved. }
true;private;0;3;/**  * Whether the bucket should be skipped due to the gap policy  */ ;/**  * Whether the bucket should be skipped due to the gap policy  */ private boolean skip() {     return sortValues.isEmpty(). }
false;public;1;21;;@Override public int compareTo(ComparableBucket that) {     int compareResult = 0.     for (FieldSortBuilder sort : sorts) {         Comparable<Object> thisValue = this.sortValues.get(sort).         Comparable<Object> thatValue = that.sortValues.get(sort).         if (thisValue == null && thatValue == null) {             continue.         } else if (thisValue == null) {             return 1.         } else if (thatValue == null) {             return -1.         } else {             compareResult = sort.order() == SortOrder.DESC ? -thisValue.compareTo(thatValue) : thisValue.compareTo(thatValue).         }         if (compareResult != 0) {             break.         }     }     return compareResult. }
