commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     if (IdFieldMapper.NAME.equals(field) && out.getVersion().before(Version.V_6_3_0)) {         out.writeString("_uid").     } else {         out.writeString(field).     }     out.writeVInt(id).     out.writeVInt(max). }
false;private;1;7;;private SliceBuilder setField(String field) {     if (Strings.isEmpty(field)) {         throw new IllegalArgumentException("field name is null or empty").     }     this.field = field.     return this. }
true;public;0;3;/**  * The name of the field to slice against  */ ;/**  * The name of the field to slice against  */ public String getField() {     return this.field. }
false;private;1;10;;private SliceBuilder setId(int id) {     if (id < 0) {         throw new IllegalArgumentException("id must be greater than or equal to 0").     }     if (max != -1 && id >= max) {         throw new IllegalArgumentException("max must be greater than id").     }     this.id = id.     return this. }
true;public;0;3;/**  * The id of the slice.  */ ;/**  * The id of the slice.  */ public int getId() {     return id. }
false;private;1;10;;private SliceBuilder setMax(int max) {     if (max <= 1) {         throw new IllegalArgumentException("max must be greater than 1").     }     if (id != -1 && id >= max) {         throw new IllegalArgumentException("max must be greater than id").     }     this.max = max.     return this. }
true;public;0;3;/**  * The maximum number of slices.  */ ;/**  * The maximum number of slices.  */ public int getMax() {     return max. }
false;public;2;7;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     innerToXContent(builder).     builder.endObject().     return builder. }
false;;1;5;;void innerToXContent(XContentBuilder builder) throws IOException {     builder.field(FIELD_FIELD.getPreferredName(), field).     builder.field(ID_FIELD.getPreferredName(), id).     builder.field(MAX_FIELD.getPreferredName(), max). }
false;public,static;1;4;;public static SliceBuilder fromXContent(XContentParser parser) throws IOException {     SliceBuilder builder = PARSER.parse(parser, new SliceBuilder(), null).     return builder. }
false;public;1;10;;@Override public boolean equals(Object other) {     if (!(other instanceof SliceBuilder)) {         return false.     }     SliceBuilder o = (SliceBuilder) other.     return ((field == null && o.field == null) || field.equals(o.field)) && id == o.id && o.max == max. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(this.field, this.id, this.max). }
true;public;4;101;/**  * Converts this QueryBuilder to a lucene {@link Query}.  *  * @param context Additional information needed to build the query  */ ;/**  * Converts this QueryBuilder to a lucene {@link Query}.  *  * @param context Additional information needed to build the query  */ public Query toFilter(ClusterService clusterService, ShardSearchRequest request, QueryShardContext context, Version minNodeVersion) {     final MappedFieldType type = context.fieldMapper(field).     if (type == null) {         throw new IllegalArgumentException("field " + field + " not found").     }     int shardId = request.shardId().id().     int numShards = context.getIndexSettings().getNumberOfShards().     if (minNodeVersion.onOrAfter(Version.V_6_4_0) && (request.preference() != null || request.indexRoutings().length > 0)) {         GroupShardsIterator<ShardIterator> group = buildShardIterator(clusterService, request).         assert group.size() <= numShards : "index routing shards: " + group.size() + " cannot be greater than total number of shards: " + numShards.         if (group.size() < numShards) {             /**              * The routing of this request targets a subset of the shards of this index so we need to we retrieve              * the original {@link GroupShardsIterator} and compute the request shard id and number of              * shards from it.              * This behavior has been added in {@link Version#V_6_4_0} so if there is another node in the cluster              * with an older version we use the original shard id and number of shards in order to ensure that all              * slices use the same numbers.              */             numShards = group.size().             int ord = 0.             shardId = -1.             // remap the original shard id with its index (position) in the sorted shard iterator.             for (ShardIterator it : group) {                 assert it.shardId().getIndex().equals(request.shardId().getIndex()).                 if (request.shardId().equals(it.shardId())) {                     shardId = ord.                     break.                 }                 ++ord.             }             assert shardId != -1 : "shard id: " + request.shardId().getId() + " not found in index shard routing".         }     }     String field = this.field.     boolean useTermQuery = false.     if ("_uid".equals(field)) {         // on new indices, the _id acts as a _uid         field = IdFieldMapper.NAME.         if (context.getIndexSettings().getIndexVersionCreated().onOrAfter(Version.V_7_0_0)) {             throw new IllegalArgumentException("Computing slices on the [_uid] field is illegal for 7.x indices, use [_id] instead").         }         DEPRECATION_LOG.deprecated("Computing slices on the [_uid] field is deprecated for 6.x indices, use [_id] instead").         useTermQuery = true.     } else if (IdFieldMapper.NAME.equals(field)) {         useTermQuery = true.     } else if (type.hasDocValues() == false) {         throw new IllegalArgumentException("cannot load numeric doc values on " + field).     } else {         IndexFieldData ifm = context.getForField(type).         if (ifm instanceof IndexNumericFieldData == false) {             throw new IllegalArgumentException("cannot load numeric doc values on " + field).         }     }     if (numShards == 1) {         return useTermQuery ? new TermsSliceQuery(field, id, max) : new DocValuesSliceQuery(field, id, max).     }     if (max >= numShards) {         // the number of slices is greater than the number of shards         // in such case we can reduce the number of requested shards by slice         // first we check if the slice is responsible of this shard         int targetShard = id % numShards.         if (targetShard != shardId) {             // the shard is not part of this slice, we can skip it.             return new MatchNoDocsQuery("this shard is not part of the slice").         }         // compute the number of slices where this shard appears         int numSlicesInShard = max / numShards.         int rest = max % numShards.         if (rest > targetShard) {             numSlicesInShard++.         }         if (numSlicesInShard == 1) {             // this shard has only one slice so we must check all the documents             return new MatchAllDocsQuery().         }         // get the new slice id for this shard         int shardSlice = id / numShards.         return useTermQuery ? new TermsSliceQuery(field, shardSlice, numSlicesInShard) : new DocValuesSliceQuery(field, shardSlice, numSlicesInShard).     }     // the number of shards is greater than the number of slices     // check if the shard is assigned to the slice     int targetSlice = shardId % max.     if (id != targetSlice) {         // the shard is not part of this slice, we can skip it.         return new MatchNoDocsQuery("this shard is not part of the slice").     }     return new MatchAllDocsQuery(). }
true;private;2;7;/**  * Returns the {@link GroupShardsIterator} for the provided <code>request</code>.  */ ;/**  * Returns the {@link GroupShardsIterator} for the provided <code>request</code>.  */ private GroupShardsIterator<ShardIterator> buildShardIterator(ClusterService clusterService, ShardSearchRequest request) {     final ClusterState state = clusterService.state().     String[] indices = new String[] { request.shardId().getIndex().getName() }.     Map<String, Set<String>> routingMap = request.indexRoutings().length > 0 ? Collections.singletonMap(indices[0], Sets.newHashSet(request.indexRoutings())) : null.     return clusterService.operationRouting().searchShards(state, indices, routingMap, request.preference()). }
false;public;0;4;;@Override public String toString() {     return Strings.toString(this, true, true). }
