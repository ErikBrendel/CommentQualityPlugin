commented;modifiers;parameterAmount;loc;comment;code
false;public,static;0;18;;public static List<Entry> getNamedWriteables() {     List<Entry> entries = new ArrayList<>().     // Cluster State     registerClusterCustom(entries, SnapshotsInProgress.TYPE, SnapshotsInProgress::new, SnapshotsInProgress::readDiffFrom).     registerClusterCustom(entries, RestoreInProgress.TYPE, RestoreInProgress::new, RestoreInProgress::readDiffFrom).     registerClusterCustom(entries, SnapshotDeletionsInProgress.TYPE, SnapshotDeletionsInProgress::new, SnapshotDeletionsInProgress::readDiffFrom).     // Metadata     registerMetaDataCustom(entries, RepositoriesMetaData.TYPE, RepositoriesMetaData::new, RepositoriesMetaData::readDiffFrom).     registerMetaDataCustom(entries, IngestMetadata.TYPE, IngestMetadata::new, IngestMetadata::readDiffFrom).     registerMetaDataCustom(entries, ScriptMetaData.TYPE, ScriptMetaData::new, ScriptMetaData::readDiffFrom).     registerMetaDataCustom(entries, IndexGraveyard.TYPE, IndexGraveyard::new, IndexGraveyard::readDiffFrom).     registerMetaDataCustom(entries, PersistentTasksCustomMetaData.TYPE, PersistentTasksCustomMetaData::new, PersistentTasksCustomMetaData::readDiffFrom).     // Task Status (not Diffable)     entries.add(new Entry(Task.Status.class, PersistentTasksNodeService.Status.NAME, PersistentTasksNodeService.Status::new)).     return entries. }
true;public,static;1;15;/**  * For interoperability with transport clients older than 6.3, we need to strip customs  * from the cluster state that the client might not be able to deserialize  *  * @param clusterState the cluster state to filter the customs from  * @return the adapted cluster state  */ ;/**  * For interoperability with transport clients older than 6.3, we need to strip customs  * from the cluster state that the client might not be able to deserialize  *  * @param clusterState the cluster state to filter the customs from  * @return the adapted cluster state  */ public static ClusterState filterCustomsForPre63Clients(ClusterState clusterState) {     final ClusterState.Builder builder = ClusterState.builder(clusterState).     clusterState.customs().keysIt().forEachRemaining(name -> {         if (PRE_6_3_CLUSTER_CUSTOMS_WHITE_LIST.contains(name) == false) {             builder.removeCustom(name).         }     }).     final MetaData.Builder metaBuilder = MetaData.builder(clusterState.metaData()).     clusterState.metaData().customs().keysIt().forEachRemaining(name -> {         if (PRE_6_3_METADATA_CUSTOMS_WHITE_LIST.contains(name) == false) {             metaBuilder.removeCustom(name).         }     }).     return builder.metaData(metaBuilder).build(). }
false;public,static;0;15;;public static List<NamedXContentRegistry.Entry> getNamedXWriteables() {     List<NamedXContentRegistry.Entry> entries = new ArrayList<>().     // Metadata     entries.add(new NamedXContentRegistry.Entry(MetaData.Custom.class, new ParseField(RepositoriesMetaData.TYPE), RepositoriesMetaData::fromXContent)).     entries.add(new NamedXContentRegistry.Entry(MetaData.Custom.class, new ParseField(IngestMetadata.TYPE), IngestMetadata::fromXContent)).     entries.add(new NamedXContentRegistry.Entry(MetaData.Custom.class, new ParseField(ScriptMetaData.TYPE), ScriptMetaData::fromXContent)).     entries.add(new NamedXContentRegistry.Entry(MetaData.Custom.class, new ParseField(IndexGraveyard.TYPE), IndexGraveyard::fromXContent)).     entries.add(new NamedXContentRegistry.Entry(MetaData.Custom.class, new ParseField(PersistentTasksCustomMetaData.TYPE), PersistentTasksCustomMetaData::fromXContent)).     return entries. }
false;private,static;4;4;;private static <T extends ClusterState.Custom> void registerClusterCustom(List<Entry> entries, String name, Reader<? extends T> reader, Reader<NamedDiff> diffReader) {     registerCustom(entries, ClusterState.Custom.class, name, reader, diffReader). }
false;private,static;4;4;;private static <T extends MetaData.Custom> void registerMetaDataCustom(List<Entry> entries, String name, Reader<? extends T> reader, Reader<NamedDiff> diffReader) {     registerCustom(entries, MetaData.Custom.class, name, reader, diffReader). }
false;private,static;5;5;;private static <T extends NamedWriteable> void registerCustom(List<Entry> entries, Class<T> category, String name, Reader<? extends T> reader, Reader<NamedDiff> diffReader) {     entries.add(new Entry(category, name, reader)).     entries.add(new Entry(NamedDiff.class, name, diffReader)). }
false;public;0;3;;public IndexNameExpressionResolver getIndexNameExpressionResolver() {     return indexNameExpressionResolver. }
true;public,static;3;27;/**  * Return a new {@link AllocationDecider} instance with builtin deciders as well as those from plugins.  */ ;// TODO: this is public so allocation benchmark can access the default deciders...can we do that in another way? /**  * Return a new {@link AllocationDecider} instance with builtin deciders as well as those from plugins.  */ public static Collection<AllocationDecider> createAllocationDeciders(Settings settings, ClusterSettings clusterSettings, List<ClusterPlugin> clusterPlugins) {     // collect deciders by class so that we can detect duplicates     Map<Class, AllocationDecider> deciders = new LinkedHashMap<>().     addAllocationDecider(deciders, new MaxRetryAllocationDecider()).     addAllocationDecider(deciders, new ResizeAllocationDecider()).     addAllocationDecider(deciders, new ReplicaAfterPrimaryActiveAllocationDecider()).     addAllocationDecider(deciders, new RebalanceOnlyWhenActiveAllocationDecider()).     addAllocationDecider(deciders, new ClusterRebalanceAllocationDecider(settings, clusterSettings)).     addAllocationDecider(deciders, new ConcurrentRebalanceAllocationDecider(settings, clusterSettings)).     addAllocationDecider(deciders, new EnableAllocationDecider(settings, clusterSettings)).     addAllocationDecider(deciders, new NodeVersionAllocationDecider()).     addAllocationDecider(deciders, new SnapshotInProgressAllocationDecider()).     addAllocationDecider(deciders, new RestoreInProgressAllocationDecider()).     addAllocationDecider(deciders, new FilterAllocationDecider(settings, clusterSettings)).     addAllocationDecider(deciders, new SameShardAllocationDecider(settings, clusterSettings)).     addAllocationDecider(deciders, new DiskThresholdDecider(settings, clusterSettings)).     addAllocationDecider(deciders, new ThrottlingAllocationDecider(settings, clusterSettings)).     addAllocationDecider(deciders, new ShardsLimitAllocationDecider(settings, clusterSettings)).     addAllocationDecider(deciders, new AwarenessAllocationDecider(settings, clusterSettings)).     clusterPlugins.stream().flatMap(p -> p.createAllocationDeciders(settings, clusterSettings).stream()).forEach(d -> addAllocationDecider(deciders, d)).     return deciders.values(). }
true;private,static;2;5;/**  * Add the given allocation decider to the given deciders collection, erroring if the class name is already used.  */ ;/**  * Add the given allocation decider to the given deciders collection, erroring if the class name is already used.  */ private static void addAllocationDecider(Map<Class, AllocationDecider> deciders, AllocationDecider decider) {     if (deciders.put(decider.getClass(), decider) != null) {         throw new IllegalArgumentException("Cannot specify allocation decider [" + decider.getClass().getName() + "] twice").     } }
false;private,static;3;20;;private static ShardsAllocator createShardsAllocator(Settings settings, ClusterSettings clusterSettings, List<ClusterPlugin> clusterPlugins) {     Map<String, Supplier<ShardsAllocator>> allocators = new HashMap<>().     allocators.put(BALANCED_ALLOCATOR, () -> new BalancedShardsAllocator(settings, clusterSettings)).     for (ClusterPlugin plugin : clusterPlugins) {         plugin.getShardsAllocators(settings, clusterSettings).forEach((k, v) -> {             if (allocators.put(k, v) != null) {                 throw new IllegalArgumentException("ShardsAllocator [" + k + "] already defined").             }         }).     }     String allocatorName = SHARDS_ALLOCATOR_TYPE_SETTING.get(settings).     Supplier<ShardsAllocator> allocatorSupplier = allocators.get(allocatorName).     if (allocatorSupplier == null) {         throw new IllegalArgumentException("Unknown ShardsAllocator [" + allocatorName + "]").     }     return Objects.requireNonNull(allocatorSupplier.get(), "ShardsAllocator factory for [" + allocatorName + "] returned null"). }
false;public;0;3;;public AllocationService getAllocationService() {     return allocationService. }
false;protected;0;22;;@Override protected void configure() {     bind(GatewayAllocator.class).asEagerSingleton().     bind(AllocationService.class).toInstance(allocationService).     bind(ClusterService.class).toInstance(clusterService).     bind(NodeConnectionsService.class).asEagerSingleton().     bind(MetaDataDeleteIndexService.class).asEagerSingleton().     bind(MetaDataIndexStateService.class).asEagerSingleton().     bind(MetaDataMappingService.class).asEagerSingleton().     bind(MetaDataIndexAliasesService.class).asEagerSingleton().     bind(MetaDataUpdateSettingsService.class).asEagerSingleton().     bind(MetaDataIndexTemplateService.class).asEagerSingleton().     bind(IndexNameExpressionResolver.class).toInstance(indexNameExpressionResolver).     bind(RoutingService.class).asEagerSingleton().     bind(DelayedAllocationService.class).asEagerSingleton().     bind(ShardStateAction.class).asEagerSingleton().     bind(NodeMappingRefreshAction.class).asEagerSingleton().     bind(MappingUpdatedAction.class).asEagerSingleton().     bind(TaskResultsService.class).asEagerSingleton().     bind(AllocationDeciders.class).toInstance(allocationDeciders).     bind(ShardsAllocator.class).toInstance(shardsAllocator). }
