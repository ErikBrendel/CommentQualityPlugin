commented;modifiers;parameterAmount;loc;comment;code
false;protected;0;4;;@Override protected String executor() {     return Names.SAME. }
false;protected;0;4;;@Override protected ClearVotingConfigExclusionsResponse newResponse() {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
false;protected;1;4;;@Override protected ClearVotingConfigExclusionsResponse read(StreamInput in) throws IOException {     return new ClearVotingConfigExclusionsResponse(in). }
false;public;1;4;;@Override public void onNewClusterState(ClusterState state) {     submitClearVotingConfigExclusionsTask(request, startTimeMillis, listener). }
false;public;0;5;;@Override public void onClusterServiceClose() {     listener.onFailure(new ElasticsearchException("cluster service closed while waiting for removal of nodes " + initialState.getVotingConfigExclusions())). }
false;public;1;6;;@Override public void onTimeout(TimeValue timeout) {     listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for removal of nodes. if nodes should not be removed, set waitForRemoval to false. " + initialState.getVotingConfigExclusions())). }
false;protected;3;43;;@Override protected void masterOperation(ClearVotingConfigExclusionsRequest request, ClusterState initialState, ActionListener<ClearVotingConfigExclusionsResponse> listener) throws Exception {     final long startTimeMillis = threadPool.relativeTimeInMillis().     final Predicate<ClusterState> allExclusionsRemoved = newState -> {         for (VotingConfigExclusion tombstone : initialState.getVotingConfigExclusions()) {             // NB checking for the existence of any node with this persistent ID, because persistent IDs are how votes are counted.             if (newState.nodes().nodeExists(tombstone.getNodeId())) {                 return false.             }         }         return true.     }.     if (request.getWaitForRemoval() && allExclusionsRemoved.test(initialState) == false) {         final ClusterStateObserver clusterStateObserver = new ClusterStateObserver(initialState, clusterService, request.getTimeout(), logger, threadPool.getThreadContext()).         clusterStateObserver.waitForNextChange(new Listener() {              @Override             public void onNewClusterState(ClusterState state) {                 submitClearVotingConfigExclusionsTask(request, startTimeMillis, listener).             }              @Override             public void onClusterServiceClose() {                 listener.onFailure(new ElasticsearchException("cluster service closed while waiting for removal of nodes " + initialState.getVotingConfigExclusions())).             }              @Override             public void onTimeout(TimeValue timeout) {                 listener.onFailure(new ElasticsearchTimeoutException("timed out waiting for removal of nodes. if nodes should not be removed, set waitForRemoval to false. " + initialState.getVotingConfigExclusions())).             }         }, allExclusionsRemoved).     } else {         submitClearVotingConfigExclusionsTask(request, startTimeMillis, listener).     } }
false;public;1;8;;@Override public ClusterState execute(ClusterState currentState) {     final CoordinationMetaData newCoordinationMetaData = CoordinationMetaData.builder(currentState.coordinationMetaData()).clearVotingConfigExclusions().build().     final MetaData newMetaData = MetaData.builder(currentState.metaData()).coordinationMetaData(newCoordinationMetaData).build().     return ClusterState.builder(currentState).metaData(newMetaData).build(). }
false;public;2;4;;@Override public void onFailure(String source, Exception e) {     listener.onFailure(e). }
false;public;0;4;;@Override public TimeValue timeout() {     return TimeValue.timeValueMillis(request.getTimeout().millis() + startTimeMillis - threadPool.relativeTimeInMillis()). }
false;public;3;4;;@Override public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {     listener.onResponse(new ClearVotingConfigExclusionsResponse()). }
false;private;3;28;;private void submitClearVotingConfigExclusionsTask(ClearVotingConfigExclusionsRequest request, long startTimeMillis, ActionListener<ClearVotingConfigExclusionsResponse> listener) {     clusterService.submitStateUpdateTask("clear-voting-config-exclusions", new ClusterStateUpdateTask(Priority.URGENT) {          @Override         public ClusterState execute(ClusterState currentState) {             final CoordinationMetaData newCoordinationMetaData = CoordinationMetaData.builder(currentState.coordinationMetaData()).clearVotingConfigExclusions().build().             final MetaData newMetaData = MetaData.builder(currentState.metaData()).coordinationMetaData(newCoordinationMetaData).build().             return ClusterState.builder(currentState).metaData(newMetaData).build().         }          @Override         public void onFailure(String source, Exception e) {             listener.onFailure(e).         }          @Override         public TimeValue timeout() {             return TimeValue.timeValueMillis(request.getTimeout().millis() + startTimeMillis - threadPool.relativeTimeInMillis()).         }          @Override         public void clusterStateProcessed(String source, ClusterState oldState, ClusterState newState) {             listener.onResponse(new ClearVotingConfigExclusionsResponse()).         }     }). }
false;protected;2;4;;@Override protected ClusterBlockException checkBlock(ClearVotingConfigExclusionsRequest request, ClusterState state) {     return state.blocks().globalBlockedException(ClusterBlockLevel.METADATA_WRITE). }
