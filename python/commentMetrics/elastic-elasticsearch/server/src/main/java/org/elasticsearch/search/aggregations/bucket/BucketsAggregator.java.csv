commented;modifiers;parameterAmount;loc;comment;code
true;public,final;0;3;/**  * Return an upper bound of the maximum bucket ordinal seen so far.  */ ;/**  * Return an upper bound of the maximum bucket ordinal seen so far.  */ public final long maxBucketOrd() {     return docCounts.size(). }
true;public,final;1;3;/**  * Ensure there are at least <code>maxBucketOrd</code> buckets available.  */ ;/**  * Ensure there are at least <code>maxBucketOrd</code> buckets available.  */ public final void grow(long maxBucketOrd) {     docCounts = bigArrays.grow(docCounts, maxBucketOrd). }
true;public,final;3;4;/**  * Utility method to collect the given doc in the given bucket (identified by the bucket ordinal)  */ ;/**  * Utility method to collect the given doc in the given bucket (identified by the bucket ordinal)  */ public final void collectBucket(LeafBucketCollector subCollector, int doc, long bucketOrd) throws IOException {     grow(bucketOrd + 1).     collectExistingBucket(subCollector, doc, bucketOrd). }
true;public,final;3;4;/**  * Same as {@link #collectBucket(LeafBucketCollector, int, long)}, but doesn't check if the docCounts needs to be re-sized.  */ ;/**  * Same as {@link #collectBucket(LeafBucketCollector, int, long)}, but doesn't check if the docCounts needs to be re-sized.  */ public final void collectExistingBucket(LeafBucketCollector subCollector, int doc, long bucketOrd) throws IOException {     docCounts.increment(bucketOrd, 1).     subCollector.collect(doc, bucketOrd). }
false;public,final;2;12;;public final void mergeBuckets(long[] mergeMap, long newNumBuckets) {     try (IntArray oldDocCounts = docCounts) {         docCounts = bigArrays.newIntArray(newNumBuckets, true).         docCounts.fill(0, newNumBuckets, 0).         for (int i = 0. i < oldDocCounts.size(). i++) {             int docCount = oldDocCounts.get(i).             if (docCount != 0) {                 docCounts.increment(mergeMap[i], docCount).             }         }     } }
false;public;0;3;;public IntArray getDocCounts() {     return docCounts. }
true;public,final;2;4;/**  * Utility method to increment the doc counts of the given bucket (identified by the bucket ordinal)  */ ;/**  * Utility method to increment the doc counts of the given bucket (identified by the bucket ordinal)  */ public final void incrementBucketDocCount(long bucketOrd, int inc) {     docCounts = bigArrays.grow(docCounts, bucketOrd + 1).     docCounts.increment(bucketOrd, inc). }
true;public,final;1;11;/**  * Utility method to return the number of documents that fell in the given bucket (identified by the bucket ordinal)  */ ;/**  * Utility method to return the number of documents that fell in the given bucket (identified by the bucket ordinal)  */ public final int bucketDocCount(long bucketOrd) {     if (bucketOrd >= docCounts.size()) {         // bucketAggregations(3) on the filter aggregator anyway to build sub-aggregations.         return 0.     } else {         return docCounts.get(bucketOrd).     } }
true;protected,final;1;3;/**  * Adds {@code count} buckets to the global count for the request and fails if this number is greater than  * the maximum number of buckets allowed in a response  */ ;/**  * Adds {@code count} buckets to the global count for the request and fails if this number is greater than  * the maximum number of buckets allowed in a response  */ protected final void consumeBucketsAndMaybeBreak(int count) {     multiBucketConsumer.accept(count). }
true;protected,final;1;7;/**  * Required method to build the child aggregations of the given bucket (identified by the bucket ordinal).  */ ;/**  * Required method to build the child aggregations of the given bucket (identified by the bucket ordinal).  */ protected final InternalAggregations bucketAggregations(long bucket) throws IOException {     final InternalAggregation[] aggregations = new InternalAggregation[subAggregators.length].     for (int i = 0. i < subAggregators.length. i++) {         aggregations[i] = subAggregators[i].buildAggregation(bucket).     }     return new InternalAggregations(Arrays.asList(aggregations)). }
true;protected,final;0;7;/**  * Utility method to build empty aggregations of the sub aggregators.  */ ;/**  * Utility method to build empty aggregations of the sub aggregators.  */ protected final InternalAggregations bucketEmptyAggregations() {     final InternalAggregation[] aggregations = new InternalAggregation[subAggregators.length].     for (int i = 0. i < subAggregators.length. i++) {         aggregations[i] = subAggregators[i].buildEmptyAggregation().     }     return new InternalAggregations(Arrays.asList(aggregations)). }
false;public,final;0;6;;@Override public final void close() {     try (Releasable releasable = docCounts) {         super.close().     } }
