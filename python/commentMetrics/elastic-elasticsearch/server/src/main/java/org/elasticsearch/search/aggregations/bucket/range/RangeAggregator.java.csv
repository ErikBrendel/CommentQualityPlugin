commented;modifiers;parameterAmount;loc;comment;code
false;public;1;8;;@Override public void writeTo(StreamOutput out) throws IOException {     out.writeOptionalString(key).     out.writeOptionalString(fromAsStr).     out.writeOptionalString(toAsStr).     out.writeDouble(from).     out.writeDouble(to). }
false;public;0;3;;public double getFrom() {     return this.from. }
false;public;0;3;;public double getTo() {     return this.to. }
false;public;0;3;;public String getFromAsString() {     return this.fromAsStr. }
false;public;0;3;;public String getToAsString() {     return this.toAsStr. }
false;public;0;3;;public String getKey() {     return this.key. }
false;;1;3;;boolean matches(double value) {     return value >= from && value < to. }
false;public;0;4;;@Override public String toString() {     return "[" + from + " to " + to + ")". }
false;public,static;1;43;;public static Range fromXContent(XContentParser parser) throws IOException {     XContentParser.Token token.     String currentFieldName = null.     double from = Double.NEGATIVE_INFINITY.     String fromAsStr = null.     double to = Double.POSITIVE_INFINITY.     String toAsStr = null.     String key = null.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.VALUE_NUMBER) {             if (FROM_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 from = parser.doubleValue().             } else if (TO_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 to = parser.doubleValue().             } else {                 XContentParserUtils.throwUnknownField(currentFieldName, parser.getTokenLocation()).             }         } else if (token == XContentParser.Token.VALUE_STRING) {             if (FROM_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 fromAsStr = parser.text().             } else if (TO_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 toAsStr = parser.text().             } else if (KEY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 key = parser.text().             } else {                 XContentParserUtils.throwUnknownField(currentFieldName, parser.getTokenLocation()).             }         } else if (token == XContentParser.Token.VALUE_NULL) {             if (FROM_FIELD.match(currentFieldName, parser.getDeprecationHandler()) || TO_FIELD.match(currentFieldName, parser.getDeprecationHandler()) || KEY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {             // ignore null value             } else {                 XContentParserUtils.throwUnknownField(currentFieldName, parser.getTokenLocation()).             }         } else {             XContentParserUtils.throwUnknownToken(token, parser.getTokenLocation()).         }     }     return new Range(key, from, fromAsStr, to, toAsStr). }
false;public;2;21;;@Override public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject().     if (key != null) {         builder.field(KEY_FIELD.getPreferredName(), key).     }     if (Double.isFinite(from)) {         builder.field(FROM_FIELD.getPreferredName(), from).     }     if (Double.isFinite(to)) {         builder.field(TO_FIELD.getPreferredName(), to).     }     if (fromAsStr != null) {         builder.field(FROM_FIELD.getPreferredName(), fromAsStr).     }     if (toAsStr != null) {         builder.field(TO_FIELD.getPreferredName(), toAsStr).     }     builder.endObject().     return builder. }
false;public;0;4;;@Override public int hashCode() {     return Objects.hash(key, from, fromAsStr, to, toAsStr). }
false;public;1;15;;@Override public boolean equals(Object obj) {     if (obj == null) {         return false.     }     if (getClass() != obj.getClass()) {         return false.     }     Range other = (Range) obj.     return Objects.equals(key, other.key) && Objects.equals(from, other.from) && Objects.equals(fromAsStr, other.fromAsStr) && Objects.equals(to, other.to) && Objects.equals(toAsStr, other.toAsStr). }
false;public;0;7;;@Override public ScoreMode scoreMode() {     if (valuesSource != null && valuesSource.needsScores()) {         return ScoreMode.COMPLETE.     }     return super.scoreMode(). }
false;public;2;10;;@Override public void collect(int doc, long bucket) throws IOException {     if (values.advanceExact(doc)) {         final int valuesCount = values.docValueCount().         for (int i = 0, lo = 0. i < valuesCount. ++i) {             final double value = values.nextValue().             lo = collect(doc, value, bucket, lo).         }     } }
false;private;4;48;;private int collect(int doc, double value, long owningBucketOrdinal, int lowBound) throws IOException {     // all candidates are between these indexes     int lo = lowBound, hi = ranges.length - 1.     int mid = (lo + hi) >>> 1.     while (lo <= hi) {         if (value < ranges[mid].from) {             hi = mid - 1.         } else if (value >= maxTo[mid]) {             lo = mid + 1.         } else {             break.         }         mid = (lo + hi) >>> 1.     }     // no potential candidate     if (lo > hi)         return lo.     // binary search the lower bound     int startLo = lo, startHi = mid.     while (startLo <= startHi) {         final int startMid = (startLo + startHi) >>> 1.         if (value >= maxTo[startMid]) {             startLo = startMid + 1.         } else {             startHi = startMid - 1.         }     }     // binary search the upper bound     int endLo = mid, endHi = hi.     while (endLo <= endHi) {         final int endMid = (endLo + endHi) >>> 1.         if (value < ranges[endMid].from) {             endHi = endMid - 1.         } else {             endLo = endMid + 1.         }     }     assert startLo == lowBound || value >= maxTo[startLo - 1].     assert endHi == ranges.length - 1 || value < ranges[endHi + 1].from.     for (int i = startLo. i <= endHi. ++i) {         if (ranges[i].matches(value)) {             collectBucket(sub, doc, subBucketOrdinal(owningBucketOrdinal, i)).         }     }     return endHi + 1. }
false;public;2;66;;@Override public LeafBucketCollector getLeafCollector(LeafReaderContext ctx, final LeafBucketCollector sub) throws IOException {     final SortedNumericDoubleValues values = valuesSource.doubleValues(ctx).     return new LeafBucketCollectorBase(sub, values) {          @Override         public void collect(int doc, long bucket) throws IOException {             if (values.advanceExact(doc)) {                 final int valuesCount = values.docValueCount().                 for (int i = 0, lo = 0. i < valuesCount. ++i) {                     final double value = values.nextValue().                     lo = collect(doc, value, bucket, lo).                 }             }         }          private int collect(int doc, double value, long owningBucketOrdinal, int lowBound) throws IOException {             // all candidates are between these indexes             int lo = lowBound, hi = ranges.length - 1.             int mid = (lo + hi) >>> 1.             while (lo <= hi) {                 if (value < ranges[mid].from) {                     hi = mid - 1.                 } else if (value >= maxTo[mid]) {                     lo = mid + 1.                 } else {                     break.                 }                 mid = (lo + hi) >>> 1.             }             // no potential candidate             if (lo > hi)                 return lo.             // binary search the lower bound             int startLo = lo, startHi = mid.             while (startLo <= startHi) {                 final int startMid = (startLo + startHi) >>> 1.                 if (value >= maxTo[startMid]) {                     startLo = startMid + 1.                 } else {                     startHi = startMid - 1.                 }             }             // binary search the upper bound             int endLo = mid, endHi = hi.             while (endLo <= endHi) {                 final int endMid = (endLo + endHi) >>> 1.                 if (value < ranges[endMid].from) {                     endHi = endMid - 1.                 } else {                     endLo = endMid + 1.                 }             }             assert startLo == lowBound || value >= maxTo[startLo - 1].             assert endHi == ranges.length - 1 || value < ranges[endHi + 1].from.             for (int i = startLo. i <= endHi. ++i) {                 if (ranges[i].matches(value)) {                     collectBucket(sub, doc, subBucketOrdinal(owningBucketOrdinal, i)).                 }             }             return endHi + 1.         }     }. }
false;private;2;3;;private long subBucketOrdinal(long owningBucketOrdinal, int rangeOrd) {     return owningBucketOrdinal * ranges.length + rangeOrd. }
false;public;1;15;;@Override public InternalAggregation buildAggregation(long owningBucketOrdinal) throws IOException {     consumeBucketsAndMaybeBreak(ranges.length).     List<org.elasticsearch.search.aggregations.bucket.range.Range.Bucket> buckets = new ArrayList<>(ranges.length).     for (int i = 0. i < ranges.length. i++) {         Range range = ranges[i].         final long bucketOrd = subBucketOrdinal(owningBucketOrdinal, i).         org.elasticsearch.search.aggregations.bucket.range.Range.Bucket bucket = rangeFactory.createBucket(range.key, range.from, range.to, bucketDocCount(bucketOrd), bucketAggregations(bucketOrd), keyed, format).         buckets.add(bucket).     }     // value source can be null in the case of unmapped fields     return rangeFactory.create(name, buckets, format, keyed, pipelineAggregators(), metaData()). }
false;public;0;13;;@Override public InternalAggregation buildEmptyAggregation() {     InternalAggregations subAggs = buildEmptySubAggregations().     List<org.elasticsearch.search.aggregations.bucket.range.Range.Bucket> buckets = new ArrayList<>(ranges.length).     for (int i = 0. i < ranges.length. i++) {         Range range = ranges[i].         org.elasticsearch.search.aggregations.bucket.range.Range.Bucket bucket = rangeFactory.createBucket(range.key, range.from, range.to, 0, subAggs, keyed, format).         buckets.add(bucket).     }     // value source can be null in the case of unmapped fields     return rangeFactory.create(name, buckets, format, keyed, pipelineAggregators(), metaData()). }
false;public;0;9;;@Override public InternalAggregation buildEmptyAggregation() {     InternalAggregations subAggs = buildEmptySubAggregations().     List<org.elasticsearch.search.aggregations.bucket.range.Range.Bucket> buckets = new ArrayList<>(ranges.length).     for (RangeAggregator.Range range : ranges) {         buckets.add(factory.createBucket(range.key, range.from, range.to, 0, subAggs, keyed, format)).     }     return factory.create(name, buckets, format, keyed, pipelineAggregators(), metaData()). }
