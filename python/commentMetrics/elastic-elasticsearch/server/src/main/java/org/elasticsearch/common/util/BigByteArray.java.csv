commented;modifiers;parameterAmount;loc;comment;code
false;public;1;6;;@Override public byte get(long index) {     final int pageIndex = pageIndex(index).     final int indexInPage = indexInPage(index).     return pages[pageIndex][indexInPage]. }
false;public;2;9;;@Override public byte set(long index, byte value) {     final int pageIndex = pageIndex(index).     final int indexInPage = indexInPage(index).     final byte[] page = pages[pageIndex].     final byte ret = page[indexInPage].     page[indexInPage] = value.     return ret. }
false;public;3;24;;@Override public boolean get(long index, int len, BytesRef ref) {     assert index + len <= size().     int pageIndex = pageIndex(index).     final int indexInPage = indexInPage(index).     if (indexInPage + len <= pageSize()) {         ref.bytes = pages[pageIndex].         ref.offset = indexInPage.         ref.length = len.         return false.     } else {         ref.bytes = new byte[len].         ref.offset = 0.         ref.length = pageSize() - indexInPage.         System.arraycopy(pages[pageIndex], indexInPage, ref.bytes, 0, ref.length).         do {             ++pageIndex.             final int copyLength = Math.min(pageSize(), len - ref.length).             System.arraycopy(pages[pageIndex], 0, ref.bytes, ref.length, copyLength).             ref.length += copyLength.         } while (ref.length < len).         return true.     } }
false;public;4;19;;@Override public void set(long index, byte[] buf, int offset, int len) {     assert index + len <= size().     int pageIndex = pageIndex(index).     final int indexInPage = indexInPage(index).     if (indexInPage + len <= pageSize()) {         System.arraycopy(buf, offset, pages[pageIndex], indexInPage, len).     } else {         int copyLen = pageSize() - indexInPage.         System.arraycopy(buf, offset, pages[pageIndex], indexInPage, copyLen).         do {             ++pageIndex.             offset += copyLen.             len -= copyLen.             copyLen = Math.min(len, pageSize()).             System.arraycopy(buf, offset, pages[pageIndex], 0, copyLen).         } while (len > copyLen).     } }
false;public;3;17;;@Override public void fill(long fromIndex, long toIndex, byte value) {     if (fromIndex > toIndex) {         throw new IllegalArgumentException().     }     final int fromPage = pageIndex(fromIndex).     final int toPage = pageIndex(toIndex - 1).     if (fromPage == toPage) {         Arrays.fill(pages[fromPage], indexInPage(fromIndex), indexInPage(toIndex - 1) + 1, value).     } else {         Arrays.fill(pages[fromPage], indexInPage(fromIndex), pages[fromPage].length, value).         for (int i = fromPage + 1. i < toPage. ++i) {             Arrays.fill(pages[i], value).         }         Arrays.fill(pages[toPage], 0, indexInPage(toIndex - 1) + 1, value).     } }
false;protected;0;4;;@Override protected int numBytesPerElement() {     return 1. }
true;public;1;15;/**  * Change the size of this array. Content between indexes <code>0</code> and <code>min(size(), newSize)</code> will be preserved.  */ ;/**  * Change the size of this array. Content between indexes <code>0</code> and <code>min(size(), newSize)</code> will be preserved.  */ @Override public void resize(long newSize) {     final int numPages = numPages(newSize).     if (numPages > pages.length) {         pages = Arrays.copyOf(pages, ArrayUtil.oversize(numPages, RamUsageEstimator.NUM_BYTES_OBJECT_REF)).     }     for (int i = numPages - 1. i >= 0 && pages[i] == null. --i) {         pages[i] = newBytePage(i).     }     for (int i = numPages. i < pages.length && pages[i] != null. ++i) {         pages[i] = null.         releasePage(i).     }     this.size = newSize. }
true;public,static;1;3;/**  * Estimates the number of bytes that would be consumed by an array of the given size.  */ ;/**  * Estimates the number of bytes that would be consumed by an array of the given size.  */ public static long estimateRamBytes(final long size) {     return ESTIMATOR.ramBytesEstimated(size). }
