commented;modifiers;parameterAmount;loc;comment;code
true;public,static;1;6;/**  * Get an ActiveShardCount instance for the given value.  The value is first validated to ensure  * it is a valid shard count and throws an IllegalArgumentException if validation fails.  Valid  * values are any non-negative number.  Directly use {@link ActiveShardCount#DEFAULT} for the  * default value (which is one shard copy) or {@link ActiveShardCount#ALL} to specify all the shards.  */ ;/**  * Get an ActiveShardCount instance for the given value.  The value is first validated to ensure  * it is a valid shard count and throws an IllegalArgumentException if validation fails.  Valid  * values are any non-negative number.  Directly use {@link ActiveShardCount#DEFAULT} for the  * default value (which is one shard copy) or {@link ActiveShardCount#ALL} to specify all the shards.  */ public static ActiveShardCount from(final int value) {     if (value < 0) {         throw new IllegalArgumentException("shard count cannot be a negative value").     }     return get(value). }
true;public;1;4;/**  * Validates that the instance is valid for the given number of replicas in an index.  */ ;/**  * Validates that the instance is valid for the given number of replicas in an index.  */ public boolean validate(final int numberOfReplicas) {     assert numberOfReplicas >= 0.     return value <= numberOfReplicas + 1. }
false;private,static;1;15;;private static ActiveShardCount get(final int value) {     switch(value) {         case ACTIVE_SHARD_COUNT_DEFAULT:             return DEFAULT.         case ALL_ACTIVE_SHARDS:             return ALL.         case 1:             return ONE.         case 0:             return NONE.         default:             assert value > 1.             return new ActiveShardCount(value).     } }
false;public;1;4;;@Override public void writeTo(final StreamOutput out) throws IOException {     out.writeInt(value). }
false;public,static;1;3;;public static ActiveShardCount readFrom(final StreamInput in) throws IOException {     return get(in.readInt()). }
true;public,static;1;15;/**  * Parses the active shard count from the given string.  Valid values are "all" for  * all shard copies, null for the default value (which defaults to one shard copy),  * or a numeric value greater than or equal to 0. Any other input will throw an  * IllegalArgumentException.  */ ;/**  * Parses the active shard count from the given string.  Valid values are "all" for  * all shard copies, null for the default value (which defaults to one shard copy),  * or a numeric value greater than or equal to 0. Any other input will throw an  * IllegalArgumentException.  */ public static ActiveShardCount parseString(final String str) {     if (str == null) {         return ActiveShardCount.DEFAULT.     } else if (str.equals("all")) {         return ActiveShardCount.ALL.     } else {         int val.         try {             val = Integer.parseInt(str).         } catch (NumberFormatException e) {             throw new IllegalArgumentException("cannot parse ActiveShardCount[" + str + "]", e).         }         return ActiveShardCount.from(val).     } }
true;public;1;9;/**  * Returns true iff the given number of active shards is enough to meet  * the required shard count represented by this instance.  This method  * should only be invoked with {@link ActiveShardCount} objects created  * from {@link #from(int)}, or {@link #NONE} or {@link #ONE}.  */ ;/**  * Returns true iff the given number of active shards is enough to meet  * the required shard count represented by this instance.  This method  * should only be invoked with {@link ActiveShardCount} objects created  * from {@link #from(int)}, or {@link #NONE} or {@link #ONE}.  */ public boolean enoughShardsActive(final int activeShardCount) {     if (this.value < 0) {         throw new IllegalStateException("not enough information to resolve to shard count").     }     if (activeShardCount < 0) {         throw new IllegalArgumentException("activeShardCount cannot be negative").     }     return this.value <= activeShardCount. }
true;public;2;40;/**  * Returns true iff the given cluster state's routing table contains enough active  * shards for the given indices to meet the required shard count represented by this instance.  */ ;/**  * Returns true iff the given cluster state's routing table contains enough active  * shards for the given indices to meet the required shard count represented by this instance.  */ public boolean enoughShardsActive(final ClusterState clusterState, final String... indices) {     if (this == ActiveShardCount.NONE) {         // not waiting for any active shards         return true.     }     for (final String indexName : indices) {         final IndexMetaData indexMetaData = clusterState.metaData().index(indexName).         if (indexMetaData == null) {             // and we can stop waiting             continue.         }         final IndexRoutingTable indexRoutingTable = clusterState.routingTable().index(indexName).         if (indexRoutingTable == null && indexMetaData.getState() == IndexMetaData.State.CLOSE) {             // and we can stop waiting             continue.         }         assert indexRoutingTable != null.         if (indexRoutingTable.allPrimaryShardsActive() == false) {             // all primary shards aren't active yet             return false.         }         ActiveShardCount waitForActiveShards = this.         if (waitForActiveShards == ActiveShardCount.DEFAULT) {             waitForActiveShards = SETTING_WAIT_FOR_ACTIVE_SHARDS.get(indexMetaData.getSettings()).         }         for (final IntObjectCursor<IndexShardRoutingTable> shardRouting : indexRoutingTable.getShards()) {             if (waitForActiveShards.enoughShardsActive(shardRouting.value) == false) {                 // not enough active shard copies yet                 return false.             }         }     }     return true. }
true;public;1;12;/**  * Returns true iff the active shard count in the shard routing table is enough  * to meet the required shard count represented by this instance.  */ ;/**  * Returns true iff the active shard count in the shard routing table is enough  * to meet the required shard count represented by this instance.  */ public boolean enoughShardsActive(final IndexShardRoutingTable shardRoutingTable) {     final int activeShardCount = shardRoutingTable.activeShards().size().     if (this == ActiveShardCount.ALL) {         // which gives us the total number of shard copies         return activeShardCount == shardRoutingTable.replicaShards().size() + 1.     } else if (this == ActiveShardCount.DEFAULT) {         return activeShardCount >= 1.     } else {         return activeShardCount >= value.     } }
false;public;0;4;;@Override public int hashCode() {     return Integer.hashCode(value). }
false;public;1;11;;@Override public boolean equals(Object o) {     if (this == o) {         return true.     }     if (o == null || getClass() != o.getClass()) {         return false.     }     ActiveShardCount that = (ActiveShardCount) o.     return value == that.value. }
false;public;0;11;;@Override public String toString() {     switch(value) {         case ALL_ACTIVE_SHARDS:             return "ALL".         case ACTIVE_SHARD_COUNT_DEFAULT:             return "DEFAULT".         default:             return Integer.toString(value).     } }
