commented;modifiers;parameterAmount;loc;comment;code
false;public,abstract;0;2;;@Override public abstract MappedFieldType clone().
true;public;1;3;/**  * Return a fielddata builder for this field  *  @throws IllegalArgumentException if the fielddata is not supported on this type.  *  An IllegalArgumentException is needed in order to return an http error 400  *  when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}  *  * @param fullyQualifiedIndexName the name of the index this field-data is build for  */ ;/**  * Return a fielddata builder for this field  *  @throws IllegalArgumentException if the fielddata is not supported on this type.  *  An IllegalArgumentException is needed in order to return an http error 400  *  when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}  *  * @param fullyQualifiedIndexName the name of the index this field-data is build for  */ public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {     throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]"). }
false;public;1;16;;@Override public boolean equals(Object o) {     if (!super.equals(o))         return false.     MappedFieldType fieldType = (MappedFieldType) o.     return boost == fieldType.boost && docValues == fieldType.docValues && Objects.equals(name, fieldType.name) && Objects.equals(indexAnalyzer, fieldType.indexAnalyzer) && Objects.equals(searchAnalyzer, fieldType.searchAnalyzer) && Objects.equals(searchQuoteAnalyzer(), fieldType.searchQuoteAnalyzer()) && Objects.equals(eagerGlobalOrdinals, fieldType.eagerGlobalOrdinals) && Objects.equals(nullValue, fieldType.nullValue) && Objects.equals(nullValueAsString, fieldType.nullValueAsString) && Objects.equals(similarity, fieldType.similarity). }
false;public;0;5;;@Override public int hashCode() {     return Objects.hash(super.hashCode(), name, boost, docValues, indexAnalyzer, searchAnalyzer, searchQuoteAnalyzer, eagerGlobalOrdinals, similarity == null ? null : similarity.name(), nullValue, nullValueAsString). }
true;public,abstract;0;1;/**  * Returns the name of this type, as would be specified in mapping properties  */ ;// TODO: we need to override freeze() and add safety checks that all settings are actually set /**  * Returns the name of this type, as would be specified in mapping properties  */ public abstract String typeName().
true;private;1;9;/**  * Checks this type is the same type as other. Adds a conflict if they are different.  */ ;/**  * Checks this type is the same type as other. Adds a conflict if they are different.  */ private void checkTypeName(MappedFieldType other) {     if (typeName().equals(other.typeName()) == false) {         throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]").     } else if (getClass() != other.getClass()) {         throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and " + other.getClass().getSimpleName()).     } }
true;public;2;46;/**  * Checks for any conflicts between this field type and other.  * If strict is true, all properties must be equal.  * Otherwise, only properties which must never change in an index are checked.  */ ;/**  * Checks for any conflicts between this field type and other.  * If strict is true, all properties must be equal.  * Otherwise, only properties which must never change in an index are checked.  */ public void checkCompatibility(MappedFieldType other, List<String> conflicts) {     checkTypeName(other).     boolean indexed = indexOptions() != IndexOptions.NONE.     boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE.     // TODO: should be validating if index options go "up" (but "down" is ok)     if (indexed != mergeWithIndexed) {         conflicts.add("mapper [" + name() + "] has different [index] values").     }     if (stored() != other.stored()) {         conflicts.add("mapper [" + name() + "] has different [store] values").     }     if (hasDocValues() != other.hasDocValues()) {         conflicts.add("mapper [" + name() + "] has different [doc_values] values").     }     if (omitNorms() && !other.omitNorms()) {         conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled").     }     if (storeTermVectors() != other.storeTermVectors()) {         conflicts.add("mapper [" + name() + "] has different [store_term_vector] values").     }     if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {         conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values").     }     if (storeTermVectorPositions() != other.storeTermVectorPositions()) {         conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values").     }     if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {         conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values").     }     // null and "default"-named index analyzers both mean the default is used     if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {         if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {             conflicts.add("mapper [" + name() + "] has different [analyzer]").         }     } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {         conflicts.add("mapper [" + name() + "] has different [analyzer]").     } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {         conflicts.add("mapper [" + name() + "] has different [analyzer]").     }     if (Objects.equals(similarity(), other.similarity()) == false) {         conflicts.add("mapper [" + name() + "] has different [similarity]").     } }
false;public;0;3;;public String name() {     return name. }
false;public;1;4;;public void setName(String name) {     checkIfFrozen().     this.name = name. }
false;public;0;3;;public float boost() {     return boost. }
false;public;1;4;;public void setBoost(float boost) {     checkIfFrozen().     this.boost = boost. }
false;public;0;3;;public boolean hasDocValues() {     return docValues. }
false;public;1;4;;public void setHasDocValues(boolean hasDocValues) {     checkIfFrozen().     this.docValues = hasDocValues. }
false;public;0;3;;public NamedAnalyzer indexAnalyzer() {     return indexAnalyzer. }
false;public;1;4;;public void setIndexAnalyzer(NamedAnalyzer analyzer) {     checkIfFrozen().     this.indexAnalyzer = analyzer. }
false;public;0;3;;public NamedAnalyzer searchAnalyzer() {     return searchAnalyzer. }
false;public;1;4;;public void setSearchAnalyzer(NamedAnalyzer analyzer) {     checkIfFrozen().     this.searchAnalyzer = analyzer. }
false;public;0;3;;public NamedAnalyzer searchQuoteAnalyzer() {     return searchQuoteAnalyzer == null ? searchAnalyzer : searchQuoteAnalyzer. }
false;public;1;4;;public void setSearchQuoteAnalyzer(NamedAnalyzer analyzer) {     checkIfFrozen().     this.searchQuoteAnalyzer = analyzer. }
false;public;0;3;;public SimilarityProvider similarity() {     return similarity. }
false;public;1;4;;public void setSimilarity(SimilarityProvider similarity) {     checkIfFrozen().     this.similarity = similarity. }
true;public;0;3;/**  * Returns the value that should be added when JSON null is found, or null if no value should be added  */ ;/**  * Returns the value that should be added when JSON null is found, or null if no value should be added  */ public Object nullValue() {     return nullValue. }
true;public;0;3;/**  * Returns the null value stringified or null if there is no null value  */ ;/**  * Returns the null value stringified or null if there is no null value  */ public String nullValueAsString() {     return nullValueAsString. }
true;public;1;5;/**  * Sets the null value and initializes the string version  */ ;/**  * Sets the null value and initializes the string version  */ public void setNullValue(Object nullValue) {     checkIfFrozen().     this.nullValue = nullValue.     this.nullValueAsString = nullValue == null ? null : nullValue.toString(). }
true;public;1;3;/**  * Given a value that comes from the stored fields API, convert it to the  *  expected type. For instance a date field would store dates as longs and  *  format it back to a string in this method.  */ ;/**  * Given a value that comes from the stored fields API, convert it to the  *  expected type. For instance a date field would store dates as longs and  *  format it back to a string in this method.  */ public Object valueForDisplay(Object value) {     return value. }
true;public;0;3;/**  * Returns true if the field is searchable.  */ ;/**  * Returns true if the field is searchable.  */ public boolean isSearchable() {     return indexOptions() != IndexOptions.NONE. }
true;public;0;8;/**  * Returns true if the field is aggregatable.  */ ;/**  * Returns true if the field is aggregatable.  */ public boolean isAggregatable() {     try {         fielddataBuilder("").         return true.     } catch (IllegalArgumentException e) {         return false.     } }
true;public,abstract;2;1;// TODO: Standardize exception types ;/**  * Generates a query that will only match documents that contain the given value.  *  The default implementation returns a {@link TermQuery} over the value bytes,  *  boosted by {@link #boost()}.  *  @throws IllegalArgumentException if {@code value} cannot be converted to the expected data type or if the field is not searchable  *      due to the way it is configured (eg. not indexed)  *  @throws ElasticsearchParseException if {@code value} cannot be converted to the expected data type  *  @throws UnsupportedOperationException if the field is not searchable regardless of options  *  @throws QueryShardException if the field is not searchable regardless of options  */ // TODO: Standardize exception types public abstract Query termQuery(Object value, @Nullable QueryShardContext context).
true;public;2;7;/**  * Build a constant-scoring query that matches all values. The default implementation uses a  * {@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses  * are generated with {@link #termQuery}.  */ ;/**  * Build a constant-scoring query that matches all values. The default implementation uses a  * {@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses  * are generated with {@link #termQuery}.  */ public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {     BooleanQuery.Builder builder = new BooleanQuery.Builder().     for (Object value : values) {         builder.add(termQuery(value, context), Occur.SHOULD).     }     return new ConstantScoreQuery(builder.build()). }
true;public;8;7;/**  * Factory method for range queries.  * @param relation the relation, nulls should be interpreted like INTERSECTS  */ ;/**  * Factory method for range queries.  * @param relation the relation, nulls should be interpreted like INTERSECTS  */ public Query rangeQuery(Object lowerTerm, Object upperTerm, boolean includeLower, boolean includeUpper, ShapeRelation relation, ZoneId timeZone, DateMathParser parser, QueryShardContext context) {     throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries"). }
false;public;5;4;;public Query fuzzyQuery(Object value, Fuzziness fuzziness, int prefixLength, int maxExpansions, boolean transpositions) {     throw new IllegalArgumentException("Can only use fuzzy queries on keyword and text fields - not on [" + name + "] which is of type [" + typeName() + "]"). }
false;public;3;4;;public Query prefixQuery(String value, @Nullable MultiTermQuery.RewriteMethod method, QueryShardContext context) {     throw new QueryShardException(context, "Can only use prefix queries on keyword and text fields - not on [" + name + "] which is of type [" + typeName() + "]"). }
false;public;3;6;;public Query wildcardQuery(String value, @Nullable MultiTermQuery.RewriteMethod method, QueryShardContext context) {     throw new QueryShardException(context, "Can only use wildcard queries on keyword and text fields - not on [" + name + "] which is of type [" + typeName() + "]"). }
false;public;5;5;;public Query regexpQuery(String value, int flags, int maxDeterminizedStates, @Nullable MultiTermQuery.RewriteMethod method, QueryShardContext context) {     throw new QueryShardException(context, "Can only use regexp queries on keyword and text fields - not on [" + name + "] which is of type [" + typeName() + "]"). }
false;public,abstract;1;1;;public abstract Query existsQuery(QueryShardContext context).
false;public;3;4;;public Query phraseQuery(TokenStream stream, int slop, boolean enablePositionIncrements) throws IOException {     throw new IllegalArgumentException("Can only use phrase queries on text fields - not on [" + name + "] which is of type [" + typeName() + "]"). }
false;public;3;4;;public Query multiPhraseQuery(TokenStream stream, int slop, boolean enablePositionIncrements) throws IOException {     throw new IllegalArgumentException("Can only use phrase queries on text fields - not on [" + name + "] which is of type [" + typeName() + "]"). }
false;public;3;4;;public Query phrasePrefixQuery(TokenStream stream, int slop, int maxExpansions) throws IOException {     throw new IllegalArgumentException("Can only use phrase prefix queries on text fields - not on [" + name + "] which is of type [" + typeName() + "]"). }
false;public;3;4;;public SpanQuery spanPrefixQuery(String value, SpanMultiTermQueryWrapper.SpanRewriteMethod method, QueryShardContext context) {     throw new IllegalArgumentException("Can only use span prefix queries on text fields - not on [" + name + "] which is of type [" + typeName() + "]"). }
true;public;4;4;/**  * Create an {@link IntervalsSource} to be used for proximity queries  */ ;/**  * Create an {@link IntervalsSource} to be used for proximity queries  */ public IntervalsSource intervals(String query, int max_gaps, boolean ordered, NamedAnalyzer analyzer) throws IOException {     throw new IllegalArgumentException("Can only use interval queries on text fields - not on [" + name + "] which is of type [" + typeName() + "]"). }
true;public;8;7;/**  * Return whether all values of the given {@link IndexReader} are within the range,  *  outside the range or cross the range. The default implementation returns  *  {@link Relation#INTERSECTS}, which is always fine to return when there is  *  no way to check whether values are actually within bounds.  */ ;/**  * Return whether all values of the given {@link IndexReader} are within the range,  *  outside the range or cross the range. The default implementation returns  *  {@link Relation#INTERSECTS}, which is always fine to return when there is  *  no way to check whether values are actually within bounds.  */ public Relation isFieldWithinQuery(IndexReader reader, Object from, Object to, boolean includeLower, boolean includeUpper, ZoneId timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {     return Relation.INTERSECTS. }
true;protected,final;0;7;/**  * @throws IllegalArgumentException if the fielddata is not supported on this type.  *  An IllegalArgumentException is needed in order to return an http error 400  *  when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}  */ ;/**  * @throws IllegalArgumentException if the fielddata is not supported on this type.  *  An IllegalArgumentException is needed in order to return an http error 400  *  when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}  */ protected final void failIfNoDocValues() {     if (hasDocValues() == false) {         throw new IllegalArgumentException("Can't load fielddata on [" + name() + "] because fielddata is unsupported on fields of type [" + typeName() + "]. Use doc values instead.").     } }
false;protected,final;0;6;;protected final void failIfNotIndexed() {     if (indexOptions() == IndexOptions.NONE && pointDataDimensionCount() == 0) {         // we throw an IAE rather than an ISE so that it translates to a 4xx code rather than 5xx code on the http layer         throw new IllegalArgumentException("Cannot search on field [" + name() + "] since it is not indexed.").     } }
false;public;0;3;;public boolean eagerGlobalOrdinals() {     return eagerGlobalOrdinals. }
false;public;1;4;;public void setEagerGlobalOrdinals(boolean eagerGlobalOrdinals) {     checkIfFrozen().     this.eagerGlobalOrdinals = eagerGlobalOrdinals. }
true;public;2;9;/**  * Return a {@link DocValueFormat} that can be used to display and parse  *  values as returned by the fielddata API.  *  The default implementation returns a {@link DocValueFormat#RAW}.  */ ;/**  * Return a {@link DocValueFormat} that can be used to display and parse  *  values as returned by the fielddata API.  *  The default implementation returns a {@link DocValueFormat#RAW}.  */ public DocValueFormat docValueFormat(@Nullable String format, ZoneId timeZone) {     if (format != null) {         throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats").     }     if (timeZone != null) {         throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones").     }     return DocValueFormat.RAW. }
true;public,static;1;23;/**  * Extract a {@link Term} from a query created with {@link #termQuery} by  * recursively removing {@link BoostQuery} wrappers.  * @throws IllegalArgumentException if the wrapped query is not a {@link TermQuery}  */ ;/**  * Extract a {@link Term} from a query created with {@link #termQuery} by  * recursively removing {@link BoostQuery} wrappers.  * @throws IllegalArgumentException if the wrapped query is not a {@link TermQuery}  */ public static Term extractTerm(Query termQuery) {     while (termQuery instanceof BoostQuery) {         termQuery = ((BoostQuery) termQuery).getQuery().     }     if (termQuery instanceof TypeFieldMapper.TypesQuery) {         assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1.         return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0]).     }     if (termQuery instanceof TermInSetQuery) {         TermInSetQuery tisQuery = (TermInSetQuery) termQuery.         PrefixCodedTerms terms = tisQuery.getTermData().         if (terms.size() == 1) {             TermIterator it = terms.iterator().             BytesRef term = it.next().             return new Term(it.field(), term).         }     }     if (termQuery instanceof TermQuery == false) {         throw new IllegalArgumentException("Cannot extract a term from a query of type " + termQuery.getClass() + ": " + termQuery).     }     return ((TermQuery) termQuery).getTerm(). }
