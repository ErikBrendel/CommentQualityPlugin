# id;timestamp;commentText;codeText;commentWords;codeWords
MappedFieldType -> public Object nullValue();1524684173;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1525334055;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1527840262;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1528103657;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1528706846;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1528762805;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1535046779;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1536828374;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1538067637;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1541008027;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1541501723;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1544800440;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1547734228;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public Object nullValue();1548236405;Returns the value that should be added when JSON null is found, or null if no value should be added;public Object nullValue() {_        return nullValue__    };returns,the,value,that,should,be,added,when,json,null,is,found,or,null,if,no,value,should,be,added;public,object,null,value,return,null,value
MappedFieldType -> public String nullValueAsString();1524684173;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1525334055;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1527840262;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1528103657;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1528706846;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1528762805;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1535046779;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1536828374;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1538067637;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1541008027;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1541501723;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1544800440;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1547734228;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public String nullValueAsString();1548236405;Returns the null value stringified or null if there is no null value;public String nullValueAsString() {_        return nullValueAsString__    };returns,the,null,value,stringified,or,null,if,there,is,no,null,value;public,string,null,value,as,string,return,null,value,as,string
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1524684173;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1525334055;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1527840262;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1528103657;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1528706846;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1528762805;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1535046779;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1536828374;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1538067637;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1541008027;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1541501723;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1544800440;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone);1547734228;Return a {@link DocValueFormat} that can be used to display and parse_values as returned by the fielddata API._The default implementation returns a {@link DocValueFormat#RAW}.;public DocValueFormat docValueFormat(@Nullable String format, DateTimeZone timeZone) {_        if (format != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom formats")__        }_        if (timeZone != null) {_            throw new IllegalArgumentException("Field [" + name() + "] of type [" + typeName() + "] does not support custom time zones")__        }_        return DocValueFormat.RAW__    };return,a,link,doc,value,format,that,can,be,used,to,display,and,parse,values,as,returned,by,the,fielddata,api,the,default,implementation,returns,a,link,doc,value,format,raw;public,doc,value,format,doc,value,format,nullable,string,format,date,time,zone,time,zone,if,format,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,formats,if,time,zone,null,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,custom,time,zones,return,doc,value,format,raw
MappedFieldType -> public IntervalsSource intervals(String query, int max_gaps, boolean ordered, NamedAnalyzer analyzer) throws IOException;1544800440;Create an {@link IntervalsSource} to be used for proximity queries;public IntervalsSource intervals(String query, int max_gaps, boolean ordered, NamedAnalyzer analyzer) throws IOException {_        throw new IllegalArgumentException("Can only use interval queries on text fields - not on [" + name_            + "] which is of type [" + typeName() + "]")__    };create,an,link,intervals,source,to,be,used,for,proximity,queries;public,intervals,source,intervals,string,query,int,boolean,ordered,named,analyzer,analyzer,throws,ioexception,throw,new,illegal,argument,exception,can,only,use,interval,queries,on,text,fields,not,on,name,which,is,of,type,type,name
MappedFieldType -> public IntervalsSource intervals(String query, int max_gaps, boolean ordered, NamedAnalyzer analyzer) throws IOException;1547734228;Create an {@link IntervalsSource} to be used for proximity queries;public IntervalsSource intervals(String query, int max_gaps, boolean ordered, NamedAnalyzer analyzer) throws IOException {_        throw new IllegalArgumentException("Can only use interval queries on text fields - not on [" + name_            + "] which is of type [" + typeName() + "]")__    };create,an,link,intervals,source,to,be,used,for,proximity,queries;public,intervals,source,intervals,string,query,int,boolean,ordered,named,analyzer,analyzer,throws,ioexception,throw,new,illegal,argument,exception,can,only,use,interval,queries,on,text,fields,not,on,name,which,is,of,type,type,name
MappedFieldType -> public IntervalsSource intervals(String query, int max_gaps, boolean ordered, NamedAnalyzer analyzer) throws IOException;1548236405;Create an {@link IntervalsSource} to be used for proximity queries;public IntervalsSource intervals(String query, int max_gaps, boolean ordered, NamedAnalyzer analyzer) throws IOException {_        throw new IllegalArgumentException("Can only use interval queries on text fields - not on [" + name_            + "] which is of type [" + typeName() + "]")__    };create,an,link,intervals,source,to,be,used,for,proximity,queries;public,intervals,source,intervals,string,query,int,boolean,ordered,named,analyzer,analyzer,throws,ioexception,throw,new,illegal,argument,exception,can,only,use,interval,queries,on,text,fields,not,on,name,which,is,of,type,type,name
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1524684173;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed || tokenized() != other.tokenized()) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,tokenized,other,tokenized,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1525334055;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed || tokenized() != other.tokenized()) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,tokenized,other,tokenized,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1527840262;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed || tokenized() != other.tokenized()) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,tokenized,other,tokenized,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1528103657;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed || tokenized() != other.tokenized()) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,tokenized,other,tokenized,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1528706846;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1528762805;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1535046779;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1536828374;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1538067637;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1541008027;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1541501723;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1544800440;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1547734228;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public void checkCompatibility(MappedFieldType other, List<String> conflicts);1548236405;Checks for any conflicts between this field type and other._If strict is true, all properties must be equal._Otherwise, only properties which must never change in an index are checked.;public void checkCompatibility(MappedFieldType other, List<String> conflicts) {_        checkTypeName(other)___        boolean indexed =  indexOptions() != IndexOptions.NONE__        boolean mergeWithIndexed = other.indexOptions() != IndexOptions.NONE__        _        if (indexed != mergeWithIndexed) {_            conflicts.add("mapper [" + name() + "] has different [index] values")__        }_        if (stored() != other.stored()) {_            conflicts.add("mapper [" + name() + "] has different [store] values")__        }_        if (hasDocValues() != other.hasDocValues()) {_            conflicts.add("mapper [" + name() + "] has different [doc_values] values")__        }_        if (omitNorms() && !other.omitNorms()) {_            conflicts.add("mapper [" + name() + "] has different [norms] values, cannot change from disable to enabled")__        }_        if (storeTermVectors() != other.storeTermVectors()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector] values")__        }_        if (storeTermVectorOffsets() != other.storeTermVectorOffsets()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_offsets] values")__        }_        if (storeTermVectorPositions() != other.storeTermVectorPositions()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_positions] values")__        }_        if (storeTermVectorPayloads() != other.storeTermVectorPayloads()) {_            conflicts.add("mapper [" + name() + "] has different [store_term_vector_payloads] values")__        }__        _        if (indexAnalyzer() == null || "default".equals(indexAnalyzer().name())) {_            if (other.indexAnalyzer() != null && "default".equals(other.indexAnalyzer().name()) == false) {_                conflicts.add("mapper [" + name() + "] has different [analyzer]")__            }_        } else if (other.indexAnalyzer() == null || "default".equals(other.indexAnalyzer().name())) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        } else if (indexAnalyzer().name().equals(other.indexAnalyzer().name()) == false) {_            conflicts.add("mapper [" + name() + "] has different [analyzer]")__        }__        if (Objects.equals(similarity(), other.similarity()) == false) {_            conflicts.add("mapper [" + name() + "] has different [similarity]")__        }_    };checks,for,any,conflicts,between,this,field,type,and,other,if,strict,is,true,all,properties,must,be,equal,otherwise,only,properties,which,must,never,change,in,an,index,are,checked;public,void,check,compatibility,mapped,field,type,other,list,string,conflicts,check,type,name,other,boolean,indexed,index,options,index,options,none,boolean,merge,with,indexed,other,index,options,index,options,none,if,indexed,merge,with,indexed,conflicts,add,mapper,name,has,different,index,values,if,stored,other,stored,conflicts,add,mapper,name,has,different,store,values,if,has,doc,values,other,has,doc,values,conflicts,add,mapper,name,has,different,values,if,omit,norms,other,omit,norms,conflicts,add,mapper,name,has,different,norms,values,cannot,change,from,disable,to,enabled,if,store,term,vectors,other,store,term,vectors,conflicts,add,mapper,name,has,different,values,if,store,term,vector,offsets,other,store,term,vector,offsets,conflicts,add,mapper,name,has,different,values,if,store,term,vector,positions,other,store,term,vector,positions,conflicts,add,mapper,name,has,different,values,if,store,term,vector,payloads,other,store,term,vector,payloads,conflicts,add,mapper,name,has,different,values,if,index,analyzer,null,default,equals,index,analyzer,name,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,else,if,other,index,analyzer,null,default,equals,other,index,analyzer,name,conflicts,add,mapper,name,has,different,analyzer,else,if,index,analyzer,name,equals,other,index,analyzer,name,false,conflicts,add,mapper,name,has,different,analyzer,if,objects,equals,similarity,other,similarity,false,conflicts,add,mapper,name,has,different,similarity
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1524684173;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1525334055;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1527840262;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1528103657;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1528706846;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1528762805;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1535046779;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1536828374;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1538067637;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1541008027;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1541501723;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1544800440;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query rangeQuery(             Object lowerTerm, Object upperTerm,             boolean includeLower, boolean includeUpper,             ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,             QueryShardContext context);1547734228;Factory method for range queries._@param relation the relation, nulls should be interpreted like INTERSECTS;public Query rangeQuery(_            Object lowerTerm, Object upperTerm,_            boolean includeLower, boolean includeUpper,_            ShapeRelation relation, DateTimeZone timeZone, DateMathParser parser,_            QueryShardContext context) {_        throw new IllegalArgumentException("Field [" + name + "] of type [" + typeName() + "] does not support range queries")__    };factory,method,for,range,queries,param,relation,the,relation,nulls,should,be,interpreted,like,intersects;public,query,range,query,object,lower,term,object,upper,term,boolean,include,lower,boolean,include,upper,shape,relation,relation,date,time,zone,time,zone,date,math,parser,parser,query,shard,context,context,throw,new,illegal,argument,exception,field,name,of,type,type,name,does,not,support,range,queries
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1524684173;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1525334055;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1527840262;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1528103657;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1528706846;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1528762805;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1535046779;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1536828374;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1538067637;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1541008027;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1541501723;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1544800440;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1547734228;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public Query termsQuery(List<?> values, @Nullable QueryShardContext context);1548236405;Build a constant-scoring query that matches all values. The default implementation uses a_{@link ConstantScoreQuery} around a {@link BooleanQuery} whose {@link Occur#SHOULD} clauses_are generated with {@link #termQuery}.;public Query termsQuery(List<?> values, @Nullable QueryShardContext context) {_        BooleanQuery.Builder builder = new BooleanQuery.Builder()__        for (Object value : values) {_            builder.add(termQuery(value, context), Occur.SHOULD)__        }_        return new ConstantScoreQuery(builder.build())__    };build,a,constant,scoring,query,that,matches,all,values,the,default,implementation,uses,a,link,constant,score,query,around,a,link,boolean,query,whose,link,occur,should,clauses,are,generated,with,link,term,query;public,query,terms,query,list,values,nullable,query,shard,context,context,boolean,query,builder,builder,new,boolean,query,builder,for,object,value,values,builder,add,term,query,value,context,occur,should,return,new,constant,score,query,builder,build
MappedFieldType -> public boolean isAggregatable();1524684173;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1525334055;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1527840262;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1528103657;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1528706846;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1528762805;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1535046779;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1536828374;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1538067637;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1541008027;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1541501723;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1544800440;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1547734228;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public boolean isAggregatable();1548236405;Returns true if the field is aggregatable.;public boolean isAggregatable() {_        try {_            fielddataBuilder("")__            return true__        } catch (IllegalArgumentException e) {_            return false__        }_    };returns,true,if,the,field,is,aggregatable;public,boolean,is,aggregatable,try,fielddata,builder,return,true,catch,illegal,argument,exception,e,return,false
MappedFieldType -> public abstract String typeName()_;1524684173;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1525334055;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1527840262;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1528103657;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1528706846;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1528762805;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1535046779;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1536828374;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1538067637;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1541008027;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1541501723;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1544800440;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1547734228;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public abstract String typeName()_;1548236405;Returns the name of this type, as would be specified in mapping properties;public abstract String typeName()_;returns,the,name,of,this,type,as,would,be,specified,in,mapping,properties;public,abstract,string,type,name
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1524684173;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1525334055;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1527840262;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1528103657;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1528706846;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1528762805;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1535046779;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1536828374;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1538067637;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1541008027;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1541501723;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1544800440;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> public Relation isFieldWithinQuery(         IndexReader reader,         Object from, Object to,         boolean includeLower, boolean includeUpper,         DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException;1547734228;Return whether all values of the given {@link IndexReader} are within the range,_outside the range or cross the range. The default implementation returns_{@link Relation#INTERSECTS}, which is always fine to return when there is_no way to check whether values are actually within bounds.;public Relation isFieldWithinQuery(_        IndexReader reader,_        Object from, Object to,_        boolean includeLower, boolean includeUpper,_        DateTimeZone timeZone, DateMathParser dateMathParser, QueryRewriteContext context) throws IOException {_        return Relation.INTERSECTS__    };return,whether,all,values,of,the,given,link,index,reader,are,within,the,range,outside,the,range,or,cross,the,range,the,default,implementation,returns,link,relation,intersects,which,is,always,fine,to,return,when,there,is,no,way,to,check,whether,values,are,actually,within,bounds;public,relation,is,field,within,query,index,reader,reader,object,from,object,to,boolean,include,lower,boolean,include,upper,date,time,zone,time,zone,date,math,parser,date,math,parser,query,rewrite,context,context,throws,ioexception,return,relation,intersects
MappedFieldType -> private void checkTypeName(MappedFieldType other);1524684173;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and " + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1525334055;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and " + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1527840262;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and " + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1528103657;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and " + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1528706846;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and " + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1528762805;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and " + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1535046779;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and " + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1536828374;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and " + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1538067637;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName() + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and " + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1541008027;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName()_                + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and "_                + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1541501723;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName()_                + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and "_                + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1544800440;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName()_                + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and "_                + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1547734228;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName()_                + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and "_                + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> private void checkTypeName(MappedFieldType other);1548236405;Checks this type is the same type as other. Adds a conflict if they are different.;private void checkTypeName(MappedFieldType other) {_        if (typeName().equals(other.typeName()) == false) {_            throw new IllegalArgumentException("mapper [" + name + "] cannot be changed from type [" + typeName()_                + "] to [" + other.typeName() + "]")__        } else if (getClass() != other.getClass()) {_            throw new IllegalStateException("Type names equal for class " + getClass().getSimpleName() + " and "_                + other.getClass().getSimpleName())__        }_    };checks,this,type,is,the,same,type,as,other,adds,a,conflict,if,they,are,different;private,void,check,type,name,mapped,field,type,other,if,type,name,equals,other,type,name,false,throw,new,illegal,argument,exception,mapper,name,cannot,be,changed,from,type,type,name,to,other,type,name,else,if,get,class,other,get,class,throw,new,illegal,state,exception,type,names,equal,for,class,get,class,get,simple,name,and,other,get,class,get,simple,name
MappedFieldType -> public boolean isSearchable();1524684173;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1525334055;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1527840262;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1528103657;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1528706846;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1528762805;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1535046779;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1536828374;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1538067637;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1541008027;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1541501723;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1544800440;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1547734228;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> public boolean isSearchable();1548236405;Returns true if the field is searchable.;public boolean isSearchable() {_        return indexOptions() != IndexOptions.NONE__    };returns,true,if,the,field,is,searchable;public,boolean,is,searchable,return,index,options,index,options,none
MappedFieldType -> @Nullable     public Query queryStringTermQuery(Term term);1524684173;A term query to use when parsing a query string. Can return <tt>null</tt>.;@Nullable_    public Query queryStringTermQuery(Term term) {_        return null__    };a,term,query,to,use,when,parsing,a,query,string,can,return,tt,null,tt;nullable,public,query,query,string,term,query,term,term,return,null
MappedFieldType -> @Nullable     public Query queryStringTermQuery(Term term);1525334055;A term query to use when parsing a query string. Can return {@code null}.;@Nullable_    public Query queryStringTermQuery(Term term) {_        return null__    };a,term,query,to,use,when,parsing,a,query,string,can,return,code,null;nullable,public,query,query,string,term,query,term,term,return,null
MappedFieldType -> public static Term extractTerm(Query termQuery);1524684173;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1525334055;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1527840262;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1528103657;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1528706846;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1528762805;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1535046779;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1536828374;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1538067637;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1541008027;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1541501723;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1544800440;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1547734228;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> public static Term extractTerm(Query termQuery);1548236405;Extract a {@link Term} from a query created with {@link #termQuery} by_recursively removing {@link BoostQuery} wrappers._@throws IllegalArgumentException if the wrapped query is not a {@link TermQuery};public static Term extractTerm(Query termQuery) {_        while (termQuery instanceof BoostQuery) {_            termQuery = ((BoostQuery) termQuery).getQuery()__        }_        if (termQuery instanceof TypeFieldMapper.TypesQuery) {_            assert ((TypeFieldMapper.TypesQuery) termQuery).getTerms().length == 1__            return new Term(TypeFieldMapper.NAME, ((TypeFieldMapper.TypesQuery) termQuery).getTerms()[0])__        }_        if (termQuery instanceof TermInSetQuery) {_            TermInSetQuery tisQuery = (TermInSetQuery) termQuery__            PrefixCodedTerms terms = tisQuery.getTermData()__            if (terms.size() == 1) {_                TermIterator it = terms.iterator()__                BytesRef term = it.next()__                return new Term(it.field(), term)__            }_        }_        if (termQuery instanceof TermQuery == false) {_            throw new IllegalArgumentException("Cannot extract a term from a query of type "_                    + termQuery.getClass() + ": " + termQuery)__        }_        return ((TermQuery) termQuery).getTerm()__    };extract,a,link,term,from,a,query,created,with,link,term,query,by,recursively,removing,link,boost,query,wrappers,throws,illegal,argument,exception,if,the,wrapped,query,is,not,a,link,term,query;public,static,term,extract,term,query,term,query,while,term,query,instanceof,boost,query,term,query,boost,query,term,query,get,query,if,term,query,instanceof,type,field,mapper,types,query,assert,type,field,mapper,types,query,term,query,get,terms,length,1,return,new,term,type,field,mapper,name,type,field,mapper,types,query,term,query,get,terms,0,if,term,query,instanceof,term,in,set,query,term,in,set,query,tis,query,term,in,set,query,term,query,prefix,coded,terms,terms,tis,query,get,term,data,if,terms,size,1,term,iterator,it,terms,iterator,bytes,ref,term,it,next,return,new,term,it,field,term,if,term,query,instanceof,term,query,false,throw,new,illegal,argument,exception,cannot,extract,a,term,from,a,query,of,type,term,query,get,class,term,query,return,term,query,term,query,get,term
MappedFieldType -> protected final void failIfNoDocValues();1524684173;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1525334055;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1527840262;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1528103657;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1528706846;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1528762805;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1535046779;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1536828374;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1538067637;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1541008027;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1541501723;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1544800440;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1547734228;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> protected final void failIfNoDocValues();1548236405;@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status};protected final void failIfNoDocValues() {_        if (hasDocValues() == false) {_            throw new IllegalArgumentException("Can't load fielddata on [" + name()_                + "] because fielddata is unsupported on fields of type ["_                + typeName() + "]. Use doc values instead.")__        }_    };throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status;protected,final,void,fail,if,no,doc,values,if,has,doc,values,false,throw,new,illegal,argument,exception,can,t,load,fielddata,on,name,because,fielddata,is,unsupported,on,fields,of,type,type,name,use,doc,values,instead
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1524684173;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1525334055;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1527840262;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1528103657;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1528706846;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1528762805;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1535046779;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1536828374;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1538067637;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1541008027;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1541501723;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1544800440;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1547734228;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName);1548236405;Return a fielddata builder for this field_@throws IllegalArgumentException if the fielddata is not supported on this type._An IllegalArgumentException is needed in order to return an http error 400_when this error occurs in a request. see: {@link org.elasticsearch.ExceptionsHelper#status}__@param fullyQualifiedIndexName the name of the index this field-data is build for;public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {_        throw new IllegalArgumentException("Fielddata is not supported on field [" + name() + "] of type [" + typeName() + "]")__    };return,a,fielddata,builder,for,this,field,throws,illegal,argument,exception,if,the,fielddata,is,not,supported,on,this,type,an,illegal,argument,exception,is,needed,in,order,to,return,an,http,error,400,when,this,error,occurs,in,a,request,see,link,org,elasticsearch,exceptions,helper,status,param,fully,qualified,index,name,the,name,of,the,index,this,field,data,is,build,for;public,index,field,data,builder,fielddata,builder,string,fully,qualified,index,name,throw,new,illegal,argument,exception,fielddata,is,not,supported,on,field,name,of,type,type,name
MappedFieldType -> public void setNullValue(Object nullValue);1524684173;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1525334055;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1527840262;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1528103657;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1528706846;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1528762805;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1535046779;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1536828374;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1538067637;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1541008027;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1541501723;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1544800440;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1547734228;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public void setNullValue(Object nullValue);1548236405;Sets the null value and initializes the string version;public void setNullValue(Object nullValue) {_        checkIfFrozen()__        this.nullValue = nullValue__        this.nullValueAsString = nullValue == null ? null : nullValue.toString()__    };sets,the,null,value,and,initializes,the,string,version;public,void,set,null,value,object,null,value,check,if,frozen,this,null,value,null,value,this,null,value,as,string,null,value,null,null,null,value,to,string
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1524684173;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1525334055;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1527840262;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1528103657;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1528706846;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1528762805;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1535046779;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type or if the field is not searchable_due to the way it is configured (eg. not indexed)_@throws ElasticsearchParseException if {@code value} cannot be converted to the expected data type_@throws UnsupportedOperationException if the field is not searchable regardless of options_@throws QueryShardException if the field is not searchable regardless of options;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,or,if,the,field,is,not,searchable,due,to,the,way,it,is,configured,eg,not,indexed,throws,elasticsearch,parse,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,throws,unsupported,operation,exception,if,the,field,is,not,searchable,regardless,of,options,throws,query,shard,exception,if,the,field,is,not,searchable,regardless,of,options;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1536828374;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type or if the field is not searchable_due to the way it is configured (eg. not indexed)_@throws ElasticsearchParseException if {@code value} cannot be converted to the expected data type_@throws UnsupportedOperationException if the field is not searchable regardless of options_@throws QueryShardException if the field is not searchable regardless of options;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,or,if,the,field,is,not,searchable,due,to,the,way,it,is,configured,eg,not,indexed,throws,elasticsearch,parse,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,throws,unsupported,operation,exception,if,the,field,is,not,searchable,regardless,of,options,throws,query,shard,exception,if,the,field,is,not,searchable,regardless,of,options;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1538067637;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type or if the field is not searchable_due to the way it is configured (eg. not indexed)_@throws ElasticsearchParseException if {@code value} cannot be converted to the expected data type_@throws UnsupportedOperationException if the field is not searchable regardless of options_@throws QueryShardException if the field is not searchable regardless of options;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,or,if,the,field,is,not,searchable,due,to,the,way,it,is,configured,eg,not,indexed,throws,elasticsearch,parse,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,throws,unsupported,operation,exception,if,the,field,is,not,searchable,regardless,of,options,throws,query,shard,exception,if,the,field,is,not,searchable,regardless,of,options;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1541008027;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type or if the field is not searchable_due to the way it is configured (eg. not indexed)_@throws ElasticsearchParseException if {@code value} cannot be converted to the expected data type_@throws UnsupportedOperationException if the field is not searchable regardless of options_@throws QueryShardException if the field is not searchable regardless of options;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,or,if,the,field,is,not,searchable,due,to,the,way,it,is,configured,eg,not,indexed,throws,elasticsearch,parse,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,throws,unsupported,operation,exception,if,the,field,is,not,searchable,regardless,of,options,throws,query,shard,exception,if,the,field,is,not,searchable,regardless,of,options;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1541501723;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type or if the field is not searchable_due to the way it is configured (eg. not indexed)_@throws ElasticsearchParseException if {@code value} cannot be converted to the expected data type_@throws UnsupportedOperationException if the field is not searchable regardless of options_@throws QueryShardException if the field is not searchable regardless of options;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,or,if,the,field,is,not,searchable,due,to,the,way,it,is,configured,eg,not,indexed,throws,elasticsearch,parse,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,throws,unsupported,operation,exception,if,the,field,is,not,searchable,regardless,of,options,throws,query,shard,exception,if,the,field,is,not,searchable,regardless,of,options;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1544800440;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type or if the field is not searchable_due to the way it is configured (eg. not indexed)_@throws ElasticsearchParseException if {@code value} cannot be converted to the expected data type_@throws UnsupportedOperationException if the field is not searchable regardless of options_@throws QueryShardException if the field is not searchable regardless of options;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,or,if,the,field,is,not,searchable,due,to,the,way,it,is,configured,eg,not,indexed,throws,elasticsearch,parse,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,throws,unsupported,operation,exception,if,the,field,is,not,searchable,regardless,of,options,throws,query,shard,exception,if,the,field,is,not,searchable,regardless,of,options;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1547734228;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type or if the field is not searchable_due to the way it is configured (eg. not indexed)_@throws ElasticsearchParseException if {@code value} cannot be converted to the expected data type_@throws UnsupportedOperationException if the field is not searchable regardless of options_@throws QueryShardException if the field is not searchable regardless of options;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,or,if,the,field,is,not,searchable,due,to,the,way,it,is,configured,eg,not,indexed,throws,elasticsearch,parse,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,throws,unsupported,operation,exception,if,the,field,is,not,searchable,regardless,of,options,throws,query,shard,exception,if,the,field,is,not,searchable,regardless,of,options;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;1548236405;Generates a query that will only match documents that contain the given value._The default implementation returns a {@link TermQuery} over the value bytes,_boosted by {@link #boost()}._@throws IllegalArgumentException if {@code value} cannot be converted to the expected data type or if the field is not searchable_due to the way it is configured (eg. not indexed)_@throws ElasticsearchParseException if {@code value} cannot be converted to the expected data type_@throws UnsupportedOperationException if the field is not searchable regardless of options_@throws QueryShardException if the field is not searchable regardless of options;public abstract Query termQuery(Object value, @Nullable QueryShardContext context)_;generates,a,query,that,will,only,match,documents,that,contain,the,given,value,the,default,implementation,returns,a,link,term,query,over,the,value,bytes,boosted,by,link,boost,throws,illegal,argument,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,or,if,the,field,is,not,searchable,due,to,the,way,it,is,configured,eg,not,indexed,throws,elasticsearch,parse,exception,if,code,value,cannot,be,converted,to,the,expected,data,type,throws,unsupported,operation,exception,if,the,field,is,not,searchable,regardless,of,options,throws,query,shard,exception,if,the,field,is,not,searchable,regardless,of,options;public,abstract,query,term,query,object,value,nullable,query,shard,context,context
MappedFieldType -> public Object valueForDisplay(Object value);1524684173;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1525334055;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1527840262;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1528103657;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1528706846;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1528762805;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1535046779;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1536828374;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1538067637;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1541008027;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1541501723;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1544800440;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1547734228;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
MappedFieldType -> public Object valueForDisplay(Object value);1548236405;Given a value that comes from the stored fields API, convert it to the_expected type. For instance a date field would store dates as longs and_format it back to a string in this method.;public Object valueForDisplay(Object value) {_        return value__    };given,a,value,that,comes,from,the,stored,fields,api,convert,it,to,the,expected,type,for,instance,a,date,field,would,store,dates,as,longs,and,format,it,back,to,a,string,in,this,method;public,object,value,for,display,object,value,return,value
