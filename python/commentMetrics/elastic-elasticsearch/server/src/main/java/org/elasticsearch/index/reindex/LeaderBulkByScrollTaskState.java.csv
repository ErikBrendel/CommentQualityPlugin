commented;modifiers;parameterAmount;loc;comment;code
true;public;0;3;/**  * Returns the number of slices this BulkByScrollRequest will use  */ ;/**  * Returns the number of slices this BulkByScrollRequest will use  */ public int getSlices() {     return slices. }
true;public;1;8;/**  * Get the combined statuses of slice subtasks, merged with the given list of statuses  */ ;/**  * Get the combined statuses of slice subtasks, merged with the given list of statuses  */ public BulkByScrollTask.Status getStatus(List<BulkByScrollTask.StatusOrException> statuses) {     // We only have access to the statuses of requests that have finished so we return them     if (statuses.size() != results.length()) {         throw new IllegalArgumentException("Given number of statuses does not match amount of expected results").     }     addResultsToList(statuses).     return new BulkByScrollTask.Status(unmodifiableList(statuses), task.getReasonCancelled()). }
true;public;0;3;/**  * Get the combined statuses of sliced subtasks  */ ;/**  * Get the combined statuses of sliced subtasks  */ public BulkByScrollTask.Status getStatus() {     return getStatus(Arrays.asList(new BulkByScrollTask.StatusOrException[results.length()])). }
true;public;0;3;/**  * The number of sliced subtasks that are still running  */ ;/**  * The number of sliced subtasks that are still running  */ public int runningSliceSubTasks() {     return runningSubtasks.get(). }
false;private;1;9;;private void addResultsToList(List<BulkByScrollTask.StatusOrException> sliceStatuses) {     for (Result t : results.asList()) {         if (t.response != null) {             sliceStatuses.set(t.sliceId, new BulkByScrollTask.StatusOrException(t.response.getStatus())).         } else {             sliceStatuses.set(t.sliceId, new BulkByScrollTask.StatusOrException(t.failure)).         }     } }
true;public;3;6;/**  * Record a response from a slice and respond to the listener if the request is finished.  */ ;/**  * Record a response from a slice and respond to the listener if the request is finished.  */ public void onSliceResponse(ActionListener<BulkByScrollResponse> listener, int sliceId, BulkByScrollResponse response) {     results.setOnce(sliceId, new Result(sliceId, response)).     /* If the request isn't finished we could automatically rethrottle the sub-requests here but we would only want to do that if we          * were fairly sure they had a while left to go. */     recordSliceCompletionAndRespondIfAllDone(listener). }
true;public;3;5;/**  * Record a failure from a slice and respond to the listener if the request is finished.  */ ;/**  * Record a failure from a slice and respond to the listener if the request is finished.  */ public void onSliceFailure(ActionListener<BulkByScrollResponse> listener, int sliceId, Exception e) {     results.setOnce(sliceId, new Result(sliceId, e)).     recordSliceCompletionAndRespondIfAllDone(listener). // TODO cancel when a slice fails? }
false;private;1;25;;private void recordSliceCompletionAndRespondIfAllDone(ActionListener<BulkByScrollResponse> listener) {     if (runningSubtasks.decrementAndGet() != 0) {         return.     }     List<BulkByScrollResponse> responses = new ArrayList<>(results.length()).     Exception exception = null.     for (Result t : results.asList()) {         if (t.response == null) {             assert t.failure != null : "exception shouldn't be null if value is null".             if (exception == null) {                 exception = t.failure.             } else {                 exception.addSuppressed(t.failure).             }         } else {             assert t.failure == null : "exception should be null if response is not null".             responses.add(t.response).         }     }     if (exception == null) {         listener.onResponse(new BulkByScrollResponse(responses, task.getReasonCancelled())).     } else {         listener.onFailure(exception).     } }
