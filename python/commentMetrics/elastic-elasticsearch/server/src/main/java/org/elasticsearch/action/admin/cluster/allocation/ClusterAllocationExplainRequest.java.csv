commented;modifiers;parameterAmount;loc;comment;code
false;public;1;10;;@Override public void writeTo(StreamOutput out) throws IOException {     super.writeTo(out).     out.writeOptionalString(index).     out.writeOptionalVInt(shard).     out.writeOptionalBoolean(primary).     out.writeOptionalString(currentNode).     out.writeBoolean(includeYesDecisions).     out.writeBoolean(includeDiskInfo). }
false;public;0;16;;@Override public ActionRequestValidationException validate() {     ActionRequestValidationException validationException = null.     if (this.useAnyUnassignedShard() == false) {         if (this.index == null) {             validationException = addValidationError("index must be specified", validationException).         }         if (this.shard == null) {             validationException = addValidationError("shard must be specified", validationException).         }         if (this.primary == null) {             validationException = addValidationError("primary must be specified", validationException).         }     }     return validationException. }
true;public;0;3;/**  * Returns {@code true} iff the first unassigned shard is to be used  */ ;/**  * Returns {@code true} iff the first unassigned shard is to be used  */ public boolean useAnyUnassignedShard() {     return this.index == null && this.shard == null && this.primary == null && this.currentNode == null. }
true;public;1;4;/**  * Sets the index name of the shard to explain.  */ ;/**  * Sets the index name of the shard to explain.  */ public ClusterAllocationExplainRequest setIndex(String index) {     this.index = index.     return this. }
true;public;0;4;/**  * Returns the index name of the shard to explain, or {@code null} to use any unassigned shard (see {@link #useAnyUnassignedShard()}).  */ ;/**  * Returns the index name of the shard to explain, or {@code null} to use any unassigned shard (see {@link #useAnyUnassignedShard()}).  */ @Nullable public String getIndex() {     return this.index. }
true;public;1;4;/**  * Sets the shard id of the shard to explain.  */ ;/**  * Sets the shard id of the shard to explain.  */ public ClusterAllocationExplainRequest setShard(Integer shard) {     this.shard = shard.     return this. }
true;public;0;4;/**  * Returns the shard id of the shard to explain, or {@code null} to use any unassigned shard (see {@link #useAnyUnassignedShard()}).  */ ;/**  * Returns the shard id of the shard to explain, or {@code null} to use any unassigned shard (see {@link #useAnyUnassignedShard()}).  */ @Nullable public Integer getShard() {     return this.shard. }
true;public;1;4;/**  * Sets whether to explain the allocation of the primary shard or a replica shard copy  * for the shard id (see {@link #getShard()}).  */ ;/**  * Sets whether to explain the allocation of the primary shard or a replica shard copy  * for the shard id (see {@link #getShard()}).  */ public ClusterAllocationExplainRequest setPrimary(Boolean primary) {     this.primary = primary.     return this. }
true;public;0;4;/**  * Returns {@code true} if explaining the primary shard for the shard id (see {@link #getShard()}),  * {@code false} if explaining a replica shard copy for the shard id, or {@code null} to use any  * unassigned shard (see {@link #useAnyUnassignedShard()}).  */ ;/**  * Returns {@code true} if explaining the primary shard for the shard id (see {@link #getShard()}),  * {@code false} if explaining a replica shard copy for the shard id, or {@code null} to use any  * unassigned shard (see {@link #useAnyUnassignedShard()}).  */ @Nullable public Boolean isPrimary() {     return this.primary. }
true;public;1;4;/**  * Requests the explain API to explain an already assigned replica shard currently allocated to  * the given node.  */ ;/**  * Requests the explain API to explain an already assigned replica shard currently allocated to  * the given node.  */ public ClusterAllocationExplainRequest setCurrentNode(String currentNodeId) {     this.currentNode = currentNodeId.     return this. }
true;public;0;4;/**  * Returns the node holding the replica shard to be explained.  Returns {@code null} if any replica shard  * can be explained.  */ ;/**  * Returns the node holding the replica shard to be explained.  Returns {@code null} if any replica shard  * can be explained.  */ @Nullable public String getCurrentNode() {     return currentNode. }
true;public;1;3;/**  * Set to {@code true} to include yes decisions for a particular node.  */ ;/**  * Set to {@code true} to include yes decisions for a particular node.  */ public void includeYesDecisions(boolean includeYesDecisions) {     this.includeYesDecisions = includeYesDecisions. }
true;public;0;3;/**  * Returns {@code true} if yes decisions should be included.  Otherwise only "no" and "throttle"  * decisions are returned.  */ ;/**  * Returns {@code true} if yes decisions should be included.  Otherwise only "no" and "throttle"  * decisions are returned.  */ public boolean includeYesDecisions() {     return this.includeYesDecisions. }
true;public;1;3;/**  * Set to {@code true} to include information about the gathered disk information of nodes in the cluster.  */ ;/**  * Set to {@code true} to include information about the gathered disk information of nodes in the cluster.  */ public void includeDiskInfo(boolean includeDiskInfo) {     this.includeDiskInfo = includeDiskInfo. }
true;public;0;3;/**  * Returns {@code true} if information about disk usage and shard sizes should also be returned.  */ ;/**  * Returns {@code true} if information about disk usage and shard sizes should also be returned.  */ public boolean includeDiskInfo() {     return this.includeDiskInfo. }
false;public;0;16;;@Override public String toString() {     StringBuilder sb = new StringBuilder("ClusterAllocationExplainRequest[").     if (this.useAnyUnassignedShard()) {         sb.append("useAnyUnassignedShard=true").     } else {         sb.append("index=").append(index).         sb.append(",shard=").append(shard).         sb.append(",primary?=").append(primary).         if (currentNode != null) {             sb.append(",currentNode=").append(currentNode).         }     }     sb.append(",includeYesDecisions?=").append(includeYesDecisions).     return sb.toString(). }
false;public,static;1;3;;public static ClusterAllocationExplainRequest parse(XContentParser parser) throws IOException {     return PARSER.parse(parser, new ClusterAllocationExplainRequest(), null). }
false;public;1;4;;@Override public void readFrom(StreamInput in) throws IOException {     throw new UnsupportedOperationException("usage of Streamable is to be replaced by Writeable"). }
