commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;5;;@Override protected boolean resolveIndex(GetFieldMappingsIndexRequest request) {     // internal action, index already resolved     return false. }
false;protected;2;5;;@Override protected ShardsIterator shards(ClusterState state, InternalRequest request) {     // Will balance requests between shards     return state.routingTable().index(request.concreteIndex()).randomAllActiveShardsIt(). }
false;protected;2;33;;@Override protected GetFieldMappingsResponse shardOperation(final GetFieldMappingsIndexRequest request, ShardId shardId) {     assert shardId != null.     IndexService indexService = indicesService.indexServiceSafe(shardId.getIndex()).     Version indexCreatedVersion = indexService.mapperService().getIndexSettings().getIndexVersionCreated().     Predicate<String> metadataFieldPredicate = (f) -> indicesService.isMetaDataField(indexCreatedVersion, f).     Predicate<String> fieldPredicate = metadataFieldPredicate.or(indicesService.getFieldFilter().apply(shardId.getIndexName())).     DocumentMapper mapper = indexService.mapperService().documentMapper().     Collection<String> typeIntersection.     if (request.types().length == 0) {         typeIntersection = mapper == null ? Collections.emptySet() : Collections.singleton(mapper.type()).     } else {         typeIntersection = mapper != null && Regex.simpleMatch(request.types(), mapper.type()) ? Collections.singleton(mapper.type()) : Collections.emptySet().         if (typeIntersection.isEmpty()) {             throw new TypeMissingException(shardId.getIndex(), request.types()).         }     }     Map<String, Map<String, FieldMappingMetaData>> typeMappings = new HashMap<>().     for (String type : typeIntersection) {         DocumentMapper documentMapper = indexService.mapperService().documentMapper(type).         Map<String, FieldMappingMetaData> fieldMapping = findFieldMappingsByType(fieldPredicate, documentMapper, request).         if (!fieldMapping.isEmpty()) {             typeMappings.put(type, fieldMapping).         }     }     return new GetFieldMappingsResponse(singletonMap(shardId.getIndexName(), Collections.unmodifiableMap(typeMappings))). }
false;protected;0;4;;@Override protected GetFieldMappingsResponse newResponse() {     return new GetFieldMappingsResponse(). }
false;protected;2;4;;@Override protected ClusterBlockException checkRequestBlock(ClusterState state, InternalRequest request) {     return state.blocks().indexBlockedException(ClusterBlockLevel.METADATA_READ, request.concreteIndex()). }
false;public;1;7;;@Override public String param(String key) {     if (INCLUDE_DEFAULTS.equals(key)) {         return "true".     }     return null. }
false;public;2;7;;@Override public String param(String key, String defaultValue) {     if (INCLUDE_DEFAULTS.equals(key)) {         return "true".     }     return defaultValue. }
false;public;2;7;;@Override public boolean paramAsBoolean(String key, boolean defaultValue) {     if (INCLUDE_DEFAULTS.equals(key)) {         return true.     }     return defaultValue. }
false;public;2;7;;@Override public Boolean paramAsBoolean(String key, Boolean defaultValue) {     if (INCLUDE_DEFAULTS.equals(key)) {         return true.     }     return defaultValue. }
false;private,static;3;29;;private static Map<String, FieldMappingMetaData> findFieldMappingsByType(Predicate<String> fieldPredicate, DocumentMapper documentMapper, GetFieldMappingsIndexRequest request) {     Map<String, FieldMappingMetaData> fieldMappings = new HashMap<>().     final DocumentFieldMappers allFieldMappers = documentMapper.mappers().     for (String field : request.fields()) {         if (Regex.isMatchAllPattern(field)) {             for (Mapper fieldMapper : allFieldMappers) {                 addFieldMapper(fieldPredicate, fieldMapper.name(), fieldMapper, fieldMappings, request.includeDefaults()).             }         } else if (Regex.isSimpleMatchPattern(field)) {             for (Mapper fieldMapper : allFieldMappers) {                 if (Regex.simpleMatch(field, fieldMapper.name())) {                     addFieldMapper(fieldPredicate, fieldMapper.name(), fieldMapper, fieldMappings, request.includeDefaults()).                 }             }         } else {             // not a pattern             Mapper fieldMapper = allFieldMappers.getMapper(field).             if (fieldMapper != null) {                 addFieldMapper(fieldPredicate, field, fieldMapper, fieldMappings, request.includeDefaults()).             } else if (request.probablySingleFieldRequest()) {                 fieldMappings.put(field, FieldMappingMetaData.NULL).             }         }     }     return Collections.unmodifiableMap(fieldMappings). }
false;private,static;5;16;;private static void addFieldMapper(Predicate<String> fieldPredicate, String field, Mapper fieldMapper, Map<String, FieldMappingMetaData> fieldMappings, boolean includeDefaults) {     if (fieldMappings.containsKey(field)) {         return.     }     if (fieldPredicate.test(field)) {         try {             BytesReference bytes = XContentHelper.toXContent(fieldMapper, XContentType.JSON, includeDefaults ? includeDefaultsParams : ToXContent.EMPTY_PARAMS, false).             fieldMappings.put(field, new FieldMappingMetaData(fieldMapper.name(), bytes)).         } catch (IOException e) {             throw new ElasticsearchException("failed to serialize XContent of field [" + field + "]", e).         }     } }
