commented;modifiers;parameterAmount;loc;comment;code
false;public;0;4;;@Override public String getName() {     return "document_index_action". }
false;public;0;4;;@Override public String getName() {     return "document_create_action". }
false;public;2;6;;@Override public RestChannelConsumer prepareRequest(RestRequest request, final NodeClient client) throws IOException {     validateOpType(request.params().get("op_type")).     request.params().put("op_type", "create").     return RestIndexAction.this.prepareRequest(request, client). }
false;;1;5;;void validateOpType(String opType) {     if (null != opType && false == "create".equals(opType.toLowerCase(Locale.ROOT))) {         throw new IllegalArgumentException("opType must be 'create', found: [" + opType + "]").     } }
false;public;2;32;;@Override public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {     IndexRequest indexRequest.     final String type = request.param("type").     if (type != null && type.equals(MapperService.SINGLE_MAPPING_NAME) == false) {         deprecationLogger.deprecatedAndMaybeLog("index_with_types", TYPES_DEPRECATION_MESSAGE).         indexRequest = new IndexRequest(request.param("index"), type, request.param("id")).     } else {         indexRequest = new IndexRequest(request.param("index")).         indexRequest.id(request.param("id")).     }     indexRequest.routing(request.param("routing")).     indexRequest.setPipeline(request.param("pipeline")).     indexRequest.source(request.requiredContent(), request.getXContentType()).     indexRequest.timeout(request.paramAsTime("timeout", IndexRequest.DEFAULT_TIMEOUT)).     indexRequest.setRefreshPolicy(request.param("refresh")).     indexRequest.version(RestActions.parseVersion(request)).     indexRequest.versionType(VersionType.fromString(request.param("version_type"), indexRequest.versionType())).     indexRequest.setIfSeqNo(request.paramAsLong("if_seq_no", indexRequest.ifSeqNo())).     indexRequest.setIfPrimaryTerm(request.paramAsLong("if_primary_term", indexRequest.ifPrimaryTerm())).     String sOpType = request.param("op_type").     String waitForActiveShards = request.param("wait_for_active_shards").     if (waitForActiveShards != null) {         indexRequest.waitForActiveShards(ActiveShardCount.parseString(waitForActiveShards)).     }     if (sOpType != null) {         indexRequest.opType(sOpType).     }     return channel -> client.index(indexRequest, new RestStatusToXContentListener<>(channel, r -> r.getLocation(indexRequest.routing()))). }
