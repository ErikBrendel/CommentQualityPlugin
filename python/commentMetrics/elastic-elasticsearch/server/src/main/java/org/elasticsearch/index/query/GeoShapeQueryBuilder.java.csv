commented;modifiers;parameterAmount;loc;comment;code
false;protected;1;25;;@Override protected void doWriteTo(StreamOutput out) throws IOException {     if (supplier != null) {         throw new IllegalStateException("supplier must be null, can't serialize suppliers, missing a rewriteAndFetch?").     }     out.writeString(fieldName).     boolean hasShape = shape != null.     out.writeBoolean(hasShape).     if (hasShape) {         out.writeNamedWriteable(shape).     } else {         out.writeOptionalString(indexedShapeId).         out.writeOptionalString(indexedShapeType).         out.writeOptionalString(indexedShapeIndex).         out.writeOptionalString(indexedShapePath).         if (out.getVersion().onOrAfter(Version.V_6_4_0)) {             out.writeOptionalString(indexedShapeRouting).         } else if (indexedShapeRouting != null) {             throw new IllegalStateException("indexed shape routing cannot be serialized to older nodes").         }     }     relation.writeTo(out).     out.writeOptionalWriteable(strategy).     out.writeBoolean(ignoreUnmapped). }
true;public;0;3;/**  * @return the name of the field that will be queried  */ ;/**  * @return the name of the field that will be queried  */ public String fieldName() {     return fieldName. }
true;public;0;3;/**  * @return the shape used in the Query  */ ;/**  * @return the shape used in the Query  */ public ShapeBuilder shape() {     return shape. }
true;public;0;3;/**  * @return the ID of the indexed Shape that will be used in the Query  */ ;/**  * @return the ID of the indexed Shape that will be used in the Query  */ public String indexedShapeId() {     return indexedShapeId. }
true;public;0;4;/**  * @return the document type of the indexed Shape that will be used in the  *         Query  *  * @deprecated Types are in the process of being removed.  */ ;/**  * @return the document type of the indexed Shape that will be used in the  *         Query  *  * @deprecated Types are in the process of being removed.  */ @Deprecated public String indexedShapeType() {     return indexedShapeType. }
true;public;1;8;/**  * Defines which spatial strategy will be used for building the geo shape  * Query. When not set, the strategy that will be used will be the one that  * is associated with the geo shape field in the mappings.  *  * @param strategy  *            The spatial strategy to use for building the geo shape Query  * @return this  */ ;/**  * Defines which spatial strategy will be used for building the geo shape  * Query. When not set, the strategy that will be used will be the one that  * is associated with the geo shape field in the mappings.  *  * @param strategy  *            The spatial strategy to use for building the geo shape Query  * @return this  */ public GeoShapeQueryBuilder strategy(SpatialStrategy strategy) {     if (strategy != null && strategy == SpatialStrategy.TERM && relation != ShapeRelation.INTERSECTS) {         throw new IllegalArgumentException("strategy [" + strategy.getStrategyName() + "] only supports relation [" + ShapeRelation.INTERSECTS.getRelationName() + "] found relation [" + relation.getRelationName() + "]").     }     this.strategy = strategy.     return this. }
true;public;0;3;/**  * @return The spatial strategy to use for building the geo shape Query  */ ;/**  * @return The spatial strategy to use for building the geo shape Query  */ public SpatialStrategy strategy() {     return strategy. }
true;public;1;4;/**  * Sets the name of the index where the indexed Shape can be found  *  * @param indexedShapeIndex Name of the index where the indexed Shape is  * @return this  */ ;/**  * Sets the name of the index where the indexed Shape can be found  *  * @param indexedShapeIndex Name of the index where the indexed Shape is  * @return this  */ public GeoShapeQueryBuilder indexedShapeIndex(String indexedShapeIndex) {     this.indexedShapeIndex = indexedShapeIndex.     return this. }
true;public;0;3;/**  * @return the index name for the indexed Shape that will be used in the  *         Query  */ ;/**  * @return the index name for the indexed Shape that will be used in the  *         Query  */ public String indexedShapeIndex() {     return indexedShapeIndex. }
true;public;1;4;/**  * Sets the path of the field in the indexed Shape document that has the Shape itself  *  * @param indexedShapePath Path of the field where the Shape itself is defined  * @return this  */ ;/**  * Sets the path of the field in the indexed Shape document that has the Shape itself  *  * @param indexedShapePath Path of the field where the Shape itself is defined  * @return this  */ public GeoShapeQueryBuilder indexedShapePath(String indexedShapePath) {     this.indexedShapePath = indexedShapePath.     return this. }
true;public;0;3;/**  * @return the path of the indexed Shape that will be used in the Query  */ ;/**  * @return the path of the indexed Shape that will be used in the Query  */ public String indexedShapePath() {     return indexedShapePath. }
true;public;1;4;/**  * Sets the optional routing to the indexed Shape that will be used in the query  *  * @param indexedShapeRouting indexed shape routing  * @return this  */ ;/**  * Sets the optional routing to the indexed Shape that will be used in the query  *  * @param indexedShapeRouting indexed shape routing  * @return this  */ public GeoShapeQueryBuilder indexedShapeRouting(String indexedShapeRouting) {     this.indexedShapeRouting = indexedShapeRouting.     return this. }
true;public;0;3;/**  * @return the optional routing to the indexed Shape that will be used in the  *         Query  */ ;/**  * @return the optional routing to the indexed Shape that will be used in the  *         Query  */ public String indexedShapeRouting() {     return indexedShapeRouting. }
true;public;1;11;/**  * Sets the relation of query shape and indexed shape.  *  * @param relation relation of the shapes  * @return this  */ ;/**  * Sets the relation of query shape and indexed shape.  *  * @param relation relation of the shapes  * @return this  */ public GeoShapeQueryBuilder relation(ShapeRelation relation) {     if (relation == null) {         throw new IllegalArgumentException("No Shape Relation defined").     }     if (SpatialStrategy.TERM.equals(strategy) && relation != ShapeRelation.INTERSECTS) {         throw new IllegalArgumentException("current strategy [" + strategy.getStrategyName() + "] only supports relation [" + ShapeRelation.INTERSECTS.getRelationName() + "] found relation [" + relation.getRelationName() + "]").     }     this.relation = relation.     return this. }
true;public;0;3;/**  * @return the relation of query shape and indexed shape to use in the Query  */ ;/**  * @return the relation of query shape and indexed shape to use in the Query  */ public ShapeRelation relation() {     return relation. }
true;public;1;4;/**  * Sets whether the query builder should ignore unmapped fields (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the field is unmapped.  */ ;/**  * Sets whether the query builder should ignore unmapped fields (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the field is unmapped.  */ public GeoShapeQueryBuilder ignoreUnmapped(boolean ignoreUnmapped) {     this.ignoreUnmapped = ignoreUnmapped.     return this. }
true;public;0;3;/**  * Gets whether the query builder will ignore unmapped fields (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the field is unmapped.  */ ;/**  * Gets whether the query builder will ignore unmapped fields (and run a  * {@link MatchNoDocsQuery} in place of this query) or throw an exception if  * the field is unmapped.  */ public boolean ignoreUnmapped() {     return ignoreUnmapped. }
false;protected;1;45;;@Override protected Query doToQuery(QueryShardContext context) {     if (shape == null || supplier != null) {         throw new UnsupportedOperationException("query must be rewritten first").     }     final ShapeBuilder shapeToQuery = shape.     final MappedFieldType fieldType = context.fieldMapper(fieldName).     if (fieldType == null) {         if (ignoreUnmapped) {             return new MatchNoDocsQuery().         } else {             throw new QueryShardException(context, "failed to find geo_shape field [" + fieldName + "]").         }     } else if (fieldType.typeName().equals(BaseGeoShapeFieldMapper.CONTENT_TYPE) == false) {         throw new QueryShardException(context, "Field [" + fieldName + "] is not of type [geo_shape] but of type [" + fieldType.typeName() + "]").     }     final BaseGeoShapeFieldMapper.BaseGeoShapeFieldType ft = (BaseGeoShapeFieldMapper.BaseGeoShapeFieldType) fieldType.     Query query.     if (strategy != null || ft instanceof LegacyGeoShapeFieldMapper.GeoShapeFieldType) {         LegacyGeoShapeFieldMapper.GeoShapeFieldType shapeFieldType = (LegacyGeoShapeFieldMapper.GeoShapeFieldType) ft.         SpatialStrategy spatialStrategy = shapeFieldType.strategy().         if (this.strategy != null) {             spatialStrategy = this.strategy.         }         PrefixTreeStrategy prefixTreeStrategy = shapeFieldType.resolvePrefixTreeStrategy(spatialStrategy).         if (prefixTreeStrategy instanceof RecursivePrefixTreeStrategy && relation == ShapeRelation.DISJOINT) {             // this strategy doesn't support disjoint anymore: but it did             // before, including creating lucene fieldcache (!)             // in this case, execute disjoint as exists && !intersects             BooleanQuery.Builder bool = new BooleanQuery.Builder().             Query exists = ExistsQueryBuilder.newFilter(context, fieldName).             Query intersects = prefixTreeStrategy.makeQuery(getArgs(shapeToQuery, ShapeRelation.INTERSECTS)).             bool.add(exists, BooleanClause.Occur.MUST).             bool.add(intersects, BooleanClause.Occur.MUST_NOT).             query = new ConstantScoreQuery(bool.build()).         } else {             query = new ConstantScoreQuery(prefixTreeStrategy.makeQuery(getArgs(shapeToQuery, relation))).         }     } else {         query = new ConstantScoreQuery(getVectorQuery(context, shapeToQuery)).     }     return query. }
false;private;2;10;;private Query getVectorQuery(QueryShardContext context, ShapeBuilder queryShapeBuilder) {     // CONTAINS queries are not yet supported by VECTOR strategy     if (relation == ShapeRelation.CONTAINS) {         throw new QueryShardException(context, ShapeRelation.CONTAINS + " query relation not supported for Field [" + fieldName + "]").     }     // wrap geoQuery as a ConstantScoreQuery     return getVectorQueryFromShape(context, queryShapeBuilder.buildGeometry()). }
false;public;1;4;;@Override public Query visit(Circle circle) {     throw new QueryShardException(context, "Field [" + fieldName + "] found and unknown shape Circle"). }
false;public;1;6;;@Override public Query visit(GeometryCollection<?> collection) {     BooleanQuery.Builder bqb = new BooleanQuery.Builder().     visit(bqb, collection).     return bqb.build(). }
false;private;2;10;;private void visit(BooleanQuery.Builder bqb, GeometryCollection<?> collection) {     for (Geometry shape : collection) {         if (shape instanceof MultiPoint) {             // Flatten multipoints             visit(bqb, (GeometryCollection<?>) shape).         } else {             bqb.add(shape.visit(this), BooleanClause.Occur.SHOULD).         }     } }
false;public;1;4;;@Override public Query visit(org.elasticsearch.geo.geometry.Line line) {     return LatLonShape.newLineQuery(fieldName(), relation.getLuceneRelation(), new Line(line.getLats(), line.getLons())). }
false;public;1;4;;@Override public Query visit(LinearRing ring) {     throw new QueryShardException(context, "Field [" + fieldName + "] found and unsupported shape LinearRing"). }
false;public;1;8;;@Override public Query visit(MultiLine multiLine) {     Line[] lines = new Line[multiLine.size()].     for (int i = 0. i < multiLine.size(). i++) {         lines[i] = new Line(multiLine.get(i).getLats(), multiLine.get(i).getLons()).     }     return LatLonShape.newLineQuery(fieldName(), relation.getLuceneRelation(), lines). }
false;public;1;5;;@Override public Query visit(MultiPoint multiPoint) {     throw new QueryShardException(context, "Field [" + fieldName + "] does not support " + GeoShapeType.MULTIPOINT + " queries"). }
false;public;1;8;;@Override public Query visit(MultiPolygon multiPolygon) {     Polygon[] polygons = new Polygon[multiPolygon.size()].     for (int i = 0. i < multiPolygon.size(). i++) {         polygons[i] = toLucenePolygon(multiPolygon.get(i)).     }     return LatLonShape.newPolygonQuery(fieldName(), relation.getLuceneRelation(), polygons). }
false;public;1;5;;@Override public Query visit(Point point) {     return LatLonShape.newBoxQuery(fieldName, relation.getLuceneRelation(), point.getLat(), point.getLat(), point.getLon(), point.getLon()). }
false;public;1;4;;@Override public Query visit(org.elasticsearch.geo.geometry.Polygon polygon) {     return LatLonShape.newPolygonQuery(fieldName(), relation.getLuceneRelation(), toLucenePolygon(polygon)). }
false;public;1;5;;@Override public Query visit(org.elasticsearch.geo.geometry.Rectangle r) {     return LatLonShape.newBoxQuery(fieldName(), relation.getLuceneRelation(), r.getMinLat(), r.getMaxLat(), r.getMinLon(), r.getMaxLon()). }
false;private;2;77;;private Query getVectorQueryFromShape(QueryShardContext context, Geometry queryShape) {     return queryShape.visit(new GeometryVisitor<Query>() {          @Override         public Query visit(Circle circle) {             throw new QueryShardException(context, "Field [" + fieldName + "] found and unknown shape Circle").         }          @Override         public Query visit(GeometryCollection<?> collection) {             BooleanQuery.Builder bqb = new BooleanQuery.Builder().             visit(bqb, collection).             return bqb.build().         }          private void visit(BooleanQuery.Builder bqb, GeometryCollection<?> collection) {             for (Geometry shape : collection) {                 if (shape instanceof MultiPoint) {                     // Flatten multipoints                     visit(bqb, (GeometryCollection<?>) shape).                 } else {                     bqb.add(shape.visit(this), BooleanClause.Occur.SHOULD).                 }             }         }          @Override         public Query visit(org.elasticsearch.geo.geometry.Line line) {             return LatLonShape.newLineQuery(fieldName(), relation.getLuceneRelation(), new Line(line.getLats(), line.getLons())).         }          @Override         public Query visit(LinearRing ring) {             throw new QueryShardException(context, "Field [" + fieldName + "] found and unsupported shape LinearRing").         }          @Override         public Query visit(MultiLine multiLine) {             Line[] lines = new Line[multiLine.size()].             for (int i = 0. i < multiLine.size(). i++) {                 lines[i] = new Line(multiLine.get(i).getLats(), multiLine.get(i).getLons()).             }             return LatLonShape.newLineQuery(fieldName(), relation.getLuceneRelation(), lines).         }          @Override         public Query visit(MultiPoint multiPoint) {             throw new QueryShardException(context, "Field [" + fieldName + "] does not support " + GeoShapeType.MULTIPOINT + " queries").         }          @Override         public Query visit(MultiPolygon multiPolygon) {             Polygon[] polygons = new Polygon[multiPolygon.size()].             for (int i = 0. i < multiPolygon.size(). i++) {                 polygons[i] = toLucenePolygon(multiPolygon.get(i)).             }             return LatLonShape.newPolygonQuery(fieldName(), relation.getLuceneRelation(), polygons).         }          @Override         public Query visit(Point point) {             return LatLonShape.newBoxQuery(fieldName, relation.getLuceneRelation(), point.getLat(), point.getLat(), point.getLon(), point.getLon()).         }          @Override         public Query visit(org.elasticsearch.geo.geometry.Polygon polygon) {             return LatLonShape.newPolygonQuery(fieldName(), relation.getLuceneRelation(), toLucenePolygon(polygon)).         }          @Override         public Query visit(org.elasticsearch.geo.geometry.Rectangle r) {             return LatLonShape.newBoxQuery(fieldName(), relation.getLuceneRelation(), r.getMinLat(), r.getMaxLat(), r.getMinLon(), r.getMaxLon()).         }     }). }
false;public;1;40;;@Override public void onResponse(GetResponse response) {     try {         if (!response.isExists()) {             throw new IllegalArgumentException("Shape with ID [" + getRequest.id() + "] in type [" + getRequest.type() + "] not found").         }         if (response.isSourceEmpty()) {             throw new IllegalArgumentException("Shape with ID [" + getRequest.id() + "] in type [" + getRequest.type() + "] source disabled").         }         String[] pathElements = path.split("\\.").         int currentPathSlot = 0.         // It is safe to use EMPTY here because this never uses namedObject         try (XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, response.getSourceAsBytesRef())) {             XContentParser.Token currentToken.             while ((currentToken = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (currentToken == XContentParser.Token.FIELD_NAME) {                     if (pathElements[currentPathSlot].equals(parser.currentName())) {                         parser.nextToken().                         if (++currentPathSlot == pathElements.length) {                             listener.onResponse(ShapeParser.parse(parser)).                             return.                         }                     } else {                         parser.nextToken().                         parser.skipChildren().                     }                 }             }             throw new IllegalStateException("Shape with name [" + getRequest.id() + "] found but missing " + path + " field").         }     } catch (Exception e) {         onFailure(e).     } }
false;public;1;4;;@Override public void onFailure(Exception e) {     listener.onFailure(e). }
true;private;4;52;/**  * Fetches the Shape with the given ID in the given type and index.  *  * @param getRequest  *            GetRequest containing index, type and id  * @param path  *            Name or path of the field in the Shape Document where the  *            Shape itself is located  */ ;/**  * Fetches the Shape with the given ID in the given type and index.  *  * @param getRequest  *            GetRequest containing index, type and id  * @param path  *            Name or path of the field in the Shape Document where the  *            Shape itself is located  */ private void fetch(Client client, GetRequest getRequest, String path, ActionListener<ShapeBuilder> listener) {     getRequest.preference("_local").     client.get(getRequest, new ActionListener<GetResponse>() {          @Override         public void onResponse(GetResponse response) {             try {                 if (!response.isExists()) {                     throw new IllegalArgumentException("Shape with ID [" + getRequest.id() + "] in type [" + getRequest.type() + "] not found").                 }                 if (response.isSourceEmpty()) {                     throw new IllegalArgumentException("Shape with ID [" + getRequest.id() + "] in type [" + getRequest.type() + "] source disabled").                 }                 String[] pathElements = path.split("\\.").                 int currentPathSlot = 0.                 // It is safe to use EMPTY here because this never uses namedObject                 try (XContentParser parser = XContentHelper.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, response.getSourceAsBytesRef())) {                     XContentParser.Token currentToken.                     while ((currentToken = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                         if (currentToken == XContentParser.Token.FIELD_NAME) {                             if (pathElements[currentPathSlot].equals(parser.currentName())) {                                 parser.nextToken().                                 if (++currentPathSlot == pathElements.length) {                                     listener.onResponse(ShapeParser.parse(parser)).                                     return.                                 }                             } else {                                 parser.nextToken().                                 parser.skipChildren().                             }                         }                     }                     throw new IllegalStateException("Shape with name [" + getRequest.id() + "] found but missing " + path + " field").                 }             } catch (Exception e) {                 onFailure(e).             }         }          @Override         public void onFailure(Exception e) {             listener.onFailure(e).         }     }). }
false;public,static;2;14;;public static SpatialArgs getArgs(ShapeBuilder shape, ShapeRelation relation) {     switch(relation) {         case DISJOINT:             return new SpatialArgs(SpatialOperation.IsDisjointTo, shape.buildS4J()).         case INTERSECTS:             return new SpatialArgs(SpatialOperation.Intersects, shape.buildS4J()).         case WITHIN:             return new SpatialArgs(SpatialOperation.IsWithin, shape.buildS4J()).         case CONTAINS:             return new SpatialArgs(SpatialOperation.Contains, shape.buildS4J()).         default:             throw new IllegalArgumentException("invalid relation [" + relation + "]").     } }
false;protected;2;42;;@Override protected void doXContent(XContentBuilder builder, Params params) throws IOException {     builder.startObject(NAME).     builder.startObject(fieldName).     if (strategy != null) {         builder.field(STRATEGY_FIELD.getPreferredName(), strategy.getStrategyName()).     }     if (shape != null) {         builder.field(SHAPE_FIELD.getPreferredName()).         shape.toXContent(builder, params).     } else {         builder.startObject(INDEXED_SHAPE_FIELD.getPreferredName()).field(SHAPE_ID_FIELD.getPreferredName(), indexedShapeId).         if (indexedShapeType != null) {             builder.field(SHAPE_TYPE_FIELD.getPreferredName(), indexedShapeType).         }         if (indexedShapeIndex != null) {             builder.field(SHAPE_INDEX_FIELD.getPreferredName(), indexedShapeIndex).         }         if (indexedShapePath != null) {             builder.field(SHAPE_PATH_FIELD.getPreferredName(), indexedShapePath).         }         if (indexedShapeRouting != null) {             builder.field(SHAPE_ROUTING_FIELD.getPreferredName(), indexedShapeRouting).         }         builder.endObject().     }     if (relation != null) {         builder.field(RELATION_FIELD.getPreferredName(), relation.getRelationName()).     }     builder.endObject().     builder.field(IGNORE_UNMAPPED_FIELD.getPreferredName(), ignoreUnmapped).     printBoostAndQueryName(builder).     builder.endObject(). }
false;public,static;1;117;;public static GeoShapeQueryBuilder fromXContent(XContentParser parser) throws IOException {     String fieldName = null.     ShapeRelation shapeRelation = null.     SpatialStrategy strategy = null.     ShapeBuilder shape = null.     String id = null.     String type = null.     String index = null.     String shapePath = null.     String shapeRouting = null.     XContentParser.Token token.     String currentFieldName = null.     float boost = AbstractQueryBuilder.DEFAULT_BOOST.     String queryName = null.     boolean ignoreUnmapped = DEFAULT_IGNORE_UNMAPPED.     while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {         if (token == XContentParser.Token.FIELD_NAME) {             currentFieldName = parser.currentName().         } else if (token == XContentParser.Token.START_OBJECT) {             if (fieldName != null) {                 throw new ParsingException(parser.getTokenLocation(), "[" + GeoShapeQueryBuilder.NAME + "] point specified twice. [" + currentFieldName + "]").             }             fieldName = currentFieldName.             while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                 if (token == XContentParser.Token.FIELD_NAME) {                     currentFieldName = parser.currentName().                     token = parser.nextToken().                     if (SHAPE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         shape = ShapeParser.parse(parser).                     } else if (STRATEGY_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         String strategyName = parser.text().                         strategy = SpatialStrategy.fromString(strategyName).                         if (strategy == null) {                             throw new ParsingException(parser.getTokenLocation(), "Unknown strategy [" + strategyName + " ]").                         }                     } else if (RELATION_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         shapeRelation = ShapeRelation.getRelationByName(parser.text()).                         if (shapeRelation == null) {                             throw new ParsingException(parser.getTokenLocation(), "Unknown shape operation [" + parser.text() + " ]").                         }                     } else if (INDEXED_SHAPE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                         while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {                             if (token == XContentParser.Token.FIELD_NAME) {                                 currentFieldName = parser.currentName().                             } else if (token.isValue()) {                                 if (SHAPE_ID_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                                     id = parser.text().                                 } else if (SHAPE_TYPE_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                                     type = parser.text().                                 } else if (SHAPE_INDEX_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                                     index = parser.text().                                 } else if (SHAPE_PATH_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                                     shapePath = parser.text().                                 } else if (SHAPE_ROUTING_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                                     shapeRouting = parser.text().                                 }                             } else {                                 throw new ParsingException(parser.getTokenLocation(), "[" + GeoShapeQueryBuilder.NAME + "] unknown token [" + token + "] after [" + currentFieldName + "]").                             }                         }                     } else {                         throw new ParsingException(parser.getTokenLocation(), "[" + GeoShapeQueryBuilder.NAME + "] query does not support [" + currentFieldName + "]").                     }                 }             }         } else if (token.isValue()) {             if (AbstractQueryBuilder.BOOST_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 boost = parser.floatValue().             } else if (AbstractQueryBuilder.NAME_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 queryName = parser.text().             } else if (IGNORE_UNMAPPED_FIELD.match(currentFieldName, parser.getDeprecationHandler())) {                 ignoreUnmapped = parser.booleanValue().             } else {                 throw new ParsingException(parser.getTokenLocation(), "[" + GeoShapeQueryBuilder.NAME + "] query does not support [" + currentFieldName + "]").             }         }     }     GeoShapeQueryBuilder builder.     if (type != null) {         deprecationLogger.deprecatedAndMaybeLog("geo_share_query_with_types", TYPES_DEPRECATION_MESSAGE).     }     if (shape != null) {         builder = new GeoShapeQueryBuilder(fieldName, shape).     } else {         builder = new GeoShapeQueryBuilder(fieldName, id, type).     }     if (index != null) {         builder.indexedShapeIndex(index).     }     if (shapePath != null) {         builder.indexedShapePath(shapePath).     }     if (shapeRouting != null) {         builder.indexedShapeRouting(shapeRouting).     }     if (shapeRelation != null) {         builder.relation(shapeRelation).     }     if (strategy != null) {         builder.strategy(strategy).     }     if (queryName != null) {         builder.queryName(queryName).     }     builder.boost(boost).     builder.ignoreUnmapped(ignoreUnmapped).     return builder. }
false;protected;1;14;;@Override protected boolean doEquals(GeoShapeQueryBuilder other) {     return Objects.equals(fieldName, other.fieldName) && Objects.equals(indexedShapeId, other.indexedShapeId) && Objects.equals(indexedShapeIndex, other.indexedShapeIndex) && Objects.equals(indexedShapePath, other.indexedShapePath) && Objects.equals(indexedShapeType, other.indexedShapeType) && Objects.equals(indexedShapeRouting, other.indexedShapeRouting) && Objects.equals(relation, other.relation) && Objects.equals(shape, other.shape) && Objects.equals(supplier, other.supplier) && Objects.equals(strategy, other.strategy) && Objects.equals(ignoreUnmapped, other.ignoreUnmapped). }
false;protected;0;5;;@Override protected int doHashCode() {     return Objects.hash(fieldName, indexedShapeId, indexedShapeIndex, indexedShapePath, indexedShapeType, indexedShapeRouting, relation, shape, strategy, ignoreUnmapped, supplier). }
false;public;0;4;;@Override public String getWriteableName() {     return NAME. }
false;protected;1;25;;@Override protected QueryBuilder doRewrite(QueryRewriteContext queryRewriteContext) throws IOException {     if (supplier != null) {         return supplier.get() == null ? this : new GeoShapeQueryBuilder(this.fieldName, supplier.get()).relation(relation).strategy(strategy).     } else if (this.shape == null) {         SetOnce<ShapeBuilder> supplier = new SetOnce<>().         queryRewriteContext.registerAsyncAction((client, listener) -> {             GetRequest getRequest.             if (indexedShapeType == null) {                 getRequest = new GetRequest(indexedShapeIndex, indexedShapeId).             } else {                 getRequest = new GetRequest(indexedShapeIndex, indexedShapeType, indexedShapeId).             }             getRequest.routing(indexedShapeRouting).             fetch(client, getRequest, indexedShapePath, ActionListener.wrap(builder -> {                 supplier.set(builder).                 listener.onResponse(null).             }, listener::onFailure)).         }).         return new GeoShapeQueryBuilder(this.fieldName, supplier::get, this.indexedShapeId, this.indexedShapeType).relation(relation).strategy(strategy).     }     return this. }
